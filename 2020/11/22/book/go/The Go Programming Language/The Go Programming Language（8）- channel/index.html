

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="1ch0">
  <meta name="keywords" content="">
  <title>The Go Programming Language（8）- channel - 1ch0&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>1ch0's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                联系我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      1ch0
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2020-11-22 10:00" pubdate>
        2020年11月22日 上午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      14.9k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      182
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">The Go Programming Language（8）- channel</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：5 个月前
                
              </p>
            
            <div class="markdown-body" id="post-body">
              <hr>
<h1 id="The-Go-Programming-Language（8"><a href="#The-Go-Programming-Language（8" class="headerlink" title="The Go Programming Language（8)"></a>The Go Programming Language（8)</h1><h3 id="源码、PDF版、Markdown、xmind版下载链接"><a href="#源码、PDF版、Markdown、xmind版下载链接" class="headerlink" title="源码、PDF版、Markdown、xmind版下载链接"></a>源码、PDF版、Markdown、xmind版下载链接</h3><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://<span class="hljs-number">1</span>tnt<span class="hljs-number">1</span>.lanzous.com/b<span class="hljs-number">00</span>o<span class="hljs-number">36</span>ytc</code></pre>

<p>密码：</p>
<pre><code class="hljs angelscript"><span class="hljs-number">1</span>ch0</code></pre>

<hr>
<h2 id="ch8-Goroutines和Channels"><a href="#ch8-Goroutines和Channels" class="headerlink" title="ch8  Goroutines和Channels"></a>ch8  Goroutines和Channels</h2><h3 id="ch8-4-Channels"><a href="#ch8-4-Channels" class="headerlink" title="ch8.4   Channels"></a>ch8.4   Channels</h3><ul>
<li><p>ch8.4.0   简介</p>
<ul>
<li><p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为chan int。</p>
</li>
<li><p>使用内置的make函数，我们可以创建一个channel：</p>
<pre><code class="hljs Go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>) <span class="hljs-comment">// ch has type &#x27;chan int&#x27;</span></code></pre>
</li>
<li><p>和map类似，channel也对应一个make创建的底层数据结构的引用。当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。</p>
</li>
<li><p>两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。</p>
</li>
<li><p>一个channel有发送和接受两个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都使用<code>&lt;-</code>运算符。在发送语句中，<code>&lt;-</code>运算符分割channel和要发送的值。在接收语句中，<code>&lt;-</code>运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。</p>
<pre><code class="hljs Go">ch &lt;- x  <span class="hljs-comment">// a send statement</span>
x = &lt;-ch <span class="hljs-comment">// a receive expression in an assignment statement</span>
&lt;-ch     <span class="hljs-comment">// a receive statement; result is discarded</span></code></pre>
</li>
<li><p>Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。</p>
<ul>
<li><p>使用内置的close函数就可以关闭一个channel：</p>
<pre><code class="hljs Go"><span class="hljs-built_in">close</span>(ch)</code></pre>
</li>
</ul>
</li>
<li><p>以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。</p>
<pre><code class="hljs Go">ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)    <span class="hljs-comment">// unbuffered channel</span>
ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// unbuffered channel</span>
ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// buffered channel with capacity 3</span></code></pre>
</li>
<li><p>我们将先讨论无缓存的channel，然后在8.4.4节讨论带缓存的channel。</p>
</li>
</ul>
</li>
<li><p>ch8.4.1 不带缓存的Channels</p>
<ul>
<li><p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</p>
</li>
<li><p>基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收到数据发生在再次唤醒唤醒发送者goroutine之前</p>
<ul>
<li><em>happens before</em>，这是Go语言并发内存模型的一个关键术语！</li>
</ul>
</li>
<li><p>在讨论并发编程时，当我们说x事件在y事件之前发生（<em>happens before</em>），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。</p>
</li>
<li><p>当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。在下一章中我们将看到，当两个goroutine并发访问了相同的变量时，我们有必要保证某些事件的执行顺序，以避免出现某些并发问题。</p>
</li>
<li><p>在8.3节的客户端程序，它在主goroutine中（译注：就是执行main函数的goroutine）将标准输入复制到server，因此当客户端程序关闭标准输入时，后台goroutine可能依然在工作。我们需要让主goroutine等待后台goroutine完成工作后再退出，我们使用了一个channel来同步两个goroutine：</p>
<p><u><i>gopl.io/ch8/netcat3</i></u></p>
<pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		log.Fatal(err)
	&#125;
	done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		io.Copy(os.Stdout, conn) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring errors</span>
		log.Println(<span class="hljs-string">&quot;done&quot;</span>)
		done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// signal the main goroutine</span>
	&#125;()
	mustCopy(conn, os.Stdin)
	conn.Close()
	&lt;-done <span class="hljs-comment">// wait for background goroutine to finish</span>
&#125;</code></pre>
</li>
<li><p>当用户关闭了标准输入，主goroutine中的mustCopy函数调用将返回，然后调用conn.Close()关闭读和写方向的网络连接。关闭网络连接中的写方向的连接将导致server程序收到一个文件（end-of-file）结束的信号。关闭网络连接中读方向的连接将导致后台goroutine的io.Copy函数调用返回一个“read from closed connection”（“从关闭的连接读”）类似的错误，因此我们临时移除了错误日志语句；在练习8.3将会提供一个更好的解决方案。（需要注意的是go语句调用了一个函数字面量，这是Go语言中启动goroutine常用的形式。）</p>
</li>
<li><p>在后台goroutine返回之前，它先打印一个日志信息，然后向done对应的channel发送一个值。主goroutine在退出前先等待从done对应的channel接收一个值。因此，总是可以在程序退出前正确输出“done”消息。</p>
</li>
<li><p>基于channels发送消息有两个重要方面。首先每个消息都有一个值，但是有时候通讯的事实和发生的时刻也同样重要。当我们更希望强调通讯发生的时刻时，我们将它称为<strong>消息事件</strong>。有些消息事件并不携带额外的信息，它仅仅是用作两个goroutine之间的同步，这时候我们可以用<code>struct&#123;&#125;</code>空结构体作为channels元素的类型，虽然也可以使用bool或int类型实现同样的功能，<code>done &lt;- 1</code>语句也比<code>done &lt;- struct&#123;&#125;&#123;&#125;</code>更短。</p>
</li>
</ul>
</li>
<li><p>ch8.4.2 串联的Channels（Pipeline）</p>
<ul>
<li><p>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline）。下面的程序用两个channels将三个goroutine串联起来</p>
<ul>
<li>第一个goroutine是一个计数器，用于生成0、1、2、……形式的整数序列，然后通过channel将该整数序列发送给第二个goroutine；</li>
<li>第二个goroutine是一个求平方的程序，对收到的每个整数求平方,然后将平方后的结果通过第二个channel发送给第三个goroutine</li>
<li>第三个goroutine是一个打印程序，打印收到的每个整数。</li>
</ul>
</li>
<li><p>为了保持例子清晰，我们有意选择了非常简单的函数，当然三个goroutine的计算很简单，在现实中确实没有必要为如此简单的运算构建三个goroutine。</p>
<p><u><i>gopl.io/ch8/pipeline1</i></u></p>
<pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	naturals := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)
	squares := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)

	<span class="hljs-comment">// Counter</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		<span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; ; x++ &#123;
			naturals &lt;- x
		&#125;
	&#125;()

	<span class="hljs-comment">// Squarer</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		<span class="hljs-keyword">for</span> &#123;
			x := &lt;-naturals
			squares &lt;- x * x
		&#125;
	&#125;()

	<span class="hljs-comment">// Printer (in main goroutine)</span>
	<span class="hljs-keyword">for</span> &#123;
		fmt.Println(&lt;-squares)
	&#125;
&#125;</code></pre>
</li>
<li><p>如您所料，上面的程序将生成0、1、4、9、……形式的无穷数列。像这样的串联Channels的管道（Pipelines）可以用在需要长时间运行的服务中，每个长时间运行的goroutine可能会包含一个死循环，在不同goroutine的死循环内部使用串联的Channels来通信。但是，如果我们希望通过Channels只发送有限的数列该如何处理呢？</p>
</li>
<li><p>如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现：</p>
<pre><code class="hljs Go"><span class="hljs-built_in">close</span>(naturals)</code></pre>
</li>
<li><p>当一个channel被关闭后，再向该channel发送数据将导致panic异常。当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。关闭上面例子中的naturals变量对应的channel并不能终止循环，它依然会收到一个永无休止的零值序列，然后将它们发送给打印者goroutine。</p>
</li>
<li><p>没有办法直接测试一个channel是否被关闭，但是接收操作有一个变体形式：它多接收一个结果，多接收的第二个结果是一个布尔值ok，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。使用这个特性，我们可以修改squarer函数中的循环代码，当naturals对应的channel被关闭并没有值可接收时跳出循环，并且也关闭squares对应的channel.</p>
<pre><code class="hljs Go"><span class="hljs-comment">// Squarer</span>
<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-keyword">for</span> &#123;
		x, ok := &lt;-naturals
		<span class="hljs-keyword">if</span> !ok &#123;
			<span class="hljs-keyword">break</span> <span class="hljs-comment">// channel was closed and drained</span>
		&#125;
		squares &lt;- x * x
	&#125;
	<span class="hljs-built_in">close</span>(squares)
&#125;()</code></pre>
</li>
<li><p>因为上面的语法是笨拙的，而且这种处理模式很常见，因此Go语言的range循环可直接在channels上面迭代。使用range循环是上面处理模式的简洁语法，它依次从channel接收数据，当channel被关闭并且没有值可接收时跳出循环。</p>
</li>
<li><p>在下面的改进中，我们的计数器goroutine只生成100个含数字的序列，然后关闭naturals对应的channel，这将导致计算平方数的squarer对应的goroutine可以正常终止循环并关闭squares对应的channel。（在一个更复杂的程序中，可以通过defer语句关闭对应的channel。）最后，主goroutine也可以正常终止循环并退出程序。</p>
<p><u><i>gopl.io/ch8/pipeline2</i></u></p>
<pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	naturals := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)
	squares := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)

	<span class="hljs-comment">// Counter</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		<span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">100</span>; x++ &#123;
			naturals &lt;- x
		&#125;
		<span class="hljs-built_in">close</span>(naturals)
	&#125;()

	<span class="hljs-comment">// Squarer</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		<span class="hljs-keyword">for</span> x := <span class="hljs-keyword">range</span> naturals &#123;
			squares &lt;- x * x
		&#125;
		<span class="hljs-built_in">close</span>(squares)
	&#125;()

	<span class="hljs-comment">// Printer (in main goroutine)</span>
	<span class="hljs-keyword">for</span> x := <span class="hljs-keyword">range</span> squares &#123;
		fmt.Println(x)
	&#125;
&#125;</code></pre>

<ul>
<li>其实你并不需要关闭每一个channel。只有当需要告诉接收者goroutine，所有的数据已经全部发送时才需要关闭channel。不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。</li>
<li>不要将关闭一个打开文件的操作和关闭一个channel操作混淆。对于每个打开的文件，都需要在不使用的时候调用对应的Close方法来关闭文件。</li>
</ul>
</li>
<li><p>试图重复关闭一个channel将导致panic异常，试图关闭一个nil值的channel也将导致panic异常。关闭一个channels还会触发一个广播机制，我们将在8.9节讨论。</p>
</li>
</ul>
</li>
<li><p>ch8.4.3 单方向的Channel</p>
<ul>
<li><p>随着程序的增长，人们习惯于将大的函数拆分为小的函数。我们前面的例子中使用了三个goroutine，然后用两个channels来连接它们，它们都是main函数的局部变量。将三个goroutine拆分为以下三个函数是自然的想法：</p>
<pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squarer</span><span class="hljs-params">(out, in <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printer</span><span class="hljs-params">(in <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span></code></pre>

<ul>
<li><p>其中计算平方的squarer函数在两个串联Channels的中间，因此拥有两个channel类型的参数，一个用于输入一个用于输出。两个channel都拥有相同的类型，但是它们的使用方式相反：一个只用于接收，另一个只用于发送。参数的名字in和out已经明确表示了这个意图，但是并无法保证squarer函数向一个in参数对应的channel发送数据或者从一个out参数对应的channel接收数据。</p>
<ul>
<li>箭头<code>&lt;-</code>和关键字chan的相对位置表明了channel的方向。</li>
<li>这种限制将在编译期检测。</li>
</ul>
</li>
</ul>
</li>
<li><p>这种场景是典型的。当一个channel作为一个函数参数时，它一般总是被专门用于只发送或者只接收。</p>
</li>
<li><p>因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，因此对一个只接收的channel调用close将是一个编译错误。</p>
</li>
<li><p>这是改进的版本，这一次参数使用了单方向channel类型：</p>
<p><u><i>gopl.io/ch8/pipeline3</i></u></p>
<pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>)</span></span> &#123;
 <span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">100</span>; x++ &#123;
 out &lt;- x
 &#125;
 <span class="hljs-built_in">close</span>(out)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squarer</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>, in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;
 <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> in &#123;
 out &lt;- v * v
 &#125;
 <span class="hljs-built_in">close</span>(out)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printer</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;
 <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> in &#123;
 fmt.Println(v)
 &#125;
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
 naturals := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)
 squares := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)
 <span class="hljs-keyword">go</span> counter(naturals)
 <span class="hljs-keyword">go</span> squarer(squares, naturals)
 printer(squares)
&#125;</code></pre>
</li>
<li><p>调用counter（naturals）时，naturals的类型将隐式地从chan int转换成chan&lt;- int。调用printer(squares)也会导致相似的隐式转换，这一次是转换为<code>&lt;-chan int</code>类型只接收型的channel。任何双向channel向单向channel变量的赋值操作都将导致该隐式转换。这里并没有反向转换的语法：也就是不能将一个类似<code>chan&lt;- int</code>类型的单向型的channel转换为<code>chan int</code>类型的双向型的channel。</p>
</li>
</ul>
</li>
<li><p>ch8.4.4 带缓存的Channels</p>
<ul>
<li><p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。图8.2是ch变量对应的channel的图形表示形式。</p>
<pre><code class="hljs Go">ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">3</span>)</code></pre>
</li>
<li><p>向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</p>
</li>
<li><p>我们可以在无阻塞的情况下连续向新创建的channel发送三个值：</p>
<pre><code class="hljs Go">ch &lt;- <span class="hljs-string">&quot;A&quot;</span>
ch &lt;- <span class="hljs-string">&quot;B&quot;</span>
ch &lt;- <span class="hljs-string">&quot;C&quot;</span></code></pre>

<ul>
<li><p>此刻，channel的内部缓存队列将是满的（图8.3），如果有第四个发送操作将发生阻塞。</p>
</li>
<li><p>如果我们接收一个值，</p>
<pre><code class="hljs Go">fmt.Println(&lt;-ch) <span class="hljs-comment">// &quot;A&quot;</span></code></pre>
</li>
<li><p>那么channel的缓存队列将不是满的也不是空的（图8.4），因此对该channel执行的发送或接收操作都不会发生阻塞。通过这种方式，channel的缓存队列解耦了接收和发送的goroutine。</p>
</li>
<li><p>在某些特殊情况下，程序可能需要知道channel内部缓存的容量，可以用内置的cap函数获取：</p>
<pre><code class="hljs Go">fmt.Println(<span class="hljs-built_in">cap</span>(ch)) <span class="hljs-comment">// &quot;3&quot;</span></code></pre>
</li>
<li><p>同样，对于内置的len函数，如果传入的是channel，那么将返回channel内部缓存队列中有效元素的个数。因为在并发程序中该信息会随着接收操作而失效，但是它对某些故障诊断和性能优化会有帮助。</p>
<pre><code class="hljs Go">fmt.Println(<span class="hljs-built_in">len</span>(ch)) <span class="hljs-comment">// &quot;2&quot;</span></code></pre>
</li>
<li><p>在继续执行两次接收操作后channel内部的缓存队列将又成为空的，如果有第四个接收操作将发生阻塞：</p>
<pre><code class="hljs Go">fmt.Println(&lt;-ch) <span class="hljs-comment">// &quot;B&quot;</span>
fmt.Println(&lt;-ch) <span class="hljs-comment">// &quot;C&quot;</span></code></pre>
</li>
<li><p>在这个例子中，发送和接收操作都发生在同一个goroutine中，但是在真实的程序中它们一般由不同的goroutine执行。Go语言新手有时候会将一个带缓存的channel当作同一个goroutine中的队列使用，虽然语法看似简单，但实际上这是一个错误。Channel和goroutine的调度器机制是紧密相连的，如果没有其他goroutine从channel接收，发送者——或许是整个程序——将会面临永远阻塞的风险。如果你只是需要一个简单的队列，使用slice就可以了。</p>
</li>
</ul>
</li>
<li><p>下面的例子展示了一个使用了带缓存channel的应用。它并发地向三个镜像站点发出请求，三个镜像站点分散在不同的地理位置。它们分别将收到的响应发送到带缓存channel，最后接收者只接收第一个收到的响应，也就是最快的那个响应。因此mirroredQuery函数可能在另外两个响应慢的镜像站点响应之前就返回了结果。</p>
<pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mirroredQuery</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;
	responses := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">3</span>)
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; responses &lt;- request(<span class="hljs-string">&quot;asia.gopl.io&quot;</span>) &#125;()
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; responses &lt;- request(<span class="hljs-string">&quot;europe.gopl.io&quot;</span>) &#125;()
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; responses &lt;- request(<span class="hljs-string">&quot;americas.gopl.io&quot;</span>) &#125;()
	<span class="hljs-keyword">return</span> &lt;-responses <span class="hljs-comment">// return the quickest response</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">request</span><span class="hljs-params">(hostname <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(response <span class="hljs-keyword">string</span>)</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;</code></pre>

<ul>
<li>多个goroutines并发地向同一个channel发送数据，或从同一个channel接收数据都是常见的用法。</li>
</ul>
</li>
<li><p>如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住。这种情况，称为goroutines泄漏，这将是一个BUG。和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。</p>
</li>
<li><p>关于无缓存或带缓存channels之间的选择，或者是带缓存channels的容量大小的选择，都可能影响程序的正确性。无缓存channel更强地保证了每个发送操作与相应的同步接收操作；但是对于带缓存channel，这些操作是解耦的。同样，即使我们知道将要发送到一个channel的信息的数量上限，创建一个对应容量大小的带缓存channel也是不现实的，因为这要求在执行任何接收操作之前缓存所有已经发送的值。如果未能分配足够的缓存将导致程序死锁。</p>
</li>
<li><p>Channel的缓存也可能影响程序的性能。想象一家蛋糕店有三个厨师，一个烘焙，一个上糖衣，还有一个将每个蛋糕传递到它下一个厨师的生产线。在狭小的厨房空间环境，每个厨师在完成蛋糕后必须等待下一个厨师已经准备好接受它；这类似于在一个无缓存的channel上进行沟通。</p>
</li>
<li><p>如果在每个厨师之间有一个放置一个蛋糕的额外空间，那么每个厨师就可以将一个完成的蛋糕临时放在那里而马上进入下一个蛋糕的制作中；这类似于将channel的缓存队列的容量设置为1。只要每个厨师的平均工作效率相近，那么其中大部分的传输工作将是迅速的，个体之间细小的效率差异将在交接过程中弥补。如果厨师之间有更大的额外空间——也是就更大容量的缓存队列——将可以在不停止生产线的前提下消除更大的效率波动，例如一个厨师可以短暂地休息，然后再加快赶上进度而不影响其他人。</p>
</li>
<li><p>另一方面，如果生产线的前期阶段一直快于后续阶段，那么它们之间的缓存在大部分时间都将是满的。相反，如果后续阶段比前期阶段更快，那么它们之间的缓存在大部分时间都将是空的。对于这类场景，额外的缓存并没有带来任何好处。</p>
</li>
<li><p>生产线的隐喻对于理解channels和goroutines的工作机制是很有帮助的。例如，如果第二阶段是需要精心制作的复杂操作，一个厨师可能无法跟上第一个厨师的进度，或者是无法满足第三阶段厨师的需求。要解决这个问题，我们可以再雇佣另一个厨师来帮助完成第二阶段的工作，他执行相同的任务但是独立工作。这类似于基于相同的channels创建另一个独立的goroutine。</p>
</li>
<li><p>我们没有太多的空间展示全部细节，但是gopl.io/ch8/cake包模拟了这个蛋糕店，可以通过不同的参数调整。它还对上面提到的几种场景提供对应的基准测试（§11.4） 。</p>
</li>
</ul>
</li>
</ul>
<h3 id="ch8-5-并发的循环"><a href="#ch8-5-并发的循环" class="headerlink" title="ch8.5   并发的循环"></a>ch8.5   并发的循环</h3><ul>
<li><p>本节中，我们会探索一些用来在并行时循环迭代的常见并发模型。我们会探究从全尺寸图片生成一些缩略图的问题。gopl.io/ch8/thumbnail包提供了ImageFile函数来帮我们拉伸图片。我们不会说明这个函数的实现，只需要从gopl.io下载它。</p>
<p><u><i>gopl.io/ch8/thumbnail</i></u></p>
<pre><code class="hljs go"><span class="hljs-keyword">package</span> thumbnail

<span class="hljs-comment">// ImageFile reads an image from infile and writes</span>
<span class="hljs-comment">// a thumbnail-size version of it in the same directory.</span>
<span class="hljs-comment">// It returns the generated file name, e.g., &quot;foo.thumb.jpg&quot;.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ImageFile</span><span class="hljs-params">(infile <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span></code></pre>
</li>
<li><p>下面的程序会循环迭代一些图片文件名，并为每一张图片生成一个缩略图：</p>
<p><u><i>gopl.io/ch8/thumbnail</i></u></p>
<pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails makes thumbnails of the specified files.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails</span><span class="hljs-params">(filenames []<span class="hljs-keyword">string</span>)</span></span> &#123;
	<span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;
		<span class="hljs-keyword">if</span> _, err := thumbnail.ImageFile(f); err != <span class="hljs-literal">nil</span> &#123;
			log.Println(err)
		&#125;
	&#125;
&#125;</code></pre>
</li>
<li><p>显然我们处理文件的顺序无关紧要，因为每一个图片的拉伸操作和其它图片的处理操作都是彼此独立的。像这种子问题都是完全彼此独立的问题被叫做易并行embarrassingly parallel问题，易并行问题是最容易被实现成并行的一类问题，并且最能够享受到并发带来的好处，能够随着并行的规模线性地扩展。</p>
</li>
<li><p>下面让我们并行地执行这些操作，从而将文件IO的延迟隐藏掉，并用上多核cpu的计算能力来拉伸图像。我们的第一个并发程序只是使用了一个go关键字。这里我们先忽略掉错误，之后再进行处理。</p>
<pre><code class="hljs go"><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails2</span><span class="hljs-params">(filenames []<span class="hljs-keyword">string</span>)</span></span> &#123;
	<span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;
		<span class="hljs-keyword">go</span> thumbnail.ImageFile(f) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring errors</span>
	&#125;
&#125;</code></pre>

<ul>
<li>这个版本运行的实在有点太快，实际上，由于它比最早的版本使用的时间要短得多，即使当文件名的slice中只包含有一个元素。这就有点奇怪了，如果程序没有并发执行的话，那为什么一个并发的版本还是要快呢？</li>
<li>答案其实是makeThumbnails在它还没有完成工作之前就已经返回了。它启动了所有的goroutine，每一个文件名对应一个，但没有等待它们一直到执行完毕。</li>
</ul>
</li>
<li><p>没有什么直接的办法能够等待goroutine完成，但是我们可以改变goroutine里的代码让其能够将完成情况报告给外部的goroutine知晓，使用的方式是向一个共享的channel中发送事件。因为我们已经确切地知道有len(filenames)个内部goroutine，所以外部的goroutine只需要在返回之前对这些事件计数。</p>
<pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails3 makes thumbnails of the specified files in parallel.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails3</span><span class="hljs-params">(filenames []<span class="hljs-keyword">string</span>)</span></span> &#123;
	ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)
	<span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-keyword">string</span>)</span></span> &#123;
			thumbnail.ImageFile(f) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring errors</span>
			ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;
		&#125;(f)
	&#125;
	<span class="hljs-comment">// Wait for goroutines to complete.</span>
	<span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> filenames &#123;
		&lt;-ch
	&#125;
&#125;</code></pre>

<ul>
<li><p>注意我们将f的值作为一个显式的变量传给了函数，而不是在循环的闭包中声明：</p>
<pre><code class="hljs go"><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		thumbnail.ImageFile(f) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span>
		<span class="hljs-comment">// ...</span>
	&#125;()
&#125;</code></pre>
</li>
</ul>
</li>
<li><p>回忆一下之前在5.6.1节中，匿名函数中的循环变量快照问题。上面这个单独的变量f是被所有的匿名函数值所共享，且会被连续的循环迭代所更新的。当新的goroutine开始执行字面函数时，for循环可能已经更新了f并且开始了另一轮的迭代或者（更有可能的）已经结束了整个循环，所以当这些goroutine开始读取f的值时，它们所看到的值已经是slice的最后一个元素了。显式地添加这个参数，我们能够确保使用的f是当go语句执行时的“当前”那个f。</p>
</li>
<li><p>如果我们想要从每一个worker goroutine往主goroutine中返回值时该怎么办呢？当我们调用thumbnail.ImageFile创建文件失败的时候，它会返回一个错误。下一个版本的makeThumbnails会返回其在做拉伸操作时接收到的第一个错误：</p>
<pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails4 makes thumbnails for the specified files in parallel.</span>
<span class="hljs-comment">// It returns an error if any step failed.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails4</span><span class="hljs-params">(filenames []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;
	errors := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> error)

	<span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-keyword">string</span>)</span></span> &#123;
			_, err := thumbnail.ImageFile(f)
			errors &lt;- err
		&#125;(f)
	&#125;

	<span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> filenames &#123;
		<span class="hljs-keyword">if</span> err := &lt;-errors; err != <span class="hljs-literal">nil</span> &#123;
			<span class="hljs-keyword">return</span> err <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect: goroutine leak!</span>
		&#125;
	&#125;

	<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
&#125;</code></pre>

<ul>
<li>这个程序有一个微妙的bug。当它遇到第一个非nil的error时会直接将error返回到调用方，使得没有一个goroutine去排空errors channel。这样剩下的worker goroutine在向这个channel中发送值时，都会永远地阻塞下去，并且永远都不会退出。这种情况叫做goroutine泄露（§8.4.4），可能会导致整个程序卡住或者跑出out of memory的错误。</li>
<li>最简单的解决办法就是用一个具有合适大小的buffered channel，这样这些worker goroutine向channel中发送错误时就不会被阻塞。（一个可选的解决办法是创建一个另外的goroutine，当main goroutine返回第一个错误的同时去排空channel。）</li>
</ul>
</li>
<li><p>下一个版本的makeThumbnails使用了一个buffered channel来返回生成的图片文件的名字，附带生成时的错误。</p>
<pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails5 makes thumbnails for the specified files in parallel.</span>
<span class="hljs-comment">// It returns the generated file names in an arbitrary order,</span>
<span class="hljs-comment">// or an error if any step failed.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails5</span><span class="hljs-params">(filenames []<span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(thumbfiles []<span class="hljs-keyword">string</span>, err error)</span></span> &#123;
	<span class="hljs-keyword">type</span> item <span class="hljs-keyword">struct</span> &#123;
		thumbfile <span class="hljs-keyword">string</span>
		err       error
	&#125;

	ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> item, <span class="hljs-built_in">len</span>(filenames))
	<span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-keyword">string</span>)</span></span> &#123;
			<span class="hljs-keyword">var</span> it item
			it.thumbfile, it.err = thumbnail.ImageFile(f)
			ch &lt;- it
		&#125;(f)
	&#125;

	<span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> filenames &#123;
		it := &lt;-ch
		<span class="hljs-keyword">if</span> it.err != <span class="hljs-literal">nil</span> &#123;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, it.err
		&#125;
		thumbfiles = <span class="hljs-built_in">append</span>(thumbfiles, it.thumbfile)
	&#125;

	<span class="hljs-keyword">return</span> thumbfiles, <span class="hljs-literal">nil</span>
&#125;</code></pre>

<ul>
<li>我们最后一个版本的makeThumbnails返回了新文件们的大小总计数（bytes）。和前面的版本都不一样的一点是我们在这个版本里没有把文件名放在slice里，而是通过一个string的channel传过来，所以我们无法对循环的次数进行预测。</li>
</ul>
</li>
<li><p>为了知道最后一个goroutine什么时候结束（最后一个结束并不一定是最后一个开始），我们需要一个递增的计数器，在每一个goroutine启动时加一，在goroutine退出时减一。这需要一种特殊的计数器，这个计数器需要在多个goroutine操作时做到安全并且提供在其减为零之前一直等待的一种方法。这种计数类型被称为sync.WaitGroup，下面的代码就用到了这种方法：</p>
<pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails6 makes thumbnails for each file received from the channel.</span>
<span class="hljs-comment">// It returns the number of bytes occupied by the files it creates.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails6</span><span class="hljs-params">(filenames &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int64</span></span> &#123;
	sizes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int64</span>)
	<span class="hljs-keyword">var</span> wg sync.WaitGroup <span class="hljs-comment">// number of working goroutines</span>
	<span class="hljs-keyword">for</span> f := <span class="hljs-keyword">range</span> filenames &#123;
		wg.Add(<span class="hljs-number">1</span>)
		<span class="hljs-comment">// worker</span>
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-keyword">string</span>)</span></span> &#123;
			<span class="hljs-keyword">defer</span> wg.Done()
			thumb, err := thumbnail.ImageFile(f)
			<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
				log.Println(err)
				<span class="hljs-keyword">return</span>
			&#125;
			info, _ := os.Stat(thumb) <span class="hljs-comment">// OK to ignore error</span>
			sizes &lt;- info.Size()
		&#125;(f)
	&#125;

	<span class="hljs-comment">// closer</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		wg.Wait()
		<span class="hljs-built_in">close</span>(sizes)
	&#125;()

	<span class="hljs-keyword">var</span> total <span class="hljs-keyword">int64</span>
	<span class="hljs-keyword">for</span> size := <span class="hljs-keyword">range</span> sizes &#123;
		total += size
	&#125;
	<span class="hljs-keyword">return</span> total
&#125;</code></pre>

<ul>
<li>注意Add和Done方法的不对称。Add是为计数器加一，必须在worker goroutine开始之前调用，而不是在goroutine中；否则的话我们没办法确定Add是在”closer” goroutine调用Wait之前被调用。并且Add还有一个参数，但Done却没有任何参数；其实它和Add(-1)是等价的。我们使用defer来确保计数器即使是在出错的情况下依然能够正确地被减掉。上面的程序代码结构是当我们使用并发循环，但又不知道迭代次数时很通常而且很地道的写法。</li>
<li>sizes channel携带了每一个文件的大小到main goroutine，在main goroutine中使用了range loop来计算总和。观察一下我们是怎样创建一个closer goroutine，并让其在所有worker goroutine们结束之后再关闭sizes channel的。两步操作：wait和close，必须是基于sizes的循环的并发。考虑一下另一种方案：如果等待操作被放在了main goroutine中，在循环之前，这样的话就永远都不会结束了，如果在循环之后，那么又变成了不可达的部分，因为没有任何东西去关闭这个channel，这个循环就永远都不会终止。</li>
</ul>
</li>
</ul>
<h3 id="ch8-6-示例：并发的Web爬虫"><a href="#ch8-6-示例：并发的Web爬虫" class="headerlink" title="ch8.6   示例：并发的Web爬虫"></a>ch8.6   示例：并发的Web爬虫</h3><ul>
<li><p>在5.6节中，我们做了一个简单的web爬虫，用bfs(广度优先)算法来抓取整个网站。在本节中，我们会让这个爬虫并行化，这样每一个彼此独立的抓取命令可以并行进行IO，最大化利用网络资源。crawl函数和gopl.io/ch5/findlinks3中的是一样的。</p>
<p><u><i>gopl.io/ch8/crawl1</i></u></p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawl</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;
	fmt.Println(url)
	list, err := links.Extract(url)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		log.Print(err)
	&#125;
	<span class="hljs-keyword">return</span> list
&#125;</code></pre>
</li>
<li><p>主函数和5.6节中的breadthFirst(广度优先)类似。像之前一样，一个worklist是一个记录了需要处理的元素的队列，每一个元素都是一个需要抓取的URL列表，不过这一次我们用channel代替slice来做这个队列。每一个对crawl的调用都会在他们自己的goroutine中进行并且会把他们抓到的链接发送回worklist。</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	worklist := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">string</span>)

	<span class="hljs-comment">// Start with the command-line arguments.</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- os.Args[<span class="hljs-number">1</span>:] &#125;()

	<span class="hljs-comment">// Crawl the web concurrently.</span>
	seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)
	<span class="hljs-keyword">for</span> list := <span class="hljs-keyword">range</span> worklist &#123;
		<span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> list &#123;
			<span class="hljs-keyword">if</span> !seen[link] &#123;
				seen[link] = <span class="hljs-literal">true</span>
				<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(link <span class="hljs-keyword">string</span>)</span></span> &#123;
					worklist &lt;- crawl(link)
				&#125;(link)
			&#125;
		&#125;
	&#125;
&#125;</code></pre>
</li>
<li><p>注意这里的crawl所在的goroutine会将link作为一个显式的参数传入，来避免“循环变量快照”的问题（在5.6.1中有讲解）。另外注意这里将命令行参数传入worklist也是在一个另外的goroutine中进行的，这是为了避免channel两端的main goroutine与crawler goroutine都尝试向对方发送内容，却没有一端接收内容时发生死锁。当然，这里我们也可以用buffered channel来解决问题，这里不再赘述。</p>
</li>
<li><p>现在爬虫可以高并发地运行起来，并且可以产生一大堆的URL了，不过还是会有俩问题。一个问题是在运行一段时间后可能会出现在log的错误信息里的：</p>
<pre><code class="hljs awk">$ go build gopl.io<span class="hljs-regexp">/ch8/</span>crawl1
$ .<span class="hljs-regexp">/crawl1 http:/</span><span class="hljs-regexp">/gopl.io/</span>
http:<span class="hljs-regexp">//g</span>opl.io/
https:<span class="hljs-regexp">//g</span>olang.org<span class="hljs-regexp">/help/</span>
https:<span class="hljs-regexp">//g</span>olang.org<span class="hljs-regexp">/doc/</span>
https:<span class="hljs-regexp">//g</span>olang.org<span class="hljs-regexp">/blog/</span>
...
<span class="hljs-number">2015</span><span class="hljs-regexp">/07/</span><span class="hljs-number">15</span> <span class="hljs-number">18</span>:<span class="hljs-number">22</span>:<span class="hljs-number">12</span> Get ...: dial tcp: lookup blog.golang.org: no such host
<span class="hljs-number">2015</span><span class="hljs-regexp">/07/</span><span class="hljs-number">15</span> <span class="hljs-number">18</span>:<span class="hljs-number">22</span>:<span class="hljs-number">12</span> Get ...: dial tcp <span class="hljs-number">23.21</span>.<span class="hljs-number">222.120</span>:<span class="hljs-number">443</span>: socket: too many open files
...</code></pre>
</li>
<li><p>最初的错误信息是一个让人莫名的DNS查找失败，即使这个域名是完全可靠的。而随后的错误信息揭示了原因：这个程序一次性创建了太多网络连接，超过了每一个进程的打开文件数限制，既而导致了在调用net.Dial像DNS查找失败这样的问题。</p>
</li>
<li><p>这个程序实在是太并行了。无穷无尽地并行化并不是什么好事情，因为不管怎么说，你的系统总是会有一些个限制因素，比如CPU核心数会限制你的计算负载，比如你的硬盘转轴和磁头数限制了你的本地磁盘IO操作频率，比如你的网络带宽限制了你的下载速度上限，或者是你的一个web服务的服务容量上限等等。</p>
<ul>
<li>为了解决这个问题，我们可以限制并发程序所使用的资源来使之适应自己的运行环境。对于我们的例子来说，最简单的方法就是限制对links.Extract在同一时间最多不会有超过n次调用，这里的n一般小于文件描述符的上限值，比如20。这和一个夜店里限制客人数目是一个道理，只有当有客人离开时，才会允许新的客人进入店内。</li>
<li>我们可以用一个有容量限制的buffered channel来控制并发，这类似于操作系统里的计数信号量概念。从概念上讲，channel里的n个空槽代表n个可以处理内容的token（通行证），从channel里接收一个值会释放其中的一个token，并且生成一个新的空槽位。这样保证了在没有接收介入时最多有n个发送操作。（这里可能我们拿channel里填充的槽来做token更直观一些，不过还是这样吧。）由于channel里的元素类型并不重要，我们用一个零值的struct{}来作为其元素。</li>
</ul>
</li>
<li><p>让我们重写crawl函数，将对links.Extract的调用操作用获取、释放token的操作包裹起来，来确保同一时间对其只有20个调用。信号量数量和其能操作的IO资源数量应保持接近。</p>
<p><u><i>gopl.io/ch8/crawl2</i></u></p>
<pre><code class="hljs go"><span class="hljs-comment">// tokens is a counting semaphore used to</span>
<span class="hljs-comment">// enforce a limit of 20 concurrent requests.</span>
<span class="hljs-keyword">var</span> tokens = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">20</span>)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawl</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;
	fmt.Println(url)
	tokens &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// acquire a token</span>
	list, err := links.Extract(url)
	&lt;-tokens <span class="hljs-comment">// release the token</span>
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		log.Print(err)
	&#125;
	<span class="hljs-keyword">return</span> list
&#125;</code></pre>

<ul>
<li><p>第二个问题是这个程序永远都不会终止，即使它已经爬到了所有初始链接衍生出的链接。（当然，除非你慎重地选择了合适的初始化URL或者已经实现了练习8.6中的深度限制，你应该还没有意识到这个问题。）为了使这个程序能够终止，我们需要在worklist为空或者没有crawl的goroutine在运行时退出主循环。</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	worklist := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">string</span>)
	<span class="hljs-keyword">var</span> n <span class="hljs-keyword">int</span> <span class="hljs-comment">// number of pending sends to worklist</span>

	<span class="hljs-comment">// Start with the command-line arguments.</span>
	n++
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- os.Args[<span class="hljs-number">1</span>:] &#125;()

	<span class="hljs-comment">// Crawl the web concurrently.</span>
	seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)

	<span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n-- &#123;
		list := &lt;-worklist
		<span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> list &#123;
			<span class="hljs-keyword">if</span> !seen[link] &#123;
				seen[link] = <span class="hljs-literal">true</span>
				n++
				<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(link <span class="hljs-keyword">string</span>)</span></span> &#123;
					worklist &lt;- crawl(link)
				&#125;(link)
			&#125;
		&#125;
	&#125;
&#125;</code></pre>
</li>
<li><p>这个版本中，计数器n对worklist的发送操作数量进行了限制。每一次我们发现有元素需要被发送到worklist时，我们都会对n进行++操作，在向worklist中发送初始的命令行参数之前，我们也进行过一次++操作。这里的操作++是在每启动一个crawler的goroutine之前。主循环会在n减为0时终止，这时候说明没活可干了。</p>
</li>
<li><p>现在这个并发爬虫会比5.6节中的深度优先搜索版快上20倍，而且不会出什么错，并且在其完成任务时也会正确地终止。</p>
</li>
</ul>
</li>
<li><p>下面的程序是避免过度并发的另一种思路。这个版本使用了原来的crawl函数，但没有使用计数信号量，取而代之用了20个常驻的crawler goroutine，这样来保证最多20个HTTP请求在并发。</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	worklist := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">string</span>)  <span class="hljs-comment">// lists of URLs, may have duplicates</span>
	unseenLinks := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>) <span class="hljs-comment">// de-duplicated URLs</span>

	<span class="hljs-comment">// Add command-line arguments to worklist.</span>
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- os.Args[<span class="hljs-number">1</span>:] &#125;()

	<span class="hljs-comment">// Create 20 crawler goroutines to fetch each unseen link.</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;
		<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
			<span class="hljs-keyword">for</span> link := <span class="hljs-keyword">range</span> unseenLinks &#123;
				foundLinks := crawl(link)
				<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- foundLinks &#125;()
			&#125;
		&#125;()
	&#125;

	<span class="hljs-comment">// The main goroutine de-duplicates worklist items</span>
	<span class="hljs-comment">// and sends the unseen ones to the crawlers.</span>
	seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)
	<span class="hljs-keyword">for</span> list := <span class="hljs-keyword">range</span> worklist &#123;
		<span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> list &#123;
			<span class="hljs-keyword">if</span> !seen[link] &#123;
				seen[link] = <span class="hljs-literal">true</span>
				unseenLinks &lt;- link
			&#125;
		&#125;
	&#125;
&#125;</code></pre>

<ul>
<li>所有的爬虫goroutine现在都是被同一个channel - unseenLinks喂饱的了。主goroutine负责拆分它从worklist里拿到的元素，然后把没有抓过的经由unseenLinks channel发送给一个爬虫的goroutine。</li>
<li>seen这个map被限定在main goroutine中；也就是说这个map只能在main goroutine中进行访问。类似于其它的信息隐藏方式，这样的约束可以让我们从一定程度上保证程序的正确性。</li>
<li>例如，内部变量不能够在函数外部被访问到；变量（§2.3.4）在没有发生变量逃逸（译注：局部变量被全局变量引用地址导致变量被分配在堆上）的情况下是无法在函数外部访问的；一个对象的封装字段无法被该对象的方法以外的方法访问到。在所有的情况下，信息隐藏都可以帮助我们约束我们的程序，使其不发生意料之外的情况。</li>
<li>crawl函数爬到的链接在一个专有的goroutine中被发送到worklist中来避免死锁。为了节省篇幅，这个例子的终止问题我们先不进行详细阐述了。</li>
</ul>
</li>
</ul>
<h3 id="ch8-7-基于select的多路复用"><a href="#ch8-7-基于select的多路复用" class="headerlink" title="ch8.7   基于select的多路复用"></a>ch8.7   基于select的多路复用</h3><ul>
<li><p>下面的程序会进行火箭发射的倒计时。time.Tick函数返回一个channel，程序会周期性地像一个节拍器一样向这个channel发送事件。每一个事件的值是一个时间戳，不过更有意思的是其传送方式。</p>
<p><u><i>gopl.io/ch8/countdown1</i></u></p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	fmt.Println(<span class="hljs-string">&quot;Commencing countdown.&quot;</span>)
	tick := time.Tick(<span class="hljs-number">1</span> * time.Second)
	<span class="hljs-keyword">for</span> countdown := <span class="hljs-number">10</span>; countdown &gt; <span class="hljs-number">0</span>; countdown-- &#123;
		fmt.Println(countdown)
		&lt;-tick
	&#125;
	launch()
&#125;</code></pre>

<p>现在我们让这个程序支持在倒计时中，用户按下</p>
</li>
<li><p>现在我们让这个程序支持在倒计时中，用户按下return键时直接中断发射流程。首先，我们启动一个goroutine，这个goroutine会尝试从标准输入中读入一个单独的byte并且，如果成功了，会向名为abort的channel发送一个值。</p>
<p><u><i>gopl.io/ch8/countdown2</i></u></p>
<pre><code class="hljs go">abort := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)
<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
	os.Stdin.Read(<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">1</span>)) <span class="hljs-comment">// read a single byte</span>
	abort &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;
&#125;()</code></pre>
</li>
<li><p>现在每一次计数循环的迭代都需要等待两个channel中的其中一个返回事件了：当一切正常时的ticker channel（就像NASA jorgon的”nominal”，译注：这梗估计我们是不懂了）或者异常时返回的abort事件。我们无法做到从每一个channel中接收信息，如果我们这么做的话，如果第一个channel中没有事件发过来那么程序就会立刻被阻塞，这样我们就无法收到第二个channel中发过来的事件。这时候我们需要多路复用（multiplex）这些操作了，为了能够多路复用，我们使用了select语句。</p>
<pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;
<span class="hljs-keyword">case</span> &lt;-ch1:
	<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">case</span> x := &lt;-ch2:
	<span class="hljs-comment">// ...use x...</span>
<span class="hljs-keyword">case</span> ch3 &lt;- y:
	<span class="hljs-comment">// ...</span>
<span class="hljs-keyword">default</span>:
	<span class="hljs-comment">// ...</span>
&#125;</code></pre>
</li>
<li><p>上面是select语句的一般形式。和switch语句稍微有点相似，也会有几个case和最后的default选择分支。每一个case代表一个通信操作（在某个channel上进行发送或者接收），并且会包含一些语句组成的一个语句块。一个接收表达式可能只包含接收表达式自身（译注：不把接收到的值赋值给变量什么的），就像上面的第一个case，或者包含在一个简短的变量声明中，像第二个case里一样；第二种形式让你能够引用接收到的值。</p>
</li>
<li><p>select会等待case中有能够执行的case时去执行。当条件满足时，select才会去通信并执行case之后的语句；这时候其它通信是不会执行的。一个没有任何case的select语句写作select{}，会永远地等待下去。</p>
</li>
<li><p>让我们回到我们的火箭发射程序。time.After函数会立即返回一个channel，并起一个新的goroutine在经过特定的时间后向该channel发送一个独立的值。下面的select语句会一直等待直到两个事件中的一个到达，无论是abort事件或者一个10秒经过的事件。如果10秒经过了还没有abort事件进入，那么火箭就会发射。</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">// ...create abort channel...</span>

	fmt.Println(<span class="hljs-string">&quot;Commencing countdown.  Press return to abort.&quot;</span>)
	<span class="hljs-keyword">select</span> &#123;
	<span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">10</span> * time.Second):
		<span class="hljs-comment">// Do nothing.</span>
	<span class="hljs-keyword">case</span> &lt;-abort:
		fmt.Println(<span class="hljs-string">&quot;Launch aborted!&quot;</span>)
		<span class="hljs-keyword">return</span>
	&#125;
	launch()
&#125;</code></pre>
</li>
<li><p>下面这个例子更微妙。ch这个channel的buffer大小是1，所以会交替的为空或为满，所以只有一个case可以进行下去，无论i是奇数或者偶数，它都会打印0 2 4 6 8。</p>
<pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)
<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;
	<span class="hljs-keyword">select</span> &#123;
	<span class="hljs-keyword">case</span> x := &lt;-ch:
		fmt.Println(x) <span class="hljs-comment">// &quot;0&quot; &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot;</span>
	<span class="hljs-keyword">case</span> ch &lt;- i:
	&#125;
&#125;</code></pre>
</li>
<li><p>如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会。增加前一个例子的buffer大小会使其输出变得不确定，因为当buffer既不为满也不为空时，select语句的执行情况就像是抛硬币的行为一样是随机的。</p>
</li>
<li><p>下面让我们的发射程序打印倒计时。这里的select语句会使每次循环迭代等待一秒来执行退出操作。</p>
<p><u><i>gopl.io/ch8/countdown3</i></u></p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">// ...create abort channel...</span>

	fmt.Println(<span class="hljs-string">&quot;Commencing countdown.  Press return to abort.&quot;</span>)
	tick := time.Tick(<span class="hljs-number">1</span> * time.Second)
	<span class="hljs-keyword">for</span> countdown := <span class="hljs-number">10</span>; countdown &gt; <span class="hljs-number">0</span>; countdown-- &#123;
		fmt.Println(countdown)
		<span class="hljs-keyword">select</span> &#123;
		<span class="hljs-keyword">case</span> &lt;-tick:
			<span class="hljs-comment">// Do nothing.</span>
		<span class="hljs-keyword">case</span> &lt;-abort:
			fmt.Println(<span class="hljs-string">&quot;Launch aborted!&quot;</span>)
			<span class="hljs-keyword">return</span>
		&#125;
	&#125;
	launch()
&#125;</code></pre>

<ul>
<li><p>time.Tick函数表现得好像它创建了一个在循环中调用time.Sleep的goroutine，每次被唤醒时发送一个事件。当countdown函数返回时，它会停止从tick中接收事件，但是ticker这个goroutine还依然存活，继续徒劳地尝试向channel中发送值，然而这时候已经没有其它的goroutine会从该channel中接收值了——这被称为goroutine泄露（§8.4.4）。</p>
</li>
<li><p>Tick函数挺方便，但是只有当程序整个生命周期都需要这个时间时我们使用它才比较合适。否则的话，我们应该使用下面的这种模式：</p>
<pre><code class="hljs go">ticker := time.NewTicker(<span class="hljs-number">1</span> * time.Second)
&lt;-ticker.C    <span class="hljs-comment">// receive from the ticker&#x27;s channel</span>
ticker.Stop() <span class="hljs-comment">// cause the ticker&#x27;s goroutine to terminate</span></code></pre>
</li>
</ul>
</li>
<li><p>有时候我们希望能够从channel中发送或者接收值，并避免因为发送或者接收导致的阻塞，尤其是当channel没有准备好写或者读时。select语句就可以实现这样的功能。select会有一个default来设置当其它的操作都不能够马上被处理时程序需要执行哪些逻辑。</p>
<ul>
<li><p>下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”。</p>
<pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;
<span class="hljs-keyword">case</span> &lt;-abort:
	fmt.Printf(<span class="hljs-string">&quot;Launch aborted!\n&quot;</span>)
	<span class="hljs-keyword">return</span>
<span class="hljs-keyword">default</span>:
	<span class="hljs-comment">// do nothing</span>
&#125;</code></pre>
</li>
<li><p>channel的零值是nil。也许会让你觉得比较奇怪，nil的channel有时候也是有一些用处的。因为对一个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到。</p>
</li>
<li><p>这使得我们可以用nil来激活或者禁用case，来达成处理其它输入或输出事件时超时和取消的逻辑。我们会在下一节中看到一个例子。</p>
</li>
</ul>
</li>
</ul>
<h3 id="ch8-8-示例：并发的字典遍历"><a href="#ch8-8-示例：并发的字典遍历" class="headerlink" title="ch8.8   示例：并发的字典遍历"></a>ch8.8   示例：并发的字典遍历</h3><ul>
<li><p>在本小节中，我们会创建一个程序来生成指定目录的硬盘使用情况报告，这个程序和Unix里的du工具比较相似。大多数工作用下面这个walkDir函数来完成，这个函数使用dirents函数来枚举一个目录下的所有入口。</p>
<p><u><i>gopl.io/ch8/du1</i></u></p>
<pre><code class="hljs go"><span class="hljs-comment">// walkDir recursively walks the file tree rooted at dir</span>
<span class="hljs-comment">// and sends the size of each found file on fileSizes.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkDir</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>, fileSizes <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int64</span>)</span></span> &#123;
	<span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> dirents(dir) &#123;
		<span class="hljs-keyword">if</span> entry.IsDir() &#123;
			subdir := filepath.Join(dir, entry.Name())
			walkDir(subdir, fileSizes)
		&#125; <span class="hljs-keyword">else</span> &#123;
			fileSizes &lt;- entry.Size()
		&#125;
	&#125;
&#125;

<span class="hljs-comment">// dirents returns the entries of directory dir.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dirents</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">os</span>.<span class="hljs-title">FileInfo</span></span> &#123;
	entries, err := ioutil.ReadDir(dir)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;du1: %v\n&quot;</span>, err)
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
	&#125;
	<span class="hljs-keyword">return</span> entries
&#125;</code></pre>
</li>
<li><p>ioutil.ReadDir函数会返回一个os.FileInfo类型的slice，os.FileInfo类型也是os.Stat这个函数的返回值。对每一个子目录而言，walkDir会递归地调用其自身，同时也在递归里获取每一个文件的信息。walkDir函数会向fileSizes这个channel发送一条消息。这条消息包含了文件的字节大小。</p>
</li>
<li><p>下面的主函数，用了两个goroutine。后台的goroutine调用walkDir来遍历命令行给出的每一个路径并最终关闭fileSizes这个channel。主goroutine会对其从channel中接收到的文件大小进行累加，并输出其和。</p>
<pre><code class="hljs go"><span class="hljs-keyword">package</span> main

<span class="hljs-keyword">import</span> (
	<span class="hljs-string">&quot;flag&quot;</span>
	<span class="hljs-string">&quot;fmt&quot;</span>
	<span class="hljs-string">&quot;io/ioutil&quot;</span>
	<span class="hljs-string">&quot;os&quot;</span>
	<span class="hljs-string">&quot;path/filepath&quot;</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">// Determine the initial directories.</span>
	flag.Parse()
	roots := flag.Args()
	<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(roots) == <span class="hljs-number">0</span> &#123;
		roots = []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;.&quot;</span>&#125;
	&#125;

	<span class="hljs-comment">// Traverse the file tree.</span>
	fileSizes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int64</span>)
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		<span class="hljs-keyword">for</span> _, root := <span class="hljs-keyword">range</span> roots &#123;
			walkDir(root, fileSizes)
		&#125;
		<span class="hljs-built_in">close</span>(fileSizes)
	&#125;()

	<span class="hljs-comment">// Print the results.</span>
	<span class="hljs-keyword">var</span> nfiles, nbytes <span class="hljs-keyword">int64</span>
	<span class="hljs-keyword">for</span> size := <span class="hljs-keyword">range</span> fileSizes &#123;
		nfiles++
		nbytes += size
	&#125;
	printDiskUsage(nfiles, nbytes)
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printDiskUsage</span><span class="hljs-params">(nfiles, nbytes <span class="hljs-keyword">int64</span>)</span></span> &#123;
	fmt.Printf(<span class="hljs-string">&quot;%d files  %.1f GB\n&quot;</span>, nfiles, <span class="hljs-keyword">float64</span>(nbytes)/<span class="hljs-number">1e9</span>)
&#125;</code></pre>

<ul>
<li><p>这个程序会在打印其结果之前卡住很长时间。</p>
<pre><code class="hljs awk">$ go build gopl.io<span class="hljs-regexp">/ch8/</span>du1
$ .<span class="hljs-regexp">/du1 $HOME /u</span>sr <span class="hljs-regexp">/bin /</span>etc
<span class="hljs-number">213201</span> files  <span class="hljs-number">62.7</span> GB</code></pre>
</li>
</ul>
</li>
<li><p>如果在运行的时候能够让我们知道处理进度的话想必更好。但是，如果简单地把printDiskUsage函数调用移动到循环里会导致其打印出成百上千的输出。</p>
</li>
<li><p>下面这个du的变种会间歇打印内容，不过只有在调用时提供了-v的flag才会显示程序进度信息。在roots目录上循环的后台goroutine在这里保持不变。主goroutine现在使用了计时器来每500ms生成事件，然后用select语句来等待文件大小的消息来更新总大小数据，或者一个计时器的事件来打印当前的总大小数据。如果-v的flag在运行时没有传入的话，tick这个channel会保持为nil，这样在select里的case也就相当于被禁用了。</p>
<p><u><i>gopl.io/ch8/du2</i></u></p>
<pre><code class="hljs go"><span class="hljs-keyword">var</span> verbose = flag.Bool(<span class="hljs-string">&quot;v&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;show verbose progress messages&quot;</span>)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">// ...start background goroutine...</span>

	<span class="hljs-comment">// Print the results periodically.</span>
	<span class="hljs-keyword">var</span> tick &lt;-<span class="hljs-keyword">chan</span> time.Time
	<span class="hljs-keyword">if</span> *verbose &#123;
		tick = time.Tick(<span class="hljs-number">500</span> * time.Millisecond)
	&#125;
	<span class="hljs-keyword">var</span> nfiles, nbytes <span class="hljs-keyword">int64</span>
loop:
	<span class="hljs-keyword">for</span> &#123;
		<span class="hljs-keyword">select</span> &#123;
		<span class="hljs-keyword">case</span> size, ok := &lt;-fileSizes:
			<span class="hljs-keyword">if</span> !ok &#123;
				<span class="hljs-keyword">break</span> loop <span class="hljs-comment">// fileSizes was closed</span>
			&#125;
			nfiles++
			nbytes += size
		<span class="hljs-keyword">case</span> &lt;-tick:
			printDiskUsage(nfiles, nbytes)
		&#125;
	&#125;
	printDiskUsage(nfiles, nbytes) <span class="hljs-comment">// final totals</span>
&#125;</code></pre>

<ul>
<li><p>由于我们的程序不再使用range循环，第一个select的case必须显式地判断fileSizes的channel是不是已经被关闭了，这里可以用到channel接收的二值形式。如果channel已经被关闭了的话，程序会直接退出循环。这里的break语句用到了标签break，这样可以同时终结select和for两个循环；如果没有用标签就break的话只会退出内层的select循环，而外层的for循环会使之进入下一轮select循环。</p>
</li>
<li><p>现在程序会悠闲地为我们打印更新流：</p>
<pre><code class="hljs angelscript">$ go build gopl.io/ch8/du2
$ ./du2 -v $HOME /usr /bin /etc
<span class="hljs-number">28608</span> files  <span class="hljs-number">8.3</span> GB
<span class="hljs-number">54147</span> files  <span class="hljs-number">10.3</span> GB
<span class="hljs-number">93591</span> files  <span class="hljs-number">15.1</span> GB
<span class="hljs-number">127169</span> files  <span class="hljs-number">52.9</span> GB
<span class="hljs-number">175931</span> files  <span class="hljs-number">62.2</span> GB
<span class="hljs-number">213201</span> files  <span class="hljs-number">62.7</span> GB</code></pre>
</li>
</ul>
</li>
<li><p>然而这个程序还是会花上很长时间才会结束。完全可以并发调用walkDir，从而发挥磁盘系统的并行性能。下面这个第三个版本的du，会对每一个walkDir的调用创建一个新的goroutine。它使用sync.WaitGroup（§8.5）来对仍旧活跃的walkDir调用进行计数，另一个goroutine会在计数器减为零的时候将fileSizes这个channel关闭。</p>
<p><u><i>gopl.io/ch8/du3</i></u></p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">// ...determine roots...</span>
	<span class="hljs-comment">// Traverse each root of the file tree in parallel.</span>
	fileSizes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int64</span>)
	<span class="hljs-keyword">var</span> n sync.WaitGroup
	<span class="hljs-keyword">for</span> _, root := <span class="hljs-keyword">range</span> roots &#123;
		n.Add(<span class="hljs-number">1</span>)
		<span class="hljs-keyword">go</span> walkDir(root, &amp;n, fileSizes)
	&#125;
	<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
		n.Wait()
		<span class="hljs-built_in">close</span>(fileSizes)
	&#125;()
	<span class="hljs-comment">// ...select loop...</span>
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkDir</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>, n *sync.WaitGroup, fileSizes <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int64</span>)</span></span> &#123;
	<span class="hljs-keyword">defer</span> n.Done()
	<span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> dirents(dir) &#123;
		<span class="hljs-keyword">if</span> entry.IsDir() &#123;
			n.Add(<span class="hljs-number">1</span>)
			subdir := filepath.Join(dir, entry.Name())
			<span class="hljs-keyword">go</span> walkDir(subdir, n, fileSizes)
		&#125; <span class="hljs-keyword">else</span> &#123;
			fileSizes &lt;- entry.Size()
		&#125;
	&#125;
&#125;</code></pre>
</li>
<li><p>由于这个程序在高峰期会创建成百上千的goroutine，我们需要修改dirents函数，用计数信号量来阻止他同时打开太多的文件，就像我们在8.7节中的并发爬虫一样</p>
<pre><code class="hljs go"><span class="hljs-comment">// sema is a counting semaphore for limiting concurrency in dirents.</span>
<span class="hljs-keyword">var</span> sema = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">20</span>)

<span class="hljs-comment">// dirents returns the entries of directory dir.</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dirents</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">os</span>.<span class="hljs-title">FileInfo</span></span> &#123;
	sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;        <span class="hljs-comment">// acquire token</span>
	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; &lt;-sema &#125;() <span class="hljs-comment">// release token</span>
	<span class="hljs-comment">// ...</span></code></pre>
</li>
<li><p>这个版本比之前那个快了好几倍，尽管其具体效率还是和你的运行环境，机器配置相关。</p>
</li>
</ul>
<h3 id="ch8-9-并发的退出"><a href="#ch8-9-并发的退出" class="headerlink" title="ch8.9   并发的退出"></a>ch8.9   并发的退出</h3><ul>
<li><p>有时候我们需要通知goroutine停止它正在干的事情，比如一个正在执行计算的web服务，然而它的客户端已经断开了和服务端的连接。</p>
</li>
<li><p>Go语言并没有提供在一个goroutine中终止另一个goroutine的方法，由于这样会导致goroutine之间的共享变量落在未定义的状态上。在8.7节中的rocket launch程序中，我们往名字叫abort的channel里发送了一个简单的值，在countdown的goroutine中会把这个值理解为自己的退出信号。但是如果我们想要退出两个或者任意多个goroutine怎么办呢？</p>
</li>
<li><p>一种可能的手段是向abort的channel里发送和goroutine数目一样多的事件来退出它们。如果这些goroutine中已经有一些自己退出了，那么会导致我们的channel里的事件数比goroutine还多，这样导致我们的发送直接被阻塞。</p>
</li>
<li><p>另一方面，如果这些goroutine又生成了其它的goroutine，我们的channel里的数目又太少了，所以有些goroutine可能会无法接收到退出消息。一般情况下我们是很难知道在某一个时刻具体有多少个goroutine在运行着的。另外，当一个goroutine从abort channel中接收到一个值的时候，他会消费掉这个值，这样其它的goroutine就没法看到这条信息。为了能够达到我们退出goroutine的目的，我们需要更靠谱的策略，来通过一个channel把消息广播出去，这样goroutine们能够看到这条事件消息，并且在事件完成之后，可以知道这件事已经发生过了。</p>
</li>
<li><p>回忆一下我们关闭了一个channel并且被消费掉了所有已发送的值，操作channel之后的代码可以立即被执行，并且会产生零值。我们可以将这个机制扩展一下，来作为我们的广播机制：不要向channel发送值，而是用关闭一个channel来进行广播。</p>
</li>
<li><p>只要一些小修改，我们就可以把退出逻辑加入到前一节的du程序。首先，我们创建一个退出的channel，不需要向这个channel发送任何值，但其所在的闭包内要写明程序需要退出。我们同时还定义了一个工具函数，cancelled，这个函数在被调用的时候会轮询退出状态。</p>
<p><u><i>gopl.io/ch8/du4</i></u></p>
<pre><code class="hljs go"><span class="hljs-keyword">var</span> done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cancelled</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;
	<span class="hljs-keyword">select</span> &#123;
	<span class="hljs-keyword">case</span> &lt;-done:
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
	<span class="hljs-keyword">default</span>:
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>
	&#125;
&#125;</code></pre>
</li>
<li><p>下面我们创建一个从标准输入流中读取内容的goroutine，这是一个比较典型的连接到终端的程序。每当有输入被读到（比如用户按了回车键），这个goroutine就会把取消消息通过关闭done的channel广播出去。</p>
<pre><code class="hljs go"><span class="hljs-comment">// Cancel traversal when input is detected.</span>
<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;
	os.Stdin.Read(<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">1</span>)) <span class="hljs-comment">// read a single byte</span>
	<span class="hljs-built_in">close</span>(done)
&#125;()</code></pre>
</li>
<li><p>现在我们需要使我们的goroutine来对取消进行响应。在main goroutine中，我们添加了select的第三个case语句，尝试从done channel中接收内容。如果这个case被满足的话，在select到的时候即会返回，但在结束之前我们需要把fileSizes channel中的内容“排”空，在channel被关闭之前，舍弃掉所有值。这样可以保证对walkDir的调用不要被向fileSizes发送信息阻塞住，可以正确地完成。</p>
<pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;
	<span class="hljs-keyword">select</span> &#123;
	<span class="hljs-keyword">case</span> &lt;-done:
		<span class="hljs-comment">// Drain fileSizes to allow existing goroutines to finish.</span>
		<span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> fileSizes &#123;
			<span class="hljs-comment">// Do nothing.</span>
		&#125;
		<span class="hljs-keyword">return</span>
	<span class="hljs-keyword">case</span> size, ok := &lt;-fileSizes:
		<span class="hljs-comment">// ...</span>
	&#125;
&#125;</code></pre>
</li>
<li><p>walkDir这个goroutine一启动就会轮询取消状态，如果取消状态被设置的话会直接返回，并且不做额外的事情。这样我们将所有在取消事件之后创建的goroutine改变为无操作。</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkDir</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>, n *sync.WaitGroup, fileSizes <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int64</span>)</span></span> &#123;
	<span class="hljs-keyword">defer</span> n.Done()
	<span class="hljs-keyword">if</span> cancelled() &#123;
		<span class="hljs-keyword">return</span>
	&#125;
	<span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> dirents(dir) &#123;
		<span class="hljs-comment">// ...</span>
	&#125;
&#125;</code></pre>
</li>
<li><p>在walkDir函数的循环中我们对取消状态进行轮询可以带来明显的益处，可以避免在取消事件发生时还去创建goroutine。取消本身是有一些代价的；想要快速的响应需要对程序逻辑进行侵入式的修改。确保在取消发生之后不要有代价太大的操作可能会需要修改你代码里的很多地方，但是在一些重要的地方去检查取消事件也确实能带来很大的好处。</p>
</li>
<li><p>对这个程序的一个简单的性能分析可以揭示瓶颈在dirents函数中获取一个信号量。下面的select可以让这种操作可以被取消，并且可以将取消时的延迟从几百毫秒降低到几十毫秒。</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dirents</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">os</span>.<span class="hljs-title">FileInfo</span></span> &#123;
	<span class="hljs-keyword">select</span> &#123;
	<span class="hljs-keyword">case</span> sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="hljs-comment">// acquire token</span>
	<span class="hljs-keyword">case</span> &lt;-done:
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">// cancelled</span>
	&#125;
	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; &lt;-sema &#125;() <span class="hljs-comment">// release token</span>
	<span class="hljs-comment">// ...read directory...</span>
&#125;</code></pre>
</li>
<li><p>现在当取消发生时，所有后台的goroutine都会迅速停止并且主函数会返回。当然，当主函数返回时，一个程序会退出，而我们又无法在主函数退出的时候确认其已经释放了所有的资源</p>
<ul>
<li>因为程序都退出了，你的代码都没法执行了</li>
</ul>
</li>
<li><p>这里有一个方便的窍门我们可以一用：取代掉直接从主函数返回，我们调用一个panic，然后runtime会把每一个goroutine的栈dump下来。</p>
</li>
<li><p>如果main goroutine是唯一一个剩下的goroutine的话，他会清理掉自己的一切资源。但是如果还有其它的goroutine没有退出，他们可能没办法被正确地取消掉，也有可能被取消但是取消操作会很花时间；所以这里的一个调研还是很有必要的。我们用panic来获取到足够的信息来验证我们上面的判断，看看最终到底是什么样的情况。</p>
</li>
</ul>
<h3 id="ch8-10-示例：聊天服务"><a href="#ch8-10-示例：聊天服务" class="headerlink" title="ch8.10  示例：聊天服务"></a>ch8.10  示例：聊天服务</h3><ul>
<li><p>我们用一个聊天服务器来终结本章节的内容，这个程序可以让一些用户通过服务器向其它所有用户广播文本消息。这个程序中有四种goroutine。main和broadcaster各自是一个goroutine实例，每一个客户端的连接都会有一个handleConn和clientWriter的goroutine。broadcaster是select用法的不错的样例，因为它需要处理三种不同类型的消息。</p>
</li>
<li><p>下面演示的main goroutine的工作，是listen和accept(译注：网络编程里的概念)从客户端过来的连接。对每一个连接，程序都会建立一个新的handleConn的goroutine，就像我们在本章开头的并发的echo服务器里所做的那样。</p>
<p><u><i>gopl.io/ch8/chat</i></u></p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		log.Fatal(err)
	&#125;
	<span class="hljs-keyword">go</span> broadcaster()
	<span class="hljs-keyword">for</span> &#123;
		conn, err := listener.Accept()
		<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
			log.Print(err)
			<span class="hljs-keyword">continue</span>
		&#125;
		<span class="hljs-keyword">go</span> handleConn(conn)
	&#125;
&#125;</code></pre>
</li>
<li><p>然后是broadcaster的goroutine。他的内部变量clients会记录当前建立连接的客户端集合。其记录的内容是每一个客户端的消息发出channel的“资格”信息。</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> client <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">string</span> <span class="hljs-comment">// an outgoing message channel</span>

<span class="hljs-keyword">var</span> (
	entering = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)
	leaving  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)
	messages = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>) <span class="hljs-comment">// all incoming client messages</span>
)

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">broadcaster</span><span class="hljs-params">()</span></span> &#123;
	clients := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[client]<span class="hljs-keyword">bool</span>) <span class="hljs-comment">// all connected clients</span>
	<span class="hljs-keyword">for</span> &#123;
		<span class="hljs-keyword">select</span> &#123;
		<span class="hljs-keyword">case</span> msg := &lt;-messages:
			<span class="hljs-comment">// Broadcast incoming message to all</span>
			<span class="hljs-comment">// clients&#x27; outgoing message channels.</span>
			<span class="hljs-keyword">for</span> cli := <span class="hljs-keyword">range</span> clients &#123;
				cli &lt;- msg
			&#125;
		<span class="hljs-keyword">case</span> cli := &lt;-entering:
			clients[cli] = <span class="hljs-literal">true</span>

		<span class="hljs-keyword">case</span> cli := &lt;-leaving:
			<span class="hljs-built_in">delete</span>(clients, cli)
			<span class="hljs-built_in">close</span>(cli)
		&#125;
	&#125;
&#125;</code></pre>

<ul>
<li>broadcaster监听来自全局的entering和leaving的channel来获知客户端的到来和离开事件。当其接收到其中的一个事件时，会更新clients集合，当该事件是离开行为时，它会关闭客户端的消息发送channel。</li>
<li>broadcaster也会监听全局的消息channel，所有的客户端都会向这个channel中发送消息。当broadcaster接收到什么消息时，就会将其广播至所有连接到服务端的客户端。</li>
</ul>
</li>
<li><p>现在让我们看看每一个客户端的goroutine。handleConn函数会为它的客户端创建一个消息发送channel并通过entering channel来通知客户端的到来。然后它会读取客户端发来的每一行文本，并通过全局的消息channel来将这些文本发送出去，并为每条消息带上发送者的前缀来标明消息身份。当客户端发送完毕后，handleConn会通过leaving这个channel来通知客户端的离开并关闭连接。</p>
<pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;
	ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>) <span class="hljs-comment">// outgoing client messages</span>
	<span class="hljs-keyword">go</span> clientWriter(conn, ch)

	who := conn.RemoteAddr().String()
	ch &lt;- <span class="hljs-string">&quot;You are &quot;</span> + who
	messages &lt;- who + <span class="hljs-string">&quot; has arrived&quot;</span>
	entering &lt;- ch

	input := bufio.NewScanner(conn)
	<span class="hljs-keyword">for</span> input.Scan() &#123;
		messages &lt;- who + <span class="hljs-string">&quot;: &quot;</span> + input.Text()
	&#125;
	<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors from input.Err()</span>

	leaving &lt;- ch
	messages &lt;- who + <span class="hljs-string">&quot; has left&quot;</span>
	conn.Close()
&#125;

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clientWriter</span><span class="hljs-params">(conn net.Conn, ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)</span></span> &#123;
	<span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> ch &#123;
		fmt.Fprintln(conn, msg) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring network errors</span>
	&#125;
&#125;</code></pre>

<ul>
<li>另外，handleConn为每一个客户端创建了一个clientWriter的goroutine，用来接收向客户端发送消息的channel中的广播消息，并将它们写入到客户端的网络连接。客户端的读取循环会在broadcaster接收到leaving通知并关闭了channel后终止。</li>
</ul>
</li>
<li><p>下面演示的是当服务器有两个活动的客户端连接，并且在两个窗口中运行的情况，使用netcat来聊天：</p>
<pre><code class="hljs angelscript">$ go build gopl.io/ch8/chat
$ go build gopl.io/ch8/netcat3
$ ./chat &amp;
$ ./netcat3
You are <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64208</span>               $ ./netcat3
<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span> has arrived           You are <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span>
Hi!
<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64208</span>: Hi!                  <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64208</span>: Hi!
                                      Hi yourself.
<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span>: Hi yourself.         <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span>: Hi yourself.
^C
                                      <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64208</span> has left
$ ./netcat3
You are <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64216</span>               <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64216</span> has arrived
                                      Welcome.
<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span>: Welcome.             <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span>: Welcome.
                                      ^C
<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span> has left”</code></pre>
</li>
<li><p>当与n个客户端保持聊天session时，这个程序会有2n+2个并发的goroutine，然而这个程序却并不需要显式的锁（§9.2）。clients这个map被限制在了一个独立的goroutine broadcaster中，所以它不能被并发地访问。多个goroutine共享的变量只有这些channel和net.Conn的实例，两个东西都是并发安全的。我们会在下一章中更多地讲解约束，并发安全以及goroutine中共享变量的含义。</p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Book/">Book</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/go/">go</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处。</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2020/11/23/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%889%EF%BC%89/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">The Go Programming Language（9）</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2020/11/22/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%888%EF%BC%89-%20goroutine/">
                        <span class="hidden-mobile">The Go Programming Language（8）- goroutine</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://1ch0.github.io/" target="_blank" rel="nofollow noopener"><span>1ch0</span></a> <i class="iconfont icon-love"></i> <a href="https://1ch0.github.io/" target="_blank" rel="nofollow noopener"><span>Go</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "The Go Programming Language（8）- channel&nbsp;",
      ],
      cursorChar: ".",
      typeSpeed: 100,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>















</body>
</html>
