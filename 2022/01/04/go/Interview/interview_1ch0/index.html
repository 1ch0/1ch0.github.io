

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="1ch0">
  <meta name="keywords" content="">
  <title>Go Interview - 1ch0&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>1ch0's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                联系我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      1ch0
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-04 15:17" pubdate>
        2022年1月4日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      10k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      116
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Go Interview</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：4 个月前
                
              </p>
            
            <div class="markdown-body" id="post-body">
              <h1 id="Go-Interview-Summary"><a href="#Go-Interview-Summary" class="headerlink" title="Go Interview  Summary"></a>Go Interview  Summary</h1><h2 id="base-concept"><a href="#base-concept" class="headerlink" title="base concept"></a>base concept</h2><h3 id="make-new"><a href="#make-new" class="headerlink" title="make   new"></a>make   new</h3><p>new(T) make(T, args) 是 Go 语言内建函数,用来分配内存，但适用的类型不同<br><code>new(T) 会为了 T 类型新建新的内存空间并返回内存地址，即 *T, 用于 数组，结构体</code><br><code>make(T, args) 会返回初始化T类型的值，适用于 slice，map，channel</code></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>Go语言中闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此，简单的说：</p>
<p>函数 + 引用环境 = 闭包</p>
<ul>
<li>在go中，当我们<strong>调用</strong>函数或者将<strong>函数运算的结果</strong>赋值给变量的时候，是需要<strong>加括号</strong>的，同时括号里面是参数</li>
<li>在go中，当我们将<strong>函数本身</strong>赋值给某个变量的时候，是不能加括号的</li>
</ul>
<h3 id="接口类型断言和type-switch"><a href="#接口类型断言和type-switch" class="headerlink" title="接口类型断言和type-switch"></a>接口类型断言和type-switch</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/f-ck-need-u/p/9893347.html"></a></p>
<pre><code class="hljs go"><span class="hljs-keyword">package</span> main
 
<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span>
 
<span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;
	Name <span class="hljs-keyword">string</span>
&#125;
 
<span class="hljs-keyword">type</span> Mouse <span class="hljs-keyword">struct</span> &#123;
	Name <span class="hljs-keyword">string</span>
&#125;
 
<span class="hljs-keyword">type</span> Introduce <span class="hljs-keyword">interface</span> &#123;
	Intro()
&#125;
 
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span><span class="hljs-title">Intro</span><span class="hljs-params">()</span></span>&#123;
	fmt.Println(<span class="hljs-string">&quot;hi, i am Cat, you can call me:&quot;</span>,c.Name)
&#125;
 
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mouse)</span><span class="hljs-title">Intro</span><span class="hljs-params">()</span></span> &#123;
	fmt.Println(<span class="hljs-string">&quot;hi, i am Mouse, you can call me:&quot;</span>,m.Name)
&#125;

<span class="hljs-comment">// 接口参数</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selfIntro</span><span class="hljs-params">(in Introduce)</span></span>  &#123;
	in.Intro()
&#125;
 
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">typeJudge</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;
	<span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>)&#123;
	<span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>,<span class="hljs-keyword">int8</span>,<span class="hljs-keyword">int64</span>,<span class="hljs-keyword">int16</span>,<span class="hljs-keyword">int32</span>,<span class="hljs-keyword">uint</span>,<span class="hljs-keyword">uint8</span>,<span class="hljs-keyword">uint16</span>,<span class="hljs-keyword">uint32</span>,<span class="hljs-keyword">uint64</span>:
		fmt.Println(<span class="hljs-string">&quot;整型变量&quot;</span>)
	<span class="hljs-keyword">case</span> <span class="hljs-keyword">float32</span>,<span class="hljs-keyword">float64</span>:
		fmt.Println(<span class="hljs-string">&quot;浮点型变量&quot;</span>)
	<span class="hljs-keyword">case</span> []<span class="hljs-keyword">byte</span>,[]<span class="hljs-keyword">rune</span>,<span class="hljs-keyword">string</span>:
		fmt.Println(<span class="hljs-string">&quot;字符串变量&quot;</span>)
	<span class="hljs-keyword">default</span>:
		fmt.Println(<span class="hljs-string">&quot;不清楚...&quot;</span>)
	&#125;
&#125;
 

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;
	<span class="hljs-comment">//-----------动态类型--------------</span>
	tom := Cat&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;
	selfIntro(&amp;tom)
	jerry := Mouse&#123;<span class="hljs-string">&quot;Jerry&quot;</span>&#125;
	selfIntro(&amp;jerry)
	<span class="hljs-comment">//-----------类型断言与type-switch--------</span>
	typeJudge(<span class="hljs-number">1</span>)
	typeJudge(<span class="hljs-number">1.1</span>)
	typeJudge(<span class="hljs-string">&quot;1.1&quot;</span>)
	typeJudge([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hi&quot;</span>))
	typeJudge([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)
&#125;</code></pre>



<h3 id="实现-set"><a href="#实现-set" class="headerlink" title="实现 set"></a>实现 set</h3><h3 id="Go语言如何跳出多层循环"><a href="#Go语言如何跳出多层循环" class="headerlink" title="Go语言如何跳出多层循环"></a>Go语言如何跳出多层循环</h3><ol>
<li>标记, break</li>
<li>goto</li>
</ol>
<h3 id="channel-应用场景"><a href="#channel-应用场景" class="headerlink" title="channel  应用场景"></a>channel  应用场景</h3><blockquote>
<ul>
<li>数据交流：当作并发的 buffer 或者 queue，解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者（Producer）和消费者（Consumer）。</li>
<li>数据传递：一个 goroutine 将数据交给另一个 goroutine，相当于把数据的拥有权 (引用) 托付出去。</li>
<li>信号通知：一个 goroutine 可以将信号 (closing、closed、data ready 等) 传递给另一个或者另一组 goroutine。</li>
<li>任务编排：可以让一组 goroutine 按照一定的顺序并发或者串行的执行，这就是编排的功能。</li>
<li>锁：利用 Channel 也可以实现互斥锁的机制。</li>
</ul>
</blockquote>
<h3 id="知道golang的内存逃逸吗？什么情况下会发生内存逃逸？"><a href="#知道golang的内存逃逸吗？什么情况下会发生内存逃逸？" class="headerlink" title="知道golang的内存逃逸吗？什么情况下会发生内存逃逸？"></a>知道golang的<strong>内存逃逸</strong>吗？什么情况下会发生内存逃逸？</h3><p><code>golang程序变量</code>会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在<code>栈上</code>分配。否则就说它 <code>逃逸</code> 了，必须在<code>堆上分配</code>。</p>
<p>能引起变量逃逸到堆上的<strong>典型情况</strong>：</p>
<ul>
<li><strong>在方法内把局部变量指针返回</strong> 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。</li>
<li><strong>发送指针或带有指针的值到 channel 中。</strong> 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。</li>
<li>*<strong>在一个切片上存储指针或带指针的值。</strong> 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</li>
<li><strong>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。</strong> slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</li>
<li><strong>在 interface 类型上调用方法。</strong> 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。</li>
</ul>
<h3 id="append-实现传入切片"><a href="#append-实现传入切片" class="headerlink" title="append 实现传入切片"></a>append 实现传入切片</h3><h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h3><p>append的时候发生扩容的动作</p>
<ul>
<li>append单个元素，或者append少量的多个元素，这里的少量指double之后的容量能容纳，这样就会走以下扩容流程，不足1024，双倍扩容，超过1024的，1.25倍扩容。</li>
<li>若是append多个元素，且double后的容量不能容纳，直接使用预估的容量。</li>
</ul>
<p><strong>以上两个分支得到新容量后，均需要根据slice的类型size，算出新的容量所需的内存情况<code>capmem</code>，然后再进行<code>capmem</code>向上取整，得到新的所需内存，除上类型size，得到真正的最终容量,作为新的slice的容量。</strong></p>
<h3 id="nil切片和空切片指向的地址一样吗"><a href="#nil切片和空切片指向的地址一样吗" class="headerlink" title="nil切片和空切片指向的地址一样吗"></a><strong>nil切片和空切片指向的地址一样吗</strong></h3><ul>
<li><strong>nil切片和空切片指向的地址不一样。nil空切片引用数组指针地址为0（无指向任何实际地址）</strong></li>
<li><strong>空切片的引用数组指针地址是有的，且固定为一个值</strong></li>
</ul>
<h3 id="json包里使用的时候，结构体里的变量不加tag能不能正常转成json里的字段？"><a href="#json包里使用的时候，结构体里的变量不加tag能不能正常转成json里的字段？" class="headerlink" title="json包里使用的时候，结构体里的变量不加tag能不能正常转成json里的字段？"></a><code>json</code>包里使用的时候，结构体里的变量不加<code>tag</code>能不能正常转成<code>json</code>里的字段？</h3><ul>
<li><p>如果变量<code>首字母小写</code>，则为<code>private</code>。无论如何<code>不能转</code>，因为取不到<code>反射信息</code>。</p>
</li>
<li><p>如果变量<code>首字母大写</code>，则为<code>public</code>。</p>
</li>
<li><ul>
<li><code>不加tag</code>，可以正常转为<code>json</code>里的字段，<code>json</code>内字段名跟结构体内字段<code>原名一致</code>。</li>
<li><code>加了tag</code>，从<code>struct</code>转<code>json</code>的时候，<code>json</code>的字段名就是<code>tag</code>里的字段名，原字段名已经没用。</li>
</ul>
</li>
</ul>
<h3 id="for循环select时，如果通道已经关闭会怎么样？如果select中的case只有一个，又会怎么样？"><a href="#for循环select时，如果通道已经关闭会怎么样？如果select中的case只有一个，又会怎么样？" class="headerlink" title="for循环select时，如果通道已经关闭会怎么样？如果select中的case只有一个，又会怎么样？"></a><code>for</code>循环<code>select</code>时，如果通道已经关闭会怎么样？如果<code>select</code>中的<code>case</code>只有一个，又会怎么样？</h3><ul>
<li>for循环<code>select</code>时，如果其中一个case通道已经关闭，则每次都会执行到这个case。</li>
<li>如果select里边只有一个case，而这个case被关闭了，则会出现死循环。</li>
</ul>
<p>把关闭后的通道至赋值为 nil ， 则 select 读取会阻塞</p>
<ul>
<li><code>select</code>中如果任意某个通道有值可读时，它就会被执行，其他被忽略。</li>
<li>如果没有<code>default</code>字句，<code>select</code>将有可能阻塞，直到某个通道有值可以运行，所以<code>select</code>里最好有一个<code>default</code>，否则将有一直阻塞的风险。</li>
</ul>
<h3 id="对已经关闭的的-chan-进行读写，会怎么样？为什么？"><a href="#对已经关闭的的-chan-进行读写，会怎么样？为什么？" class="headerlink" title="对已经关闭的的 chan 进行读写，会怎么样？为什么？"></a>对<strong>已经关闭</strong>的的 <code>chan</code> 进行读写，会怎么样？<strong>为什么？</strong></h3><ul>
<li><p>读<strong>已经关闭</strong>的 <code>chan</code> 能一直读到东西，但是读到的内容根据通道内<code>关闭前</code>是否有元素而不同。</p>
</li>
<li><ul>
<li>如果 <code>chan</code> 关闭前，<code>buffer</code> 内有元素<strong>还未读</strong> , 会正确读到 <code>chan</code> 内的值，且返回的第二个 bool 值（是否读成功）为 <code>true</code>。</li>
<li>如果 <code>chan</code> 关闭前，<code>buffer</code> 内有元素<strong>已经被读完</strong>，<code>chan</code> 内无值，接下来所有接收的值都会非阻塞直接成功，返回 <code>channel</code> 元素的<strong>零值</strong>，但是第二个 <code>bool</code> 值一直为 <code>false</code>。</li>
</ul>
</li>
<li><p>写<strong>已经关闭</strong>的 <code>chan</code> 会 <code>panic</code></p>
</li>
</ul>
<h3 id="对未初始化的的-chan-进行读写，会怎么样？为什么？"><a href="#对未初始化的的-chan-进行读写，会怎么样？为什么？" class="headerlink" title="对未初始化的的 chan 进行读写，会怎么样？为什么？"></a>对<strong>未初始化</strong>的的 <code>chan</code> 进行读写，会怎么样？<strong>为什么？</strong></h3><p>读写<strong>未初始化</strong>的 <code>chan</code> 都会<strong>阻塞</strong>。</p>
<h3 id="能说说uintptr和unsafe-Pointer的区别吗？"><a href="#能说说uintptr和unsafe-Pointer的区别吗？" class="headerlink" title="能说说uintptr和unsafe.Pointer的区别吗？"></a>能说说uintptr和unsafe.Pointer的区别吗？</h3><ul>
<li>unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；</li>
<li>而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；</li>
<li>unsafe.Pointer 可以和 普通指针 进行相互转换；</li>
<li>unsafe.Pointer 可以和 uintptr 进行相互转换。</li>
</ul>
<h3 id="拷贝大切片一定比小切片代价大吗？"><a href="#拷贝大切片一定比小切片代价大吗？" class="headerlink" title="拷贝大切片一定比小切片代价大吗？"></a>拷贝大切片一定比小切片代价大吗？</h3><p>并不是，所有切片的大小相同；<strong>三个字段</strong>（一个 uintptr，两个int）。切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字。所以 <strong>拷贝大切片跟小切片的代价应该是一样的</strong>。</p>
<h3 id="字符串转成byte数组，会发生内存拷贝吗？"><a href="#字符串转成byte数组，会发生内存拷贝吗？" class="headerlink" title="字符串转成byte数组，会发生内存拷贝吗？"></a>字符串转成byte数组，会发生内存拷贝吗？</h3><p>字符串转成切片，会产生拷贝。严格来说，只要是发生类型强转都会发生内存拷贝。那么问题来了。<br>频繁的内存拷贝操作听起来对性能不大友好。<strong>有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢？</strong></p>
<ul>
<li><p>想要在底层转换二者，只需要把 <code>StringHeader</code> 的地址强转成 <code>SliceHeader</code> 就行。那么go有个很强的包叫 <code>unsafe</code> 。</p>
</li>
<li><ul>
<li>1.<code>unsafe.Pointer(&amp;a)</code>方法可以得到变量<code>a</code>的地址。</li>
<li>2.<code>(*reflect.StringHeader)(unsafe.Pointer(&amp;a))</code> 可以把字符串a转成底层结构的形式。</li>
<li>3.<code>(*[]byte)(unsafe.Pointer(&amp;ssh))</code> 可以把ssh底层结构体转成byte的切片的指针。</li>
<li>4.再通过 <code>*</code>转为指针指向的实际内容。</li>
</ul>
</li>
</ul>
<h3 id="翻转含有中文、数字、英文字母的字符串"><a href="#翻转含有中文、数字、英文字母的字符串" class="headerlink" title="翻转含有中文、数字、英文字母的字符串"></a>翻转含有<code>中文、数字、英文字母</code>的字符串</h3><ul>
<li><code>rune</code>关键字，从golang源码中看出，它是int32的别名（-2^31 ~ 2^31-1），比起byte（-128～127），<strong>可表示更多的字符</strong>。</li>
<li>由于rune可表示的范围更大，所以能处理一切字符，当然也包括<strong>中文字符</strong>。在平时计算中文字符，可用rune。</li>
<li>因此将<code>字符串</code>转为<code>rune的切片</code>，再进行翻转，完美解决。</li>
</ul>
<h3 id="在不执行resp-Body-Close-的情况下，泄漏了吗？如果泄漏，泄漏了多少个goroutine"><a href="#在不执行resp-Body-Close-的情况下，泄漏了吗？如果泄漏，泄漏了多少个goroutine" class="headerlink" title="在不执行resp.Body.Close()的情况下，泄漏了吗？如果泄漏，泄漏了多少个goroutine?"></a><strong>在不执行<code>resp.Body.Close()</code>的情况下，泄漏了吗？如果泄漏，泄漏了多少个<code>goroutine</code>?</strong></h3><ul>
<li><p><code>http.Get</code> 默认使用 <code>DefaultTransport</code> 管理连接。</p>
</li>
<li><p>所以结论呼之欲出了，虽然执行了 <code>6</code> 次循环，而且每次都没有执行 <code>Body.Close()</code> ,就是因为执行了<code>ioutil.ReadAll()</code>把内容都读出来了，连接得以复用，因此只泄漏了一个<code>读goroutine</code>和一个<code>写goroutine</code>，最后加上<code>main goroutine</code>，所以答案就是<code>3个goroutine</code>。</p>
</li>
<li><p>从另外一个角度说，正常情况下我们的代码都会执行 <code>ioutil.ReadAll()</code>，但如果此时忘了 <code>resp.Body.Close()</code>，确实会导致泄漏。但如果你<strong>调用的域名一直是同一个</strong>的话，那么只会泄漏一个 <code>读goroutine</code> 和一个<code>写goroutine</code>，<strong>这就是为什么代码明明不规范但却看不到明显内存泄漏的原因</strong>。</p>
</li>
</ul>
<h3 id="数据库连接池orm"><a href="#数据库连接池orm" class="headerlink" title="数据库连接池orm"></a>数据库连接池orm</h3><blockquote>
<p>本文由 <a target="_blank" rel="noopener" href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a target="_blank" rel="noopener" href="https://blog.csdn.net/gcglhd/article/details/109717743">blog.csdn.net</a></p>
</blockquote>
<p>背景：</p>
<pre><code>    在开发过程中遇到一个瓶颈那就是，数据库的连接池设置，有两个需求第一个就是**大量用户同时并发操作数据库的时候，会出现连接超时问题**。其次就是用户**少量的时候如何实现快速的实现数据的相关操作**：针对这两个问题，我们需要进行相关的数据库的配置。</code></pre>
<p>首先我们采用的是 Go 语言开发，然后使用的就是 Gorm 包进行相关的数据库操作。</p>
<ol>
<li>Grom 相关的学习文档如下：</li>
</ol>
<p><a target="_blank" rel="noopener" href="http://gorm.book.jasperxu.com/">http://gorm.book.jasperxu.com/</a></p>
<p><a target="_blank" rel="noopener" href="https://gorm.io/docs/generic_interface.html">https://gorm.io/docs/generic_interface.html</a></p>
<ol start="2">
<li>连接池的原理参考博客：</li>
</ol>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39902875/article/details/112098338">https://blog.csdn.net/weixin_39902875/article/details/112098338</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/taoshihan/p/11922953.html">https://www.cnblogs.com/taoshihan/p/11922953.html</a></p>
<ol start="3">
<li>针对背景中遇到的问题，我们进行相关的处理：</li>
</ol>
<p>1） 针对大量用户并发操作数据库出现连接超时问题：</p>
<p>gorm 底层是根据 sql.DB 实现的，而 sql.DB 里面提供了相关的配置函数：</p>
<pre><code class="hljs yaml"><span class="hljs-attr">datasource:</span>
  <span class="hljs-attr">maxConn:</span> <span class="hljs-number">200</span>
  <span class="hljs-attr">maxOpen:</span> <span class="hljs-number">200</span></code></pre>

<p>2）针对少量用户快速实现相关数据库1操作的问题：</p>
<p>gorm 底层是根据 sql.DB 实现的，而 sql.DB 里面提供了相关的配置函数：</p>
<pre><code class="hljs go"><span class="hljs-keyword">type</span> Database <span class="hljs-keyword">struct</span> &#123;
	MaxConn <span class="hljs-keyword">int</span>
	MaxOpen <span class="hljs-keyword">int</span>
&#125;
<span class="hljs-keyword">var</span> DatabaseConfig = <span class="hljs-built_in">new</span>(Database) <span class="hljs-comment">//设置全局的引用型指针变量</span>
 
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetConfig</span><span class="hljs-params">()</span> *<span class="hljs-title">Database</span></span> &#123;
	viper.SetConfigFile(<span class="hljs-string">&quot;conf/settings.yml&quot;</span>)
	content, err := ioutil.ReadFile(<span class="hljs-string">&quot;conf/settings.yml&quot;</span>)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		fmt.Println(<span class="hljs-string">&quot;ioutil获取配置文件失败！&quot;</span>)
	&#125;
	err = viper.ReadConfig(strings.NewReader(os.ExpandEnv(<span class="hljs-keyword">string</span>(content))))
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		fmt.Println(<span class="hljs-string">&quot;viperhuoqu 配置文件失败！&quot;</span>)
	&#125;
	cfgDatabase := viper.Sub(<span class="hljs-string">&quot;datasource&quot;</span>)
	DatabaseConfig = InitDatabase(cfgDatabase)
	<span class="hljs-keyword">return</span> DatabaseConfig
&#125;
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitDatabase</span><span class="hljs-params">(cfg *viper.Viper)</span> *<span class="hljs-title">Database</span></span> &#123;
	db := &amp;Database&#123;
		MaxConn: cfg.GetInt(<span class="hljs-string">&quot;maxConn&quot;</span>),
		MaxOpen: cfg.GetInt(<span class="hljs-string">&quot;maxOpen&quot;</span>),
	&#125;
	<span class="hljs-keyword">return</span> db
&#125;</code></pre>

<p><strong>3）一般情况上面的两个函数是一起使用的，而且最大连接数的设置，必须要大于最大可空闲连接数。</strong></p>
<p>实例：我们下面以一个 Gorm 的实例进行相关的使用说明：</p>
<p>第一步： 我们要采用配置文件的方式进行相关的测试，配置文件名称：setings.yml。内容如下：</p>
<pre><code class="hljs stata"><span class="hljs-keyword">var</span> <span class="hljs-keyword">DB</span> *gorm.<span class="hljs-keyword">DB</span>
func main() &#123;
	<span class="hljs-comment">//获得一个*grom.DB对象</span>
	<span class="hljs-keyword">DB</span>, <span class="hljs-keyword">err</span> := gorm.<span class="hljs-keyword">Open</span>(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;username:password@/database?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>)
	<span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;
		fmt.Println(<span class="hljs-string">&quot;Gorm 异常：&quot;</span>, <span class="hljs-keyword">err</span>)
	&#125;
	<span class="hljs-comment">//根据*grom.DB对象获得*sql.DB的通用数据库接口</span>
	sqlDb := <span class="hljs-keyword">DB</span>.<span class="hljs-keyword">DB</span>()
	defer sqlDb.<span class="hljs-keyword">Close</span>()
	database := GetConfig()
	fmt.Println(<span class="hljs-string">&quot;maxConn: &quot;</span>, database.MaxConn)
	fmt.Println(<span class="hljs-string">&quot;maxOpen: &quot;</span>, database.MaxOpen)
	sqlDb.SetMaxOpenConns(database.MaxOpen)	<span class="hljs-comment">//设置最大连接数</span>
    sqlDb.SetMaxIdleConns(database.MaxConn) <span class="hljs-comment">//设置最大的空闲连接数</span>
	data, _ := json.Marshal(sqlDb.Stats()) <span class="hljs-comment">//获得当前的SQL配置情况</span>
	fmt.Println(<span class="hljs-built_in">string</span>(data))
&#125;</code></pre>

<p>第二步：相关的 viper 获取配置文件信息，具体的细节可以参考我之前的相关博客：  </p>
<pre><code class="hljs taggerscript">GOROOT=D:<span class="hljs-symbol">\G</span>o #gosetup
GOPATH=E:<span class="hljs-symbol">\G</span>opath;E:<span class="hljs-symbol">\D</span>evelop<span class="hljs-symbol">\g</span>owork;E:<span class="hljs-symbol">\G</span>ITwork<span class="hljs-symbol">\g</span>inWork #gosetup
D:<span class="hljs-symbol">\G</span>o<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\g</span>o.exe build -o C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\g</span>ree<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\T</span>emp<span class="hljs-symbol">\_</span>__8go_build_main_go.exe E:<span class="hljs-symbol">\D</span>evelop<span class="hljs-symbol">\g</span>owork<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\t</span>est<span class="hljs-symbol">\m</span>ain.go #gosetup
C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\g</span>ree<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\T</span>emp<span class="hljs-symbol">\_</span>__8go_build_main_go.exe #gosetup
maxConn:  200
maxOpen:  200
&#123;&quot;MaxOpenConnections&quot;:200,&quot;OpenConnections&quot;:1,&quot;InUse&quot;:0,&quot;Idle&quot;:1,&quot;WaitCount&quot;:0,&quot;WaitDuration&quot;:0,&quot;MaxIdleClosed&quot;:0,&quot;MaxIdleTimeClosed&quot;:0,&quot;MaxLifetimeClosed&quot;:0&#125;
 
Process finished with exit code 0</code></pre>

<p>第三步： 主函数进行相关的测试：</p>
<pre><code class="hljs stata">func Test2(t *testing.T) &#123;
	dsn := <span class="hljs-string">&quot;root:****@tcp(127.0.0.1:3306)/Mytest?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>
	<span class="hljs-keyword">db</span>, _ := gorm.<span class="hljs-keyword">Open</span>(mysql.<span class="hljs-keyword">Open</span>(dsn), &amp;gorm.Config&#123;&#125;)
	<span class="hljs-keyword">var</span> <span class="hljs-keyword">pro</span> ProTransMapping
	<span class="hljs-keyword">pro</span>.ID = 1
 
	<span class="hljs-keyword">db</span>.Debug().Where(<span class="hljs-string">&quot;id = ?&quot;</span>,<span class="hljs-keyword">pro</span>.ID).Take(&amp;<span class="hljs-keyword">pro</span>)
	<span class="hljs-keyword">pro</span>.Manufacturer = <span class="hljs-string">&quot;&quot;</span>
	<span class="hljs-keyword">pro</span>.DevicePro = <span class="hljs-string">&quot;&quot;</span>
	<span class="hljs-keyword">db</span>.<span class="hljs-keyword">Save</span>(&amp;<span class="hljs-keyword">pro</span>)
&#125;</code></pre>

<p> 最后一步就是：测试验证：</p>
<pre><code class="hljs taggerscript">GOROOT=D:<span class="hljs-symbol">\G</span>o #gosetup
GOPATH=E:<span class="hljs-symbol">\G</span>opath;E:<span class="hljs-symbol">\D</span>evelop<span class="hljs-symbol">\g</span>owork;E:<span class="hljs-symbol">\G</span>ITwork<span class="hljs-symbol">\g</span>inWork #gosetup
D:<span class="hljs-symbol">\G</span>o<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\g</span>o.exe build -o C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\g</span>ree<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\T</span>emp<span class="hljs-symbol">\_</span>__8go_build_main_go.exe E:<span class="hljs-symbol">\D</span>evelop<span class="hljs-symbol">\g</span>owork<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\t</span>est<span class="hljs-symbol">\m</span>ain.go #gosetup
C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\g</span>ree<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\T</span>emp<span class="hljs-symbol">\_</span>__8go_build_main_go.exe #gosetup
maxConn:  200
maxOpen:  200
&#123;&quot;MaxOpenConnections&quot;:200,&quot;OpenConnections&quot;:1,&quot;InUse&quot;:0,&quot;Idle&quot;:1,&quot;WaitCount&quot;:0,&quot;WaitDuration&quot;:0,&quot;MaxIdleClosed&quot;:0,&quot;MaxIdleTimeClosed&quot;:0,&quot;MaxLifetimeClosed&quot;:0&#125;
 
Process finished with exit code 0</code></pre>

<p>二.  更新空值问题：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/oxspirt/p/11240527.html">https://www.cnblogs.com/oxspirt/p/11240527.html</a></p>
<pre><code>  方法 1 ：当前遇到一个问题，那就是使用 gorm 的时候采用更新方式去更新数据，如果更新后的值为 0，“” 或者 nil，就不会更新该字段，而是只更新非空的其他字段。</code></pre>
<p>解决方式，采用 map 去更新要更新的数据，不需要采用 struct 结构体。</p>
<pre><code>  方法 2： 采用 save 的方式，先进行 take 获取源数据，然后在 save 进行保存。</code></pre>
<pre><code class="hljs stata">func Test2(t *testing.T) &#123;
	dsn := <span class="hljs-string">&quot;root:****@tcp(127.0.0.1:3306)/Mytest?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>
	<span class="hljs-keyword">db</span>, _ := gorm.<span class="hljs-keyword">Open</span>(mysql.<span class="hljs-keyword">Open</span>(dsn), &amp;gorm.Config&#123;&#125;)
	<span class="hljs-keyword">var</span> <span class="hljs-keyword">pro</span> ProTransMapping
	<span class="hljs-keyword">pro</span>.ID = 1
 
	<span class="hljs-keyword">db</span>.Debug().Where(<span class="hljs-string">&quot;id = ?&quot;</span>,<span class="hljs-keyword">pro</span>.ID).Take(&amp;<span class="hljs-keyword">pro</span>)
	<span class="hljs-keyword">pro</span>.Manufacturer = <span class="hljs-string">&quot;&quot;</span>
	<span class="hljs-keyword">pro</span>.DevicePro = <span class="hljs-string">&quot;&quot;</span>
	<span class="hljs-keyword">db</span>.<span class="hljs-keyword">Save</span>(&amp;<span class="hljs-keyword">pro</span>)
&#125;</code></pre>


<p>最近在使用 go 语言的 orm 做一些数据库的操作，最后发现了一个 bug 就是 invalid connection，所以就去的了解了一下链接池和 mysql 的超时时间，下面我就用 go 的 orm+mysql 来说明（我理解语言都是相通的，原理应该都是一样的）。</p>
<p>在我们要对数据库进行增删改查的时候，第一步就是要去连接数据库</p>
<pre><code class="hljs go"><span class="hljs-comment">//conn the database</span>
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ConnDb</span><span class="hljs-params">(dbConnString <span class="hljs-keyword">string</span>, dbName <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;
	maxIdle := <span class="hljs-number">50</span>
	maxConn := <span class="hljs-number">50</span>
	err := orm.RegisterDataBase(dbName, <span class="hljs-string">&quot;mysql&quot;</span>, dbConnString+<span class="hljs-string">&quot;?charset=utf8&amp;loc=Asia%2FShanghai&quot;</span>, maxIdle, maxConn)
 
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;
		util.GLogger.Errorw(<span class="hljs-string">&quot;in Connect DB&quot;</span>, <span class="hljs-string">&quot;err&quot;</span>, err)
	&#125;
	<span class="hljs-keyword">return</span> err
&#125;</code></pre>

<p>这里面连接的就是 mysql 数据库，设置的最大连接池为 50，最大空闲连接是 50。</p>
<p>而这个连接池主要是做什么的呢？简单的说就是，你要去数据库里面拿数据改数据，你就需要和数据库建立起一个管道，这个就是建立一个网络连接，我们都知道 tcp 连接是比较耗时的，那么既然已经花了一定时间去建立了这个管道，那么我怎么才能随取随用，而不用丢弃呢？那么连接池就是存放这些已经建立的管道的地方，50 这个数值呢，可以简单的理解成最多放 50 个管道，注意，这个并不是越大越好，因为太大的话会比较占内存，当然了太小了会出现等待阻塞的情况。</p>
<p>既然连接池里面就是放这些管道的，那么空闲连接就是指这些空闲的管道，那么就很明显了，空闲连接的数值设置就不要大于连接池的大小了，因为大了连接池也不会帮你保存那么多的空闲连接管道的。</p>
<p>了解了这些简单的概念之后，那么每次访问数据库的时候是怎么一个工作流呢？</p>
<p><img src="https://img-blog.csdnimg.cn/20190917000424380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbmxhaXBlbmcxMQ==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif"></p>
<p>通过这个图我们就可以很清晰的看到整个连接访问的流程。</p>
<p>step1（获取可用的连接）去连接池里面寻找可用的空闲连接，如果没有空闲的连接了，那么就去判断是否连接池已满，如果没有超过，那么就去新建一个连接，如果满了，那么就等待连接的释放；当然了，如果有空闲连接的话，就直接判断这个连接是否过期，没有过期就直接用，过期了就重新去判断这个连接池是否已经满了，没有的话就去新建连接，满了就等待。</p>
<p>step2 （操作数据库）拿到了这个连接就去做增删改查操作。</p>
<p>step3 （释放连接）操作完数据库之后需要释放连接，那么释放的连接就会空闲下来，如果超过空闲连接数，就是直接关闭掉，如果没有就给等待的使用。</p>
<p>那么你就会注意到了，这个连接是会失效的：</p>
<p>mysql 数据库的 timeout，当你和数据库建立起连接的时候，数据库不能一直信任你啊，那么数据库就有了超时这一说，就是过了这个时间段我就不信任你这个连接了，你必须再次和我连接，查看数据库设置的各种超时时间的语句如下：</p>
<pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span>  <span class="hljs-string">&#x27;%timeout%&#x27;</span>;</code></pre>

<p>其中这里面会有两个超时时间：交互式连接超时时间（interactive_timeout）和非交互式连接超时时间（wait_timeout）</p>
<p>交互式连接：就是你通过命令行与 mysql 连接</p>
<p>非交互式连接：就是在程序中与 mysql 连接</p>
<p>而这个非交互超时时间就是在连接池里面一直空闲的连接的空闲时间超过 wait_timeout 的设定的时候就会失效。那么这个时候当程序拿到这个空闲连接的时候去做查询的时候就会出现最开始出现的问题，invalid connection。</p>
<p>了解了基本原理之后，针对 invalid connection 无效连接的解决办法就很简单了：</p>
<ol>
<li><p>延长数据库的 wait_timeout 时间。</p>
</li>
<li><p>程序定时去检查这些失效的连接及时丢弃掉，注意这里程序的检查时间就需要小于 mysql 设置的 wait_timeout 的值。</p>
</li>
</ol>
<p>以上就是我对连接池的理解，如有错误还请大神指出，谢谢～</p>
<h3 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h3><p>1、Simple RPC<br>proto语法 :<br>简单rpc 这就是一般的rpc调用，一个请求对象对应一个返回对象<br>proto语法：</p>
<p>rpc simpleHello(Person) returns (Result) {}<br>1<br>客户端发起一次请求，服务端响应一个数据，即标准RPC通信。<br>这种模式，一个每一次都是发起一个独立的tcp连接，走一次三次握手和四次挥手！</p>
<p>2、 Server-side streaming RPC<br>服务端流式rpc 一个请求对象，服务端可以传回多个结果对象<br>proto语法 :</p>
<p>rpc serverStreamHello(Person) returns (stream Result) {}<br>1<br>服务端流 RPC 下，客户端发出一个请求，但不会立即得到一个响应，而是在服务端与客户端之间建立一个单向的流，服务端可以随时向流中写入多个响应消息，最后主动关闭流，而客户端需要监听这个流，不断获取响应直到流关闭</p>
<p>应用场景举例：<br>典型的例子是客户端向服务端发送一个股票代码，服务端就把该股票的实时数据源源不断的返回给客户端。</p>
<p>3、Client-side streaming RPC<br>客户端流式rpc 客户端传入多个请求对象，服务端返回一个响应结果<br>proto语法 :</p>
<p>rpc clientStreamHello(stream Person) returns (Result) {}<br>1<br>应用场景：<br>物联网终端向服务器报送数据。</p>
<p>4、 Bidirectional streaming RPC<br>双向流式rpc 结合客户端流式rpc和服务端流式rpc，可以传入多个对象，返回多个响应对象<br>proto语法 :</p>
<p>rpc biStreamHello(stream Person) returns (stream Result) {}<br>1<br>应用场景：聊天应用。</p>
<p>总结<br>流式 RPC 定义与 简单 RPC 的区别只是在请求或返回参数前增加了 stream 关键词，如下：</p>
<p>service HelloService {<br>  // 客户端流式 RPC<br>  rpc SayHello1 (stream  HelloRequest) returns (HelloResponse);<br>  // 服务端流式 RPC<br>  rpc SayHello2 (HelloRequest) returns (stream HelloResponse);<br>  // 双向流式 RPC<br>  rpc SayHello3 (stream  HelloRequest) returns (stream HelloResponse);}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>grpc应用场景<br>gRPC设计为低延迟和高吞吐量通信。gRPC非常适用于效率至关重要的轻型微服务。点对点实时通信 - gRPC对双向流媒体提供出色的支持。gRPC服务可以实时推送消息而无需轮询。多语言混合开发环境 - gRPC工具支持所有流行的开发语言，使gRPC成为多语言开发环境的理想选择。</p>
<p>网络受限环境 - 使用Protobuf（一种轻量级消息格式）序列化gRPC消息。gRPC消息始终小于等效的JSON消息。</p>
<h2 id="IAM-认证-授权"><a href="#IAM-认证-授权" class="headerlink" title="IAM 认证 授权"></a>IAM 认证 授权</h2><h2 id="Gin"><a href="#Gin" class="headerlink" title="Gin"></a>Gin</h2><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><h3 id="路由树"><a href="#路由树" class="headerlink" title="路由树"></a>路由树</h3><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>Map 与工厂模式<br>• Map 的 value 可以是⼀一个⽅方法<br>• 与 Go 的 Dock type 接⼝口⽅方式⼀一起，可以⽅方便便的实现单⼀一⽅方法对象的⼯工⼚厂模式</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="三次握手-四次挥手"><a href="#三次握手-四次挥手" class="headerlink" title="三次握手 四次挥手"></a>三次握手 四次挥手</h3><h3 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h3><h3 id="TCP-与-HTTP"><a href="#TCP-与-HTTP" class="headerlink" title="TCP 与 HTTP"></a>TCP 与 HTTP</h3><h3 id="HTTP-1-0-1-1-2-0-3-0"><a href="#HTTP-1-0-1-1-2-0-3-0" class="headerlink" title="HTTP 1.0 1.1 2.0 3.0"></a>HTTP 1.0 1.1 2.0 3.0</h3><h3 id="Rpc和Http的区别"><a href="#Rpc和Http的区别" class="headerlink" title="Rpc和Http的区别"></a>Rpc和Http的区别</h3><p>RPC：Remote Produce Call远程过程调用。自定义数据格式，基于原生TCP通信，速度快，效率高。</p>
<p>Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。</p>
<ul>
<li><strong>相同点</strong>：底层通讯都是基于socket，都可以实现远程调用，都可以实现服务调用服务</li>
<li><strong>不同点：</strong><br><strong>RPC</strong>：框架有：dubbo、cxf、（RMI远程方法调用）Hessian<br>当使用RPC框架实现服务间调用的时候，要求服务提供方和服务消费方 都必须使用统一的RPC框架，要么都dubbo，要么都cxf<br>跨操作系统在同一编程语言内使用<br>优势：调用快、处理快<br><strong>http</strong>：框架有：httpClient<br>当使用http进行服务间调用的时候，无需关注服务提供方使用的编程语言，也无需关注服务消费方使用的编程语言，服务提供方只需要提供restful风格的接口，服务消费方，按照restful的原则，请求服务，即可<br>跨系统跨编程语言的远程调用框架<br>优势：通用性强<br><strong>总结：对比RPC和http的区别</strong><br>1 RPC要求服务提供方和服务调用方都需要使用相同的技术，要么都hessian，要么都dubbo<br>而http无需关注语言的实现，只需要遵循rest规范<br>2 RPC的开发要求较多，像Hessian框架还需要服务器提供完整的接口代码(包名.类名.方法名必须完全一致)，否则客户端无法运行<br>3 Hessian只支持POST请求<br>4 Hessian只支持JAVA语言</li>
</ul>
<h3 id="TLS-加密原理"><a href="#TLS-加密原理" class="headerlink" title="TLS 加密原理"></a>TLS 加密原理</h3><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul>
<li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li>
<li>2××：成功，报文已经收到并被正确处理；</li>
<li>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</li>
<li>4××：客户端错误，请求报文有误，服务器无法处理；</li>
<li>5××：服务器错误，服务器在处理请求时内部发生了错误。</li>
</ul>
<blockquote>
<p>HTTPS 解决了 HTTP 里 “明文”“不安全” 的缺点，尽最大可能保证着我们的上网安全。</p>
</blockquote>
<p>服务器收到请求报文，解析后需要进行处理，具体的业务逻辑多种多样，但最后必定是拼出一个响应报文发回客户端。</p>
<p>响应报文由响应头加响应体数据组成，响应头又由状态行和头字段构成。</p>
<p>我们先来复习一下状态行的结构，有三部分：</p>
<p><img src="https://static001.geekbang.org/resource/image/a1/00/a1477b903cd4d5a69686683c0dbc3300.png" srcset="/img/loading.gif"></p>
<p>开头的 Version 部分是 HTTP 协议的版本号，通常是 HTTP/1.1，用处不是很大。</p>
<p>后面的 Reason 部分是原因短语，是状态码的简短文字描述，例如 “OK”“Not Found” 等等，也可以自定义。但它只是为了兼容早期的文本客户端而存在，提供的信息很有限，目前的大多数客户端都会忽略它。</p>
<p>所以，状态行里有用的就只剩下中间的状态码（Status Code）了。它是一个十进制数字，以代码的形式表示服务器对请求的处理结果，就像我们通常编写程序时函数返回的错误码一样。</p>
<p>不过你要注意，它的名字是 “状态码” 而不是“错误码”。也就是说，它的含义不仅是错误，更重要的意义在于表达 HTTP 数据处理的“状态”，客户端可以依据代码适时转换处理状态，例如继续发送请求、切换协议，重定向跳转等，有那么点 TCP 状态转换的意思。</p>
<p>目前 RFC 标准里规定的状态码是三位数，所以取值范围就是从 000 到 999。但如果把代码简单地从 000 开始顺序编下去就显得有点太 “low”，不灵活、不利于扩展，所以状态码也被设计成有一定的格式。</p>
<p>RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0<del>99 不用，这样状态码的实际可用范围就大大缩小了，由 000</del>999 变成了 100~599。</p>
<p>这五类的具体含义是：</p>
<p>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</p>
<p>2××：成功，报文已经收到并被正确处理；</p>
<p>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</p>
<p>4××：客户端错误，请求报文有误，服务器无法处理；</p>
<p>5××：服务器错误，服务器在处理请求时内部发生了错误。</p>
<p>在 HTTP 协议中，正确地理解并应用这些状态码不是客户端或服务器单方的责任，而是双方共同的责任。</p>
<p>客户端作为请求的发起方，获取响应报文后，需要通过状态码知道请求是否被正确处理，是否要再次发送请求，如果出错了原因又是什么。这样才能进行下一步的动作，要么发送新请求，要么改正错误重发请求。</p>
<p>服务器端作为请求的接收方，也应该很好地运用状态码。在处理请求时，选择最恰当的状态码回复客户端，告知客户端处理的结果，指示客户端下一步应该如何行动。特别是在出错的时候，尽量不要简单地返 400、500 这样意思含糊不清的状态码。</p>
<p>目前 RFC 标准里总共有 41 个状态码，但状态码的定义是开放的，允许自行扩展。所以 Apache、Nginx 等 Web 服务器都定义了一些专有的状态码。如果你自己开发 Web 应用，也完全可以在不冲突的前提下定义新的代码。</p>
<p>在我们的实验环境里也可以对这些状态码做测试验证，访问 URI“/12-1”，用查询参数 “code=xxx” 来检查这些状态码的效果，服务器不仅会在状态行里显示状态码，还会在响应头里用自定义的 “Expect-Code” 字段输出这个代码。</p>
<p><code>1××</code></p>
<p>1×× 类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。</p>
<p>我们偶尔能够见到的是 “101 Switching Protocols”。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。</p>
<p><code>2××</code></p>
<p>2×× 类状态码表示服务器收到并成功处理了客户端的请求，这也是客户端最愿意看到的状态码。</p>
<p>“200 OK” 是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。</p>
<p>“204 No Content”是另一个很常见的成功状态码，它的含义与 “200 OK” 基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。</p>
<p>“206 Partial Content” 是 HTTP 分块下载或断点续传的基础，在客户端发送 “范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。</p>
<p>状态码 206 通常还会伴随着头字段 “Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如 “Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</p>
<p><code>3××</code></p>
<p>3×× 类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的 “重定向”，包括著名的 301、302 跳转。</p>
<p>“301 Moved Permanently” 俗称 “永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。</p>
<p>与它类似的是 “302 Found”，曾经的描述短语是 “Moved Temporarily”，俗称 “临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。</p>
<p>301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是 “永久”，一个是 “临时”，所以在场景、用法上差距很大。</p>
<p>比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是 “永久” 的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。</p>
<p>再比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于 “临时” 的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</p>
<p>“304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成 “重定向已到缓存的文件”（即 “缓存重定向”）。</p>
<p>301、302 和 304 分别涉及了 HTTP 协议里重要的 “重定向跳转” 和“缓存控制”，在之后的课程中我还会细讲。</p>
<p><code>4××</code></p>
<p>4×× 类状态码表示客户端发送的请求报文有误，服务器无法处理，它就是真正的 “错误码” 含义了。</p>
<p>“400 Bad Request” 是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是 “一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</p>
<p>“403 Forbidden” 实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个 “闭门羹”。</p>
<p>“404 Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被 “用滥了”，只要服务器“不高兴” 就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。</p>
<p>4×× 里剩下的一些代码较明确地说明了错误的原因，都很好理解，开发中常用的有：</p>
<p>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</p>
<p>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</p>
<p>408 Request Timeout：请求超时，服务器等待了过长的时间；</p>
<p>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</p>
<p>413 Request Entity Too Large：请求报文里的 body 太大；</p>
<p>414 Request-URI Too Long：请求行里的 URI 太大；</p>
<p>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</p>
<p>431 Request Header Fields Too Large：请求头某个字段或总体太大；</p>
<p><code>5xx</code></p>
<p>5×× 类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的 “错误码”。</p>
<p>“500 Internal Server Error” 与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。</p>
<p>“501 Not Implemented”表示客户端请求的功能还不支持，这个错误码比 500 要 “温和” 一些，和 “即将开业，敬请期待” 的意思差不多，不过具体什么时候 “开业” 就不好说了。</p>
<p>“502 Bad Gateway” 通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</p>
<p>“503 Service Unavailable” 表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的 “网络服务正忙，请稍后重试” 的提示信息就是状态码 503。</p>
<p>503 是一个 “临时” 的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个 “Retry-After” 字段，指示客户端可以在多久以后再次尝试发送请求。</p>
<p><strong>小结</strong></p>
<p>状态码是十进制的三位数，分为五类，从 100 到 599；</p>
<p>2×× 类状态码表示成功，常用的有 200、204、206；</p>
<p>3×× 类状态码表示重定向，常用的有 301、302、304；</p>
<p>4×× 类状态码表示客户端错误，常用的有 400、403、404；</p>
<p>5×× 类状态码表示服务器错误，常用的有 500、501、502、503。</p>
<h3 id="RPC-调用与-HTTP-调用的区别"><a href="#RPC-调用与-HTTP-调用的区别" class="headerlink" title="RPC 调用与 HTTP 调用的区别"></a>RPC 调用与 HTTP 调用的区别</h3><p><strong>a. 区别：</strong></p>
<ul>
<li>-传输协议</li>
</ul>
<p>RPC，可以基于TCP协议，也可以基于HTTP协议</p>
<p>HTTP，基于HTTP协议</p>
<ul>
<li>传输效率</li>
</ul>
<p>RPC，使⽤⾃定义的TCP协议，可以让请求报⽂体积更⼩，或者使⽤HTTP2协议，也可以很好的减少报⽂的体积，提⾼传输效率</p>
<p>HTTP，如果是基于HTTP1.1的协议，请求中会包含很多⽆⽤的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为⼀个RPC来使⽤的，这时标准RPC框架更多的是服务治理</p>
<ul>
<li>性能消耗，主要在于序列化和反序列化的耗时</li>
</ul>
<p>RPC，可以基于thrift实现⾼效的⼆进制传输</p>
<p>HTTP，⼤部分是通过json来实现的，字节⼤⼩和序列化耗时都⽐thrift要更消耗性能</p>
<ul>
<li>负载均衡</li>
</ul>
<p>RPC，基本都⾃带了负载均衡策略</p>
<p>HTTP，需要配置Nginx，HAProxy来实现</p>
<ul>
<li>服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）</li>
</ul>
<p>RPC，能做到⾃动通知，不影响上游</p>
<p>HTTP，需要事先通知，修改Nginx/HAProxy配置</p>
<p><strong>b. 总结：</strong></p>
<p>RPC主要⽤于公司内部的服务调⽤，性能消耗低，传输效率⾼，服务治理⽅便。HTTP主要⽤于对外的异构环境，浏览器接⼝调⽤，APP接⼝调⽤，第三⽅接⼝调⽤等。</p>
<h3 id="机密性，完整性，身份认证和不可否认"><a href="#机密性，完整性，身份认证和不可否认" class="headerlink" title="机密性，完整性，身份认证和不可否认"></a>机密性，完整性，身份认证和不可否认</h3><p>机密性由对称加密AES保证，完整性由SHA384摘要算法保证，身份认证和不可否认由RSA非对称加密保证</p>
<h3 id="加密算法有哪些"><a href="#加密算法有哪些" class="headerlink" title="加密算法有哪些"></a>加密算法有哪些</h3><ul>
<li>对称加密算法；</li>
<li>非对称加密算法；</li>
<li>Hash算法；</li>
</ul>
<p>加密算法的核心思想是“把一个小秘密（密钥）转化为一个大秘密（密文消息）”，守住了小秘密，也就守住了大秘密；</p>
<p>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换，常用的有 AES 和 ChaCha20；</p>
<p>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢，常用的有 RSA 和 ECC；</p>
<p>把对称加密和非对称加密结合起来就得到了“又好又快”的混合加密，也就是 TLS 里使用的加密方式。</p>
<h3 id="Go-对密码加密"><a href="#Go-对密码加密" class="headerlink" title="Go 对密码加密"></a>Go 对密码加密</h3><p>密码 + 盐（一串随机数） 再Hash</p>
<p><strong><em>\</em>Go语言提供了一种较为安全的加密方式，使用GoLang golang.org/x/crypto/bcrypt 模块，通过该模块可以快速实现密码的存储处理。**</strong></p>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="查看-CPU-占用前五的进程"><a href="#查看-CPU-占用前五的进程" class="headerlink" title="查看 CPU 占用前五的进程"></a>查看 CPU 占用前五的进程</h3><p>linux 下 取进程占用 cpu 最高的前10个进程</p>
<p>ps aux|head -1;ps aux|grep -v PID|sort -rn -k +3|head</p>
<p>linux 下 取进程占用内存(MEM)最高的前10个进程</p>
<p>ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="恢复上一次-commit"><a href="#恢复上一次-commit" class="headerlink" title="恢复上一次 commit"></a>恢复上一次 commit</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h3><h3 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LeastSquares</span><span class="hljs-params">(x[]<span class="hljs-keyword">float64</span>,y[]<span class="hljs-keyword">float64</span>)</span><span class="hljs-params">(a <span class="hljs-keyword">float64</span>,b <span class="hljs-keyword">float64</span>)</span></span>&#123;
    <span class="hljs-comment">// x是横坐标数据,y是纵坐标数据</span>
    <span class="hljs-comment">// a是斜率，b是截距</span>
    xi := <span class="hljs-keyword">float64</span>(<span class="hljs-number">0</span>)
    x2 := <span class="hljs-keyword">float64</span>(<span class="hljs-number">0</span>)
    yi := <span class="hljs-keyword">float64</span>(<span class="hljs-number">0</span>)
    xy := <span class="hljs-keyword">float64</span>(<span class="hljs-number">0</span>)

    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(x)!= <span class="hljs-built_in">len</span>(y) &#123;
        beego.Debug(<span class="hljs-string">&quot;最小二乘时，两数组长度不一致!&quot;</span>)
    &#125;<span class="hljs-keyword">else</span> &#123;
        length := <span class="hljs-keyword">float64</span>(<span class="hljs-built_in">len</span>(x))
        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(x); i++&#123;
            xi += x[i]
            x2 += x[i] * x[i]
            yi += y[i]
            xy += x[i] * y[i]
        &#125;
        a = (yi * xi - xy * length) / (xi * xi - x2 * length)
        b = (yi * x2 - xy * xi) / (x2 * length - xi * xi)
    &#125;
    <span class="hljs-keyword">return</span>
&#125;</code></pre>



<h3 id="双蛋问题"><a href="#双蛋问题" class="headerlink" title="双蛋问题"></a>双蛋问题</h3><p>分十组，每组遍历</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Golang/">Golang</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/interview/">interview</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处。</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/01/04/go/Interview/interview_00/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Go Interview</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/04/tmp/windows/shell/">
                        <span class="hidden-mobile">windows shell</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://1ch0.github.io/" target="_blank" rel="nofollow noopener"><span>1ch0</span></a> <i class="iconfont icon-love"></i> <a href="https://1ch0.github.io/" target="_blank" rel="nofollow noopener"><span>Go</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Go Interview&nbsp;",
      ],
      cursorChar: ".",
      typeSpeed: 100,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>















</body>
</html>
