

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="1ch0">
  <meta name="keywords" content="">
  <title>Docker 核心技术 - 1ch0&#39;s blog</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css" />
    
  

  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>1ch0's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                联系我
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" href="javascript:">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="container page-header text-center fade-in-up">
            <span class="h2" id="subtitle">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      1ch0
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-07-13 15:11" pubdate>
        2022年7月13日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      8.5k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      106
       分钟
    </span>
  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto" id="post">
            <!-- SEO header -->
            <h1 style="display: none">Docker 核心技术</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：24 分钟前
                
              </p>
            
            <div class="markdown-body" id="post-body">
              <h1 id="3-Docker-核心技术"><a href="#3-Docker-核心技术" class="headerlink" title="3. Docker 核心技术"></a>3. Docker 核心技术</h1><h2 id="3-1-从系统架构谈起"><a href="#3-1-从系统架构谈起" class="headerlink" title="3.1 从系统架构谈起"></a>3.1 从系统架构谈起</h2><h3 id="3-1-1-传统分层架构-vs-微服务架构"><a href="#3-1-1-传统分层架构-vs-微服务架构" class="headerlink" title="3.1.1 传统分层架构 vs 微服务架构"></a>3.1.1 传统分层架构 vs 微服务架构</h3><ul>
<li>传统分层架构<ul>
<li>优点：<ul>
<li>易部署</li>
<li>易测试</li>
<li>易横向拓展</li>
</ul>
</li>
<li>缺点：<ul>
<li>难以理解整体</li>
<li>不易快速维护</li>
<li>启动慢</li>
<li>部署慢</li>
<li>变更引起的回归问题多</li>
<li>难以做持续集成和持续部署</li>
</ul>
</li>
</ul>
</li>
<li>微服务<ul>
<li>优点：<ul>
<li>高内聚、松耦合</li>
<li>复杂系统更加可维护</li>
<li>服务独立部署，易于持续集成和持续部署</li>
<li>每个微服务独立拓展</li>
</ul>
</li>
<li>缺点：<ul>
<li>增加了系统的复杂性，把集群部署变成了分布式部署。需要实现基于消息或 RPC 的进程间通讯，需要处理部署失败等分布式系统的复杂问题</li>
<li>微服务采用分区数据库架构，一个事务需要更新不同微服务的数据库，分布式事务更复杂（失败回滚）</li>
<li>测试更加复杂</li>
<li>部署监控更复杂<h3 id="3-1-2-微服务改造"><a href="#3-1-2-微服务改造" class="headerlink" title="3.1.2 微服务改造"></a>3.1.2 微服务改造</h3></li>
</ul>
</li>
</ul>
</li>
<li>分离微服务的方法建议<ul>
<li>审视并发现可以分离的业务逻辑</li>
<li>寻找天生隔离的代码模块，可以借助静态代码分析工具</li>
<li>不同并发规模，不同内存需求的模块都可以分理出不同的微服务，此方法可提高资源利用率，节省成本</li>
</ul>
</li>
<li>常用的可微服务化的组件<ul>
<li>用户和账户管理</li>
<li>授权和会话管理</li>
<li>系统配置</li>
<li>通知和通讯服务</li>
<li>照片、多媒体、元数据等</li>
</ul>
</li>
<li><strong>分解原则：基于 Size、Scope、Capabilities</strong><h3 id="3-1-3-微服务间通讯"><a href="#3-1-3-微服务间通讯" class="headerlink" title="3.1.3 微服务间通讯"></a>3.1.3 微服务间通讯</h3></li>
<li>点对点<ul>
<li>多用于系统内部多组件之间通讯</li>
<li>有大量的重复模块，如认证授权</li>
<li>缺少统一规范，如监控、审计等功能</li>
<li>后期维护成本高，服务和服务的依赖关系错综复杂，难以管理</li>
</ul>
</li>
<li><strong>API 网关</strong><ul>
<li>基于一个轻量级的 message gateway</li>
<li>新 API 通过注册至 Gateway 实现</li>
<li>整合实现 Common function<h2 id="3-2-理解-Docker"><a href="#3-2-理解-Docker" class="headerlink" title="3.2 理解 Docker"></a>3.2 理解 Docker</h2><h3 id="3-2-1-Docker"><a href="#3-2-1-Docker" class="headerlink" title="3.2.1 Docker"></a>3.2.1 Docker</h3>• 基于 Linux 内核的 Cgroup,  Namespace ，以 及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。<br>• 最初实现是基于 LXC,从 0.7 以后开始去除 LXC, 转而使用自行开发的 Lib container, 从 1.11 开始， 则进一步演进为使用 rune 和 Containerd 。<br>• Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等， 极大的简化了容器的创建和维护，使得 Docker  技术比虚拟机技术更为轻便、快捷。</li>
</ul>
</li>
</ul>
<h3 id="3-2-2-Why-Docker"><a href="#3-2-2-Why-Docker" class="headerlink" title="3.2.2 Why Docker"></a>3.2.2 Why Docker</h3><ul>
<li>更高效地利用系统资源</li>
<li>更快速的启动时间</li>
<li>一致的运行环境</li>
<li>持续交付和部署</li>
<li>更轻松地迁移</li>
<li>更轻松地维护和扩展<h3 id="3-2-3-虚拟机和容器对比"><a href="#3-2-3-虚拟机和容器对比" class="headerlink" title="3.2.3 虚拟机和容器对比"></a>3.2.3 虚拟机和容器对比</h3></li>
<li>运行时</li>
<li>性能<table>
<thead>
<tr>
<th>特性</th>
<th>容器</th>
<th>虚拟机</th>
</tr>
</thead>
<tbody><tr>
<td>启动</td>
<td>秒级</td>
<td>分钟级</td>
</tr>
<tr>
<td>硬盘使用</td>
<td>MB</td>
<td>GB</td>
</tr>
<tr>
<td>性能</td>
<td>接近原生</td>
<td>弱于</td>
</tr>
<tr>
<td>系统支持量</td>
<td>单机支持上千容器</td>
<td>一般几十个</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="3-2-4-Docker-Install"><a href="#3-2-4-Docker-Install" class="headerlink" title="3.2.4 Docker Install"></a>3.2.4 Docker Install</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 备份初始源</span>
cp /etc/apt/sources.list /etc/apt/sources.list_backup

tee /etc/apt/sources.list &lt;&lt; EOF
<span class="hljs-meta">#</span><span class="bash">  阿里源</span>
deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse
deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse
EOF
<span class="hljs-meta">#</span><span class="bash"> 添加公钥</span>
apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 40976EAF437D05B5

apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3B4FE6ACC0B21F32


apt-get -y update 
apt-get -y upgrade
apt-get -y install build-essential
apt -y autoremove

<span class="hljs-meta">#</span><span class="bash"> 卸载旧版</span>
sudo apt-get remove docker docker-engine docker.io containerd runc
<span class="hljs-meta">#</span><span class="bash"> 安装 docker 1</span>
curl -fsSL https://get.docker.com | bash -s docker --mirror aliyun
<span class="hljs-meta">#</span><span class="bash"> 安装 docker 2</span>
curl -sSL https://get.daocloud.io/docker | sh

<span class="hljs-meta">#</span><span class="bash"> 安装 docker compose</span>
curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-compose
chmod +x /usr/local/bin/docker-compose
docker-compose -v
systemctl daemon-reload
service docker restart
service docker status 

<span class="hljs-meta">#</span><span class="bash"> Install bash-completion</span>
apt install -y bash-completion
source /usr/share/bash-completion/bash_completion
source /usr/share/bash-completion/completions/docker</code></pre>

<h3 id="3-2-5-容器操作"><a href="#3-2-5-容器操作" class="headerlink" title="3.2.5 容器操作"></a>3.2.5 容器操作</h3><table>
<thead>
<tr>
<th>命令</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>docker run<br/>    - -it 交互<br/>    - -d 后台运行<br/>    - -p 端口映射（目的：Docker内）<br/>    - -v 磁盘挂载<br/>    - –rm 退出时删除</td>
<td>启动</td>
</tr>
<tr>
<td>docker inspect</td>
<td><strong>查看容器细节</strong></td>
</tr>
<tr>
<td>docker attach<br />nsenter –target $PID –mount –uts –ipc –net –pid</td>
<td><strong>进入容器</strong></td>
</tr>
<tr>
<td>docker cp file1 <containerid>:/file-to-path</td>
<td>拷贝文件至容器内</td>
</tr>
<tr>
<td>docker start</td>
<td>启动已终止容器</td>
</tr>
<tr>
<td>docker stop</td>
<td>停止容器</td>
</tr>
<tr>
<td>docker ps</td>
<td>查看容器进程</td>
</tr>
</tbody></table>
<h2 id="3-3-Docker-核心技术"><a href="#3-3-Docker-核心技术" class="headerlink" title="3.3 Docker 核心技术"></a>3.3 Docker 核心技术</h2><h3 id="3-3-1-容器主要特性"><a href="#3-3-1-容器主要特性" class="headerlink" title="3.3.1 容器主要特性"></a>3.3.1 容器主要特性</h3><ul>
<li>安全性</li>
<li>可配额</li>
<li>隔离性</li>
<li>便携性</li>
</ul>
<h3 id="3-3-2-Namespace"><a href="#3-3-2-Namespace" class="headerlink" title="3.3.2 Namespace"></a>3.3.2 Namespace</h3><blockquote>
<p>Linux Namespace 是一种 Linux Kernel 提供的资源隔离方案：</p>
<ul>
<li>系统可以为进程分配不同的 Namespace</li>
<li>并保证不同的 Namespace 资源独立分配、进程彼此隔离，即 不同的 Namespace 下的机才能拿互不干扰</li>
</ul>
</blockquote>
<h4 id="3-3-2-1-Linux-内核代码中-Namespace-的实现"><a href="#3-3-2-1-Linux-内核代码中-Namespace-的实现" class="headerlink" title="3.3.2.1 Linux 内核代码中 Namespace 的实现"></a>3.3.2.1 Linux 内核代码中 Namespace 的实现</h4><ul>
<li><p>进程数据结构</p>
<pre><code class="hljs shell">struct task_struct&#123;
  ...
  /* namespaces */
	struct nsproxy *nsproxy;
&#125;</code></pre>
</li>
<li><p>Namespace 数据结构</p>
<pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nsproxy</span>&#123;</span>
  <span class="hljs-keyword">atomic_t</span> count;
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uts_namespace</span> *<span class="hljs-title">uts_ns</span>;</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_namespace</span> *<span class="hljs-title">ipc_ns</span>;</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mnt_namesapce</span> *<span class="hljs-title">mnt_ns</span>;</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_namespace</span> *<span class="hljs-title">pid_ns_for_children</span>;</span>
  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span> *<span class="hljs-title">net_ns</span>;</span>
&#125;</code></pre>

</li>
</ul>
<h4 id="3-3-2-2-Linux-对-Namespace-操作方法"><a href="#3-3-2-2-Linux-对-Namespace-操作方法" class="headerlink" title="3.3.2.2 Linux 对 Namespace 操作方法"></a>3.3.2.2 Linux 对 Namespace 操作方法</h4><ul>
<li><p>clone</p>
<p>在创建新进程的系统调用时，可以通过 flags 参数指定需要新建的 Namespace 类型：</p>
<pre><code class="hljs c++"><span class="hljs-comment">// CLONE_NEWGROUP / CLONE_NEWIPC / CLONE_NEWNS / CLONE_NEWPID / CLONE_NEWUSER / CLONE_NEWUTS</span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*fn)(<span class="hljs-keyword">void</span>*), <span class="hljs-keyword">void</span> *child_stack, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">void</span> *arg)</span></span></code></pre>
</li>
<li><p>setns</p>
<p>该系统调用可以让调用进程加入某个已经存在的 Namespace 中：</p>
<p>int setns(int fd, int nstype)</p>
</li>
<li><p>unshare</p>
<p>该系统调用可以将调用进程移动到新的 Namespace 下：</p>
<p>int unshare(int flags)</p>
</li>
</ul>
<h4 id="3-3-2-3-隔离性"><a href="#3-3-2-3-隔离性" class="headerlink" title="3.3.2.3 隔离性"></a>3.3.2.3 隔离性</h4><table>
<thead>
<tr>
<th align="center">Namespace 类型</th>
<th align="center">隔离资源</th>
<th align="center">Kernel 版本</th>
</tr>
</thead>
<tbody><tr>
<td align="center">IPC</td>
<td align="center">System V IPC 和 POSIX 消息队列</td>
<td align="center">2.6.19</td>
</tr>
<tr>
<td align="center">Network</td>
<td align="center">网络设备、网络协议栈、网络端口等</td>
<td align="center">2.6.29</td>
</tr>
<tr>
<td align="center">PID</td>
<td align="center">进程</td>
<td align="center">2.6.14</td>
</tr>
<tr>
<td align="center">Mount</td>
<td align="center">挂载点</td>
<td align="center">2.4.19</td>
</tr>
<tr>
<td align="center">UTS</td>
<td align="center">主机名和域名</td>
<td align="center">2.6.19</td>
</tr>
<tr>
<td align="center">USR</td>
<td align="center">用户和用户组</td>
<td align="center">3.8</td>
</tr>
</tbody></table>
<ul>
<li>Pid namespace<ul>
<li>不同用户的进程就是通过 Pid namespace 隔离开的，且不同 namespace 中可以有相同 Pid</li>
<li>有了 Pid namespace，每个 namespace 中的 Pid 能够相互隔离</li>
</ul>
</li>
<li>net namespace<ul>
<li>网络隔离是通过 net namespace 实现的，每个 net namespace 有独立的 network devices,IP addresses,IP routing tables，/proc/net 目录</li>
<li>Docker 默认采用 veth 的方式将 container 中的虚拟网卡桶 host 上的一个 docker bridge: docker0 连接在一起</li>
</ul>
</li>
<li>ipc namespace<ul>
<li>Container 中进程交互还是采用 linux 常见的进程间交互方法（interprocess communication- IPC)，包括常见的信号量、消息队列和共享内存</li>
<li>container 的进程间交互实际上还是 host 上具有下载那个同 Pid namespace 中的进程间交互，因此需要在 IPC 资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32 位 ID</li>
</ul>
</li>
<li>mnt namespace<ul>
<li>mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了</li>
</ul>
</li>
<li>uts namespace<ul>
<li>UTS(“UNIX Time-sharing System”) namespace 允许每个 container 拥有独立的 hostname 和 domain name，使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程</li>
</ul>
</li>
<li>user namespace<ul>
<li>每个 container 可以有不同的 user 和 group id，也就是说可以在 container 内部用 container 内部的用户执行程序而非 Host 上的用户</li>
</ul>
</li>
</ul>
<h4 id="3-3-2-4-关于-namespace-的常用操作"><a href="#3-3-2-4-关于-namespace-的常用操作" class="headerlink" title="3.3.2.4 关于 namespace 的常用操作"></a>3.3.2.4 关于 namespace 的常用操作</h4><table>
<thead>
<tr>
<th>名称</th>
<th>命令</th>
</tr>
</thead>
<tbody><tr>
<td>查看当前系统的 namespace</td>
<td>lsns -t <type></td>
</tr>
<tr>
<td>查看某进程的 namespace</td>
<td>ls -la /proc/<pid>/ns/</td>
</tr>
<tr>
<td>进入某 namespace 运行命令</td>
<td>nsenter -t <pid> -m ip addr</td>
</tr>
</tbody></table>
<h4 id="3-3-2-5-课后练习"><a href="#3-3-2-5-课后练习" class="headerlink" title="3.3.2.5 课后练习"></a>3.3.2.5 课后练习</h4><blockquote>
<ol>
<li><p>在新 network namespace 执行 sleep 指令</p>
<pre><code class="hljs shell">unshare -fn sleep 60</code></pre>
</li>
<li><p>查看进程信息</p>
<pre><code class="hljs shell">ps -ef|grep sleep</code></pre>
</li>
<li><p>查看网络 Namespace</p>
<pre><code class="hljs shell">lsns -t net</code></pre>
</li>
<li><p>进入该进程所在 Namespace 查看网络配置，与主机不一致</p>
<pre><code class="hljs shell">nsenter -t pid -n ip a</code></pre>
</li>
</ol>
</blockquote>
<h3 id="3-3-3-Cgroups"><a href="#3-3-3-Cgroups" class="headerlink" title="3.3.3 Cgroups"></a>3.3.3 Cgroups</h3><blockquote>
<ul>
<li><p>Cgroups(Control Groups) 是 Linux 下用于对一个或一组进程进程资源开工至和监控的机制</p>
</li>
<li><p>可以对诸如 CPU 使用时间、内存、磁盘 I/O 等进程所需的资源进程限制</p>
</li>
<li><p>不同资源的具体管理工作由相应的 Cgroup 子系统（Subsystem）来实现</p>
</li>
<li><p>针对不同类型的资源限制，只要将限制策略在不同的子系统上进程关联即可</p>
</li>
<li><p>Cgroups 在不同的系统资源管理子系统中以层级树（Hierarchy）的方式来组织管理：</p>
<p>每个Cgroup 都可以包含其他的子 Cgroup，因此子 Cgroup 能使员工的资源除了受本 Cgroup 配置的资源参数限制，还受到父 Cgroup 设置的资源限制</p>
</li>
</ul>
</blockquote>
<h4 id="3-3-3-1-Linux-内核代码中-Cgroups-的实现"><a href="#3-3-3-1-Linux-内核代码中-Cgroups-的实现" class="headerlink" title="3.3.3.1 Linux 内核代码中 Cgroups 的实现"></a>3.3.3.1 Linux 内核代码中 Cgroups 的实现</h4><ul>
<li><p>进程数据结构</p>
<pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>&#123;</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_CGROUPS</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">css_set_rcu</span> *<span class="hljs-title">cgroups</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">cg_list</span>;</span>
    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>
&#125;</code></pre>
</li>
<li><p>css_set 是 cgroup_subsys_state 对象的集合数据结构</p>
<pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">css_set</span>&#123;</span>
    <span class="hljs-comment">/*</span>
<span class="hljs-comment">    * Set of subsystem state, one for each subsystem.This array is</span>
<span class="hljs-comment">    * immutable after creation apart from the init_css_set during</span>
<span class="hljs-comment">    * subsystem registration(at boot time).</span>
<span class="hljs-comment">    */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cgroup_subsys_state</span> *<span class="hljs-title">subsys</span>[<span class="hljs-title">CGROUP_SUBSYS_COUNT</span>];</span>
&#125;</code></pre>

</li>
</ul>
<h4 id="3-3-3-2-可配额-可度量"><a href="#3-3-3-2-可配额-可度量" class="headerlink" title="3.3.3.2 可配额/可度量"></a>3.3.3.2 可配额/可度量</h4><ul>
<li>cgroups 实现了对资源的配额和度量<ul>
<li>blkio：这个子系统设置限制每个块设备的输入输出控制。例如：磁盘，光盘以及 USB 等等</li>
<li>cpu：这个子系统使用调度程序为 cgroup 任务提供 CPU 的访问</li>
<li>cpuacct：产生 cgroup 任务的 CPU 资源报告</li>
<li>cpuset：如果是多核心的 CPU，这个子系统会为 cgroup 任务分配单独的 CPU和内存</li>
<li>devices：允许或拒绝 cgroup 任务对设备的访问</li>
<li>freezer：暂停和恢复 cgroup 任务</li>
<li>memory：设置每个 cgroup 的内存限制以及产生内存资源报告</li>
<li>net_cls：标记每个网络包以供 cgroup 方便使用</li>
<li>ns：名称空间子系统</li>
<li>pid：进程标识子系统</li>
</ul>
</li>
</ul>
<h4 id="3-3-3-3-CPU-子系统"><a href="#3-3-3-3-CPU-子系统" class="headerlink" title="3.3.3.3 CPU 子系统"></a>3.3.3.3 CPU 子系统</h4><table>
<thead>
<tr>
<th>名称</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>cpu.shares</td>
<td>可出让的能获得 CPU 使用时间的相对值</td>
</tr>
<tr>
<td>cpu.cfs_period_us</td>
<td>用来配置时间周期长度，单位为 us（微秒）</td>
</tr>
<tr>
<td>cpu.cfs_quota_us</td>
<td>用来配置当前 cgroup 在 csf_period_us 时间内最多<br />能使用的 CPU 时间数，单位为 us（微秒）</td>
</tr>
<tr>
<td>cpu.stat</td>
<td>Cgroup 内的进程使用的 CPU 时间统计</td>
</tr>
<tr>
<td>nr_periods</td>
<td>经过 cpu.cfs_period_us 的时间周期数量</td>
</tr>
<tr>
<td>nr_throttled</td>
<td>在经过的周期内，有多少次因为机才能拿在指定的时间周期<br />内用光了配额时间而受到限制</td>
</tr>
<tr>
<td>throttled_time</td>
<td>Cgroup 中的进程被限制使用 CPU 的总用时，单位为 us（微秒）</td>
</tr>
</tbody></table>
<h4 id="3-3-3-4-Linux-调度器"><a href="#3-3-3-4-Linux-调度器" class="headerlink" title="3.3.3.4 Linux 调度器"></a>3.3.3.4 Linux 调度器</h4><p>内核默认提供了 5 个调度器，Linux 内核使用 struct sched_class 来对调度器进程抽象</p>
<ul>
<li>Stop 调度器，stop_sched_class: 优先级最高的调度类，可以抢占其他所有进程，不能被其他进程抢占</li>
<li>Deadline调度器，dl_sched_class: 使用红黑树，把进程按照绝对截止期限进行排序，选择最小进程进行调度运行</li>
<li>RT 调度器，rt_sched_class: 实时调度器，为每个优先级维护一个队列</li>
<li>CFS 调度器，cfs_sched_class: 完全公平调度器，采用完全公平调度算法，引入虚拟运行使劲概念</li>
<li>IDLE-Task 调度器，idle_sched_class: 空闲调度器，每个 CPU 都会有一个 idle 线程，当没有其他进程可以调度时，调度运行 idle 线程。</li>
</ul>
<h4 id="3-3-3-5-CFS-调度器"><a href="#3-3-3-5-CFS-调度器" class="headerlink" title="3.3.3.5 CFS 调度器"></a>3.3.3.5 CFS 调度器</h4><ul>
<li>CFS 是 Completely Fair Scheduler 简称，即完全公平调度器</li>
<li>CFS 实现的主要思想是维护为任务提供处理器时间方面的平衡，这意味着应给进程分配相当数量的处理器</li>
<li>分给某个任务的时间失去平衡时，应给失去平衡的任务分配使劲，让其执行<ul>
<li>vruntime = 实际运行时间*1024 / 进程权重</li>
</ul>
</li>
<li>进程按照各自不同的速率在物理时钟街拍内前进，优先级高则权重大，其虚拟时钟比真实时钟跑得慢，但获得比较多的运行时间</li>
</ul>
<h4 id="3-3-3-6-vruntime-红黑树"><a href="#3-3-3-6-vruntime-红黑树" class="headerlink" title="3.3.3.6 vruntime 红黑树"></a>3.3.3.6 vruntime 红黑树</h4><p>CFS 调度器没有将进程维护在运行队列中，而是维护了一个以虚拟运行时间为顺序的红黑树。</p>
<p>红黑树的主要特点有：</p>
<ul>
<li>自平衡，树上没有一条路径会比其他路径长出两倍</li>
<li>O(log n) 时间复杂度，能够在树上进程快速高效地插入或删除进程</li>
</ul>
<h4 id="3-3-3-7-CFS-进程调度"><a href="#3-3-3-7-CFS-进程调度" class="headerlink" title="3.3.3.7 CFS 进程调度"></a>3.3.3.7 CFS 进程调度</h4><ul>
<li>在时钟周期开始时，调度器调用 _schedule() 函数来开始调度的运行</li>
<li>_schedule() 函数调用 pick_next_task() 让进程调度器从就绪队列中选择一个最合适的进程 next，即红黑树最左边的节点</li>
<li>通过 context_switch() 切换到新的地址空间，从而保证 next 进程运行</li>
<li>在时钟周期结束时，调度器调用 entity_tick() 函数来更新进程负载、进程状态以及 vruntime（当前 vruntime + 该时钟周期内运行的时间）</li>
<li>最后，将该进程的虚拟时间与就绪队列红黑树中最左边的调度实体的虚拟时间做比较，如果小于最左边的时间，则不用触发调度，继续调度当前调度实体。</li>
</ul>
<h4 id="3-3-3-8-CPU-子系统练习"><a href="#3-3-3-8-CPU-子系统练习" class="headerlink" title="3.3.3.8 CPU 子系统练习"></a>3.3.3.8 CPU 子系统练习</h4><blockquote>
<ol>
<li><p>在 cgroup cpu 子系统目录中创建目录结构</p>
<pre><code class="hljs shell">cd /sys/fs/cgroup/cpu
mkdir cpudemo
cd cpudemo</code></pre>
</li>
<li><p>运行 busyloop</p>
</li>
<li><p>执行 top 查看 CPU 使用情况，CPU 占用 200%</p>
</li>
<li><p>通过 cgroup 限制 CPU</p>
<pre><code class="hljs shell">cd /sys/fs/cgroup/cpu/cpudemo
<span class="hljs-meta">#</span><span class="bash"> 把进程添加到 cgroup 进程配置组</span>
ps -ef|grep busyloop|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;&gt; cgroup.procs
<span class="hljs-meta">#</span><span class="bash"> 设置 cpuquota</span>
echo 10000 &gt; cpu.cfs_quota_us</code></pre>
</li>
<li><p>执行 top 查看 CPU 使用情况，CPU占用变为10%</p>
</li>
</ol>
</blockquote>
<h4 id="3-3-3-9-cpuacct-子系统"><a href="#3-3-3-9-cpuacct-子系统" class="headerlink" title="3.3.3.9 cpuacct 子系统"></a>3.3.3.9 cpuacct 子系统</h4><p>用于统计 Cgroup 及其子 Cgroup 下进程的 CPU 的使用情况</p>
<ul>
<li>cpuacct.usage：包含该 Cgroup 及其子 Cgroup 下进程使用 CPU 的时间，单位是 ns（纳秒）</li>
<li>cpuacct.stat：包含 Cgroup 及其子 Cgroup 下进程使用的 CPU 时间，以及用户态和内核态的时间</li>
</ul>
<h4 id="3-3-3-10-Memory-子系统"><a href="#3-3-3-10-Memory-子系统" class="headerlink" title="3.3.3.10 Memory 子系统"></a>3.3.3.10 Memory 子系统</h4><ul>
<li>memory.usage_in_bytes：cgroup 下进程使用的内存，包含 cgroup 及其子 cgroup 下的进程使用的内存</li>
<li>memory.max_usage_in_bytes：cgroup 下进程使员工内存的最大值，包含子 cgroup 的内存使用量</li>
<li>memory.limit_in_bytes：设置 Cgroup 下进程最多能使用的内存。如果设置为 -1，表示对该 cgroup 的内存使用不做限制</li>
<li>memory.oom_control：设置是否在 Cgroup 中使用 OOM（Out of Memory）Killer，默认为使用，当属于该 cgroup 的进程使用的内存超过最大的限定值时，会立刻被 OOM Killer 处理</li>
</ul>
<h4 id="3-3-3-11-Cgroup-driver"><a href="#3-3-3-11-Cgroup-driver" class="headerlink" title="3.3.3.11 Cgroup driver"></a>3.3.3.11 Cgroup driver</h4><p>systemd：</p>
<ul>
<li>当操作系统使用 systemd 作为 init system 时，初始化进程生成一个根 cgroup 目录结构并作为 cgroup 管理器</li>
<li>systemd 与 cgroup 紧密结合，并且为每个 systemd unit 分配 cgroup</li>
</ul>
<p>cgroupfs：</p>
<ul>
<li>docker 默认用 cgroupfs 作为 cgroup 驱动</li>
</ul>
<p>存在问题：</p>
<ul>
<li>因此，在 systemd 作为 init system 的系统中，默认并存着两套 groupdriver</li>
<li>这会使得系统中 docker 和 kubelet 管理的进程别 cgroupfs 驱动管，而 systemd 拉起的服务由 systemd 驱动管，让 cgroup 管理混乱且容器在资源紧张时引发问题。</li>
<li>因此 kubelet 会默认 –cgroup-driver=systemd，若运行时 cgroup 不一致时，kubelet 会报错</li>
</ul>
<h4 id="3-3-3-12-课后练习"><a href="#3-3-3-12-课后练习" class="headerlink" title="3.3.3.12 课后练习"></a>3.3.3.12 课后练习</h4><blockquote>
<ol>
<li>在 cgroup memory 子系统目录中创建目录结构</li>
</ol>
<pre><code class="hljs shell">cd /sys/fs/cgroup/memory
mkdir memorydemo
cd memorydemo</code></pre>

<ol start="2">
<li>运行 malloc</li>
<li>查看内存使用情况</li>
</ol>
<pre><code class="hljs shell">watch &#x27;ps -aux|grep malloc|grep -v grep&#x27;</code></pre>

<ol start="4">
<li><p>通过 cgroup 限制 memory </p>
<ol>
<li>把进程添加到 cgroup 进程配置组</li>
</ol>
<pre><code class="hljs shell">ps -ef|grep malloc|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; &gt; cgroup.procs</code></pre>

<ol start="2">
<li>设置 memory.limit_int_bytes</li>
</ol>
<pre><code class="hljs shell">echo 104960000 &gt; memory.limit_in_bytes</code></pre></li>
<li><p>等待进程被 oom kill</p>
</li>
</ol>
</blockquote>
<h4 id="3-3-3-13-文件系统"><a href="#3-3-3-13-文件系统" class="headerlink" title="3.3.3.13 文件系统"></a>3.3.3.13 文件系统</h4><blockquote>
<p> Union FS</p>
<ul>
<li>将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）的文件系统</li>
<li>支持为每一个成员目录（类似 Git Branch）设定 readonly、readwrite 和 whiteout-able 权限</li>
<li>文件系统分层，对 readonly 权限的 branch 可以逻辑上进行修改（增量地，不影响 readonly 部分的）</li>
<li>通常 Union FS 有两个用途，一方面可以将多个 disk 挂到同一个目录下，另一个更常用的就是将一个 readonly 的 branch 和一个 writeable 的 branch 联合在一起</li>
</ul>
</blockquote>
<h4 id="3-3-3-14-容器镜像"><a href="#3-3-3-14-容器镜像" class="headerlink" title="3.3.3.14 容器镜像"></a>3.3.3.14 容器镜像</h4><ul>
<li>基础镜像层</li>
<li>通用层</li>
</ul>
<h4 id="3-3-3-15-Docker-的文件系统"><a href="#3-3-3-15-Docker-的文件系统" class="headerlink" title="3.3.3.15 Docker 的文件系统"></a>3.3.3.15 Docker 的文件系统</h4><ul>
<li>典型的 Linux 文件系统组成：<ul>
<li>Bootfs（boot file system）<ul>
<li>Bootloader - 引导加载 kernel</li>
<li>Kernel - 当 kernel 被加载到内存中后 umount bootfs</li>
</ul>
</li>
<li>rootfs（root file system）<ul>
<li>/dev , /proc , /bin , /etc 等标准目录和文件</li>
<li>对于不同的 linux 发行版，bootfs 基本是一致的，但 rootfs 会有差别</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-3-3-15-Docker-启动"><a href="#3-3-3-15-Docker-启动" class="headerlink" title="3.3.3.15 Docker 启动"></a>3.3.3.15 Docker 启动</h4><ul>
<li>Linux<ul>
<li>在启动后，首先将 rootfs 设置为 readonly，进行一系列检查，然后将其切换为“readwrite” 供用户使用</li>
</ul>
</li>
<li>Docker 启动<ul>
<li>初始化时也是将 rootfs 以 readonly 方式加载并检查，然而接下来利用 union mount 的方式将一个 readwrite 文件系统挂载在 readonly 的 rootfs 之上</li>
<li>并且允许再次将下层的 FS （file system）设定为 readonly 并且向上叠加</li>
<li>这样一组 readonly 和一个 writeable 的结构构成一个 container 的运行时态，每一个 FS 被称作一个 FS 层。</li>
</ul>
</li>
</ul>
<h4 id="3-3-3-16-写操作"><a href="#3-3-3-16-写操作" class="headerlink" title="3.3.3.16 写操作"></a>3.3.3.16 写操作</h4><blockquote>
<p>由于镜像具有共享特性，所以对容器可写层的操作需要依赖存储驱动提供的写时复制和用时分配机制，以此来支持对容器可写层的修改，进而提高对存储和内存资源的利用率。</p>
</blockquote>
<ul>
<li><p>写时复制</p>
<p>写时复制，即 Copy-on-Write。一个镜像可以被多个容器使用，但是不需要在内存和磁盘上做多个拷贝。在需要对镜像提供的文件进行修改时，该文件会从镜像的文件系统被复制到容器的可写层的文件系统进行修改，而镜像里面的文件不会改变。不同容器对文件的修改都相互独立、互不影响。</p>
</li>
<li><p>用时分配</p>
<p>按需分配空间，而非提前分配，即当一个文件被创建出来后，才会分配空间。</p>
</li>
</ul>
<h4 id="3-3-3-17-容器存储驱动"><a href="#3-3-3-17-容器存储驱动" class="headerlink" title="3.3.3.17  容器存储驱动"></a>3.3.3.17  容器存储驱动</h4><table>
<thead>
<tr>
<th>存储驱动</th>
<th>Docker</th>
<th>Containerd</th>
</tr>
</thead>
<tbody><tr>
<td>AUFS</td>
<td>在 Ubuntu 或者 Debian 上支持</td>
<td>不支持</td>
</tr>
<tr>
<td>OverlayFS</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Device Mapper</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>Btrfs</td>
<td>社区版本在 Ubunntu 或者 Debian 上支持<br />企业版本在 SLES 上支持</td>
<td>支持</td>
</tr>
<tr>
<td>ZFS</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th align="center">存储驱动</th>
<th align="center">优点</th>
<th align="center">缺点</th>
<th align="center">应用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center">AUFS</td>
<td align="center">Docker 最早支持的驱动类型，稳定性高</td>
<td align="center">并未进入主线的内核，因此只能在有限的场合下使用。另外在实现上具有多层结构，在层比较多的场景下，做写时复制有时会需要比较长的时间</td>
<td align="center">少 I/O 的场景</td>
</tr>
<tr>
<td align="center">OverlayFS</td>
<td align="center">并入主线内核，可以在目前几乎所有发行版本上使用。实现上只有两层，因此性能比 AUFS 高</td>
<td align="center">写时复制机制需要复制整个文件，而不是只针对修改部分进行复制，因此对大文件操作会需要比较长的时间。其中 Overlay 在 Docker 的后续版本中被移除</td>
<td align="center">少 I/O 的场景</td>
</tr>
<tr>
<td align="center">Device Mapper</td>
<td align="center">并入主线内核，针对块 操作，性能比较高。修改文件时只需复制需要修改的块，效率高</td>
<td align="center">不同容器之间不能共享缓存。在 Docker 的后续版本中会被移除</td>
<td align="center">I/O 密集场景</td>
</tr>
<tr>
<td align="center">BtrFS</td>
<td align="center">并入主线内核，虽然是文件级操作系统，但是可以对块进行操作</td>
<td align="center">需要消耗比较多的内存，稳定性相对比较差</td>
<td align="center">需要支持 Snapshot 等比较特殊的场景</td>
</tr>
<tr>
<td align="center">ZFS</td>
<td align="center">不同的容器之间可以共享缓存，多个容器访问相同的文件能够共享一个单一的 Page Cache</td>
<td align="center">在频繁写操作的场景下，会产生比较严重的磁盘碎片。需要消耗比较多的内存，另外稳定性相对比较差。</td>
<td align="center">容器高密度部署的场景</td>
</tr>
</tbody></table>
<h4 id="3-3-3-18-以-OverlayFS-为例"><a href="#3-3-3-18-以-OverlayFS-为例" class="headerlink" title="3.3.3.18  以 OverlayFS 为例"></a>3.3.3.18  以 OverlayFS 为例</h4><p>OverlayFS 也是一种与 AUFS 类似的联合文件系统，同样属于文件级的存储驱动，包含了最初的 Overlay 和 更新更稳定的 overlay2。</p>
<h4 id="3-3-3-19-OverlayFS-文件系统练习"><a href="#3-3-3-19-OverlayFS-文件系统练习" class="headerlink" title="3.3.3.19  OverlayFS 文件系统练习"></a>3.3.3.19  OverlayFS 文件系统练习</h4><pre><code class="hljs shel">mkdir upper lower merged work
echo &quot;from lower&quot; &gt;lower&#x2F;in_lower.txt
echo &quot;from upper&quot; &gt;lower&#x2F;in_upper.txt
echo &quot;from lower&quot; &gt;lower&#x2F;in_both.txt
echo &quot;from upper&quot; &gt;lower&#x2F;in_both.txt
mount -t overlay overlay -o lowerdir&#x3D;&#96;pwd&#96;&#x2F;lower,upperdir&#x3D;&#96;pwd&#96;&#x2F;upper,workdir&#x3D;&#96;pwd&#96;&#x2F;work &#96;pwd&#96;&#x2F;merged
cat merged&#x2F;in_both.txt
delete merged&#x2F;in_both.txt
delete merged&#x2F;in_lower.txt
delete merged&#x2F;in_upper.txt</code></pre>

<h4 id="3-3-3-20-OCI-容器标准"><a href="#3-3-3-20-OCI-容器标准" class="headerlink" title="3.3.3.20 OCI 容器标准"></a>3.3.3.20 OCI 容器标准</h4><p> Open Container Initiative</p>
<ul>
<li>OCI 组织于 2015 年创建，是一个致力于定义容器镜像标准和运行时标准的开放式组织</li>
<li>OCI 定义了镜像标准（Image Specification）、运行时标准（Runtime Specification）和分发标准（Distribution Specification）<ul>
<li>镜像标准定义应用如何打包</li>
<li>运行时标准定义如何解压应用包并运行</li>
<li>分发标准定义如何分发容器镜像</li>
</ul>
</li>
</ul>
<h4 id="3-3-3-21-Docker-引擎架构"><a href="#3-3-3-21-Docker-引擎架构" class="headerlink" title="3.3.3.21 Docker 引擎架构"></a>3.3.3.21 Docker 引擎架构</h4><ul>
<li>Docker client  docker 命令行   REST</li>
<li>Docker server  docker daemon    GRPC</li>
<li>containerd  </li>
<li>shim</li>
<li>runc</li>
</ul>
<h2 id="3-4-容器网络"><a href="#3-4-容器网络" class="headerlink" title="3.4 容器网络"></a>3.4 容器网络</h2><h3 id="3-4-1-网络"><a href="#3-4-1-网络" class="headerlink" title="3.4.1 网络"></a>3.4.1 网络</h3><ul>
<li><p>Null 模式（–net=None）</p>
<ul>
<li>把容器放入独立的网络空阿金但不做任何网络配置</li>
<li>用户需要通过运行 docker network 命令来完成网络配置</li>
</ul>
</li>
<li><p>Host</p>
<ul>
<li>使用主机网络名空间，复用主机网络</li>
</ul>
</li>
<li><p>Container</p>
<ul>
<li>重用其他容器的网络</li>
</ul>
</li>
<li><p>Bridge（–net=bridge）</p>
<ul>
<li>使用 LInux 网桥和 iptables 提供容器互联，Docker 在每台主机上创建一个名叫 docker0 的网桥，通过 veth pair 来连接该主机的每一个 EndPoint</li>
</ul>
</li>
<li><p>Overlay（libnetwork,libkv）</p>
<ul>
<li>通过网络封包实现</li>
</ul>
</li>
<li><p>Remote(work with remote drivers)</p>
<ul>
<li>Underlay: 使用现有底层网络，为每一个容器配置可路由的网络 IP</li>
</ul>
</li>
<li><p>Overlay</p>
<ul>
<li>通过网络封包实现</li>
</ul>
</li>
</ul>
<h3 id="3-4-2-Null-模式"><a href="#3-4-2-Null-模式" class="headerlink" title="3.4.2 Null 模式"></a>3.4.2 Null 模式</h3><ul>
<li>Null 模式是一个空实现</li>
<li>可以通过 Null 模式启动容器并在宿主机上通过命令为容器配置网络</li>
</ul>
<pre><code class="hljs shell">mkdir -p /var/run/netsns
find -L /var/run/netns -type | -delete
ln -s /proc/$pid/ns/net /var/run/netns/$pid
ip link add A type veth peer name B
brctl addif br0 A
ip link set A up
ip link set B netns $pid
ip netns exec $pid ip link set dev B name eth0
ip netns exec $pid ip link set eth0 up
ip netns exec $pid ip addr add
<span class="hljs-meta">$</span><span class="bash">SETIP/<span class="hljs-variable">$SETMASK</span> dev eth0</span>
ip netns exec $pid ip route add default via $GATEWAY</code></pre>

<h3 id="3-4-3-默认模式-网桥和-NAT"><a href="#3-4-3-默认模式-网桥和-NAT" class="headerlink" title="3.4.3 默认模式 - 网桥和 NAT"></a>3.4.3 默认模式 - 网桥和 NAT</h3><ul>
<li>为主机 eth0 分配 ip 192.168.0.101</li>
<li>启动 docker daemon，查看主机 iptables<ul>
<li>POSTROUTINE -A POSTROUTING -s 172.17.0.0/16 ! -o docker -j MASQUERADE</li>
</ul>
</li>
<li>在主机启动容器<ul>
<li>docker run -d –name nginx -p 8080:80 nginx</li>
<li>Docker 会以标准模式配置网络<ul>
<li>创建 veth pair</li>
<li>将 veth pair 的一段连接到 docker0 网桥</li>
<li>veth pair 的另外一段设置为容器名空间的 eth0</li>
<li>为容器名空间的 eth0 分配 ip</li>
<li>主机上的 iptables 规则： PREROUTING -A DOCKER ! -i docker0 -p tcp -m tcp –dport 2333 -j DNAT –to-destination 172.17.0.2:22</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-4-4-Underlay"><a href="#3-4-4-Underlay" class="headerlink" title="3.4.4 Underlay"></a>3.4.4 Underlay</h3><ul>
<li>采用 Linux 网桥设备（sbrctl）通过物理网络连通容器</li>
<li>创建新的网桥设备 mydr0</li>
<li>将主机网卡加入网桥</li>
<li>把主机网卡的地址配置到网桥，并把默认路由规则转移到网桥 mydr0</li>
<li>启动容器</li>
<li>创建 veth 对，并且把一个 peer 添加到网桥 mydr0</li>
<li>配置容器把 veth 的另一个 peer 分配给容器网卡</li>
</ul>
<h3 id="3-4-5-Docker-Libnetwork-Overlay"><a href="#3-4-5-Docker-Libnetwork-Overlay" class="headerlink" title="3.4.5 Docker Libnetwork Overlay"></a>3.4.5 Docker Libnetwork Overlay</h3><ul>
<li>Docker overlay 网络驱动原生支持多主机网络</li>
<li>Libnetwork 是一个内置的基于 VXLAN 的网络驱动</li>
</ul>
<h4 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h4><h4 id="Overlay-network-Sample-Flannel"><a href="#Overlay-network-Sample-Flannel" class="headerlink" title="Overlay network Sample - Flannel"></a>Overlay network Sample - Flannel</h4><h2 id="3-5-Dockerfile-的最佳实践"><a href="#3-5-Dockerfile-的最佳实践" class="headerlink" title="3.5 Dockerfile 的最佳实践"></a>3.5 Dockerfile 的最佳实践</h2><h3 id="3-5-1-创建-docker-镜像"><a href="#3-5-1-创建-docker-镜像" class="headerlink" title="3.5.1 创建 docker 镜像"></a>3.5.1 创建 docker 镜像</h3><ul>
<li><p>定义 Dockerfile</p>
<pre><code class="hljs dockerfile"><span class="hljs-comment"># Nginx image</span>
<span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">20.04</span>

<span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">&quot;maintainer&quot;</span>=<span class="hljs-string">&quot;1ch0 github1ch0@163.com&quot;</span></span>

<span class="hljs-comment"># COPY sources.list /etc/apt/sources.list</span>

<span class="hljs-keyword">RUN</span><span class="bash"> apt update &amp;&amp; apt install -y iproute2 ntpdate tcpdump telnet traceroute nfs-kernel-server nfs-common lrzsz tree openssl libssl-dev libpcre3 libpcre3-dev zlib1g-dev gcc openssh-server iotop unzip zip make vim &amp;&amp; mkdir -p /data/nginx</span>

<span class="hljs-keyword">ADD</span><span class="bash"> nginx-1.20.2.tar.gz /usr/<span class="hljs-built_in">local</span>/src</span>
<span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/src/nginx-1.20.2 &amp;&amp; ./configure --prefix=/apps/nginx &amp;&amp; make &amp;&amp; make install &amp;&amp; ln -sv /apps/nginx/sbin/nginx /usr/bin &amp;&amp; rm -rf /usr/<span class="hljs-built_in">local</span>/src/nginx-1.20.2 &amp;&amp; rm -rf /usr/<span class="hljs-built_in">local</span>/src/nginx-1.20.2.tar.gz</span>
<span class="hljs-comment"># ADD nginx.conf /apps/nginx/conf/nginx.conf</span>
<span class="hljs-comment"># ADD static.tar.gz /data/nginx/html</span>

<span class="hljs-keyword">RUN</span><span class="bash"> ln -sv /dev/stdout /apps/nginx/logs/access.log</span>
<span class="hljs-keyword">RUN</span><span class="bash"> ln -sv /dev/stderr /apps/nginx/logs/error.log</span>
<span class="hljs-comment"># sed -i -E &#x27;s,listen 80;,listen 80;\n listen [::]:80;,&#x27; /etc/nginx/conf.d/default.conf</span>

<span class="hljs-keyword">RUN</span><span class="bash"> groupadd -g 2022 nginx &amp;&amp; useradd -g nginx -s /usr/sbin/nologin -u 2022 nginx &amp;&amp; chown -R nginx.nginx /apps/nginx /data/nginx</span>

<span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span> <span class="hljs-number">443</span>
<span class="hljs-keyword">STOPSIGNAL</span> SIGTERM

<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/apps/nginx/sbin/nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]</span>
</code></pre>
</li>
<li><p>docker build</p>
</li>
</ul>
<h3 id="3-5-2-回顾-12-Factor-之进程"><a href="#3-5-2-回顾-12-Factor-之进程" class="headerlink" title="3.5.2 回顾 12 Factor 之进程"></a>3.5.2 回顾 12 Factor 之进程</h3><ul>
<li>运行环境中，应用程序通常是以一个和多个进程运行的<ul>
<li>12-Factor 应用的进程必须无状态（Stateless）且无共享（Share nothing）</li>
</ul>
</li>
<li>任何需要持久化的数据都要存储在后端服务内，比如数据库<ul>
<li>应在构建阶段将源代码编译成待执行应用</li>
</ul>
</li>
<li>Session Sticky 是 12-Factor 极力反对的<ul>
<li>Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中</li>
</ul>
</li>
</ul>
<p><strong>Docker 遵循以上原则管理和构建应用</strong></p>
<h3 id="3-5-3-理解构建上下文（Build-Context）"><a href="#3-5-3-理解构建上下文（Build-Context）" class="headerlink" title="3.5.3 理解构建上下文（Build Context）"></a>3.5.3 理解构建上下文（Build Context）</h3><ul>
<li>当运行 docker build 命令时，当前工作目录被称为构建上下文。</li>
<li>docker build 默认查找当前目录的 Dockerfile 作为构建输入，也可以通过 -f 指定 Dockerfile<ul>
<li>docker build -f ./Dockerfile</li>
</ul>
</li>
<li>当 docker build 运行时，首先会把构建上下文传输给 docker daemon，把没用的文件包含在构建上下文时，会导致传输时间长，构建需要的资源多，构建出的镜像大等问题<ul>
<li>试着到一个包含文件很多的目录运行下面的命令，会感受到差异</li>
<li>docker build -f $GOPATH/src/github.com/cncamp/golang/httpserver/Dockerfile</li>
<li>docker build $GOPATH/src/github.com/cncamp/golang/httpserver/Dockerfile</li>
<li><strong>可以通过 .dockerignore 文件从编译上下文排除某些文件</strong></li>
</ul>
</li>
<li>因此需要确保狗阿金上下文清晰，比如创建一个专门的目录放置 Dockerfile，并在目录中运行 docker build</li>
</ul>
<h3 id="3-5-4-Build-Cache"><a href="#3-5-4-Build-Cache" class="headerlink" title="3.5.4 Build Cache"></a>3.5.4 Build Cache</h3><blockquote>
<p>构建容器镜像时，Docker 依次读取 Dockerfile 中的指令，并按顺序依次执行构建指令</p>
<p>Docker 读取指令后，会先判断缓存中是否有可用的已存镜像，只有已存镜像不存在时才会重新构建。</p>
<ul>
<li>通常 Docker 简单判断 Dockerfile 中的指令与镜像</li>
<li>针对 ADD 和 COPY 指令，Docker 判断该镜像层每一个文件的内容并生成一个 checksum，与现存镜像比较时，Docker 比较的是二者的 checksum,</li>
<li>其他指令，比如 RUN apt-get -y update，Docker 简单比较与现存镜像中的指令字串是否一致</li>
<li>当某一层 cache 失效以后，所有层级的 cache 均一并失效，后续指令都重新构建镜像</li>
</ul>
</blockquote>
<h3 id="3-5-5-多段构建（Multi-stage-build）"><a href="#3-5-5-多段构建（Multi-stage-build）" class="headerlink" title="3.5.5 多段构建（Multi-stage build）"></a>3.5.5 多段构建（Multi-stage build）</h3><ul>
<li><p>有效减少镜像层级的方式</p>
<pre><code class="hljs shell">FROM golang:1.16-alpine AS build
RUN apk add --no-cache git
RUN go get github.com/golang/dep/cmd/dep

COPY Gopkg.lock Gopkg.toml /go/src/project/
WORKDIR /go/src/project/
RUN dep ensure -vendor-only

COPY . /go/src/project
RUN go build -o /bin/project

FROM scratch
COPY --from=build /bin/project /bin/project
EXPOSE 8080
ENTRYPOINT [&quot;/bin/project&quot;]
CMD[&quot;-help&quot;]
</code></pre>

</li>
</ul>
<h3 id="3-5-6-Dockerfile-常用指令"><a href="#3-5-6-Dockerfile-常用指令" class="headerlink" title="3.5.6 Dockerfile 常用指令"></a>3.5.6 Dockerfile 常用指令</h3><ul>
<li><p>FROM : 选择基础镜像，推荐 alpine</p>
<p>FROM [–platform=<platform>] <image> [@<digest>] [AS <name>]</p>
</li>
<li><p>LABELS : 按标签组织项目</p>
<p>LABEL multi.label1=”value1” multi.label2=”value2” other=”value3”</p>
<p>配合Label fitler 可过滤镜像查询结果</p>
<p>docker images -f label=multi.label1=”value1”</p>
</li>
<li><p>RUN : 执行命令</p>
<p>最常见的用法是 RUN apt-get update &amp;&amp; apt-get install，这两条命令应该永远用 &amp;&amp; 连接，如果分开执行RUN apt-get update 构建层被缓存，可能会导致新 package 无法安装</p>
</li>
<li><p>CMD：容器镜像中包含应用的运行命令，需要带参数</p>
<p>CMD[“executable”, “param1”, “param2”…]</p>
</li>
<li><p>EXPOSE：发布端口</p>
<p>EXPOSE <port> [<port>/<protocol>…]</p>
<ul>
<li>是镜像创建者和使用者的约定</li>
<li>在 docker run -P 时，docker 会自动映射 expose 的端口到主机大端口，如 0.0.0.0:32748 -&gt; 80/tcp</li>
</ul>
</li>
<li><p>ENV：设置环境变量</p>
<p>ENV <key>=<value>…</p>
</li>
<li><p>ADD :  从源地址（ 文件，目 录或者 URL)  复制文件到目标路径</p>
<p>ADD [–chown=<user>:<group>] <src >… ＜dest&gt;<br>ADD [–chown=<user>:<group>] [  “<src >“  ，…  ” <dest>“  ］ （路径中有空格时使用）</p>
<ul>
<li>ADD 支持 Go 风格的通配符， 如 ADD check* /testdir/</li>
<li>src  如果是文件， 则必须包含在编译上下文中， ADD 指令无法添加编译上下文之外的文件</li>
<li>src  如果是 URL<ul>
<li>如果 dest 结尾没有／， 那么 dest 是目标文件名， 如果 dest 结尾有／， 那么 dest 是目标目录名</li>
</ul>
</li>
<li>如果 src  是一个目录， 则所有文件都会被复制至 dest</li>
<li>如果 src  是一个本地压缩文件， 则在 ADD 的同时完整解压操作</li>
<li>如果 dest 不存在， 则 ADD 指令会创建目标目录</li>
<li>应尽量减少通过 ADD URL 添加 rem ote 文件， 建议使用 curl  或者 wget &amp;&amp; untar</li>
</ul>
</li>
<li><p>COPY  :  从源地址（ 文件，目 录或者URL)  复制文件到目标路径</p>
<p>COPY [–chown=<user>:<group>] <src>… <d est></p>
<p>COPY [–chown=<user>:<group>] [“<src>”, … “<d est> “]  / /路径中有空格时使用</p>
<ul>
<li>COPY  的使用与ADD 类似， 但有如下区别</li>
<li>COPY  只支持本地文件的复制， 不支持URL</li>
<li>COPY  不解压文件</li>
<li>COPY   可以用于多阶段编译场景， 可以用前一个临时镜像中拷贝文件<ul>
<li>COPY –from=build  /bin/project  /bin/project</li>
</ul>
</li>
</ul>
<p>COPY  语义上更直白， 复制本地文件时， 优先使用 COPY</p>
</li>
<li><p>ENTRYPOI NT:  定义可以执行的容器镜像入口命令</p>
<p>ENTRYPOINT  [“executable”, “paraml “, “param2”]  //  docker ru n参数追加模式 </p>
<p>ENTRYPOINT  command paraml  param2  / /  docker ru n 参数替换模式</p>
<ul>
<li>docker run - ent rypoint  可替换 Do cker fi le 中定义的 ENTRYPOI NT</li>
<li>ENTRYPOI NT 的最佳实践是用ENTRYPOI NT 定义镜像主命令， 并通过 CMD 定义主要参数， 如下所示<ul>
<li>ENTRYPOINT [“s3cmd”]</li>
<li>CMD [“–help”]</li>
</ul>
</li>
</ul>
</li>
<li><p>VOLUME:     将指定目录定义为外挂存储卷， Do cker fi le 中在该指令之后所有对同—目录的修改都无效</p>
<p>VOLUME [“/data”]等价于 docker  run  -v  / data,   可通过 docke r in sp ect 查看主机的 mount point,<br>/var /lib/ docker /volumes/<containerid>/_data</p>
<p> USER:   切换运行镜像的用户和用户组， 因安全性要求， 越来越多的场景要求容器应用要以 non-ro ot 身份运行</p>
</li>
<li><p>USER <user>[:<group>]</p>
</li>
</ul>
<ul>
<li><p>WORKDIR:   等价千 cd ,   切换工作目录</p>
<p>WORKDIR  /path/to/workdir</p>
</li>
<li><p>其他非常用指令</p>
</li>
</ul>
<ul>
<li>ARG</li>
<li>ONBUILD</li>
<li>STOPSIGNAL</li>
<li>HEALTHCHECK</li>
<li>SHELL</li>
</ul>
<h3 id="3-5-7-Dockerfile-最佳实践"><a href="#3-5-7-Dockerfile-最佳实践" class="headerlink" title="3.5.7 Dockerfile 最佳实践"></a>3.5.7 Dockerfile 最佳实践</h3><blockquote>
<p> <strong>目标：易管理、少漏洞、镜像小、层级少、利用缓存</strong></p>
</blockquote>
<ul>
<li><p>不要安装无效软件包</p>
</li>
<li><p>应简化镜像中同时运行的进程数，理想状况下，每个镜像应该只有一个进程。</p>
</li>
<li><p>当无法避免同一镜像运行多进程时，应选择合理的初始化进程（init process）</p>
</li>
<li><p>最小化层级数</p>
<ul>
<li><p>最新的 docker 只有 RUN，COPY，ADD 创建新层，其他指令创建临时层，不会增加镜像大小</p>
<p>比如 EXPOSE 指令就不会生成新层</p>
</li>
<li><p>多条 RUN 命令可通过连接符连接成一条指令集以减少层数</p>
</li>
<li><p>通过多段构建减少镜像层数</p>
</li>
</ul>
</li>
<li><p>把多行参数按字母排序，可以减少可能出现的重复参数，并且提高可读性</p>
</li>
<li><p>编写 Dockerfile 的时候，应该把变更频率低的编译指令优先构建以便放在镜像底层以有效利用 build cache</p>
</li>
<li><p>复制文件时，每个文件应独立复制，这确保某个文件变更时，只影响文件对应的缓存</p>
</li>
</ul>
<h3 id="3-5-8-多进程的容器镜像"><a href="#3-5-8-多进程的容器镜像" class="headerlink" title="3.5.8 多进程的容器镜像"></a>3.5.8 多进程的容器镜像</h3><ul>
<li>选择适当的 init 进程<ul>
<li>需要捕获 SIGTERM 信号并完成子进程的优雅终止</li>
<li>负责清理退出的子进程以避免僵尸进程</li>
</ul>
</li>
<li>开源项目 <a target="_blank" rel="noopener" href="https://github.com/krallin/tini">https://github.com/krallin/tini</a></li>
</ul>
<h3 id="3-5-9-Docker-镜像管理"><a href="#3-5-9-Docker-镜像管理" class="headerlink" title="3.5.9 Docker 镜像管理"></a>3.5.9 Docker 镜像管理</h3><p>docker save/load</p>
<p>docker tag</p>
<p>docker push/pull</p>
<h3 id="3-5-10-基于-Docker-镜像的版本管理"><a href="#3-5-10-基于-Docker-镜像的版本管理" class="headerlink" title="3.5.10 基于 Docker 镜像的版本管理"></a>3.5.10 基于 Docker 镜像的版本管理</h3><ul>
<li><p>Docker tag</p>
<p>docker tag 命令可以为容器镜像添加标签</p>
<p>docker tag id hub.docker.com/user/nginx:v1.0</p>
<p>hub.docker.com: 镜像仓库地址，如果不填，默认为 hub.docker.com</p>
<p>user -&gt; 仓库 repositry</p>
<p>nginx -&gt; 镜像名</p>
<p>v1.0: tag，常用来记录版本信息</p>
</li>
</ul>
<h3 id="3-5-11-Docker-tag-与-github-的版本管理"><a href="#3-5-11-Docker-tag-与-github-的版本管理" class="headerlink" title="3.5.11 Docker tag 与 github 的版本管理"></a>3.5.11 Docker tag 与 github 的版本管理</h3><ul>
<li><p>以 Kubernetes 为例</p>
<ul>
<li><p>开发分支</p>
<ul>
<li>git checkout master</li>
</ul>
</li>
<li><p>Release 分支</p>
<ul>
<li>git checkout -b release-1.21</li>
</ul>
</li>
<li><p>在并行期，所有的变更同时进 Master 和 release branch</p>
</li>
<li><p>版本发布</p>
<ul>
<li>以 release branch 为基础构建镜像，并为镜像标记版本信息</li>
</ul>
<p>docker tag id k8s.io/kubernetes/apiserver:v1.21</p>
</li>
<li><p>在 github 中保存 release 代码快照</p>
<ul>
<li>git tag v1.21</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="3-5-12-镜像仓库"><a href="#3-5-12-镜像仓库" class="headerlink" title="3.5.12 镜像仓库"></a>3.5.12 镜像仓库</h3><p><a target="_blank" rel="noopener" href="https://hub.docker.com/">Docker hub</a></p>
<p>创建私有镜像仓库</p>
<pre><code class="hljs shell">sudo docker run -d -p 5000:5000 registry</code></pre>

<h3 id="3-5-13-Docker-优势"><a href="#3-5-13-Docker-优势" class="headerlink" title="3.5.13 Docker 优势"></a>3.5.13 Docker 优势</h3><ul>
<li>封装性<ul>
<li>不需要再启动内核，所以应用扩缩容时可以秒速启动</li>
<li>资源利用率高，直接使用宿主机内核调度资源，性能损失小</li>
<li>方便的 CPU、内存资源调整</li>
<li>能实现秒级快速回滚</li>
<li>一键启动所有依赖服务，测试不用为搭建环境犯愁，PE 也不用为建站复杂担心</li>
<li>镜像一次编译，随处使用</li>
<li>测试、生产环境高度一致（数据除外）</li>
</ul>
</li>
<li>隔离性<ul>
<li>应用的运行环境和宿主机环境无关，完全由镜像控制，一台物理机上部署多种环境的镜像测试</li>
<li>多个应用版本可以并存在机器上</li>
</ul>
</li>
<li>镜像增量分发<ul>
<li>由于采用了 Union FS，简单来说就是支持将不同的目录挂载到同一个虚拟文件系统下，并实现一种 layer 的概念，每次发布只传输变化的部分，节约带宽</li>
</ul>
</li>
<li>社区活跃<ul>
<li>Docker 命令简单、易用，社区十分活跃，且周边组件丰富</li>
</ul>
</li>
</ul>
<h2 id="4-Docker-容器技术"><a href="#4-Docker-容器技术" class="headerlink" title="4. Docker 容器技术"></a>4. Docker 容器技术</h2><h3 id="4-1-知识点回顾"><a href="#4-1-知识点回顾" class="headerlink" title="4.1 知识点回顾"></a>4.1 知识点回顾</h3><h3 id="4-2-模块三作业"><a href="#4-2-模块三作业" class="headerlink" title="4.2 模块三作业"></a>4.2 模块三作业</h3><h3 id="4-3-Docker-技巧"><a href="#4-3-Docker-技巧" class="headerlink" title="4.3 Docker 技巧"></a>4.3 Docker 技巧</h3>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/Cloud-Native/">Cloud Native</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Kubernetes/">Kubernetes</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处。</p>
              
              
                <div class="post-prevnext row">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/07/13/CloudNative/mage/1.docker/01-docker/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">K8S-M-Docker</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/13/CloudNative/cncamp/module_02/">
                        <span class="hidden-mobile"></span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a id="scroll-top-button" href="#" role="button">
      <i class="iconfont icon-arrowup" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://1ch0.github.io/" target="_blank" rel="nofollow noopener"><span>1ch0</span></a> <i class="iconfont icon-love"></i> <a href="https://1ch0.github.io/" target="_blank" rel="nofollow noopener"><span>Go</span></a> <div> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
  </div>
  

  

  
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="/js/debouncer.js" ></script>
<script  src="/js/main.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/lazyload.js" ></script>
  



  



  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





  <script  src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;

      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '#post-body',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        collapseDepth: 0,
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc').css('visibility', 'visible');
      }
    });
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Docker 核心技术&nbsp;",
      ],
      cursorChar: ".",
      typeSpeed: 100,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      searchFunc(path, 'local-search-input', 'local-search-result');
      this.onclick = null
    }
  </script>



  <script  src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />

  <script>
    $('#post img:not(.no-zoom img, img[no-zoom]), img[zoom]').each(
      function () {
        var element = document.createElement('a');
        $(element).attr('data-fancybox', 'images');
        $(element).attr('href', $(this).attr('src'));
        $(this).wrap(element);
      }
    );
  </script>















</body>
</html>
