<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Linux Init</title>
    <link href="/2022/11/04/linux/linux%20init/"/>
    <url>/2022/11/04/linux/linux%20init/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-Init"><a href="#Linux-Init" class="headerlink" title="Linux Init"></a>Linux Init</h1><h2 id="1-修改配置"><a href="#1-修改配置" class="headerlink" title="1. 修改配置"></a>1. 修改配置</h2><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-built_in">set</span> -xlsb_release -amkdir <span class="hljs-variable">$HOME</span>/workspacemkdir <span class="hljs-variable">$HOME</span>/workspace/docker-composemkdir <span class="hljs-variable">$HOME</span>/workspace/yamlmkdir <span class="hljs-variable">$HOME</span>/workspace/scriptstee -a <span class="hljs-variable">$HOME</span>/.bashrc &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string"># User specific environment</span><span class="hljs-string"># Basic envs</span><span class="hljs-string">alias rm=&#x27;rm -i&#x27;</span><span class="hljs-string">alias cp=&#x27;cp -i&#x27;</span><span class="hljs-string">alias mv=&#x27;mv -i&#x27;</span><span class="hljs-string">alias ll=&#x27;ls -al&#x27;</span><span class="hljs-string">alias ch=&#x27;chmod a+x&#x27;</span><span class="hljs-string">alias cip=&#x27;curl cip.cc&#x27;</span><span class="hljs-string">alias aip=&#x27;curl -s http://myip.ipip.net&#x27;</span><span class="hljs-string">alias c=&#x27;clear&#x27;</span><span class="hljs-string">alias vi=&#x27;nvim&#x27;</span><span class="hljs-string"># alias psi=&#x27;reptyr -s&#x27;</span><span class="hljs-string">alias psg=&#x27;ps -aux|grep&#x27;</span><span class="hljs-string">alias s=&#x27;screenfetch&#x27;</span><span class="hljs-string">alias x=&#x27;xclip&#x27;</span><span class="hljs-string">alias k=&#x27;kubectl&#x27;</span><span class="hljs-string">alias ks=&#x27;kubectl -n kube-system&#x27;</span><span class="hljs-string">alias ka=&#x27;kubectl apply -f&#x27;</span><span class="hljs-string">alias kd=&#x27;kubectl delete -f&#x27;</span><span class="hljs-string">alias dc=&#x27;docker-compose&#x27;</span><span class="hljs-string">md () &#123; mkdir -p &quot;$@&quot; &amp;&amp; cd &quot;$1&quot;; &#125;</span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string">export LANG=&quot;en_US.UTF-8&quot; # 设置系统语言为 en_US.UTF-8，避免终端出现中文乱码</span><span class="hljs-string">export PS1=&#x27;[\u@dev \W]\$ &#x27; # 默认的 PS1 设置会展示全部的路径，为了防止过长，这里只展示：&quot;用户名@dev 最后的目录名&quot;</span><span class="hljs-string"></span><span class="hljs-string"></span><span class="hljs-string">export WORKSPACE=&quot;$HOME/workspace&quot; # 设置工作目录</span><span class="hljs-string">export PATH=$HOME/bin:$PATH # 将 $HOME/bin 目录加入到 PATH 变量中    </span><span class="hljs-string"># Default entry folder</span><span class="hljs-string">cd \$WORKSPACE </span><span class="hljs-string"># 登录系统，默认进入 workspace 目录</span><span class="hljs-string">EOF</span><span class="hljs-built_in">source</span>  <span class="hljs-variable">$HOME</span>/.bashrccp /etc/apt/sources.list /etc/apt/sources.list_backuptee /etc/apt/sources.list &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">#阿里源</span><span class="hljs-string">deb http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><span class="hljs-string">deb-src http://mirrors.aliyun.com/ubuntu/ focal main restricted universe multiverse</span><span class="hljs-string">deb http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><span class="hljs-string">deb-src http://mirrors.aliyun.com/ubuntu/ focal-security main restricted universe multiverse</span><span class="hljs-string">deb http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><span class="hljs-string">deb-src http://mirrors.aliyun.com/ubuntu/ focal-updates main restricted universe multiverse</span><span class="hljs-string">deb http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><span class="hljs-string">deb-src http://mirrors.aliyun.com/ubuntu/ focal-backports main restricted universe multiverse</span><span class="hljs-string">deb http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><span class="hljs-string">deb-src http://mirrors.aliyun.com/ubuntu/ focal-proposed main restricted universe multiverse</span><span class="hljs-string">EOF</span>apt-get -y updateapt-get -y upgradesudo apt-get install libc6-dev <span class="hljs-comment"># 添加公钥</span>apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 40976EAF437D05B5apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3B4FE6ACC0B21F32apt-get -y updateapt-get -y upgradeapt -y autoremoveapt install -y screenfetch git wget net-tools vim libc6-dev snapd snapcraft add-apt-repository xclip<span class="hljs-comment"># 安装 neovim</span>sudo add-apt-repository ppa:neovim-ppa/unstablesudo apt-get updatesudo apt-get install -y neovim<span class="hljs-comment"># 安装 spacevim </span><span class="hljs-comment"># curl -sLf https://spacevim.org/cn/install.sh | bash</span><span class="hljs-comment"># 使mkfontscale和mkfontdir命令正常运行</span>sudo apt-get install -y ttf-mscorefonts-installer<span class="hljs-comment"># 使fc-cache命令正常运行</span>sudo apt-get install -y fontconfigtee -a <span class="hljs-variable">$HOME</span>/.vim/vimrc &lt;&lt; <span class="hljs-string">EOF</span><span class="hljs-string">autocmd BufNewFile *.sh exec &quot;:call SetTitle()&quot;</span><span class="hljs-string">func SetTitle()</span><span class="hljs-string">    if expand(&quot;%:e&quot;) == &#x27;sh&#x27;</span><span class="hljs-string">    call setline(1, &quot;#!/bin/bash&quot;)</span><span class="hljs-string">    call setline(2, &quot;set -x&quot;)</span><span class="hljs-string">    call setline(3, &quot;&quot;)</span><span class="hljs-string">    call setline(4, &quot;#Author:       1ch0&quot;)</span><span class="hljs-string">    call setline(5, &quot;#Date:         &quot;.strftime(&quot;%Y-%m-%d&quot;))</span><span class="hljs-string">    call setline(6, &quot;#FileName:     &quot;.expand(&quot;%&quot;))</span><span class="hljs-string">    call setline(7, &quot;#Description:  1ch0 script&quot;)</span><span class="hljs-string">    call setline(8, &quot;#Blog:         https://1ch0.github.io/&quot;)</span><span class="hljs-string">    call setline(9, &quot;#Copyright(C): &quot;.strftime(&quot;%Y&quot;).&quot; All rights reserved&quot;)</span><span class="hljs-string">    call setline(10, &quot;&quot;)</span><span class="hljs-string">    call setline(11, &quot;&quot;)  </span><span class="hljs-string">    endif</span><span class="hljs-string">endfunc</span><span class="hljs-string">autocmd BufNewFile * normal G</span><span class="hljs-string">EOF</span></code></pre><h2 id="添加用户"><a href="#添加用户" class="headerlink" title="添加用户"></a>添加用户</h2><pre><code class="hljs shell">useradd  -m devpasswd devusermod -s /bin/bash dev<span class="hljs-meta">#</span><span class="bash"> 在 groupA 添加 dev 用户</span>usermod -a -G groupA dev<span class="hljs-meta">#</span><span class="bash"> 修改文件夹权限</span>chomod -R 764 /home/dev/work/<span class="hljs-meta">#</span><span class="bash"> 修改文件夹归属</span>chown  -R  dev:dev /home/dev/work/<span class="hljs-meta">#</span><span class="bash"> root 添加其他用户 docker 执行权限</span>chmod 666 /var/run/docker.sock</code></pre><h3 id="普通用户无docker权限"><a href="#普通用户无docker权限" class="headerlink" title="普通用户无docker权限"></a>普通用户无docker权限</h3><ul><li>Example 1: Got permission denied while trying to connect to the Docker daemon socket</li></ul><p>​        sudo chmod 666 /var/run/docker.sock</p><ul><li>Example 2: Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock</li></ul><p>​        sudo chmod 666 /var/run/docker.sock</p><ul><li>Example 3: dial unix /var/run/docker.sock: connect: permission denied</li></ul><p>​        sudo setfacl –modify user:<user name or ID>:rw /var/run/docker.sock</p><ul><li>Example 4: Server: ERROR: Got permission denied while trying to connect to the Docker daemon socket</li></ul><p>​        sudo newgroup docker<br>​        sudo chmod 666 /var/run/docker.sock<br>​        sudo usermod -aG docker ${USER}</p><ul><li>Example 5: permission denied while trying to connect to the docker daemon socket</li></ul><p>​        sudo usermod -aG docker ${ubuntu}</p><ul><li>Example 6: got permission denied docker</li></ul><p>​        docker deamon permission issue</p><h2 id="安装常见软件"><a href="#安装常见软件" class="headerlink" title="安装常见软件"></a>安装常见软件</h2><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># 安装 go</span>wget https://studygolang.com/dl/golang/go1.17.11.linux-amd64.tar.gz -O /tmp/go1.17.11.linux-amd64.tar.gzmkdir -p <span class="hljs-variable">$HOME</span>/gotar -xvzf /tmp/go1.17.11.linux-amd64.tar.gz -C <span class="hljs-variable">$HOME</span>/gomv <span class="hljs-variable">$HOME</span>/go/go <span class="hljs-variable">$HOME</span>/go/go1.17.11rm -f /tmp/go1.17.11.linux-amd64.tar.gztee -a <span class="hljs-variable">$HOME</span>/.bashrc &lt;&lt;<span class="hljs-string">&#x27;EOF&#x27;</span><span class="hljs-comment"># Go envs</span><span class="hljs-built_in">export</span> GOVERSION=go1.17.11 <span class="hljs-comment"># Go 版本设置</span><span class="hljs-built_in">export</span> GO_INSTALL_DIR=<span class="hljs-variable">$HOME</span>/go <span class="hljs-comment"># Go 安装目录</span><span class="hljs-built_in">export</span> GOROOT=<span class="hljs-variable">$GO_INSTALL_DIR</span>/<span class="hljs-variable">$GOVERSION</span> <span class="hljs-comment"># GOROOT 设置</span><span class="hljs-built_in">export</span> GOPATH=<span class="hljs-variable">$HOME</span>/gopath  <span class="hljs-comment"># GOPATH 设置</span><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GOROOT</span>/bin:<span class="hljs-variable">$GOPATH</span>/bin:<span class="hljs-variable">$PATH</span> <span class="hljs-comment"># 将 Go 语言自带的和通过 go install 安装的二进制文件加入到 PATH 路径中</span><span class="hljs-built_in">export</span> GO111MODULE=<span class="hljs-string">&quot;on&quot;</span> <span class="hljs-comment"># 开启 Go moudles 特性</span><span class="hljs-built_in">export</span> GOPROXY=https://goproxy.cn,direct <span class="hljs-comment"># 安装 Go 模块时，代理服务器设置</span><span class="hljs-built_in">export</span> G_MIRROR=https://golang.google.cn/dl/<span class="hljs-built_in">export</span> GOPRIVATE=<span class="hljs-built_in">export</span> GOSUMDB=off <span class="hljs-comment"># 关闭校验 Go 依赖包的哈希值</span>EOF<span class="hljs-built_in">source</span> ~/.bashrcgo version<span class="hljs-comment"># 安装docker</span><span class="hljs-comment"># 卸载旧版</span>sudo apt-get remove docker docker-engine docker.io containerd runc<span class="hljs-comment"># 安装 docker 1</span>curl -fsSL https://get.docker.com | bash -s docker --mirror aliyun<span class="hljs-comment"># 安装 docker 2</span>curl -sSL https://get.daocloud.io/docker | sh<span class="hljs-comment"># 安装 docker compose</span>curl -L https://get.daocloud.io/docker/compose/releases/download/v2.14.0/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="hljs-built_in">local</span>/bin/docker-composechmod +x /usr/<span class="hljs-built_in">local</span>/bin/docker-composedocker-compose -vsystemctl daemon-reloadservice docker restartservice docker status <span class="hljs-comment"># brctl show 查看docker网络</span>apt install -y bridge-utils <span class="hljs-comment"># bash 补全</span>apt install -y bash-completion <span class="hljs-built_in">source</span> /usr/share/bash-completion/bash_completion<span class="hljs-built_in">source</span> /usr/share/bash-completion/completions/dockerapt install -y bridge-utils<span class="hljs-comment"># 安装 npm</span>sudo apt-get install -y npmnpm install --global yarnnpm install -g nn latest</code></pre><h3 id="1-1-修改-HOME-bashrc"><a href="#1-1-修改-HOME-bashrc" class="headerlink" title="1.1 修改  $HOME/.bashrc"></a>1.1 修改  $HOME/.bashrc</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>mkdir $HOME/workspace        tee -a $HOME/.bashrc &lt;&lt; EOF<span class="hljs-meta">#</span><span class="bash"> User specific environment</span><span class="hljs-meta">#</span><span class="bash"> Basic envs</span>alias rm=&#x27;rm -i&#x27;alias cp=&#x27;cp -i&#x27;alias mv=&#x27;mv -i&#x27;alias ll=&#x27;ls -al&#x27;alias ch=&#x27;chmod a+x&#x27;alias cip=&#x27;curl cip.cc&#x27;alias aip=&#x27;curl -s http://myip.ipip.net&#x27;alias c=&#x27;clear&#x27;alias vi=&#x27;nvim&#x27;<span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">alias</span> psi=<span class="hljs-string">&#x27;reptyr -s&#x27;</span></span>alias psg=&#x27;ps -aux|grep&#x27;alias s=&#x27;screenfetch&#x27;alias x=&#x27;xclip&#x27;alias k=&#x27;kubectl&#x27;alias ks=&#x27;kubectl -n kube-system&#x27;alias ka=&#x27;kubectl apply -f&#x27;alias kd=&#x27;kubectl delete -f&#x27;alias dc=&#x27;docker-compose&#x27;export LANG=&quot;en_US.UTF-8&quot; # 设置系统语言为 en_US.UTF-8，避免终端出现中文乱码export PS1=&#x27;[\u@dev \W]\$ &#x27; # 默认的 PS1 设置会展示全部的路径，为了防止过长，这里只展示：&quot;用户名@dev 最后的目录名&quot;export WORKSPACE=&quot;$HOME/workspace&quot; # 设置工作目录export PATH=$HOME/bin:$PATH # 将 $HOME/bin 目录加入到 PATH 变量中    <span class="hljs-meta">#</span><span class="bash"> Default entry folder</span>cd \$WORKSPACE <span class="hljs-meta">#</span><span class="bash"> 登录系统，默认进入 workspace 目录</span>EOFsource  $HOME/.bashrc</code></pre><h3 id="1-2-修改-HOME-vimrc"><a href="#1-2-修改-HOME-vimrc" class="headerlink" title="1.2  修改  $HOME/.vimrc"></a>1.2  修改  $HOME/.vimrc</h3><pre><code class="hljs shell">git clone --depth=1 https://github.com.cnpmjs.org/amix/vimrc.git ~/.vim_runtime<span class="hljs-meta">#</span><span class="bash"> github.com.cnpmjs.org</span><span class="hljs-meta">#</span><span class="bash"> hub.fastgit.org</span><span class="hljs-meta">#</span><span class="bash"> git.sdut.me</span><span class="hljs-meta">#</span><span class="bash"> github.wuyanzheshui.workers.dev</span><span class="hljs-meta">#</span><span class="bash"> raw.Githubusercontent.Com</span>sh ~/.vim_runtime/install_awesome_vimrc.shtee -a $HOME/.vimrc &lt;&lt; EOFautocmd BufNewFile *.sh exec &quot;:call SetTitle()&quot;func SetTitle()    if expand(&quot;%:e&quot;) == &#x27;sh&#x27;    call setline(1, &quot;#!/bin/bash&quot;)    call setline(2, &quot;#&quot;)    call setline(3, &quot;#***********************************************************************&quot;)    call setline(4, &quot;#         Author:            1ch0&quot;)    call setline(5, &quot;#         Date:              &quot;.strftime(&quot;%Y-%m-%d&quot;))    call setline(6, &quot;#         FileName:          &quot;.expand(&quot;%&quot;))    call setline(7, &quot;#         Description:       1ch0 script&quot;)    call setline(8, &quot;#         Blog:              https://1ch0.github.io/&quot;)    call setline(9, &quot;#         Copyright (C):     &quot;.strftime(&quot;%Y&quot;).&quot; All rights reserved&quot;)    call setline(10, &quot;#***********************************************************************&quot;)call setline(11, &quot;#&quot;)    call setline(12, &quot;&quot;)        endifendfuncautocmd BufNewFile * normal GEOF</code></pre><h4 id="Vim-常见命令"><a href="#Vim-常见命令" class="headerlink" title="Vim 常见命令"></a>Vim 常见命令</h4><pre><code class="hljs shell">i 插入到光标前面I 插入到行的开始位置a 插入到光标的后面A 插入到行的最后位置o, O 新开一行Esc 关闭插入模式:w 保存:wq, :x 保存并关闭:q 关闭（已保存）:q! 强制关闭/string 搜索string字符串，如果要忽略大小写set icn 搜索指定字符串出现的下一个位置:%s/old/new/g 全文替换指定字符串old---&gt;new:n1,n2s/old/new/g 在一定范围内替换,n1,n2表示行数dd 删除一行dw 删除一个单词x 删除后一个字符X 删除前一个字符D 删除一行最后一个字符[N]yy 复制一行或者N行yw 复制一个单词p 粘贴</code></pre><h4 id="安装-vim-plug-插件管理器"><a href="#安装-vim-plug-插件管理器" class="headerlink" title="安装 vim-plug 插件管理器"></a>安装 vim-plug 插件管理器</h4><pre><code class="hljs shell">curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</code></pre><h4 id="安装-SpaceVim"><a href="#安装-SpaceVim" class="headerlink" title="安装 SpaceVim"></a>安装 SpaceVim</h4><pre><code class="hljs shell">curl -sLf https://spacevim.org/cn/install.sh | bash<span class="hljs-meta">#</span><span class="bash"> 使mkfontscale和mkfontdir命令正常运行</span>sudo apt-get install -y ttf-mscorefonts-installer<span class="hljs-meta">#</span><span class="bash"> 使fc-cache命令正常运行</span>sudo apt-get install -y fontconfigtee -a $HOME/.vim/vimrc &lt;&lt; EOFautocmd BufNewFile *.sh exec &quot;:call SetTitle()&quot;func SetTitle()    if expand(&quot;%:e&quot;) == &#x27;sh&#x27;    call setline(1, &quot;#!/bin/bash&quot;)    call setline(2, &quot;#&quot;)    call setline(3, &quot;#&quot;)    call setline(4, &quot;#Author:       1ch0&quot;)    call setline(5, &quot;#Date:         &quot;.strftime(&quot;%Y-%m-%d&quot;))    call setline(6, &quot;#FileName:     &quot;.expand(&quot;%&quot;))    call setline(7, &quot;#Description:  1ch0 script&quot;)    call setline(8, &quot;#Blog:         https://1ch0.github.io/&quot;)    call setline(9, &quot;#Copyright(C): &quot;.strftime(&quot;%Y&quot;).&quot; All rights reserved&quot;)    call setline(10, &quot;#&quot;)    call setline(11, &quot;set -x&quot;)call setline(12, &quot;#&quot;)    call setline(13, &quot;&quot;)        endifendfuncautocmd BufNewFile * normal GEOF</code></pre><pre><code class="hljs accesslog">nslookup github.comnslookup github.global.ssl.fastly.netvi /etc/hosts<span class="hljs-number">162.125.7.1</span> http://github.global.ssl.fastly.net<span class="hljs-number">162.125.7.1</span> https://github.global.ssl.fastly.net<span class="hljs-number">20.205.243.166</span> http://github.com<span class="hljs-number">20.205.243.166</span> https://github.comsudo systemctl restart systemd-networkd</code></pre><h3 id="1-3-更换-apt-源"><a href="#1-3-更换-apt-源" class="headerlink" title="1.3 更换 apt 源"></a>1.3 更换 apt 源</h3><pre><code class="hljs shell">cp /etc/apt/sources.list /etc/apt/sources.list_backuptee /etc/apt/sources.list &lt;&lt; EOF<span class="hljs-meta">#</span><span class="bash">  阿里源</span>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverseEOF<span class="hljs-meta">#</span><span class="bash"> 添加公钥</span>apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 40976EAF437D05B5apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3B4FE6ACC0B21F32apt-get -y updateapt-get -y upgradeapt -y autoremove</code></pre><h4 id="Centos-换yun源（待完善）"><a href="#Centos-换yun源（待完善）" class="headerlink" title="Centos 换yun源（待完善）"></a>Centos 换yun源（待完善）</h4><pre><code class="hljs shell">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backupwget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-8.repoenabled=0yum clean allyum makecache</code></pre><h3 id="1-4-修改时区"><a href="#1-4-修改时区" class="headerlink" title="1.4 修改时区"></a>1.4 修改时区</h3><pre><code class="hljs shell">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<span class="hljs-meta">#</span><span class="bash"> 后回车确认</span></code></pre><h3 id="1-5-新建用户"><a href="#1-5-新建用户" class="headerlink" title="1.5 新建用户"></a>1.5 新建用户</h3><pre><code class="hljs shell">useradd passwd<span class="hljs-meta">#</span><span class="bash"> 添加 sudoers</span>sed -i &#x27;/^root.*ALL=(ALL).*ALL/a\going\tALL=(ALL) \tALL&#x27; /etc/sudoers</code></pre><h2 id="2-安装常见软件"><a href="#2-安装常见软件" class="headerlink" title="2. 安装常见软件"></a>2. 安装常见软件</h2><blockquote><p>软件个人选择</p></blockquote><h3 id="2-1-安装常用软件"><a href="#2-1-安装常用软件" class="headerlink" title="2.1 安装常用软件"></a>2.1 安装常用软件</h3><pre><code class="hljs shell">apt install -y make autoconf automake cmake  libtool gcc git-lfs telnet ctags lrzsz jq perl-CPAN libcurl-devel expat-devel openssl-devel zlib-devel gcc-c++ glibc-headersapt install -y screenfetch git wget net-tools vim xclip apt install -y iproute2 ntpdate tcpdump telnet traceroute nfs-kernel-server nfs-common lrzsz tree openssl libssl-dev libpcre3 libpcre3-dev zlib1g-dev gcc openssh-server iotop unzip zip make selinux-utils sshpass socat  openssh</code></pre><h4 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h4><pre><code class="hljs shell">cd /tmpwget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.30.2.tar.gztar -xvzf git-2.30.2.tar.gzcd git-2.30.2/./configuremakesudo make installgit --version          # 输出 git 版本号，说明安装成功git version 2.30.2</code></pre><h3 id="2-2-安装-Go"><a href="#2-2-安装-Go" class="headerlink" title="2.2 安装 Go"></a>2.2 安装 Go</h3><h4 id="安装包安装"><a href="#安装包安装" class="headerlink" title="安装包安装"></a>安装包安装</h4><h5 id="new"><a href="#new" class="headerlink" title="new"></a>new</h5><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash </span>卸载旧版本sudo apt-get remove golang-gosudo apt-get remove --auto-remove golang-gowget https://go.dev/dl/go1.19.3.linux-amd64.tar.gzrm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.19.3.linux-amd64.tar.gzln -s /usr/local/go/bin/ /usr/bin/   tee -a $HOME/.bashrc &lt;&lt;&#x27;EOF&#x27;<span class="hljs-meta">#</span><span class="bash"> Go envs</span>export GOROOT=/usr/local/go # GOROOT 设置export GOPATH=$WORKSPACE/golang # GOPATH 设置export PATH=$GOROOT/bin:$GOPATH/bin:$PATH # 将 Go 语言自带的和通过 go install 安装的二进制文件加入到 PATH 路径中export GO111MODULE=&quot;on&quot; # 开启 Go moudles 特性export GOPROXY=https://goproxy.cn,direct # 安装 Go 模块时，代理服务器设置export G_MIRROR=https://golang.google.cn/dl/export GOSUMDB=off # 关闭校验 Go 依赖包的哈希值EOFsource ~/.bashrcgo version</code></pre><h5 id="old"><a href="#old" class="headerlink" title="old"></a>old</h5><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><span class="hljs-comment"># https://go.dev/dl/go1.18.4.linux-amd64.tar.gz</span>wget https://studygolang.com/dl/golang/go1.17.11.linux-amd64.tar.gz -O /tmp/go1.17.11.linux-amd64.tar.gzmkdir <span class="hljs-variable">$HOME</span>/workspace    <span class="hljs-built_in">export</span> WORKSPACE=<span class="hljs-string">&quot;<span class="hljs-variable">$HOME</span>/workspace&quot;</span>mkdir -p <span class="hljs-variable">$HOME</span>/gotar -xvzf /tmp/go1.17.11.linux-amd64.tar.gz -C <span class="hljs-variable">$HOME</span>/gomv <span class="hljs-variable">$HOME</span>/go/go <span class="hljs-variable">$HOME</span>/go/go1.17.11rm -f /tmp/go1.17.11.linux-amd64.tar.gztee -a <span class="hljs-variable">$HOME</span>/.bashrc &lt;&lt;<span class="hljs-string">&#x27;EOF&#x27;</span><span class="hljs-comment"># Go envs</span><span class="hljs-built_in">export</span> GOVERSION=go1.17.11 <span class="hljs-comment"># Go 版本设置</span><span class="hljs-built_in">export</span> GO_INSTALL_DIR=<span class="hljs-variable">$HOME</span>/go <span class="hljs-comment"># Go 安装目录</span><span class="hljs-built_in">export</span> GOROOT=<span class="hljs-variable">$GO_INSTALL_DIR</span>/<span class="hljs-variable">$GOVERSION</span> <span class="hljs-comment"># GOROOT 设置</span><span class="hljs-built_in">export</span> GOPATH=<span class="hljs-variable">$WORKSPACE</span>/go <span class="hljs-comment"># GOPATH 设置</span><span class="hljs-built_in">export</span> PATH=<span class="hljs-variable">$GOROOT</span>/bin:<span class="hljs-variable">$GOPATH</span>/bin:<span class="hljs-variable">$PATH</span> <span class="hljs-comment"># 将 Go 语言自带的和通过 go install 安装的二进制文件加入到 PATH 路径中</span><span class="hljs-built_in">export</span> GO111MODULE=<span class="hljs-string">&quot;on&quot;</span> <span class="hljs-comment"># 开启 Go moudles 特性</span><span class="hljs-built_in">export</span> GOPROXY=https://goproxy.cn,direct <span class="hljs-comment"># 安装 Go 模块时，代理服务器设置</span><span class="hljs-built_in">export</span> G_MIRROR=https://golang.google.cn/dl/<span class="hljs-built_in">export</span> GOPRIVATE=<span class="hljs-built_in">export</span> GOSUMDB=off <span class="hljs-comment"># 关闭校验 Go 依赖包的哈希值</span>EOF<span class="hljs-built_in">source</span> ~/.bashrcgo version</code></pre><h4 id="Apt-源安装"><a href="#Apt-源安装" class="headerlink" title="Apt 源安装"></a>Apt 源安装</h4><pre><code class="hljs shell">add-apt-repository ppa:longsleep/golang-backportsapt-get updatesudo apt-get install golang-gogo versiongo env -w GO111MODULE=ongo env -w GOPROXY=https://goproxy.cn,directgo env -w G_MIRROR=https://golang.google.cn/dl/</code></pre><h4 id="使用-g-安装"><a href="#使用-g-安装" class="headerlink" title="使用 g 安装"></a>使用 g 安装</h4><pre><code class="hljs shell">curl -sSL https://raw.githubusercontent.com/voidint/g/master/install.sh | bashtar -zxvf g1.2.1.linux-amd64.tar.gz mv g /usr/local/bin/echo &quot;unalias g&quot; &gt;&gt; ~/.bashrctee -a ~/.bashrc&lt;&lt;EOFexport GOROOT=&quot;$&#123;HOME&#125;/.g/go&quot;export PATH=&quot;$&#123;HOME&#125;/.g/go/bin:$PATH&quot;export G_MIRROR=https://golang.google.cn/dl/<span class="hljs-meta">#</span><span class="bash"> Enable the go modules feature</span>export GO111MODULE=on<span class="hljs-meta">#</span><span class="bash"> Set the GOPROXY environment variable</span>export GOPROXY=https://goproxy.ioEOFsource ~/.bashrc<span class="hljs-meta">#</span><span class="bash"> https://github.com/voidint/g/releases</span>g ls-remote stableg install</code></pre><h3 id="安装-python"><a href="#安装-python" class="headerlink" title="安装 python"></a>安装 python</h3><h5 id="Conda"><a href="#Conda" class="headerlink" title="Conda"></a>Conda</h5><pre><code class="hljs shell">wget -c https://repo.continuum.io/miniconda/Miniconda3-latest-Linux-x86_64.shchmod 777 Miniconda3-latest-Linux-x86_64.sh #给执行权限bash Miniconda3-latest-Linux-x86_64.sh #运行</code></pre><h4 id="安装-gh"><a href="#安装-gh" class="headerlink" title="安装 gh"></a>安装 gh</h4><pre><code class="hljs sh">conda install gh --channel conda-forge<span class="hljs-comment"># upgrade </span>conda update gh --channel conda-forge</code></pre><h3 id="2-3-安装-Tmux"><a href="#2-3-安装-Tmux" class="headerlink" title="2.3 安装 Tmux"></a>2.3 安装 Tmux</h3><pre><code class="hljs sh">sudo apt install -y tmux</code></pre><h3 id="2-4-安装-SpaceVim"><a href="#2-4-安装-SpaceVim" class="headerlink" title="2.4 安装 SpaceVim"></a>2.4 安装 SpaceVim</h3><pre><code class="hljs shell">curl -sLf https://spacevim.org/cn/install.sh | bash<span class="hljs-meta">#</span><span class="bash"> 使mkfontscale和mkfontdir命令正常运行</span>sudo apt-get install ttf-mscorefonts-installer<span class="hljs-meta">#</span><span class="bash"> 使fc-cache命令正常运行</span>sudo apt-get install fontconfig</code></pre><h4 id="2-3-安装-vim-plug-插件管理器"><a href="#2-3-安装-vim-plug-插件管理器" class="headerlink" title="2.3 安装 vim-plug 插件管理器"></a>2.3 安装 vim-plug 插件管理器</h4><pre><code class="hljs sh">curl -fLo ~/.<span class="hljs-built_in">local</span>/share/nvim/site/<span class="hljs-built_in">autoload</span>/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</code></pre><h3 id="2-5-安装k8s"><a href="#2-5-安装k8s" class="headerlink" title="2.5 安装k8s"></a>2.5 安装k8s</h3><h4 id="Sealos"><a href="#Sealos" class="headerlink" title="Sealos"></a>Sealos</h4><h5 id="2-5-0-安装前配置"><a href="#2-5-0-安装前配置" class="headerlink" title="2.5.0 安装前配置"></a>2.5.0 安装前配置</h5><ul><li><p>统一时间</p><pre><code class="hljs shell">cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime</code></pre></li></ul><ul><li><p>修改 hostname</p><pre><code class="hljs shell">tee /etc/hostname &lt;&lt; EOFnode2EOF<span class="hljs-meta">#</span><span class="bash"> 重启linux</span>reboot</code></pre></li><li><p>配置静态 ip、ssh、root 密码 </p></li><li><p>下载常用软件，需下载 socat</p><pre><code class="hljs shell">apt install -y screenfetch git wget net-tools vim openssh socat</code></pre></li></ul><h4 id="2-5-1-安装"><a href="#2-5-1-安装" class="headerlink" title="2.5.1 安装"></a>2.5.1 安装</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载并安装sealos, sealos是个golang的二进制工具，直接下载拷贝到bin目录即可, release页面也可下载</span>wget -c https://sealyun.oss-cn-beijing.aliyuncs.com/latest/sealos &amp;&amp; \    chmod +x sealos &amp;&amp; mv sealos /usr/bin<span class="hljs-meta">#</span><span class="bash"> 下载离线资源包</span>wget -c https://sealyun.oss-cn-beijing.aliyuncs.com/05a3db657821277f5f3b92d834bbaf98-v1.22.0/kube1.22.0.tar.gz<span class="hljs-meta">#</span><span class="bash"> 安装一个三master的kubernetes集群</span>sealos init --passwd &#x27;123456&#x27; \--master 192.168.0.2  --master 192.168.0.3  --master 192.168.0.4  \--node 192.168.0.5 \--pkg-url /root/kube1.22.0.tar.gz \--version v1.22.0</code></pre><h5 id="2-5-2-增加-Master"><a href="#2-5-2-增加-Master" class="headerlink" title="2.5.2 增加 Master"></a>2.5.2 增加 Master</h5><pre><code class="hljs shell">sealos join --master 192.168.0.6 --master 192.168.0.7<span class="hljs-meta">#</span><span class="bash"> 或者多个连续IP</span>sealos join --master 192.168.0.6-192.168.0.9</code></pre><h5 id="2-5-3-增加node"><a href="#2-5-3-增加node" class="headerlink" title="2.5.3 增加node"></a>2.5.3 增加node</h5><pre><code class="hljs crmsh">sealos join --<span class="hljs-keyword">node</span> <span class="hljs-title">192</span>.<span class="hljs-number">168.0</span>.<span class="hljs-number">6</span> --<span class="hljs-keyword">node</span> <span class="hljs-title">192</span>.<span class="hljs-number">168.0</span>.<span class="hljs-number">7</span>sealos join --<span class="hljs-keyword">node</span> <span class="hljs-title">192</span>.<span class="hljs-number">168.0</span>.<span class="hljs-number">6</span>-<span class="hljs-number">192.168</span>.<span class="hljs-number">0.9</span>  <span class="hljs-comment"># 或者多个连续IP</span></code></pre><h5 id="2-5-4-删除指定master节点"><a href="#2-5-4-删除指定master节点" class="headerlink" title="2.5.4 删除指定master节点"></a>2.5.4 删除指定master节点</h5><pre><code class="hljs yaml"><span class="hljs-string">sealos</span> <span class="hljs-string">clean</span> <span class="hljs-string">--master</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.6</span> <span class="hljs-string">--master</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.7</span><span class="hljs-string">sealos</span> <span class="hljs-string">clean</span> <span class="hljs-string">--master</span> <span class="hljs-number">192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.6</span><span class="hljs-number">-192.168</span><span class="hljs-number">.0</span><span class="hljs-number">.9</span>  <span class="hljs-comment"># 或者多个连续IP</span></code></pre><h5 id="2-5-5-删除指定node节点"><a href="#2-5-5-删除指定node节点" class="headerlink" title="2.5.5 删除指定node节点"></a>2.5.5 删除指定node节点</h5><pre><code class="hljs crmsh">sealos clean --<span class="hljs-keyword">node</span> <span class="hljs-title">192</span>.<span class="hljs-number">168.0</span>.<span class="hljs-number">6</span> --<span class="hljs-keyword">node</span> <span class="hljs-title">192</span>.<span class="hljs-number">168.0</span>.<span class="hljs-number">7</span>sealos clean --<span class="hljs-keyword">node</span> <span class="hljs-title">192</span>.<span class="hljs-number">168.0</span>.<span class="hljs-number">6</span>-<span class="hljs-number">192.168</span>.<span class="hljs-number">0.9</span>  <span class="hljs-comment"># 或者多个连续IP</span></code></pre><h5 id="2-5-6-清理集群"><a href="#2-5-6-清理集群" class="headerlink" title="2.5.6 清理集群"></a>2.5.6 清理集群</h5><pre><code class="hljs ada">sealos clean <span class="hljs-comment">--all</span></code></pre><h4 id="2-5-2-使用-kubeasz安装"><a href="#2-5-2-使用-kubeasz安装" class="headerlink" title="2.5.2 使用 kubeasz安装"></a><a href="https://github.com/easzlab/kubeasz/blob/master/docs/setup/quickStart.md">2.5.2 使用 kubeasz安装</a></h4><h5 id="使用纯净服务器，未安装过-docker-k8s"><a href="#使用纯净服务器，未安装过-docker-k8s" class="headerlink" title="使用纯净服务器，未安装过 docker k8s"></a>使用纯净服务器，未安装过 docker k8s</h5><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><pre><code class="hljs shell">export release=3.0.0wget https://github.com/easzlab/kubeasz/releases/download/$&#123;release&#125;/ezdownchmod +x ./ezdown./ezdown -D./ezdown -Sdocker exec -it kubeasz ezctl start-aio</code></pre><h5 id="5-清理"><a href="#5-清理" class="headerlink" title="5.清理"></a>5.清理</h5><p>以上步骤创建的K8S开发测试环境请尽情折腾，碰到错误尽量通过查看日志、上网搜索、提交<code>issues</code>等方式解决；当然你也可以清理集群后重新创建。</p><p>在宿主机上，按照如下步骤清理</p><ul><li>清理集群 <code>docker exec -it kubeasz ezctl destroy default</code></li><li>清理运行的容器 <code>./ezdown -C</code></li><li>清理容器镜像 <code>docker system prune -a</code></li><li>停止docker服务 <code>systemctl stop docker</code></li><li>删除docker文件</li></ul><pre><code class="hljs crystal">umount /var/run/docker/netns/defaultumount /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">docker</span>/<span class="hljs-title">overlay</span></span>rm -rf /var/<span class="hljs-class"><span class="hljs-keyword">lib</span>/<span class="hljs-title">docker</span> /<span class="hljs-title">var</span>/<span class="hljs-title">run</span>/<span class="hljs-title">docker</span></span></code></pre><h3 id="2-6-安装配置-zsh"><a href="#2-6-安装配置-zsh" class="headerlink" title="2.6 安装配置 zsh"></a>2.6 安装配置 zsh</h3><pre><code class="hljs shell">apt-get install -y zshwget https://raw.github.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O - | shtee -a ~/.zshrc &lt;&lt; EOFZSH_THEME=&quot;agnoster&quot;  # 主题配置plugins=(gitzsh-autosuggestionszsh-syntax-highlighting)<span class="hljs-meta">#</span><span class="bash"> 插件配置，常用插件，git分支显示，关键字高亮，自动建议</span>source &quot;/.oh-my-zsh/custom/plugins/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot;EOF<span class="hljs-meta">#</span><span class="bash"> 安装插件</span>git clone https://hub.fastgit.org/zsh-users/zsh-autosuggestions.git ~/.oh-my-zsh/custom/plugins git clone https://hub.fastgit.org/zsh-users/zsh-syntax-highlighting.git ~/.oh-my-zsh/custom/plugins source ~/.zshrc</code></pre><h3 id="2-7-安装-Docker"><a href="#2-7-安装-Docker" class="headerlink" title="2.7 安装 Docker"></a>2.7 安装 Docker</h3><h4 id="2-7-1-安装-Docker"><a href="#2-7-1-安装-Docker" class="headerlink" title="2.7.1 安装 Docker"></a>2.7.1 安装 Docker</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 卸载旧版</span>sudo apt-get remove docker docker-engine docker.io containerd runc<span class="hljs-meta">#</span><span class="bash"> 安装 docker 1</span>curl -fsSL https://get.docker.com | bash -s docker --mirror aliyun<span class="hljs-meta">#</span><span class="bash"> 安装 docker 2</span>curl -sSL https://get.daocloud.io/docker | sh<span class="hljs-meta">#</span><span class="bash"> 安装 docker compose</span>curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composedocker-compose -vsystemctl daemon-reloadservice docker restartservice docker status apt install -y bridge-utils # brctl show 查看docker网络</code></pre><h4 id="2-7-2-安装-bash-补全"><a href="#2-7-2-安装-bash-补全" class="headerlink" title="2.7.2 安装 bash 补全"></a>2.7.2 安装 bash 补全</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> yum install -y bash-completion</span>apt install -y bash-completion source /usr/share/bash-completion/bash_completionsource /usr/share/bash-completion/completions/dockerapt install -y bridge-utils # brctl show 查看docker网络</code></pre><h3 id="2-8-安装-MongoDB"><a href="#2-8-安装-MongoDB" class="headerlink" title="2.8 安装 MongoDB"></a>2.8 安装 MongoDB</h3><pre><code class="hljs shell">wget -qO - https://www.mongodb.org/static/pgp/server-6.0.asc | sudo apt-key add -sudo apt-get install -y gnupgwget -qO - https://www.mongodb.org/static/pgp/server-6.0.asc | sudo apt-key add -echo &quot;deb [ arch=amd64,arm64 ] https://repo.mongodb.org/apt/ubuntu focal/mongodb-org/6.0 multiverse&quot; | sudo tee /etc/apt/sources.list.d/mongodb-org-6.0.listsudo apt-get updatesudo apt-get install -y mongodb-orgecho &quot;mongodb-org hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-org-database hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-org-server hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-mongosh hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-org-mongos hold&quot; | sudo dpkg --set-selectionsecho &quot;mongodb-org-tools hold&quot; | sudo dpkg --set-selectionsps --no-headers -o comm 1sudo systemctl start mongodsudo systemctl daemon-reloadsudo systemctl status mongodsudo systemctl enable mongodsudo systemctl stop mongodsudo systemctl restart mongod</code></pre><h5 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h5><pre><code class="hljs shell">sudo service mongod stopsudo apt-get purge -y mongodb-org*sudo rm -r /var/log/mongodbsudo rm -r /var/lib/mongodb</code></pre><h3 id="2-9-安装-zsh"><a href="#2-9-安装-zsh" class="headerlink" title="2.9 安装 zsh"></a>2.9 安装 zsh</h3><pre><code class="hljs shell">sudo apt update &amp;&amp; sudo apt install zsh gitsh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;chsh -s $(which zsh)git clone https://github.com/romkatv/powerlevel10k.git $ZSH_CUSTOM/themes/powerlevel10ksed -i &#x27;s/ZSH_THEME=&quot;robbyrussell&quot;/ZSH_THEME=&quot;powerlevel10k\/powerlevel10k&quot;/&#x27; ~/.zshrcsource ~/.zshrc</code></pre><h2 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h2><h3 id="3-1-配置-ssh"><a href="#3-1-配置-ssh" class="headerlink" title="3.1 配置 ssh"></a>3.1 配置 ssh</h3><ul><li>配置 root 密码，开启远程登录</li></ul><pre><code class="hljs shell">sudo passwdvim /etc/ssh/sshd_configport 22PermitRootLogin yesPasswordAuthentication notee -a /etc/ssh/sshd_config &lt;&lt; EOFport 22PermitRootLogin yesPasswordAuthentication noEOFservice sshd restart</code></pre><p>开启 ssh，关闭密码验证<br><a href="https://blog.csdn.net/qq_43228568/article/details/110824158">https://blog.csdn.net/qq_43228568/article/details/110824158</a></p><ul><li>配置 key</li></ul><pre><code class="hljs shell">https://jingyan.baidu.com/article/0f5fb0990660076d8234ea50.htmlssh-keygen -t dsa /etc/ssh/ssh_host_dsa_keyssh-keygen -t ecdsa /etc/ssh/ssh_host_ecdsa_keyssh-keygen -t ed25519 /etc/ssh/ssh_host_ed25519_keyssh-keygen -t rsa /etc/ssh/ssh_host_rsa_keyssh-keygen -t rsa1 /etc/ssh/ssh_host_rsa1_keychmod 600 /etc/ssh/*keycat /etc/ssh/ssh*pub&gt;&gt;/home/ubuntu/.ssh/authorized_keyscat /home/ubuntu/.ssh/authorized_keys &gt;/root/.ssh/authorized_keyschmod 644 /root/.ssh/authorized_keys</code></pre><h3 id="3-2-配置静态-IP"><a href="#3-2-配置静态-IP" class="headerlink" title="3.2 配置静态 IP"></a>3.2 配置静态 IP</h3><pre><code class="hljs shell">tee /etc/netplan/00-installer-config.yaml &lt;&lt; EOFnetwork:  ethernets:    ens33:      addresses:        - 192.168.0.15/24      dhcp4: no      gateway4: 192.168.0.2      nameservers:          addresses: [&#x27;114.114.114.114&#x27;]  version: 2EOFnetplan applyifconfig</code></pre><h3 id="3-3-克隆虚拟机"><a href="#3-3-克隆虚拟机" class="headerlink" title="3.3 克隆虚拟机"></a>3.3 克隆虚拟机</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改hostname</span>vim /etc/hostname<span class="hljs-meta">#</span><span class="bash"> 修改ip</span>vim /etc/netplan/00-installer-config.yamlnetplan apply</code></pre><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><pre><code class="hljs ad-summary">#!&#x2F;bin&#x2F;bashmkdir $HOME&#x2F;workspace        tee -a $HOME&#x2F;.bashrc &lt;&lt; EOF# User specific environment# Basic envsalias rm&#x3D;&#39;rm -i&#39;alias cp&#x3D;&#39;cp -i&#39;alias mv&#x3D;&#39;mv -i&#39;alias ll&#x3D;&#39;ls -al&#39;alias ch&#x3D;&#39;chmod a+x&#39;alias cip&#x3D;&#39;curl cip.cc&#39;alias c&#x3D;&#39;clear&#39;# alias psi&#x3D;&#39;reptyr -s&#39;alias psg&#x3D;&#39;ps -aux|grep&#39;alias s&#x3D;&#39;screenfetch&#39;alias dc&#x3D;&#39;docker-compose&#39;alias ll&#x3D;&#39;ls -la&#39;alias c&#x3D;&#39;clear&#39;alias aip&#x3D;&#39;curl -s http:&#x2F;&#x2F;myip.ipip.net&#39;alias k&#x3D;&#39;kubectl&#39;alias ka&#x3D;&#39;kubectl apply -f&#39;alias kd&#x3D;&#39;kubectl delete -f&#39;alias ch&#x3D;&#39;chmod a+x&#39;# Go env export GOROOT&#x3D;&quot;&#x2F;root&#x2F;.g&#x2F;go&quot; export PATH&#x3D;&quot;&#x2F;root&#x2F;.g&#x2F;go&#x2F;bin:&#x2F;root&#x2F;.g&#x2F;go&#x2F;bin:&#x2F;root&#x2F;bin:&#x2F;root&#x2F;bin:&#x2F;root&#x2F;bin:&#x2F;    root&#x2F;bin:&#x2F;usr&#x2F;local&#x2F;sbin:&#x2F;usr&#x2F;local&#x2F;bin:&#x2F;usr&#x2F;sbin:&#x2F;usr&#x2F;bin:&#x2F;sbin:&#x2F;bin:&#x2F;usr&#x2F;     games:&#x2F;usr&#x2F;local&#x2F;games:&#x2F;snap&#x2F;bin&quot; export G_MIRROR&#x3D;https:&#x2F;&#x2F;golang.google.cn&#x2F;dl&#x2F; # Enable the go modules feature export GO111MODULE&#x3D;on # Set the GOPROXY environment variable export GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.ioexport LANG&#x3D;&quot;en_US.UTF-8&quot; # 设置系统语言为 en_US.UTF-8，避免终端出现中文乱码export PS1&#x3D;&#39;[\u@dev \W]\$ &#39; # 默认的 PS1 设置会展示全部的路径，为了防止过长，这里只展示：&quot;用户名@dev 最后的目录名&quot;export WORKSPACE&#x3D;&quot;$HOME&#x2F;workspace&quot; # 设置工作目录export PATH&#x3D;$HOME&#x2F;bin:$PATH # 将 $HOME&#x2F;bin 目录加入到 PATH 变量中    # Default entry foldercd \$WORKSPACE# 登录系统，默认进入 workspace 目录EOFcp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list_backuptee &#x2F;etc&#x2F;apt&#x2F;sources.list &lt;&lt; EOF#  阿里源deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiversedeb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-security main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-updates main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-proposed main restricted universe multiversedeb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; bionic-backports main restricted universe multiverseEOF# 添加公钥apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 40976EAF437D05B5apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3B4FE6ACC0B21F32apt-get -y updateapt-get -y upgradeapt -y autoremoveapt install -y screenfetch git wget net-tools vim git clone --depth&#x3D;1 https:&#x2F;&#x2F;github.com.cnpmjs.org&#x2F;amix&#x2F;vimrc.git ~&#x2F;.vim_runtimesh ~&#x2F;.vim_runtime&#x2F;install_awesome_vimrc.shtee $HOME&#x2F;.vimrc &lt;&lt; EOFautocmd BufNewFile *.sh exec &quot;:call SetTitle()&quot;func SetTitle()    if expand(&quot;%:e&quot;) &#x3D;&#x3D; &#39;sh&#39;    call setline(1, &quot;#!&#x2F;bin&#x2F;bash&quot;)    call setline(2, &quot;#&quot;)    call setline(3, &quot;#***********************************************************************&quot;)    call setline(4, &quot;#         Author:            1ch0&quot;)    call setline(5, &quot;#         Date:              &quot;.strftime(&quot;%Y-%m-%d&quot;))    call setline(6, &quot;#         FileName:          &quot;.expand(&quot;%&quot;))    call setline(7, &quot;#         Description:       1ch0 script&quot;)    call setline(8, &quot;#         Blog:              https:&#x2F;&#x2F;1ch0.github.io&#x2F;&quot;)    call setline(9, &quot;#         Copyright (C):     &quot;.strftime(&quot;%Y&quot;).&quot; All rights reserved&quot;)    call setline(10, &quot;#***********************************************************************&quot;)    call setline(11, &quot;&quot;)    endifendfuncautocmd BufNewFile * normal GEOFsource  $HOME&#x2F;.bashrc</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 切片扩容</title>
    <link href="/2022/10/10/go/finished/go_slice_2022-10-10/"/>
    <url>/2022/10/10/go/finished/go_slice_2022-10-10/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-切片扩容"><a href="#Go-切片扩容" class="headerlink" title="Go 切片扩容"></a>Go 切片扩容</h1><blockquote><p>分享一个最近遇到的切片扩容问题</p></blockquote><h2 id="Error-code"><a href="#Error-code" class="headerlink" title="Error code"></a>Error code</h2><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> List[T comparable] <span class="hljs-keyword">struct</span> &#123;l []T&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List[T])</span> <span class="hljs-title">Insert</span><span class="hljs-params">(v T)</span></span> &#123;l.InsertAt(<span class="hljs-number">0</span>, v)<span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List[T])</span> <span class="hljs-title">InsertAt</span><span class="hljs-params">(pos <span class="hljs-keyword">int</span>, v T)</span></span> &#123;l.l, l.l[<span class="hljs-number">0</span>] = <span class="hljs-built_in">append</span>(l.l[:pos+<span class="hljs-number">1</span>], l.l[pos:]...), v<span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List[T])</span> <span class="hljs-title">Slice</span><span class="hljs-params">()</span> []<span class="hljs-title">T</span></span> &#123;<span class="hljs-keyword">return</span> l.l&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewList</span>[<span class="hljs-title">T</span> <span class="hljs-title">comparable</span>]<span class="hljs-params">(t []T)</span> *<span class="hljs-title">List</span>[<span class="hljs-title">T</span>]</span> &#123;<span class="hljs-keyword">return</span> &amp;List[T]&#123;l: t&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;l := NewList([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)fmt.Println(<span class="hljs-string">&quot;initial  data: &quot;</span>, l.Slice())l.Insert(<span class="hljs-number">4</span>)fmt.Println(<span class="hljs-string">&quot;first  insert: &quot;</span>, l.Slice())l.Insert(<span class="hljs-number">5</span>)fmt.Println(<span class="hljs-string">&quot;second insert: &quot;</span>, l.Slice())l.Insert(<span class="hljs-number">6</span>)fmt.Println(<span class="hljs-string">&quot;third  insert: &quot;</span>, l.Slice())&#125;</code></pre><h3 id="Output"><a href="#Output" class="headerlink" title="Output"></a>Output</h3><pre><code class="hljs shell">initial  data:  [1 2 3]first  insert:  [1 1 2 3]    second insert:  [5 1 1 2 3]  third  insert:  [6 5 1 1 2 3]</code></pre><h2 id="Explain"><a href="#Explain" class="headerlink" title="Explain"></a>Explain</h2><ul><li>当第一次调用 InsertAt 函数时，由于切片扩容，l.l[0] 并没有被成功修改，v 被分配给旧切片而不是新切片。</li><li>之后执行  InsertAt 函数，v 成功插入，当切片再次扩容时又会触发此问题</li></ul><h2 id="Fix-code"><a href="#Fix-code" class="headerlink" title="Fix code"></a>Fix code</h2><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span>)<span class="hljs-keyword">type</span> List[T comparable] <span class="hljs-keyword">struct</span> &#123;l []T&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List[T])</span> <span class="hljs-title">Insert</span><span class="hljs-params">(v T)</span></span> &#123;l.InsertAt(<span class="hljs-number">0</span>, v)<span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List[T])</span> <span class="hljs-title">InsertAt</span><span class="hljs-params">(pos <span class="hljs-keyword">int</span>, v T)</span></span> &#123;l.l = <span class="hljs-built_in">append</span>(l.l[:pos+<span class="hljs-number">1</span>], l.l[pos:]...)l.l[<span class="hljs-number">0</span>] = v<span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *List[T])</span> <span class="hljs-title">Slice</span><span class="hljs-params">()</span> []<span class="hljs-title">T</span></span> &#123;<span class="hljs-keyword">return</span> l.l&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewList</span>[<span class="hljs-title">T</span> <span class="hljs-title">comparable</span>]<span class="hljs-params">(t []T)</span> *<span class="hljs-title">List</span>[<span class="hljs-title">T</span>]</span> &#123;<span class="hljs-keyword">return</span> &amp;List[T]&#123;l: t&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;l := NewList([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)fmt.Println(<span class="hljs-string">&quot;initial  data: &quot;</span>, l.Slice())l.Insert(<span class="hljs-number">4</span>)fmt.Println(<span class="hljs-string">&quot;first  insert: &quot;</span>, l.Slice())l.Insert(<span class="hljs-number">5</span>)fmt.Println(<span class="hljs-string">&quot;second insert: &quot;</span>, l.Slice())l.Insert(<span class="hljs-number">6</span>)fmt.Println(<span class="hljs-string">&quot;third  insert: &quot;</span>, l.Slice())&#125;</code></pre><h3 id="Output-1"><a href="#Output-1" class="headerlink" title="Output"></a>Output</h3><pre><code class="hljs shell">initial  data:  [1 2 3]first  insert:  [4 1 2 3]    second insert:  [5 4 1 2 3]  third  insert:  [6 5 4 1 2 3]</code></pre>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cncamp_module_02</title>
    <link href="/2022/08/10/cloud/cncamp/module_02/"/>
    <url>/2022/08/10/cloud/cncamp/module_02/</url>
    
    <content type="html"><![CDATA[<h1 id="Module-02"><a href="#Module-02" class="headerlink" title="Module_02"></a>Module_02</h1><h2 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h2><h2 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h2><ul><li>size 命令</li><li>objectdump -x    看二进制文件</li></ul><h3 id="2-2-2-Linux-进程的内存使用"><a href="#2-2-2-Linux-进程的内存使用" class="headerlink" title="2.2.2 Linux 进程的内存使用"></a>2.2.2 Linux 进程的内存使用</h3><ul><li>内存页大小 4K</li><li>4级页表，将虚拟地址映射到物理地址</li><li>页交换</li></ul><h3 id="2-2-3-CPU-对内存的访问"><a href="#2-2-3-CPU-对内存的访问" class="headerlink" title="2.2.3 CPU 对内存的访问"></a>2.2.3 CPU 对内存的访问</h3><ul><li>CPU 上有个 Memory Management Unit (MMU) 单元</li></ul><h2 id="2-3-内存管理"><a href="#2-3-内存管理" class="headerlink" title="2.3 内存管理"></a>2.3 内存管理</h2><h3 id="2-3-1-堆内存管理的挑战"><a href="#2-3-1-堆内存管理的挑战" class="headerlink" title="2.3.1 堆内存管理的挑战"></a>2.3.1 堆内存管理的挑战</h3><h3 id="2-3-2-堆内存管理"><a href="#2-3-2-堆内存管理" class="headerlink" title="2.3.2 堆内存管理"></a>2.3.2 堆内存管理</h3><h2 id="2-4-包引用与依赖管理，Makefile-项目编译"><a href="#2-4-包引用与依赖管理，Makefile-项目编译" class="headerlink" title="2.4 包引用与依赖管理，Makefile 项目编译"></a>2.4 包引用与依赖管理，Makefile 项目编译</h2><h2 id="2-5-HTTP-Server-编写"><a href="#2-5-HTTP-Server-编写" class="headerlink" title="2.5 HTTP Server 编写"></a>2.5 HTTP Server 编写</h2><h3 id="2-5-1-网络协议"><a href="#2-5-1-网络协议" class="headerlink" title="2.5.1 网络协议"></a>2.5.1 网络协议</h3><h3 id="2-5-2-理解-Socket"><a href="#2-5-2-理解-Socket" class="headerlink" title="2.5.2 理解 Socket"></a>2.5.2 理解 Socket</h3><h3 id="2-5-3-理解-net-http-包"><a href="#2-5-3-理解-net-http-包" class="headerlink" title="2.5.3 理解 net.http 包"></a>2.5.3 理解 net.http 包</h3><ul><li>注册 handle 处理函数</li><li>ListenAndService</li><li>定义 handle 处理函数</li></ul><h3 id="2-5-4-阻塞-IO-模型"><a href="#2-5-4-阻塞-IO-模型" class="headerlink" title="2.5.4 阻塞 IO 模型"></a>2.5.4 阻塞 IO 模型</h3><h3 id="2-5-5-异步-IO"><a href="#2-5-5-异步-IO" class="headerlink" title="2.5.5 异步 IO"></a>2.5.5 异步 IO</h3><h3 id="2-5-6-Linux-epoll"><a href="#2-5-6-Linux-epoll" class="headerlink" title="2.5.6 Linux epoll"></a>2.5.6 Linux epoll</h3><h3 id="2-5-7-高性能-httpserver-的实现细节"><a href="#2-5-7-高性能-httpserver-的实现细节" class="headerlink" title="2.5.7 高性能 httpserver 的实现细节"></a>2.5.7 高性能 httpserver 的实现细节</h3><h2 id="2-6-调试"><a href="#2-6-调试" class="headerlink" title="2.6 调试"></a>2.6 调试</h2><h3 id="2-6-1-debug"><a href="#2-6-1-debug" class="headerlink" title="2.6.1 debug"></a>2.6.1 debug</h3><h3 id="2-6-2-dlv"><a href="#2-6-2-dlv" class="headerlink" title="2.6.2 dlv"></a>2.6.2 dlv</h3><h3 id="2-6-3-更多-debug-方法"><a href="#2-6-3-更多-debug-方法" class="headerlink" title="2.6.3 更多 debug 方法"></a>2.6.3 更多 debug 方法</h3><ul><li>添加日志<ul><li>在关键代码分支中加入日志</li></ul></li><li>与日志框架将日志输出到对应的 appender<ul><li>比如可利用 glog 进行日志输出<ul><li>可配置 appender，将标准输出转至文件</li><li>支持分级日志输出，可修改配置调整日志等级</li><li>自带时间戳和代码行，方便调试</li></ul></li></ul></li></ul><h3 id="2-6-4-Glog-使用"><a href="#2-6-4-Glog-使用" class="headerlink" title="2.6.4 Glog 使用"></a>2.6.4 Glog 使用</h3><h3 id="2-6-5-性能分析（Performance-）"><a href="#2-6-5-性能分析（Performance-）" class="headerlink" title="2.6.5 性能分析（Performance ）"></a>2.6.5 性能分析（Performance ）</h3><h2 id="2-7-Kubernetes-使用-Go"><a href="#2-7-Kubernetes-使用-Go" class="headerlink" title="2.7 Kubernetes 使用 Go"></a>2.7 Kubernetes 使用 Go</h2><h3 id="2-7-1-Rate-Limit-Queue"><a href="#2-7-1-Rate-Limit-Queue" class="headerlink" title="2.7.1 Rate Limit Queue"></a>2.7.1 Rate Limit Queue</h3><p><code>控制器模式</code></p><h3 id="2-7-2-空指针"><a href="#2-7-2-空指针" class="headerlink" title="2.7.2 空指针"></a>2.7.2 空指针</h3><h3 id="2-7-3-Map-的读写冲突"><a href="#2-7-3-Map-的读写冲突" class="headerlink" title="2.7.3 Map 的读写冲突"></a>2.7.3 Map 的读写冲突</h3><h3 id="2-7-4-kube-proxy-消耗了-10-个-CPU"><a href="#2-7-4-kube-proxy-消耗了-10-个-CPU" class="headerlink" title="2.7.4 kube-proxy 消耗了 10 个 CPU"></a>2.7.4 kube-proxy 消耗了 10 个 CPU</h3><p>perf top -p <pid></p><h3 id="2-7-5-线程池耗尽"><a href="#2-7-5-线程池耗尽" class="headerlink" title="2.7.5 线程池耗尽"></a>2.7.5 线程池耗尽</h3>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IT经典资料分享</title>
    <link href="/2022/08/02/book/github.com/IT%E7%BB%8F%E5%85%B8%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB/"/>
    <url>/2022/08/02/book/github.com/IT%E7%BB%8F%E5%85%B8%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="IT经典资料分享"><a href="#IT经典资料分享" class="headerlink" title="IT经典资料分享"></a><a href="https://github.com/marmotedu/awesome-books">IT经典资料分享</a></h1><h1 id="Table-of-Contents"><a href="#Table-of-Contents" class="headerlink" title="Table of Contents"></a>Table of Contents</h1><ul><li><a href="#it%E7%BB%8F%E5%85%B8%E8%B5%84%E6%96%99%E5%88%86%E4%BA%AB">IT经典资料分享</a><ul><li><a href="#%E5%88%86%E4%BA%AB%E8%83%8C%E6%99%AF">分享背景</a></li><li><a href="#%E7%8F%8D%E8%97%8F%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90">珍藏书籍推荐</a></li><li><a href="#%E8%AF%AD%E8%A8%80%E7%B1%BB">语言类</a><ul><li><a href="#c%E8%AF%AD%E8%A8%80">C语言</a><ul><li><a href="#c%E5%9F%BA%E7%A1%80%E8%B5%84%E6%96%99">C基础资料</a></li><li><a href="#c%E8%BF%9B%E9%98%B6%E8%B5%84%E6%96%99">C进阶资料</a></li><li><a href="#c%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B">C网络编程</a></li></ul></li><li><a href="#c">C  </a></li><li><a href="#java">Java</a></li><li><a href="#go">Go</a></li><li><a href="#python">Python</a></li><li><a href="#javascript">JavaScript</a></li><li><a href="#nodejs">NodeJS</a></li><li><a href="#php">PHP</a></li><li><a href="#perl">Perl</a></li><li><a href="#ruby">Ruby</a></li><li><a href="#scala">Scala</a></li><li><a href="#lua">Lua</a></li><li><a href="#shell">Shell</a></li><li><a href="#%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80">汇编语言</a></li><li><a href="#lisp">Lisp</a></li><li><a href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">正则表达式</a></li><li><a href="#awk">AWK</a></li><li><a href="#sed">SED</a></li><li><a href="#html--css">HTML &amp; CSS</a></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a><ul><li><a href="#%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80">网络基础</a></li><li><a href="#tcpip">TCP/IP</a></li><li><a href="#http">HTTP</a></li></ul></li><li><a href="#%E5%AD%98%E5%82%A8">存储</a><ul><li><a href="#%E5%AD%98%E5%82%A8%E5%9F%BA%E7%A1%80">存储基础</a></li><li><a href="#ceph">Ceph</a></li></ul></li><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a><ul><li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%9F%BA%E7%A1%80">操作系统基础</a></li><li><a href="#linux">Linux</a></li><li><a href="#%E5%B5%8C%E5%85%A5%E5%BC%8F">嵌入式</a></li><li><a href="#linux%E5%86%85%E6%A0%B8">Linux内核</a></li></ul></li><li><a href="#%E9%98%B2%E7%81%AB%E5%A2%99">防火墙</a></li><li><a href="#%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a><ul><li><a href="#%E7%B3%BB%E7%BB%9F%E8%99%9A%E6%8B%9F%E5%8C%96">系统虚拟化</a></li><li><a href="#docker">Docker</a></li><li><a href="#kubernetes">Kubernetes</a></li><li><a href="#serverless">Serverless</a></li><li><a href="#%E4%BA%91%E8%AE%A1%E7%AE%97%E5%9F%BA%E7%A1%80">云计算基础</a></li><li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%9F%BA%E7%A1%80">微服务基础</a></li><li><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1">负载均衡</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E7%BD%91%E6%A0%BC">服务网格</a></li></ul></li><li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a><ul><li><a href="#kafka">kafka</a></li><li><a href="#rabbitmq">RabbitMQ</a></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a><ul><li><a href="#sql">SQL</a></li><li><a href="#mysql">MySQL</a></li><li><a href="#oracle">Oracle</a></li><li><a href="#redis">Redis</a></li><li><a href="#mongo">Mongo</a></li></ul></li><li><a href="#%E5%A4%A7%E6%95%B0%E6%8D%AE">大数据</a><ul><li><a href="#hadoop">Hadoop</a></li><li><a href="#spark">Spark</a></li><li><a href="#flink">Flink</a></li><li><a href="#hbase">Hbase</a></li></ul></li><li><a href="#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a><ul><li><a href="#%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%9F%BA%E7%A1%80">人工智能基础</a></li><li><a href="#tensorflow">TensorFlow</a></li></ul></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F">分布式</a><ul><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%9F%BA%E7%A1%80">分布式基础</a></li><li><a href="#etcd">Etcd</a></li><li><a href="#zookpeer">Zookpeer</a></li></ul></li><li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a></li><li><a href="#%E7%AE%97%E6%B3%95">算法</a></li><li><a href="#%E8%BF%90%E7%BB%B4">运维</a><ul><li><a href="#%E8%BF%90%E7%BB%B4%E5%9F%BA%E7%A1%80">运维基础</a></li><li><a href="#%E6%97%A5%E5%BF%97">日志</a></li><li><a href="#%E7%9B%91%E6%8E%A7%E5%91%8A%E8%AD%A6">监控告警</a></li></ul></li><li><a href="#devops">DevOps</a></li><li><a href="#%E5%8C%BA%E5%9D%97%E9%93%BE">区块链</a></li><li><a href="#%E6%80%A7%E8%83%BD">性能</a></li><li><a href="#%E6%B5%8B%E8%AF%95">测试</a><ul><li><a href="#%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80">测试基础</a></li><li><a href="#%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95">性能测试</a></li></ul></li><li><a href="#%E5%B7%A5%E5%85%B7%E7%B1%BB">工具类</a></li><li><a href="#%E9%9D%A2%E8%AF%95">面试</a></li><li><a href="#%E5%85%B6%E5%AE%83%E8%B5%84%E6%96%99">其它资料</a></li><li><a href="#%E6%8C%89%E6%A0%87%E7%AD%BE%E6%8E%A8%E8%8D%90%E7%B3%BB%E5%88%97">按标签推荐系列</a><ul><li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%B3%BB%E5%88%97%E6%8E%A8%E8%8D%90">微服务系列推荐</a></li><li><a href="#%E4%BA%91%E5%8E%9F%E7%94%9F%E7%B3%BB%E5%88%97%E6%8E%A8%E8%8D%90">云原生系列推荐</a></li></ul></li></ul></li></ul><h2 id="云原生技术栈阅读材料推荐"><a href="#云原生技术栈阅读材料推荐" class="headerlink" title="云原生技术栈阅读材料推荐"></a>云原生技术栈阅读材料推荐</h2><table><thead><tr><th>类别</th><th>书名</th></tr></thead><tbody><tr><td>微服务</td><td>[微服务设计](<a href="https://book.douban.com/subject/26772677">https://book.douban.com/subject/26772677</a></td></tr><tr><td>Docker</td><td><a href="https://book.douban.com/subject/30329430/">《Docker 技术入门与实战》（第 3 版）</a>、<a href="https://book.douban.com/subject/26894736/">《Docker容器与容器云》（第 2 版）</a></td></tr><tr><td>Kubernetes</td><td><a href="https://book.douban.com/subject/33444476/">Kubernetes权威指南：从Docker到Kubernetes实践全接触（第4版）</a></td></tr><tr><td>Serverless</td><td><a href="https://knative.dev/docs/">Knative Documentation</a></td></tr><tr><td>KVM</td><td><a href="https://book.douban.com/subject/25743939/">KVM 虚拟化技术 : 实战与原理解析</a></td></tr><tr><td>监控告警</td><td><a href="https://prometheus.io/docs/introduction/overview/">Prometheus Documentation</a></td></tr><tr><td>调用链</td><td><a href="https://www.jaegertracing.io/docs/1.26/">Jaeger Documentation</a></td></tr><tr><td>存储</td><td><a href="https://time.geekbang.org/column/intro/391?tab=catalog">Etcd</a></td></tr><tr><td>网关</td><td><a href="https://tyk.io/docs/apim/open-source/">Tyk Open Source</a></td></tr><tr><td>消息队列</td><td><a href="https://book.douban.com/subject/30221096/">Apache Kafka实战</a></td></tr><tr><td>ServiceMesh</td><td><a href="https://book.douban.com/subject/34438220/">云原生服务网格Istio：原理、实践、架构与源码解析</a></td></tr><tr><td>服务发现</td><td><a href="https://www.consul.io/docs">Consul Documentation</a></td></tr><tr><td>网络</td><td><a href="https://docs.cilium.io/">Cilium Documentation</a></td></tr></tbody></table><h2 id="珍藏书籍推荐"><a href="#珍藏书籍推荐" class="headerlink" title="珍藏书籍推荐"></a>珍藏书籍推荐</h2><p><strong>每种分类推荐 1 ~ 5 本需要珍藏书籍：</strong></p><blockquote><p>因为个人爱好、水平优先，推荐的书可能也不一样，不服预期，大佬勿喷，可以留言，我会修正 :-)</p></blockquote><table><thead><tr><th>类别</th><th>书籍</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td>C</td><td>C程序设计(第五版)<br>C程序设计语言(第2版)<br>GNU/LINUX环境编程(第2版)<br>UNIX环境高级编程(第3版)<br>C和指针<br>C专家编程<br>Linux网络编程（第2版）<br>UNIX网络编程卷1：套接字联网API（第3版）<br>LNIX网络编程卷2：进程间通信（第2版）</td><td><a href="https://book.douban.com/subject/30385709/">https://book.douban.com/subject/30385709/</a><br><a href="https://book.douban.com/subject/1139336/">https://book.douban.com/subject/1139336/</a><br><a href="https://book.douban.com/subject/4725273/">https://book.douban.com/subject/4725273/</a><br><a href="https://book.douban.com/subject/25900403/">https://book.douban.com/subject/25900403/</a><br><a href="https://book.douban.com/subject/3012360/">https://book.douban.com/subject/3012360/</a><br><a href="https://book.douban.com/subject/2377310/">https://book.douban.com/subject/2377310/</a><br><a href="https://book.douban.com/subject/26669330/">https://book.douban.com/subject/26669330/</a><br><a href="https://book.douban.com/subject/4859464/">https://book.douban.com/subject/4859464/</a><br><a href="https://book.douban.com/subject/4886882/">https://book.douban.com/subject/4886882/</a></td></tr><tr><td>C++</td><td>C++程序设计教程（第2版）<br>C++程序设计语言（第1-4部分）<br>C++ Primer Plus（第6版）<br>C++编程思想（两卷合订本）</td><td><a href="https://book.douban.com/subject/1444656/">https://book.douban.com/subject/1444656/</a><br><a href="https://book.douban.com/subject/26857943/">https://book.douban.com/subject/26857943/</a><br><a href="https://book.douban.com/subject/10789789/">https://book.douban.com/subject/10789789/</a><br><a href="https://book.douban.com/subject/6558198/">https://book.douban.com/subject/6558198/</a></td></tr><tr><td>Java</td><td>Java编程思想（第4版）</td><td><a href="https://book.douban.com/subject/2130190/">https://book.douban.com/subject/2130190/</a></td></tr><tr><td>Go</td><td>Go程序设计语言<br>Go语言编程</td><td><a href="https://book.douban.com/subject/27044219/">https://book.douban.com/subject/27044219/</a><br><a href="https://book.douban.com/subject/11577300/">https://book.douban.com/subject/11577300/</a></td></tr><tr><td>Python</td><td>Python基础教程（第3版）<br>Python核心编程（第3版）</td><td><a href="https://book.douban.com/subject/27667375/">https://book.douban.com/subject/27667375/</a><br><a href="https://book.douban.com/subject/26801374/">https://book.douban.com/subject/26801374/</a></td></tr><tr><td>JavaScript</td><td>JavaScript高级程序设计（第3版）<br>JavaScript权威指南（第6版）</td><td><a href="https://book.douban.com/subject/10549733/">https://book.douban.com/subject/10549733/</a><br><a href="https://book.douban.com/subject/10546125/">https://book.douban.com/subject/10546125/</a></td></tr><tr><td>NodeJS</td><td>深入浅出Node.js<br>Node.js高级编程</td><td><a href="https://book.douban.com/subject/25768396/">https://book.douban.com/subject/25768396/</a><br><a href="https://book.douban.com/subject/25799431/">https://book.douban.com/subject/25799431/</a></td></tr><tr><td>PHP</td><td>PHP与MySQL程序设计（第4版）</td><td><a href="https://book.douban.com/subject/6516132/">https://book.douban.com/subject/6516132/</a></td></tr><tr><td>Perl</td><td>Perl语言入门（第5版）</td><td><a href="https://book.douban.com/subject/4088038/">https://book.douban.com/subject/4088038/</a></td></tr><tr><td>Ruby</td><td>Ruby元编程（第2版）</td><td><a href="https://book.douban.com/subject/26575429/">https://book.douban.com/subject/26575429/</a></td></tr><tr><td>Scala</td><td>Scala编程（第3版）<br>Scala程序设计（第2版）</td><td><a href="https://book.douban.com/subject/27591387/">https://book.douban.com/subject/27591387/</a><br><a href="https://book.douban.com/subject/26740545/">https://book.douban.com/subject/26740545/</a></td></tr><tr><td>Lua</td><td>Lua程序设计（第2版）</td><td><a href="https://book.douban.com/subject/3076942/">https://book.douban.com/subject/3076942/</a></td></tr><tr><td>Shell</td><td>实战Linux Shell编程与服务器管理<br>Shell脚本专家指南</td><td><a href="https://book.douban.com/subject/4722707/">https://book.douban.com/subject/4722707/</a><br><a href="https://book.douban.com/subject/4935288/">https://book.douban.com/subject/4935288/</a></td></tr><tr><td>汇编语言</td><td>汇编语言（第3版）</td><td><a href="https://item.jd.com/12259774.html?dist=jd">https://item.jd.com/12259774.html?dist=jd</a></td></tr><tr><td>Lisp</td><td>实用Common Lisp编程</td><td><a href="https://book.douban.com/subject/6859720/">https://book.douban.com/subject/6859720/</a></td></tr><tr><td>正则表达式</td><td>正则指引（第2版）<br>精通正则表达式（第3版）</td><td><a href="https://book.douban.com/subject/30352656/">https://book.douban.com/subject/30352656/</a><br><a href="https://book.douban.com/subject/2154713/">https://book.douban.com/subject/2154713/</a></td></tr><tr><td>AWK</td><td>sed与awk（第3版）</td><td><a href="https://book.douban.com/subject/1236944/">https://book.douban.com/subject/1236944/</a></td></tr><tr><td>Sed</td><td>sed与awk（第3版）</td><td><a href="https://book.douban.com/subject/1236944/">https://book.douban.com/subject/1236944/</a></td></tr><tr><td>HTML &amp; CSS</td><td>CSS权威指南（中文第3版）<br>HTML5权威指南</td><td><a href="https://book.douban.com/subject/2308234/">https://book.douban.com/subject/2308234/</a><br><a href="https://book.douban.com/subject/25786074/">https://book.douban.com/subject/25786074/</a></td></tr><tr><td>计算机网络</td><td>计算机网络（第7版）</td><td><a href="https://book.douban.com/subject/26960678/">https://book.douban.com/subject/26960678/</a></td></tr><tr><td>TCP/IP</td><td>图解TCP/IP（第5版）<br>TCP/IP详解 卷1：协议（第2版）</td><td><a href="https://book.douban.com/subject/24737674/">https://book.douban.com/subject/24737674/</a><br><a href="https://book.douban.com/subject/26825411/">https://book.douban.com/subject/26825411/</a></td></tr><tr><td>HTTP</td><td>图解HTTP<br>HTTP权威指南</td><td><a href="https://book.douban.com/subject/25863515/">https://book.douban.com/subject/25863515/</a><br><a href="https://book.douban.com/subject/10746113/">https://book.douban.com/subject/10746113/</a></td></tr><tr><td>操作系统基础</td><td>计算机操作系统（第3版）<br>计算机系统概论（第2版）</td><td><a href="https://book.douban.com/subject/1058576/">https://book.douban.com/subject/1058576/</a><br><a href="https://book.douban.com/subject/2185076/">https://book.douban.com/subject/2185076/</a></td></tr><tr><td>Linux</td><td>鸟哥的Linux私房菜:基础学习篇(第4版)<br>循序渐进Linux（第2版） : 基础知识 服务器搭建 系统管理 性能调优 虚拟化与集群应用</td><td><a href="https://book.douban.com/subject/30359954/">https://book.douban.com/subject/30359954/</a><br><a href="https://book.douban.com/subject/26758194/">https://book.douban.com/subject/26758194/</a></td></tr><tr><td>嵌入式</td><td>嵌入式Linux设备驱动开发详解</td><td><a href="https://book.douban.com/subject/2985887/">https://book.douban.com/subject/2985887/</a></td></tr><tr><td>Linux 内核</td><td>Linux内核设计与实现（原书第3版）<br>LINUX内核源代码情景分析（全册）<br>深入理解LINUX内核（第3版）<br>LINUX设备驱动程序（第3版）<br>Linux内核完全注释（修订版）<br>深入Linux内核架构<br></td><td><a href="https://book.douban.com/subject/6097773/">https://book.douban.com/subject/6097773/</a><br><a href="https://book.douban.com/subject/1231584/">https://book.douban.com/subject/1231584/</a><br><a href="https://book.douban.com/subject/2287506/">https://book.douban.com/subject/2287506/</a><br><a href="https://book.douban.com/subject/1420480/">https://book.douban.com/subject/1420480/</a><br><a href="https://book.douban.com/subject/1231236/">https://book.douban.com/subject/1231236/</a><br><a href="https://book.douban.com/subject/4843567/">https://book.douban.com/subject/4843567/</a></td></tr><tr><td>内核存储</td><td>Linux 内核模块编程<br>Linux内核探秘：深入解析文件系统和设备驱动的架构与设计<br>存储技术原理分析：基于 Linux_2.6 内核源代码<br>LINUX 设备驱动程序(第 3 版)</td><td>这本没有书籍，但是编写内核模块的经典Hello World入门书籍<br><a href="https://book.douban.com/subject/25817503/">https://book.douban.com/subject/25817503/</a><br><a href="https://book.douban.com/subject/6822367/">https://book.douban.com/subject/6822367/</a><br><a href="https://book.douban.com/subject/1420480/">https://book.douban.com/subject/1420480/</a></td></tr><tr><td>防火墙</td><td>Linux防火墙-(原书第3版)</td><td><a href="https://book.douban.com/subject/1838749/">https://book.douban.com/subject/1838749/</a></td></tr><tr><td>虚拟化原理</td><td>系统虚拟化 : 原理与实现</td><td><a href="https://book.douban.com/subject/3619896/">https://book.douban.com/subject/3619896/</a></td></tr><tr><td>KVM</td><td>KVM虚拟化技术 : 实战与原理解析</td><td><a href="https://book.douban.com/subject/25743939/">https://book.douban.com/subject/25743939/</a></td></tr><tr><td>Docker</td><td>Docker技术入门与实战（第3版）<br>Docker 容器与容器云（第2版）</td><td><a href="https://book.douban.com/subject/30329430/">https://book.douban.com/subject/30329430/</a><br><a href="https://book.douban.com/subject/26894736/">https://book.douban.com/subject/26894736/</a></td></tr><tr><td>Kubernetes</td><td>Kubernetes权威指南：从Docker到Kubernetes实践全接触（第4版）<br>基于Kubernetes的容器云平台实战</td><td><a href="https://book.douban.com/subject/33444476/">https://book.douban.com/subject/33444476/</a><br><a href="https://book.douban.com/subject/30333237/">https://book.douban.com/subject/30333237/</a></td></tr><tr><td>Serverless</td><td>Serverless架构：从原理、设计到项目实战<br>Serverless架构：无服务器应用与AWS Lambda</td><td>我们团队刘宇大佬写的一本书，没有盗版PDF<br><a href="https://book.douban.com/subject/30290516/">https://book.douban.com/subject/30290516/</a></td></tr><tr><td>微服务</td><td>微服务架构与实践（第1版）<br>微服务设计</td><td><a href="https://book.douban.com/subject/26693152/">https://book.douban.com/subject/26693152/</a><br><a href="https://book.douban.com/subject/26772677/">https://book.douban.com/subject/26772677/</a></td></tr><tr><td>ServiceMesh</td><td>云原生服务网格Istio：原理、实践、架构与源码解析</td><td><a href="https://book.douban.com/subject/34438220/">https://book.douban.com/subject/34438220/</a></td></tr><tr><td>kafka</td><td>Apache Kafka实战<br>Apache Kafka源码剖析<br>Kafka权威指南</td><td><a href="https://book.douban.com/subject/30221096/">https://book.douban.com/subject/30221096/</a><br><a href="https://book.douban.com/subject/27038473/">https://book.douban.com/subject/27038473/</a><br><a href="https://book.douban.com/subject/27665114/">https://book.douban.com/subject/27665114/</a></td></tr><tr><td>RabbitMQ</td><td>RabbitMQ实战 : 高效部署分布式消息队列</td><td><a href="https://book.douban.com/subject/26649178/">https://book.douban.com/subject/26649178/</a></td></tr><tr><td>SQL</td><td>精通SQL结构化查询语言详解</td><td><a href="https://book.douban.com/subject/2022427/">https://book.douban.com/subject/2022427/</a></td></tr><tr><td>MySQL</td><td>MySQL技术内幕InnoDB存储引擎（第1版）<br>MySQL必知必会</td><td><a href="https://book.douban.com/subject/5373022/">https://book.douban.com/subject/5373022/</a><br><a href="https://book.douban.com/subject/3354490/">https://book.douban.com/subject/3354490/</a></td></tr><tr><td>Oracle</td><td>Oracle 10g数据库管理应用与开发标准教程</td><td><a href="https://book.douban.com/subject/2316500/">https://book.douban.com/subject/2316500/</a></td></tr><tr><td>Redis</td><td>Redis设计与实现</td><td><a href="https://book.douban.com/subject/25900156/">https://book.douban.com/subject/25900156/</a></td></tr><tr><td>Mongo</td><td>MongoDB大数据处理权威指南（第2版）</td><td><a href="https://book.douban.com/subject/26269829/">https://book.douban.com/subject/26269829/</a></td></tr></tbody></table><hr><h2 id="语言类"><a href="#语言类" class="headerlink" title="语言类"></a>语言类</h2><h3 id="C语言"><a href="#C语言" class="headerlink" title="C语言"></a>C语言</h3><h4 id="C基础资料"><a href="#C基础资料" class="headerlink" title="C基础资料"></a>C基础资料</h4><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/30385709/">C程序设计(第五版)</a><br><a href="https://book.douban.com/subject/4864940/">C程序设计(第四版)</a></td><td><a href="https://book.douban.com/subject/30385709/">https://book.douban.com/subject/30385709/</a><br><a href="https://book.douban.com/subject/4864940/">https://book.douban.com/subject/4864940/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1236999/">The C Programming language</a></td><td><a href="https://book.douban.com/subject/1236999/">https://book.douban.com/subject/1236999/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1139336/">C程序设计语言(第2版)</a></td><td><a href="https://book.douban.com/subject/1139336/">https://book.douban.com/subject/1139336/</a></td></tr><tr><td><a href="https://book.douban.com/subject/6025290/">一站式学习C编程</a></td><td><a href="https://book.douban.com/subject/6025290/">https://book.douban.com/subject/6025290/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26792521/">C Primer Plus（第6版）</a></td><td><a href="https://book.douban.com/subject/26792521/">https://book.douban.com/subject/26792521/</a></td></tr></tbody></table><h4 id="C进阶资料"><a href="#C进阶资料" class="headerlink" title="C进阶资料"></a>C进阶资料</h4><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/25900403/">UNIX环境高级编程(第3版)</a></td><td><a href="https://book.douban.com/subject/25900403/">https://book.douban.com/subject/25900403/</a></td></tr><tr><td><a href="https://book.douban.com/subject/3012360/">C和指针</a></td><td><a href="https://book.douban.com/subject/3012360/">https://book.douban.com/subject/3012360/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1102097/">C陷阱与缺陷</a></td><td><a href="https://book.douban.com/subject/1102097/">https://book.douban.com/subject/1102097/</a></td></tr><tr><td><a href="https://book.douban.com/subject/2377310/">C专家编程</a></td><td><a href="https://book.douban.com/subject/2377310/">https://book.douban.com/subject/2377310/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4725273/">GNU/LINUX环境编程(第2版)</a></td><td><a href="https://book.douban.com/subject/4725273/">https://book.douban.com/subject/4725273/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1231823/">GNU/Linux 编程指南(第2版)</a></td><td><a href="https://book.douban.com/subject/1231823/">https://book.douban.com/subject/1231823/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25809330/">Linux/UNIX系统编程手册（上册）</a></td><td><a href="https://book.douban.com/subject/25809330/">https://book.douban.com/subject/25809330/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25809330/">Linux/UNIX系统编程手册（下册）</a></td><td><a href="https://book.douban.com/subject/25809330/">https://book.douban.com/subject/25809330/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4831448/">Linux程序设计（第4版）</a></td><td><a href="https://book.douban.com/subject/4831448/">https://book.douban.com/subject/4831448/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25906154/">Linux系统编程（第2版）</a></td><td><a href="https://book.douban.com/subject/25906154/">https://book.douban.com/subject/25906154/</a></td></tr></tbody></table><h4 id="C网络编程"><a href="#C网络编程" class="headerlink" title="C网络编程"></a>C网络编程</h4><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/26669330/">Linux网络编程（第2版）</a></td><td><a href="https://book.douban.com/subject/26669330/">https://book.douban.com/subject/26669330/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4859464/">UNIX网络编程卷1：套接字联网API（第3版）</a></td><td><a href="https://book.douban.com/subject/4859464/">https://book.douban.com/subject/4859464/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4886882/">UNIX网络编程卷2：进程间通信（第2版）</a></td><td><a href="https://book.douban.com/subject/4886882/">https://book.douban.com/subject/4886882/</a></td></tr></tbody></table><h3 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/10789789/">C++ Primer Plus（第6版）</a></td><td><a href="https://book.douban.com/subject/10789789/">https://book.douban.com/subject/10789789/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1842426/">Effective C++（中文第3版）</a></td><td><a href="https://book.douban.com/subject/1842426/">https://book.douban.com/subject/1842426/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1174290/">C++程序设计（第2版）</a></td><td><a href="https://book.douban.com/subject/1174290/">https://book.douban.com/subject/1174290/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1444656/">C++程序设计教程（第2版）</a></td><td><a href="https://book.douban.com/subject/1444656/">https://book.douban.com/subject/1444656/</a></td></tr><tr><td><a href="https://book.douban.com/subject/6558198/">C++编程思想（两卷合订本）</a></td><td><a href="https://book.douban.com/subject/6558198/">https://book.douban.com/subject/6558198/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26378198/">C++高级编程(中文第3版)</a></td><td><a href="https://book.douban.com/subject/26378198/">https://book.douban.com/subject/26378198/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30189176/">C++高级编程(英文第4版)</a></td><td><a href="https://book.douban.com/subject/30189176/">https://book.douban.com/subject/30189176/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27666339/">C++性能优化指南</a></td><td><a href="https://book.douban.com/subject/27666339/">https://book.douban.com/subject/27666339/</a></td></tr><tr><td><a href="https://book.douban.com/subject/2970056/">C++沉思录（第2版）</a></td><td><a href="https://book.douban.com/subject/2970056/">https://book.douban.com/subject/2970056/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26857943/">C++程序设计语言（第1-4部分）</a></td><td><a href="https://book.douban.com/subject/26857943/">https://book.douban.com/subject/26857943/</a></td></tr></tbody></table><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/2130190/">Java编程思想（第4版）</a></td><td><a href="https://book.douban.com/subject/2130190/">https://book.douban.com/subject/2130190/</a></td></tr><tr><td><a href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机（第2版）：JVM高级特性与最佳实践</a></td><td><a href="https://book.douban.com/subject/24722612/">https://book.douban.com/subject/24722612/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26900033/">Java从入门到精通（第4版）</a></td><td><a href="https://book.douban.com/subject/26900033/">https://book.douban.com/subject/26900033/</a></td></tr><tr><td><a href="https://book.douban.com/subject/10484692/">Java并发编程实战</a></td><td><a href="https://book.douban.com/subject/10484692/">https://book.douban.com/subject/10484692/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26591326/">Java并发编程的艺术</a></td><td><a href="https://book.douban.com/subject/26591326/">https://book.douban.com/subject/26591326/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30323325/">深入浅出Spring Boot 2.x</a></td><td><a href="https://book.douban.com/subject/30323325/">https://book.douban.com/subject/30323325/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26857423/">Spring Boot实战</a></td><td><a href="https://book.douban.com/subject/26857423/">https://book.douban.com/subject/26857423/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27594722/">Java函数式编程</a></td><td><a href="https://book.douban.com/subject/27594722/">https://book.douban.com/subject/27594722/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26346017/">Java 8函数式编程</a></td><td><a href="https://book.douban.com/subject/26346017/">https://book.douban.com/subject/26346017/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26581686/">Java Web高级编程 : 涵盖WebSockets、Spring Framework、JPA Hibernate和Spring Security</a></td><td><a href="https://book.douban.com/subject/26581686/">https://book.douban.com/subject/26581686/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26740520/">Java性能权威指南</a></td><td><a href="https://book.douban.com/subject/26740520/">https://book.douban.com/subject/26740520/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30358019/">实战Java高并发程序设计（第2版）</a></td><td><a href="https://book.douban.com/subject/30358019/">https://book.douban.com/subject/30358019/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1433583/">Java Nio</a></td><td><a href="https://book.douban.com/subject/1433583/">https://book.douban.com/subject/1433583/</a></td></tr></tbody></table><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/27044219/">Go程序设计语言</a></td><td><a href="https://book.douban.com/subject/27044219/">https://book.douban.com/subject/27044219/</a></td></tr><tr><td><a href="https://book.douban.com/subject/11577300/">Go语言编程</a></td><td><a href="https://book.douban.com/subject/11577300/">https://book.douban.com/subject/11577300/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27016236/">Go 并发编程实战（第2版）</a></td><td><a href="https://book.douban.com/subject/27016236/">https://book.douban.com/subject/27016236/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27015617/">Go 语言实战</a></td><td><a href="https://book.douban.com/subject/27015617/">https://book.douban.com/subject/27015617/</a></td></tr><tr><td><a href="https://book.douban.com/subject/24869910/">Go语言程序设计</a></td><td><a href="https://book.douban.com/subject/24869910/">https://book.douban.com/subject/24869910/</a></td></tr><tr><td><a href="">Go语言学习笔记</a></td><td><a href="https://book.douban.com/subject/26832468/">https://book.douban.com/subject/26832468/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30325764/">Go语言编程入门与实战技巧</a></td><td><a href="https://book.douban.com/subject/30325764/">https://book.douban.com/subject/30325764/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26859123/">Go语言圣经（中文版）</a></td><td><a href="https://book.douban.com/subject/26859123/">https://book.douban.com/subject/26859123/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30351288/">Go语言核心编程</a></td><td><a href="https://book.douban.com/subject/30351288/">https://book.douban.com/subject/30351288/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27204133/">Go Web编程</a></td><td><a href="https://book.douban.com/subject/27204133/">https://book.douban.com/subject/27204133/</a></td></tr></tbody></table><h3 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/27667375/">Python基础教程（第3版）</a></td><td><a href="https://book.douban.com/subject/27667375/">https://book.douban.com/subject/27667375/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26801374/">Python核心编程（第3版）</a></td><td><a href="https://book.douban.com/subject/26801374/">https://book.douban.com/subject/26801374/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27133480/">Python高级编程（第2版）</a></td><td><a href="https://book.douban.com/subject/27133480/">https://book.douban.com/subject/27133480/</a></td></tr><tr><td><a href="https://book.douban.com/subject/6049132/">Python学习手册（中文第4版）</a></td><td><a href="https://book.douban.com/subject/6049132/">https://book.douban.com/subject/6049132/</a></td></tr><tr><td><a href="https://book.douban.com/subject/22139956/">Python学习手册（英文第5版）</a></td><td><a href="https://book.douban.com/subject/22139956/">https://book.douban.com/subject/22139956/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26314833/">Python编程（第4版，上下册）</a></td><td><a href="https://book.douban.com/subject/26314833/">https://book.douban.com/subject/26314833/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4828875/">Python Cookbook（中文第2版）</a></td><td><a href="https://book.douban.com/subject/4828875/">https://book.douban.com/subject/4828875/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27064848/">Python高性能编程</a></td><td><a href="https://book.douban.com/subject/27064848/">https://book.douban.com/subject/27064848/</a></td></tr><tr><td><a href="https://book.douban.com/subject/5336893/">Python自然语言处理（中文版）</a></td><td><a href="https://book.douban.com/subject/5336893/">https://book.douban.com/subject/5336893/</a></td></tr><tr><td><a href="https://book.douban.com/subject/10760444/">Python For Data Analysis（英文）</a></td><td><a href="https://book.douban.com/subject/10760444/">https://book.douban.com/subject/10760444/</a></td></tr></tbody></table><h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/11506062/">JavaScript模式 </a></td><td><a href="https://book.douban.com/subject/11506062/">https://book.douban.com/subject/11506062/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26382780/">JavaScript设计模式与开发实践</a></td><td><a href="https://book.douban.com/subject/26382780/">https://book.douban.com/subject/26382780/</a></td></tr><tr><td><a href="https://book.douban.com/subject/10549733/">JavaScript权威指南（第6版）</a></td><td><a href="https://book.douban.com/subject/10549733/">https://book.douban.com/subject/10549733/</a></td></tr><tr><td><a href="https://book.douban.com/subject/10546125/">JavaScript高级程序设计（第3版）</a></td><td><a href="https://book.douban.com/subject/10546125/">https://book.douban.com/subject/10546125/</a></td></tr><tr><td><a href="https://book.douban.com/subject/3329540/">JavaScript设计模式</a></td><td><a href="https://book.douban.com/subject/3329540/">https://book.douban.com/subject/3329540/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4089837/">JavaScript学习指南（第2版）</a></td><td><a href="https://book.douban.com/subject/4089837/">https://book.douban.com/subject/4089837/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26382780/">JavaScript设计模式与开发实践</a></td><td><a href="https://book.douban.com/subject/26382780/">https://book.douban.com/subject/26382780/</a></td></tr><tr><td><a href="https://book.douban.com/subject/6038371/">JavaScript DOM编程艺术（第2版）</a></td><td><a href="https://book.douban.com/subject/6038371/">https://book.douban.com/subject/6038371/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26638316/">JavaScript忍者秘籍（第2版）</a></td><td><a href="https://book.douban.com/subject/26638316/">https://book.douban.com/subject/26638316/</a></td></tr><tr><td><a href="https://book.douban.com/subject/3590768/">JavaScript语言精粹</a></td><td><a href="https://book.douban.com/subject/3590768/">https://book.douban.com/subject/3590768/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26773411/">JavaScript经典实例（第2版）</a></td><td><a href="https://book.douban.com/subject/26773411/">https://book.douban.com/subject/26773411/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25767719/">JavaScript编程全解</a></td><td><a href="https://book.douban.com/subject/25767719/">https://book.douban.com/subject/25767719/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26707144/">JavaScript编程精解（第2版）</a></td><td><a href="https://book.douban.com/subject/26707144/">https://book.douban.com/subject/26707144/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25945449/">学习JavaScript数据结构与算法</a></td><td><a href="https://book.douban.com/subject/25945449/">https://book.douban.com/subject/25945449/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26579320/">JavaScript函数式编程</a></td><td><a href="https://book.douban.com/subject/26579320/">https://book.douban.com/subject/26579320/</a></td></tr><tr><td><a href="https://book.douban.com/subject/11534729/">JavaScript从入门到精通（标准版）</a></td><td><a href="https://book.douban.com/subject/11534729/">https://book.douban.com/subject/11534729/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25945449/">数据结构与算法JavaScript描述</a></td><td><a href="https://book.douban.com/subject/25945449/">https://book.douban.com/subject/25945449/</a></td></tr><tr><td><a href="https://book.douban.com/subject/3120941/">JavaScript开发技术大全</a></td><td><a href="https://book.douban.com/subject/3120941/">https://book.douban.com/subject/3120941/</a></td></tr></tbody></table><h3 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/25768396/">深入浅出Node.js</a></td><td><a href="https://book.douban.com/subject/25768396/">https://book.douban.com/subject/25768396/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25870705/">Node.js 实战</a></td><td><a href="https://book.douban.com/subject/25870705/">https://book.douban.com/subject/25870705/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30288107/">Node.js实战（第2版）</a></td><td><a href="https://book.douban.com/subject/30288107/">https://book.douban.com/subject/30288107/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25892704/">Node.js权威指南</a></td><td><a href="https://book.douban.com/subject/25892704/">https://book.douban.com/subject/25892704/</a></td></tr><tr><td><a href="https://book.douban.com/subject/10789820/">Node.js开发指南</a></td><td><a href="https://book.douban.com/subject/10789820/">https://book.douban.com/subject/10789820/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25799431/">Node.js高级编程</a></td><td><a href="https://book.douban.com/subject/25799431/">https://book.douban.com/subject/25799431/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26970060/">Node.js进阶之路</a></td><td><a href="https://book.douban.com/subject/26970060/">https://book.douban.com/subject/26970060/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25767596/">了不起的Node.js 将JavaScript进行到底</a></td><td><a href="https://book.douban.com/subject/25767596/">https://book.douban.com/subject/25767596/</a></td></tr></tbody></table><h3 id="PHP"><a href="#PHP" class="headerlink" title="PHP"></a>PHP</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/6516132/">PHP与MySQL程序设计（第4版）</a></td><td><a href="https://book.douban.com/subject/6516132/">https://book.douban.com/subject/6516132/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26635862/">Modern PHP（中文版）</a></td><td><a href="https://book.douban.com/subject/26635862/">https://book.douban.com/subject/26635862/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25982663/">Modern PHP（英文版）</a></td><td><a href="https://book.douban.com/subject/25982663/">https://book.douban.com/subject/25982663/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30769463/">PHP高性能开发：基础、框架与项目实战</a></td><td><a href="https://book.douban.com/subject/30769463/">https://book.douban.com/subject/30769463/</a></td></tr><tr><td><a href="https://book.douban.com/subject/6559267/">深入PHP：面向对象、模式与实践（第3版）</a></td><td><a href="https://book.douban.com/subject/6559267/">https://book.douban.com/subject/6559267/</a></td></tr></tbody></table><h3 id="Perl"><a href="#Perl" class="headerlink" title="Perl"></a>Perl</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/4088038/">Perl语言入门（第5版</a></td><td><a href="https://book.douban.com/subject/4088038/">https://book.douban.com/subject/4088038/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30549490/">Perl高效编程（第2版）</a></td><td><a href="https://book.douban.com/subject/30549490/">https://book.douban.com/subject/30549490/</a></td></tr><tr><td><a href="https://book.douban.com/subject/3335419/">PERL实例精解（第4版）</a></td><td><a href="https://book.douban.com/subject/3335419/">https://book.douban.com/subject/3335419/</a></td></tr></tbody></table><h3 id="Ruby"><a href="#Ruby" class="headerlink" title="Ruby"></a>Ruby</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/26575429/">Ruby元编程（第2版）</a></td><td><a href="https://book.douban.com/subject/26575429/">https://book.douban.com/subject/26575429/</a></td></tr></tbody></table><h3 id="Scala"><a href="#Scala" class="headerlink" title="Scala"></a>Scala</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/5377415/">Scala编程</a></td><td><a href="https://book.douban.com/subject/5377415/">https://book.douban.com/subject/5377415/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27591387/">Scala编程（第3版）</a></td><td><a href="https://book.douban.com/subject/27591387/">https://book.douban.com/subject/27591387/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26740545/">Scala程序设计（第2版）</a></td><td><a href="https://book.douban.com/subject/26740545/">https://book.douban.com/subject/26740545/</a></td></tr></tbody></table><h3 id="Lua"><a href="#Lua" class="headerlink" title="Lua"></a>Lua</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/3076942/">Lua程序设计（第2版</a></td><td><a href="https://book.douban.com/subject/3076942/">https://book.douban.com/subject/3076942/</a></td></tr></tbody></table><h3 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/4722707/">实战Linux Shell编程与服务器管理</a></td><td><a href="https://book.douban.com/subject/4722707/">https://book.douban.com/subject/4722707/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4935288/">Shell脚本专家指南</a></td><td><a href="https://book.douban.com/subject/4935288/">https://book.douban.com/subject/4935288/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26854226/">Linux命令行与shell脚本编程大全(第3版)</a></td><td><a href="https://book.douban.com/subject/26854226/">https://book.douban.com/subject/26854226/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26752891/">Linux Shell命令行及脚本编程实例详解</a></td><td><a href="https://book.douban.com/subject/26752891/">https://book.douban.com/subject/26752891/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25803528/">Linux系统命令及Shell脚本实践指南</a></td><td><a href="https://book.douban.com/subject/25803528/">https://book.douban.com/subject/25803528/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25886372/">Shell从入门到精通（第2版）</a></td><td><a href="https://book.douban.com/subject/25886372/">https://book.douban.com/subject/25886372/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30172987/">Linux Shell脚本攻略（第3版）</a></td><td><a href="https://book.douban.com/subject/30172987/">https://book.douban.com/subject/30172987/</a></td></tr><tr><td><a href="https://book.douban.com/subject/5988663/">Linux Shell编程从初学到精通</a></td><td><a href="https://book.douban.com/subject/5988663/">https://book.douban.com/subject/5988663/</a></td></tr></tbody></table><h3 id="汇编语言"><a href="#汇编语言" class="headerlink" title="汇编语言"></a>汇编语言</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://item.jd.com/12259774.html?dist=jd">汇编语言（第3版</a></td><td><a href="https://item.jd.com/12259774.html?dist=jd">https://item.jd.com/12259774.html?dist=jd</a></td></tr><tr><td><a href="https://book.douban.com/subject/1446250/">Professional Assembly Language（中文）</a></td><td><a href="https://book.douban.com/subject/1446250/">https://book.douban.com/subject/1446250/</a></td></tr><tr><td><a href="https://book.douban.com/subject/2039913/">Professional Assembly Language（英文）</a></td><td><a href="https://book.douban.com/subject/2039913/">https://book.douban.com/subject/2039913/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26769528/">汇编语言：基于x86处理器（第7版）</a></td><td><a href="https://book.douban.com/subject/26769528/">https://book.douban.com/subject/26769528/</a></td></tr><tr><td><a href="https://book.douban.com/subject/2250326/">Intel汇编语言程序设计</a></td><td><a href="https://book.douban.com/subject/2250326/">https://book.douban.com/subject/2250326/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1783103/">Windows环境下32位汇编语言程序设计（第2版）</a></td><td><a href="https://book.douban.com/subject/1783103/">https://book.douban.com/subject/1783103/</a></td></tr><tr><td><a href="https://book.douban.com/subject/24846626/">Windows环境下32位汇编语言程序设计（典藏版）</a></td><td><a href="https://book.douban.com/subject/24846626/">https://book.douban.com/subject/24846626/</a></td></tr></tbody></table><h3 id="Lisp"><a href="#Lisp" class="headerlink" title="Lisp"></a>Lisp</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/6859720/">实用Common Lisp编程</a></td><td><a href="https://book.douban.com/subject/6859720/">https://book.douban.com/subject/6859720/</a></td></tr></tbody></table><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/30352656/">正则指引（第2版）</a></td><td><a href="https://book.douban.com/subject/30352656/">https://book.douban.com/subject/30352656/</a></td></tr><tr><td><a href="https://book.douban.com/subject/2154713/">精通正则表达式（第3版）</a></td><td><a href="https://book.douban.com/subject/2154713/">https://book.douban.com/subject/2154713/</a></td></tr><tr><td><a href="https://book.douban.com/subject/2269648/">正则表达式必知必会</a></td><td><a href="https://book.douban.com/subject/2269648/">https://book.douban.com/subject/2269648/</a></td></tr><tr><td><a href="https://book.douban.com/subject/22601258/">学习正则表达式</a></td><td><a href="https://book.douban.com/subject/22601258/">https://book.douban.com/subject/22601258/</a></td></tr></tbody></table><h3 id="AWK"><a href="#AWK" class="headerlink" title="AWK"></a>AWK</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/1236944/">sed与awk（第3版</a></td><td><a href="https://book.douban.com/subject/1236944/">https://book.douban.com/subject/1236944/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26257265/">Effective awk Programming（英文）</a></td><td><a href="https://book.douban.com/subject/26257265/">https://book.douban.com/subject/26257265/</a></td></tr></tbody></table><h3 id="SED"><a href="#SED" class="headerlink" title="SED"></a>SED</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/1236944/">sed与awk（第3版）</a></td><td><a href="https://book.douban.com/subject/1236944/">https://book.douban.com/subject/1236944/</a></td></tr></tbody></table><h3 id="HTML-amp-CSS"><a href="#HTML-amp-CSS" class="headerlink" title="HTML &amp; CSS"></a>HTML &amp; CSS</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/2308234/">CSS权威指南（中文第3版）</a></td><td><a href="https://book.douban.com/subject/2308234/">https://book.douban.com/subject/2308234/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25786074/">HTML5权威指南</a></td><td><a href="https://book.douban.com/subject/25786074/">https://book.douban.com/subject/25786074/</a></td></tr><tr><td><a href="https://book.douban.com/subject/24708139/">HTML5+CSS3从入门到精通</a></td><td><a href="https://book.douban.com/subject/24708139/">https://book.douban.com/subject/24708139/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25878992/">HTML5与CSS3基础教程（第8版）</a></td><td><a href="https://book.douban.com/subject/25878992/">https://book.douban.com/subject/25878992/</a></td></tr><tr><td><a href="https://book.douban.com/subject/10608238/">HTML5程序设计（第2版）</a></td><td><a href="https://book.douban.com/subject/10608238/">https://book.douban.com/subject/10608238/</a></td></tr><tr><td><a href="https://book.douban.com/subject/3879846/">CSS Web设计高级教程</a></td><td><a href="https://book.douban.com/subject/3879846/">https://book.douban.com/subject/3879846/</a></td></tr></tbody></table><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h3 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/26960678/">计算机网络（第7版）</a></td><td><a href="https://book.douban.com/subject/26960678/">https://book.douban.com/subject/26960678/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26176870/">计算机网络：自顶向下方法(第6版)</a></td><td><a href="https://book.douban.com/subject/26176870/">https://book.douban.com/subject/26176870/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26420010/">精通Linux内核网络</a></td><td><a href="https://book.douban.com/subject/26420010/">https://book.douban.com/subject/26420010/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30866578/">网络工程师教程（第5版）</a></td><td><a href="https://book.douban.com/subject/30866578/">https://book.douban.com/subject/30866578/</a></td></tr></tbody></table><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/26825411/">TCP/IP详解 卷1：协议（第2版）</a></td><td><a href="https://book.douban.com/subject/26825411/">https://book.douban.com/subject/26825411/</a></td></tr><tr><td><a href="https://book.douban.com/subject/24737674/">图解TCP/IP（第5版）</a></td><td><a href="https://book.douban.com/subject/24737674/">https://book.douban.com/subject/24737674/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25911735/">TCP/IP网络编程</a></td><td><a href="https://book.douban.com/subject/25911735/">https://book.douban.com/subject/25911735/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4124130/">TCP/IP Sockets编程 : C语言实现（第2版）</a></td><td><a href="https://book.douban.com/subject/4124130/">https://book.douban.com/subject/4124130/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26220771/">TCP/IP协议族(第4版)</a></td><td><a href="https://book.douban.com/subject/26220771/">https://book.douban.com/subject/26220771/</a></td></tr><tr><td><a href="https://book.douban.com/subject/10556677/">TCP/IP入门经典（第5版）</a></td><td><a href="https://book.douban.com/subject/10556677/">https://book.douban.com/subject/10556677/</a></td></tr></tbody></table><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/10746113/">HTTP权威指南</a></td><td><a href="https://book.douban.com/subject/10746113/">https://book.douban.com/subject/10746113/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25863515/">图解HTTP</a></td><td><a href="https://book.douban.com/subject/25863515/">https://book.douban.com/subject/25863515/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25919428/">图解网络硬件</a></td><td><a href="https://book.douban.com/subject/25919428/">https://book.douban.com/subject/25919428/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27665112/">HTTP/2基础教程</a></td><td><a href="https://book.douban.com/subject/27665112/">https://book.douban.com/subject/27665112/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26869219/">HTTPS权威指南：在服务器和Web应用上部署SSL-TLS和PKI</a></td><td><a href="https://book.douban.com/subject/26869219/">https://book.douban.com/subject/26869219/</a></td></tr></tbody></table><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><h3 id="存储基础"><a href="#存储基础" class="headerlink" title="存储基础"></a>存储基础</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/26831614/">软件定义存储：原理、实践与生态</a></td><td><a href="https://book.douban.com/subject/26831614/">https://book.douban.com/subject/26831614/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25723658/">大规模分布式存储系统 : 原理解析与架构实战</a></td><td><a href="https://book.douban.com/subject/25723658/">https://book.douban.com/subject/25723658/</a></td></tr></tbody></table><h3 id="Ceph"><a href="#Ceph" class="headerlink" title="Ceph"></a>Ceph</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/27019132/">Ceph分布式存储学习指南</a></td><td><a href="https://book.douban.com/subject/27019132/">https://book.douban.com/subject/27019132/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27178824/">Ceph设计原理与实现</a></td><td><a href="https://book.douban.com/subject/27178824/">https://book.douban.com/subject/27178824/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26937692/">Ceph分布式存储实战</a></td><td><a href="https://book.douban.com/subject/26937692/">https://book.douban.com/subject/26937692/</a></td></tr></tbody></table><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a>操作系统基础</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/2185076/">计算机系统概论（第2版）</a></td><td><a href="https://book.douban.com/subject/2185076/">https://book.douban.com/subject/2185076/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26912767/">深入理解计算机系统（原书第3版）</a></td><td><a href="https://book.douban.com/subject/26912767/">https://book.douban.com/subject/26912767/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4289836/">操作系统概念（第7版）</a></td><td><a href="https://book.douban.com/subject/4289836/">https://book.douban.com/subject/4289836/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1058576/">计算机操作系统（第3版）</a></td><td><a href="https://book.douban.com/subject/1058576/">https://book.douban.com/subject/1058576/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26993995/">操作系统-精髓与设计原理（第8版）</a></td><td><a href="https://book.douban.com/subject/26993995/">https://book.douban.com/subject/26993995/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27096665/">现代操作系统（第4版）</a></td><td><a href="https://book.douban.com/subject/27096665/">https://book.douban.com/subject/27096665/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26604008/">计算机组成与设计-硬件软件接口（第5版）</a></td><td><a href="https://book.douban.com/subject/26604008/">https://book.douban.com/subject/26604008/</a></td></tr><tr><td><a href="https://book.douban.com/subject/2044818/">操作系统设计与实现(第三版，上册)</a></td><td><a href="https://book.douban.com/subject/2044818/">https://book.douban.com/subject/2044818/</a></td></tr></tbody></table><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/30359954/">鸟哥的Linux私房菜:基础学习篇(第4版)</a></td><td><a href="https://book.douban.com/subject/30359954/">https://book.douban.com/subject/30359954/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26758194/">循序渐进Linux（第2版） : 基础知识 服务器搭建 系统管理 性能调优 虚拟化与集群应用</a></td><td><a href="https://book.douban.com/subject/26758194/">https://book.douban.com/subject/26758194/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25743846/">深度探索Linux操作系统 : 系统构建和原理解析</a></td><td><a href="https://book.douban.com/subject/25743846/">https://book.douban.com/subject/25743846/</a></td></tr><tr><td><a href="https://book.douban.com/subject/3042029/">Linux系统管理技术手册（第2版）</a></td><td><a href="https://book.douban.com/subject/3042029/">https://book.douban.com/subject/3042029/</a></td></tr><tr><td><a href="https://book.douban.com/subject/7564094/">高性能Linux服务器构建实战：运维监控、性能调优与集群应用</a></td><td><a href="https://book.douban.com/subject/7564094/">https://book.douban.com/subject/7564094/</a></td></tr><tr><td><a href="https://book.douban.com/subject/2306842/">Linux安全体系分析与编程</a></td><td><a href="https://book.douban.com/subject/2306842/">https://book.douban.com/subject/2306842/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4027707/">Linux玩家技术宝典 : 你所不知道的Linux</a></td><td><a href="https://book.douban.com/subject/4027707/">https://book.douban.com/subject/4027707/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1237488/">Red Hat Linux安全与优化</a></td><td><a href="https://book.douban.com/subject/1237488/">https://book.douban.com/subject/1237488/</a></td></tr></tbody></table><h3 id="嵌入式"><a href="#嵌入式" class="headerlink" title="嵌入式"></a>嵌入式</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/3670713/">嵌入式Linux程序设计案例与实验教程</a></td><td><a href="https://book.douban.com/subject/3670713/">https://book.douban.com/subject/3670713/</a></td></tr><tr><td><a href="https://book.douban.com/subject/24522809/">构建嵌入式Linux核心软件系统实战 : 构建嵌入式Linux核心软件系统实战</a></td><td><a href="https://book.douban.com/subject/24522809/">https://book.douban.com/subject/24522809/</a></td></tr><tr><td><a href="https://book.douban.com/subject/3152027/">嵌入式Linux应用开发完全手册</a></td><td><a href="https://book.douban.com/subject/3152027/">https://book.douban.com/subject/3152027/</a></td></tr><tr><td><a href="https://book.douban.com/subject/2985887/">嵌入式Linux设备驱动开发详解</a></td><td><a href="https://book.douban.com/subject/2985887/">https://book.douban.com/subject/2985887/</a></td></tr><tr><td><a href="https://book.douban.com/subject/6533463/">深入浅出嵌入式底层软件开发</a></td><td><a href="https://book.douban.com/subject/6533463/">https://book.douban.com/subject/6533463/</a></td></tr></tbody></table><h3 id="Linux内核"><a href="#Linux内核" class="headerlink" title="Linux内核"></a>Linux内核</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/6097773/">Linux内核设计与实现（原书第3版）</a></td><td><a href="https://book.douban.com/subject/6097773/">https://book.douban.com/subject/6097773/</a></td></tr><tr><td><a href="https://book.douban.com/subject/2287506/">深入理解LINUX内核（第3版）</a></td><td><a href="https://book.douban.com/subject/2287506/">https://book.douban.com/subject/2287506/</a></td></tr><tr><td><a href="https://book.douban.com/subject/6433169/">Linux内核设计的艺术 : 图解Linux操作系统架构设计与实现原理</a></td><td><a href="https://book.douban.com/subject/6433169/">https://book.douban.com/subject/6433169/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1420480/">LINUX设备驱动程序（第3版）</a></td><td><a href="https://book.douban.com/subject/1420480/">https://book.douban.com/subject/1420480/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26600201/">Linux设备驱动开发详解 : 基于最新的Linux 4.0内核</a></td><td><a href="https://book.douban.com/subject/26600201/">https://book.douban.com/subject/26600201/</a></td></tr><tr><td><a href="https://book.douban.com/subject/5351818/">Linux设备驱动开发详解（第2版）</a></td><td><a href="https://book.douban.com/subject/5351818/">https://book.douban.com/subject/5351818/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4843567/">深入Linux内核架构</a></td><td><a href="https://book.douban.com/subject/4843567/">https://book.douban.com/subject/4843567/</a></td></tr><tr><td><a href="https://book.douban.com/subject/21332497/">Linux内核精髓 : 精通Linux内核必会的75个绝技</a></td><td><a href="https://book.douban.com/subject/21332497/">https://book.douban.com/subject/21332497/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1231236/">Linux内核完全注释（修订版）</a></td><td><a href="https://book.douban.com/subject/1231236/">https://book.douban.com/subject/1231236/</a></td></tr><tr><td><a href="https://book.douban.com/subject/10433743/">深入Linux设备驱动程序内核机制</a></td><td><a href="https://book.douban.com/subject/10433743/">https://book.douban.com/subject/10433743/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4015134/">深入理解LINUX网络技术内幕</a></td><td><a href="https://book.douban.com/subject/4015134/">https://book.douban.com/subject/4015134/</a></td></tr><tr><td><a href="https://book.douban.com/subject/6078728/">Linux驱动程序开发实例</a></td><td><a href="https://book.douban.com/subject/6078728/">https://book.douban.com/subject/6078728/</a></td></tr></tbody></table><h2 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h2><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/1838749/">Linux防火墙-(原书第3版)</a></td><td><a href="https://book.douban.com/subject/1838749/">https://book.douban.com/subject/1838749/</a></td></tr><tr><td><a href="https://book.douban.com/subject/3678862/">Linux防火墙</a></td><td><a href="https://book.douban.com/subject/3678862/">https://book.douban.com/subject/3678862/</a></td></tr></tbody></table><h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><h3 id="系统虚拟化"><a href="#系统虚拟化" class="headerlink" title="系统虚拟化"></a>系统虚拟化</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/3768550/">Xen虚拟化技术</a></td><td><a href="https://book.douban.com/subject/3768550/">https://book.douban.com/subject/3768550/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25743939/">KVM虚拟化技术 : 实战与原理解析</a></td><td><a href="https://book.douban.com/subject/25743939/">https://book.douban.com/subject/25743939/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26766965/">Linux KVM虚拟化架构实战指南</a></td><td><a href="https://book.douban.com/subject/26766965/">https://book.douban.com/subject/26766965/</a></td></tr><tr><td><a href="https://book.douban.com/subject/3619896/">系统虚拟化 : 原理与实现</a></td><td><a href="https://book.douban.com/subject/3619896/">https://book.douban.com/subject/3619896/</a></td></tr><tr><td><a href="https://book.douban.com/subject/19986436/">虚拟化技术原理与实现</a></td><td><a href="https://book.douban.com/subject/19986436/">https://book.douban.com/subject/19986436/</a></td></tr></tbody></table><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/26894736/">Docker 容器与容器云（第2版）</a></td><td><a href="https://book.douban.com/subject/26894736/">https://book.douban.com/subject/26894736/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30329430/">Docker技术入门与实战（第3版）</a></td><td><a href="https://book.douban.com/subject/30329430/">https://book.douban.com/subject/30329430/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26581184/">Docker 源码分析</a></td><td><a href="https://book.douban.com/subject/26581184/">https://book.douban.com/subject/26581184/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27013734/">Docker开发指南</a></td><td><a href="https://book.douban.com/subject/27013734/">https://book.douban.com/subject/27013734/</a></td></tr></tbody></table><h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/33444476/">Kubernetes权威指南：从Docker到Kubernetes实践全接触（第4版）</a></td><td><a href="https://book.douban.com/subject/33444476/">https://book.douban.com/subject/33444476/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27088186/">开源容器云OpenShift构建基于Kubernetes的企业应用云平台</a></td><td><a href="https://book.douban.com/subject/27088186/">https://book.douban.com/subject/27088186/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30333237/">基于Kubernetes的容器云平台实战</a></td><td><a href="https://book.douban.com/subject/30333237/">https://book.douban.com/subject/30333237/</a></td></tr></tbody></table><h3 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/30290516/">Serverless架构：无服务器应用与AWS Lambda</a></td><td><a href="https://book.douban.com/subject/30290516/">https://book.douban.com/subject/30290516/</a></td></tr></tbody></table><h3 id="云计算基础"><a href="#云计算基础" class="headerlink" title="云计算基础"></a>云计算基础</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/26602591/">数据中心虚拟化技术权威指南</a></td><td><a href="https://book.douban.com/subject/26602591/">https://book.douban.com/subject/26602591/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4212925/">云计算的关键技术与应用实例</a></td><td><a href="https://book.douban.com/subject/4212925/">https://book.douban.com/subject/4212925/</a></td></tr><tr><td><a href="https://book.douban.com/subject/10803946/">云计算与数据中心自动化</a></td><td><a href="https://book.douban.com/subject/10803946/">https://book.douban.com/subject/10803946/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26425400/">云计算 : 概念、技术与架构</a></td><td><a href="https://book.douban.com/subject/26425400/">https://book.douban.com/subject/26425400/</a></td></tr></tbody></table><p>##微服务</p><h3 id="微服务基础"><a href="#微服务基础" class="headerlink" title="微服务基础"></a>微服务基础</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/26772677/">微服务设计</a></td><td><a href="https://book.douban.com/subject/26772677/">https://book.douban.com/subject/26772677/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26693152/">微服务架构与实践（第1版）</a></td><td><a href="https://book.douban.com/subject/26693152/">https://book.douban.com/subject/26693152/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30278673/">Spring Cloud与Docker微服务架构实战</a></td><td><a href="https://book.douban.com/subject/30278673/">https://book.douban.com/subject/30278673/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27081188/">架构解密：从分布式到微服务</a></td><td><a href="https://book.douban.com/subject/27081188/">https://book.douban.com/subject/27081188/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27025912/">Spring Cloud微服务实战</a></td><td><a href="https://book.douban.com/subject/27025912/">https://book.douban.com/subject/27025912/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26106868/">Java RESTful Web Service实战</a></td><td><a href="https://book.douban.com/subject/26106868/">https://book.douban.com/subject/26106868/</a></td></tr></tbody></table><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/26745255/">深入理解Nginx（第2版） : 模块开发与架构解析</a></td><td><a href="https://book.douban.com/subject/26745255/">https://book.douban.com/subject/26745255/</a></td></tr><tr><td><a href="https://book.douban.com/subject/22793675/">深入理解Nginx : 模块开发与架构解析</a></td><td><a href="https://book.douban.com/subject/22793675/">https://book.douban.com/subject/22793675/</a></td></tr><tr><td><a href="https://book.douban.com/subject/10746087/">决战Nginx系统卷 : 高性能Web服务器详解与运维</a></td><td><a href="https://book.douban.com/subject/10746087/">https://book.douban.com/subject/10746087/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25773187/">Nginx高性能Web服务器详解</a></td><td><a href="https://book.douban.com/subject/25773187/">https://book.douban.com/subject/25773187/</a></td></tr></tbody></table><h3 id="服务网格"><a href="#服务网格" class="headerlink" title="服务网格"></a>服务网格</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/34438220/">云原生服务网格Istio：原理、实践、架构与源码解析</a></td><td><a href="https://book.douban.com/subject/34438220/">https://book.douban.com/subject/34438220/</a></td></tr></tbody></table><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/30221096/">Apache Kafka实战</a></td><td><a href="https://book.douban.com/subject/30221096/">https://book.douban.com/subject/30221096/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27038473/">Apache Kafka源码剖析</a></td><td><a href="https://book.douban.com/subject/27038473/">https://book.douban.com/subject/27038473/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27665114/">Kafka权威指南</a></td><td><a href="https://book.douban.com/subject/27665114/">https://book.douban.com/subject/27665114/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30128444/">Kafka源码解析与实战</a></td><td><a href="https://book.douban.com/subject/30128444/">https://book.douban.com/subject/30128444/</a></td></tr><tr><td><a href="https://book.douban.com/subject/27179953/">Kafka技术内幕</a></td><td><a href="https://book.douban.com/subject/27179953/">https://book.douban.com/subject/27179953/</a></td></tr><tr><td><a href="https://book.douban.com/subject/30437872/">深入理解Kafka：核心设计与实践原理</a></td><td><a href="https://book.douban.com/subject/30437872/">https://book.douban.com/subject/30437872/</a></td></tr></tbody></table><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/26649178/">RabbitMQ实战 : 高效部署分布式消息队列</a></td><td><a href="https://book.douban.com/subject/26649178/">https://book.douban.com/subject/26649178/</a></td></tr></tbody></table><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/2022427/">精通SQL结构化查询语言详解</a></td><td><a href="https://book.douban.com/subject/2022427/">https://book.douban.com/subject/2022427/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26579980/">SQL学习指南（第2版）</a></td><td><a href="https://book.douban.com/subject/26579980/">https://book.douban.com/subject/26579980/</a></td></tr><tr><td><a href="https://book.douban.com/subject/3691315/">SQL宝典</a></td><td><a href="https://book.douban.com/subject/3691315/">https://book.douban.com/subject/3691315/</a></td></tr></tbody></table><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/3354490/">MySQL必知必会</a></td><td><a href="https://book.douban.com/subject/3354490/">https://book.douban.com/subject/3354490/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26591051/">MySQL排错指南</a></td><td><a href="https://book.douban.com/subject/26591051/">https://book.douban.com/subject/26591051/</a></td></tr><tr><td><a href="https://book.douban.com/subject/23008813/">高性能MySQL（第3版）</a></td><td><a href="https://book.douban.com/subject/23008813/">https://book.douban.com/subject/23008813/</a></td></tr><tr><td><a href="https://book.douban.com/subject/5373022/">MySQL技术内幕InnoDB存储引擎（第1版）</a></td><td><a href="https://book.douban.com/subject/5373022/">https://book.douban.com/subject/5373022/</a></td></tr><tr><td><a href="https://book.douban.com/subject/6524185/">MySQL技术内幕（第4版）</a></td><td><a href="https://book.douban.com/subject/6524185/">https://book.douban.com/subject/6524185/</a></td></tr><tr><td><a href="https://book.douban.com/subject/4188364/">深入理解MySQL</a></td><td><a href="https://book.douban.com/subject/4188364/">https://book.douban.com/subject/4188364/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26340413/">MariaDB原理与实现</a></td><td><a href="https://book.douban.com/subject/26340413/">https://book.douban.com/subject/26340413/</a></td></tr><tr><td><a href="https://book.douban.com/subject/26630834/">高可用MySQL（第2版）</a></td><td><a href="https://book.douban.com/subject/26630834/">https://book.douban.com/subject/26630834/</a></td></tr><tr><td><a href="https://book.douban.com/subject/25872763/">MySQL内核：InnoDB存储引擎 卷1</a></td><td><a href="https://book.douban.com/subject/25872763/">https://book.douban.com/subject/25872763/</a></td></tr></tbody></table><h3 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/2316500/">Oracle 10g数据库管理应用与开发标准教程</a></td><td><a href="https://book.douban.com/subject/2316500/">https://book.douban.com/subject/2316500/</a></td></tr><tr><td><a href="https://book.douban.com/subject/1503909/">Oracle高效设计</a></td><td><a href="https://book.douban.com/subject/1503909/">https://book.douban.com/subject/1503909/</a></td></tr></tbody></table><h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/25900156/">Redis设计与实现</a></td><td><a href="https://book.douban.com/subject/25900156/">https://book.douban.com/subject/25900156/</a></td></tr></tbody></table><h3 id="Mongo"><a href="#Mongo" class="headerlink" title="Mongo"></a>Mongo</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href="https://book.douban.com/subject/26269829/">MongoDB大数据处理权威指南（第2版）</a></td><td><a href="https://book.douban.com/subject/26269829/">https://book.douban.com/subject/26269829/</a></td></tr></tbody></table><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><h3 id="人工智能基础"><a href="#人工智能基础" class="headerlink" title="人工智能基础"></a>人工智能基础</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h3 id="TensorFlow"><a href="#TensorFlow" class="headerlink" title="TensorFlow"></a>TensorFlow</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><h3 id="分布式基础"><a href="#分布式基础" class="headerlink" title="分布式基础"></a>分布式基础</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h3 id="Etcd"><a href="#Etcd" class="headerlink" title="Etcd"></a>Etcd</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h3 id="Zookpeer"><a href="#Zookpeer" class="headerlink" title="Zookpeer"></a>Zookpeer</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h2 id="运维"><a href="#运维" class="headerlink" title="运维"></a>运维</h2><h3 id="运维基础"><a href="#运维基础" class="headerlink" title="运维基础"></a>运维基础</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h3 id="监控告警"><a href="#监控告警" class="headerlink" title="监控告警"></a>监控告警</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="测试基础"><a href="#测试基础" class="headerlink" title="测试基础"></a>测试基础</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h3 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h2 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h2><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h2 id="其它资料"><a href="#其它资料" class="headerlink" title="其它资料"></a>其它资料</h2><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h2 id="按标签推荐系列"><a href="#按标签推荐系列" class="headerlink" title="按标签推荐系列"></a>按标签推荐系列</h2><h3 id="微服务系列推荐"><a href="#微服务系列推荐" class="headerlink" title="微服务系列推荐"></a>微服务系列推荐</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table><h3 id="云原生系列推荐"><a href="#云原生系列推荐" class="headerlink" title="云原生系列推荐"></a>云原生系列推荐</h3><table><thead><tr><th>书名</th><th>豆瓣读书链接</th></tr></thead><tbody><tr><td><a href=""></a></td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu 优化脚本</title>
    <link href="/2022/07/28/linux/Ubuntu%20%E4%BC%98%E5%8C%96%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/07/28/linux/Ubuntu%20%E4%BC%98%E5%8C%96%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-优化脚本"><a href="#Ubuntu-优化脚本" class="headerlink" title="Ubuntu 优化脚本"></a>Ubuntu 优化脚本</h1><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/sh</span>  . /lib/lsb/init-functionsexport LANG=zh_CN.UTF-8  <span class="hljs-meta">#</span><span class="bash">一级菜单</span>menu1()&#123;        clear        cat &lt;&lt; EOF----------------------------------------|****   欢迎使用cetnos7.x优化脚本    ****||****                                ****|----------------------------------------1. 一键优化2. 自定义优化3. 退出EOF        read -p &quot;please enter your choice[1-3]:&quot; num1&#125;  <span class="hljs-meta">#</span><span class="bash">二级菜单</span>menu2()&#123; clear cat &lt;&lt; EOF----------------------------------------|****Please Enter Your Choice:[0-13]****|----------------------------------------1. 修改字符集2. 关闭selinux3. 关闭firewalld4. 精简开机启动5. 修改文件描述符6. 安装常用工具及修改yum源7. 优化系统内核8. 加快ssh登录速度9. 禁用ctrl+alt+del重启10.设置时间同步11.history优化12.返回上级菜单13.退出EOF read -p &quot;please enter your choice[1-13]:&quot; num2  &#125;  <span class="hljs-meta">#</span><span class="bash">1.修改字符集</span>localeset()&#123; echo &quot;========================修改字符集=========================&quot; cat &gt; /etc/locale.conf &lt;&lt; EOFLANG=&quot;zh_CN.UTF-8&quot;<span class="hljs-meta">#</span><span class="bash">LANG=<span class="hljs-string">&quot;en_US.UTF-8&quot;</span></span>SYSFONT=&quot;latarcyrheb-sun16&quot;EOF source /etc/locale.conf echo &quot;#cat /etc/locale.conf&quot; cat /etc/locale.conf action &quot;完成修改字符集&quot; /bin/true echo &quot;===========================================================&quot; sleep 2&#125;  <span class="hljs-meta">#</span><span class="bash">2.关闭selinux</span>selinuxset()&#123; selinux_status=`grep &quot;SELINUX=disabled&quot; /etc/sysconfig/selinux | wc -l` echo &quot;========================禁用SELINUX========================&quot; if [ $selinux_status -eq 0 ];then  sed  -i &quot;s#SELINUX=enforcing#SELINUX=disabled#g&quot; /etc/sysconfig/selinux  setenforce 0  echo &#x27;#grep SELINUX=disabled /etc/sysconfig/selinux&#x27;  grep SELINUX=disabled /etc/sysconfig/selinux  echo &#x27;#getenforce&#x27;  getenforce else  echo &#x27;SELINUX已处于关闭状态&#x27;  echo &#x27;#grep SELINUX=disabled /etc/sysconfig/selinux&#x27;                grep SELINUX=disabled /etc/sysconfig/selinux                echo &#x27;#getenforce&#x27;                getenforce fi  action &quot;完成禁用SELINUX&quot; /bin/true echo &quot;===========================================================&quot; sleep 2&#125;  <span class="hljs-meta">#</span><span class="bash">3.关闭firewalld</span>firewalldset()&#123; echo &quot;=======================禁用firewalld========================&quot; systemctl stop firewalld.service &amp;&gt; /dev/null echo &#x27;#firewall-cmd  --state&#x27; firewall-cmd  --state systemctl disable firewalld.service &amp;&gt; /dev/null echo &#x27;#systemctl list-unit-files | grep firewalld&#x27; systemctl list-unit-files | grep firewalld action &quot;完成禁用firewalld，生产环境下建议启用！&quot; /bin/true echo &quot;===========================================================&quot; sleep 5&#125;  <span class="hljs-meta">#</span><span class="bash">4.精简开机启动</span>chkset()&#123; echo &quot;=======================精简开机启动========================&quot; systemctl disable auditd.service systemctl disable postfix.service systemctl disable dbus-org.freedesktop.NetworkManager.service echo &#x27;#systemctl list-unit-files | grep -E &quot;auditd|postfix|dbus-org\.freedesktop\.NetworkManager&quot;&#x27; systemctl list-unit-files | grep -E &quot;auditd|postfix|dbus-org\.freedesktop\.NetworkManager&quot; action &quot;完成精简开机启动&quot; /bin/true echo &quot;===========================================================&quot; sleep 2&#125;  <span class="hljs-meta">#</span><span class="bash">5.修改文件描述符</span>limitset()&#123; echo &quot;======================修改文件描述符=======================&quot; echo &#x27;* - nofile 65535&#x27;&gt;/etc/security/limits.conf ulimit -SHn 65535 echo &quot;#cat /etc/security/limits.conf&quot; cat /etc/security/limits.conf echo &quot;#ulimit -Sn ; ulimit -Hn&quot; ulimit -Sn ; ulimit -Hn action &quot;完成修改文件描述符&quot; /bin/true echo &quot;===========================================================&quot; sleep 2&#125;  <span class="hljs-meta">#</span><span class="bash">6.安装常用工具及修改yum源</span>yumset()&#123; echo &quot;=================安装常用工具及修改yum源===================&quot; yum install wget -y &amp;&gt; /dev/null if [ $? -eq 0 ];then  cd /etc/yum.repos.d/  \cp CentOS-Base.repo CentOS-Base.repo.$(date +%F)  ping -c 1 mirrors.aliyun.com &amp;&gt; /dev/null  if [ $? -eq 0 ];then  wget -O /etc/yum.repos.d/CentOS-Base.repo http://mirrors.163.com/.help/CentOS7-Base-163.repo &amp;&gt; /dev/null  yum clean all &amp;&gt; /dev/null  yum makecache &amp;&gt; /dev/null  else   echo &quot;无法连接网络&quot;       exit $?    fi else  echo &quot;wget安装失败&quot;  exit $? fi yum -y install ntpdate lsof net-tools telnet vim lrzsz tree nmap nc sysstat &amp;&gt; /dev/null action &quot;完成安装常用工具及修改yum源&quot; /bin/true echo &quot;===========================================================&quot; sleep 2&#125;  <span class="hljs-meta">#</span><span class="bash">7. 优化系统内核</span>kernelset()&#123; echo &quot;======================优化系统内核=========================&quot; chk_nf=`cat /etc/sysctl.conf | grep conntrack |wc -l` if [ $chk_nf -eq 0 ];then  cat &gt;&gt;/etc/sysctl.conf&lt;&lt;EOFnet.ipv4.tcp_fin_timeout = 2net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_syncookies = 1net.ipv4.tcp_keepalive_time = 600net.ipv4.ip_local_port_range = 4000 65000net.ipv4.tcp_max_syn_backlog = 16384net.ipv4.tcp_max_tw_buckets = 36000net.ipv4.route.gc_timeout = 100net.ipv4.tcp_syn_retries = 1net.ipv4.tcp_synack_retries = 0net.core.somaxconn = 16384net.core.netdev_max_backlog = 16384net.ipv4.tcp_max_orphans = 16384net.netfilter.nf_conntrack_max = 25000000net.netfilter.nf_conntrack_tcp_timeout_established = 180net.netfilter.nf_conntrack_tcp_timeout_time_wait = 120net.netfilter.nf_conntrack_tcp_timeout_close_wait = 60net.netfilter.nf_conntrack_tcp_timeout_fin_wait = 120EOF sysctl -p else  echo &quot;优化项已存在。&quot; fi action &quot;内核调优完成&quot; /bin/true echo &quot;===========================================================&quot; sleep 2&#125;  <span class="hljs-meta">#</span><span class="bash">8.加快ssh登录速度</span>sshset()&#123; echo &quot;======================加快ssh登录速度======================&quot; sed -i &#x27;s#^GSSAPIAuthentication yes$#GSSAPIAuthentication no#g&#x27; /etc/ssh/sshd_config sed -i &#x27;s/#UseDNS yes/UseDNS no/g&#x27; /etc/ssh/sshd_config systemctl restart sshd.service echo &quot;#grep GSSAPIAuthentication /etc/ssh/sshd_config&quot; grep GSSAPIAuthentication /etc/ssh/sshd_config echo &quot;#grep UseDNS /etc/ssh/sshd_config&quot; grep UseDNS /etc/ssh/sshd_config action &quot;完成加快ssh登录速度&quot; /bin/true echo &quot;===========================================================&quot; sleep 2&#125;  <span class="hljs-meta">#</span><span class="bash">9. 禁用ctrl+alt+del重启</span>restartset()&#123; echo &quot;===================禁用ctrl+alt+del重启====================&quot; rm -rf /usr/lib/systemd/system/ctrl-alt-del.target action &quot;完成禁用ctrl+alt+del重启&quot; /bin/true echo &quot;===========================================================&quot; sleep 2&#125;  <span class="hljs-meta">#</span><span class="bash">10. 设置时间同步</span>ntpdateset()&#123; echo &quot;=======================设置时间同步========================&quot; yum -y install ntpdate &amp;&gt; /dev/null if [ $? -eq 0 ];then  /usr/sbin/ntpdate time.windows.com  echo &quot;*/5 * * * * /usr/sbin/ntpdate ntp.aliyun.com &amp;&gt;/dev/null&quot; &gt;&gt; /var/spool/cron/root else  echo &quot;ntpdate安装失败&quot;  exit $? fi action &quot;完成设置时间同步&quot; /bin/true echo &quot;===========================================================&quot; sleep 2&#125;  <span class="hljs-meta">#</span><span class="bash">11. <span class="hljs-built_in">history</span>优化</span>historyset()&#123; echo &quot;========================history优化========================&quot; chk_his=`cat /etc/profile | grep HISTTIMEFORMAT |wc -l` if [ $chk_his -eq 0 ];then  cat &gt;&gt; /etc/profile &lt;&lt;&#x27;EOF&#x27;<span class="hljs-meta">#</span><span class="bash">设置<span class="hljs-built_in">history</span>格式</span>export HISTTIMEFORMAT=&quot;[%Y-%m-%d %H:%M:%S] [`whoami`] [`who am i|awk &#x27;&#123;print $NF&#125;&#x27;|sed -r &#x27;s#[()]##g&#x27;`]: &quot;<span class="hljs-meta">#</span><span class="bash">记录shell执行的每一条命令</span>export PROMPT_COMMAND=&#x27;\if [ -z &quot;$OLD_PWD&quot; ];then    export OLD_PWD=$PWD;fi;if [ ! -z &quot;$LAST_CMD&quot; ] &amp;&amp; [ &quot;$(history 1)&quot; != &quot;$LAST_CMD&quot; ]; then    logger -t `whoami`_shell_dir &quot;[$OLD_PWD]$(history 1)&quot;;fi;export LAST_CMD=&quot;$(history 1)&quot;;export OLD_PWD=$PWD;&#x27;EOF  source /etc/profile else  echo &quot;优化项已存在。&quot; fi action &quot;完成history优化&quot; /bin/true echo &quot;===========================================================&quot; sleep 2&#125;  <span class="hljs-meta">#</span><span class="bash">控制函数</span>main()&#123; menu1 case $num1 in  1)   localeset   selinuxset   firewalldset   chkset   limitset   yumset   kernelset   sshset   restartset   ntpdateset   historyset   ;;  2)   menu2   case $num2 in                  1)                    localeset                    ;;                  2)                    selinuxset                    ;;                  3)                    firewalldset                    ;;                  4)                    chkset                    ;;                  5)                    limitset                    ;;                  6)                        yumset                    ;;                  7)                    kernelset                    ;;                  8)                    sshset                    ;;                  9)                    restartset                    ;;                  10)                    ntpdateset                    ;;                  11)                    historyset                    ;;                  12)                    main                    ;;                  13)                    exit                    ;;                   *)                    echo &#x27;Please select a number from [1-13].&#x27;                    ;;                    esac                    ;;  3)   exit   ;;  *)   echo &#x27;Err:Please select a number from [1-3].&#x27;   sleep 3   main   ;; esac&#125;main $*</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 运维命令</title>
    <link href="/2022/07/13/linux/tmp/%E8%BF%90%E7%BB%B4%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/13/linux/tmp/%E8%BF%90%E7%BB%B4%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-运维命令"><a href="#Linux-运维命令" class="headerlink" title="Linux 运维命令"></a>Linux 运维命令</h1><h3 id="磁盘挂载"><a href="#磁盘挂载" class="headerlink" title="磁盘挂载"></a><a href="https://segmentfault.com/a/1190000017213655">磁盘挂载</a></h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 比如要扩充 /var</span><span class="hljs-meta">#</span><span class="bash"> 在创建好文件系统后 新建临时挂载点 storage</span>mkdir /storage<span class="hljs-meta">#</span><span class="bash"> 将/dev/sdb1挂载到/storage下</span>mount /dev/sdb1  /storage<span class="hljs-meta">#</span><span class="bash"> 拷贝/var下的所有内容到新的硬盘</span>cp -pdr /var /storage<span class="hljs-meta">#</span><span class="bash"> 或在/var 目录下执行：find . -depth -<span class="hljs-built_in">print</span> | cpio - pldvm /temp</span><span class="hljs-meta">#</span><span class="bash"> 删除当前/var目录下的内容</span>rm -rf /var/*<span class="hljs-meta">#</span><span class="bash"> 重新挂载硬盘到/var目录</span>umount /dev/sdb1mount /dev/sdb1 /var<span class="hljs-meta">#</span><span class="bash"> 过程中若提示磁盘忙，使用fuser找出将正在使用磁盘的程序并结束掉；</span>fuser -m -v /varfuser -m -v -i -k /var</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s question</title>
    <link href="/2022/07/13/cloud/K8S/question/k8s%20question/"/>
    <url>/2022/07/13/cloud/K8S/question/k8s%20question/</url>
    
    <content type="html"><![CDATA[<h1 id="K8s-question"><a href="#K8s-question" class="headerlink" title="K8s question"></a>K8s question</h1><h2 id="1-Init"><a href="#1-Init" class="headerlink" title="1. Init"></a>1. Init</h2><h3 id="Unable-to-connect-to-the-server-x509-certificate-signed-by-unknown-authority"><a href="#Unable-to-connect-to-the-server-x509-certificate-signed-by-unknown-authority" class="headerlink" title="Unable to connect to the server: x509: certificate signed by unknown authority"></a>Unable to connect to the server: x509: certificate signed by unknown authority</h3><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><p>删除集群然后重新创建，这个目录还是存在的。$HOME/.kube</p><h4 id="处理"><a href="#处理" class="headerlink" title="处理"></a>处理</h4><pre><code class="hljs sh">rm -rf <span class="hljs-variable">$HOME</span>/.kubemkdir -p <span class="hljs-variable">$HOME</span>/.kubesudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/configsudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config</code></pre><h3 id="The-connection-to-the-server…-6443-was-refused-did-you-specify-the-right-host-or-port"><a href="#The-connection-to-the-server…-6443-was-refused-did-you-specify-the-right-host-or-port" class="headerlink" title="The connection to the server….:6443 was refused - did you specify the right host or port?"></a>The connection to the server….:6443 was refused - did you specify the right host or port?</h3><h4 id="原因-1"><a href="#原因-1" class="headerlink" title="原因"></a>原因</h4><p> 在不关闭kubernets相关服务的情况下，对kubernets的master节点进行重启。（模拟服务器的异常掉电）</p><h4 id="处理-1"><a href="#处理-1" class="headerlink" title="处理"></a>处理</h4><p>env | grep -i kub<br>systemctl status docker.service<br>systemctl status kubelet.service<br>netstat -pnlt | grep 6443<br>systemctl status firewalld.service</p><p>journalctl -xeu kubelet<br># docker load -i kube-apiserver-amd64_v1.9.0.tar<br>systemctl restart docker.service<br>systemctl restart kubelet.service<br>kubectl get nodes</p><h3 id="Unable-to-connect-to-the-server-x509-certificate-signed-by-unknown-authority-possibly-because-of-“crypto-rsa-verification-error”-while-trying-to-verify-candidate-authority-certificate-“kubernetes”"><a href="#Unable-to-connect-to-the-server-x509-certificate-signed-by-unknown-authority-possibly-because-of-“crypto-rsa-verification-error”-while-trying-to-verify-candidate-authority-certificate-“kubernetes”" class="headerlink" title="Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of “crypto/rsa: verification error” while trying to verify candidate authority certificate “kubernetes”)"></a>Unable to connect to the server: x509: certificate signed by unknown authority (possibly because of “crypto/rsa: verification error” while trying to verify candidate authority certificate “kubernetes”)</h3><pre><code class="hljs sh">rm -rf <span class="hljs-variable">$HOME</span>/.kubemkdir -p <span class="hljs-variable">$HOME</span>/.kube sudo cp -i /etc/kubernetes/admin.conf <span class="hljs-variable">$HOME</span>/.kube/config sudo chown $(id -u):$(id -g) <span class="hljs-variable">$HOME</span>/.kube/config</code></pre>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes, bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pod 生命周期和探针</title>
    <link href="/2022/07/13/cloud/mage/2.kubernetes/Day3%EF%BC%9APod%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8E%A2%E9%92%88/"/>
    <url>/2022/07/13/cloud/mage/2.kubernetes/Day3%EF%BC%9APod%20%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%8E%A2%E9%92%88/</url>
    
    <content type="html"><![CDATA[<h1 id="Pod-生命周期和探针"><a href="#Pod-生命周期和探针" class="headerlink" title="Pod 生命周期和探针"></a>Pod 生命周期和探针</h1><h2 id="1-Pod-的状态和探针"><a href="#1-Pod-的状态和探针" class="headerlink" title="1. Pod 的状态和探针"></a><a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/">1. Pod 的状态和探针</a></h2><h3 id="1-1-Pod-状态"><a href="#1-1-Pod-状态" class="headerlink" title="1.1 Pod 状态"></a>1.1 Pod 状态</h3><ul><li><p>第⼀阶段：</p><ul><li><p>Pending:</p><p>#正在创建Pod但是Pod中的容器还没有全部被创建完成=[处于此状态的Pod应该检查Pod依赖的存储是否有权限挂载、镜像是否可以下载、调度是否正常等。</p></li><li><p>Failed</p><p>#Pod中有容器启动失败⽽导致pod⼯作异常。</p></li><li><p>Unknown</p><p>#由于某种原因⽆法获得pod的当前状态，通常是由于与pod所在的node节点通信错误。</p></li><li><p>Succeeded</p><p>#Pod中的所有容器都被成功终⽌即pod⾥所有的containers均已terminated。</p></li></ul></li><li><p>第⼆阶段：</p><ul><li><p>Unschedulable：</p><p>#Pod不能被调度，kube-scheduler没有匹配到合适的node节点</p></li><li><p>PodScheduled</p><p>#pod正处于调度中，在kube-scheduler刚开始调度的时候，还没有将pod分配到指定的node，在筛选出合适的节点后就会更新etcd数据，将pod分配到指定的node</p></li><li><p>Initialized</p><p>#所有pod中的初始化容器已经完成了</p></li><li><p>ImagePullBackOff：</p><p>#Pod所在的node节点下载镜像失败</p></li><li><p>Running</p><p>#Pod内部的容器已经被创建并且启动。</p></li><li><p>Ready<br>#表示pod中的容器已经可以提供访问服务</p></li></ul></li></ul><pre><code class="hljs json">Error: #pod 启动过程中发⽣错误NodeLost: #Pod 所在节点失联Unkown: #Pod 所在节点失联或其它未知异常Waiting: #Pod 等待启动Pending: #Pod 等待被调度Terminating: #Pod 正在被销毁CrashLoopBackOff：#pod，但是kubelet正在将它重启InvalidImageName：#node节点⽆法解析镜像名称导致的镜像⽆法下载ImageInspectError：#⽆法校验镜像，镜像不完整导致ErrImageNeverPull：#策略禁⽌拉取镜像，镜像中⼼权限是私有等ImagePullBackOff：#镜像拉取失败，但是正在重新拉取RegistryUnavailable：#镜像服务器不可⽤，⽹络原因或harbor宕机ErrImagePull：#镜像拉取出错，超时或下载被强制终⽌CreateContainerConfigError：#不能创建kubelet使⽤的容器配置CreateContainerError：#创建容器失败PreStartContainer： #执⾏preStart hook报错，Pod hook(钩⼦)是由 Kubernetes 管理的 kubelet 发起的，当容器中的进程启动前或者容器中的进程终⽌之前运⾏，⽐如容器创建完成后⾥⾯的服务启动之前可以检查⼀下依赖的其它服务是否启动，或者容器退出之前可以把容器中的服务先通过命令停⽌。PostStartHookError：#执⾏ postStart hook 报错RunContainerError：#pod运⾏失败，容器中没有初始化PID为1的守护进程等ContainersNotInitialized：#pod没有初始化完毕ContainersNotReady：#pod没有准备完毕ContainerCreating：#pod正在创建中PodInitializing：#pod正在初始化中DockerDaemonNotReady：#node节点decker服务没有启动NetworkPluginNotReady：#⽹络插件还没有完全启动</code></pre><h3 id="1-2-Pod-调度过程"><a href="#1-2-Pod-调度过程" class="headerlink" title="1.2 Pod 调度过程"></a>1.2 Pod 调度过程</h3><h3 id="1-3-Pod-探针"><a href="#1-3-Pod-探针" class="headerlink" title="1.3 Pod 探针"></a><a href="https://kubernetes.io/zh/docs/concepts/workloads/pods/pod-lifecycle/%23%E5%AE%B9%E5%99%A8%E6%8E%A2%E9%92%88">1.3 Pod 探针</a></h3><h4 id="1-3-1-探针简介"><a href="#1-3-1-探针简介" class="headerlink" title="1.3.1 探针简介"></a>1.3.1 探针简介</h4><ul><li><p>探针 是由 kubelet 对容器执⾏的定期诊断，以保证Pod的状态始终处于运⾏状态，要执⾏诊断，kubelet 调⽤由容器实现的Handler(处理程序)，有三种类型的处理程序：</p><pre><code class="hljs json">ExecAction#在容器内执⾏指定命令，如果命令退出时返回码为0则认为诊断成功。TCPSocketAction#对指定端⼝上的容器的IP地址进⾏TCP检查，如果端⼝打开，则诊断被认为是成功的。HTTPGetAction#对指定的端⼝和路径上的容器的IP地址执⾏HTTPGet请求，如果响应的状态码⼤于等于200且⼩于 400，则诊断被认为是成功的。</code></pre></li><li><p>每次探测都将获得以下三种结果之⼀：</p><pre><code class="hljs json">成功：容器通过了诊断。失败：容器未通过诊断。未知：诊断失败，因此不会采取任何⾏动。</code></pre></li></ul><h4 id="1-3-2-配置探针"><a href="#1-3-2-配置探针" class="headerlink" title="1.3.2 配置探针"></a>1.3.2 配置探针</h4><blockquote><p>基于探针实现对Pod的状态检测</p></blockquote><h4 id="1-3-2-1-探针类型"><a href="#1-3-2-1-探针类型" class="headerlink" title="1.3.2.1 探针类型"></a>1.3.2.1 探针类型</h4><ul><li>livenessProbe<br>#存活探针，检测容器容器是否正在运⾏，如果存活探测失败，则kubelet会杀死容器，并且容器将受到其重启策略的影响，如果容器不提供存活探针，则默认状态为 Success，livenessProbe⽤于控制是否重启pod。</li><li>readinessProbe<br>#就绪探针，如果就绪探测失败，端点控制器将从与Pod匹配的所有Service的端点中删除该Pod的IP地址，初始延迟之前的就绪状态默认为Failure(失败)，如果容器不提供就绪探针，则默认状态为 Success，readinessProbe⽤于控制pod是否添加⾄service。</li></ul><h4 id="1-3-2-2-探针配置"><a href="#1-3-2-2-探针配置" class="headerlink" title="1.3.2.2 探针配置"></a><a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/">1.3.2.2 探针配置</a></h4><ul><li><p>探针有很多配置字段，可以使⽤这些字段精确的控制存活和就绪检测的⾏为：</p><pre><code class="hljs json">initialDelaySeconds: 120#初始化延迟时间，告诉kubelet在执⾏第⼀次探测前应该等待多少秒，默认是0秒，最⼩值是0periodSeconds: 60#探测周期间隔时间，指定了kubelet应该每多少秒秒执⾏⼀次存活探测，默认是 10 秒。最⼩值是 1timeoutSeconds: 5#单次探测超时时间，探测的超时后等待多少秒，默认值是1秒，最⼩值是1。successThreshold: 1#从失败转为成功的重试次数，探测器在失败后，被视为成功的最⼩连续成功数，默认值是1，存活探测的这个值必须是1，最⼩值是 1。failureThreshold： 3#从成功转为失败的重试次数，当Pod启动了并且探测到失败，Kubernetes的重试次数，存活探测情况下的放弃就意味着重新启动容器，就绪探测情况下的放弃Pod 会被打上未就绪的标签，默认值是3，最⼩值是1。</code></pre></li><li><p>HTTP 探测器可以在 httpGet 上配置额外的字段：</p><pre><code class="hljs json">host:#连接使⽤的主机名，默认是Pod的 IP，也可以在HTTP头中设置 “Host” 来代替。scheme: http#⽤于设置连接主机的⽅式（HTTP 还是 HTTPS），默认是 HTTP。path: /monitor/index.html#访问 HTTP 服务的路径。httpHeaders:#请求中⾃定义的 HTTP 头,HTTP 头字段允许重复。port: 80#访问容器的端⼝号或者端⼝名，如果数字必须在 1 ～ 65535 之间。</code></pre></li></ul><h4 id="1-3-2-3-HTTP探针示例"><a href="#1-3-2-3-HTTP探针示例" class="headerlink" title="1.3.2.3 HTTP探针示例"></a>1.3.2.3 HTTP探针示例</h4><pre><code class="hljs yaml"><span class="hljs-comment"># cat nginx.yaml</span><span class="hljs-comment">#apiVersion: extensions/v1beta1</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>  <span class="hljs-attr">selector:</span><span class="hljs-attr">matchLabels:</span> <span class="hljs-comment">#rs or deployment</span>  <span class="hljs-attr">app:</span> <span class="hljs-string">ng-deploy-80</span><span class="hljs-comment">#matchExpressions:</span><span class="hljs-comment"># - &#123;key: app, operator: In, values: [ng-deploy-80,ng-rs-81]&#125;</span>  <span class="hljs-attr">template:</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">labels:</span><span class="hljs-attr">app:</span> <span class="hljs-string">ng-deploy-80</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ng-deploy-80</span><span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.5</span><span class="hljs-attr">ports:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><span class="hljs-comment">#readinessProbe:</span><span class="hljs-attr">livenessProbe:</span>  <span class="hljs-attr">httpGet:</span><span class="hljs-comment">#path: /monitor/monitor.html</span><span class="hljs-attr">path:</span> <span class="hljs-string">/index.html</span><span class="hljs-attr">port:</span> <span class="hljs-number">80</span><span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span><span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">3</span><span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span><span class="hljs-attr">successThreshold:</span> <span class="hljs-number">1</span><span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">ng-deploy-80</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">ports:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><span class="hljs-attr">port:</span> <span class="hljs-number">81</span><span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><span class="hljs-attr">nodePort:</span> <span class="hljs-number">40012</span><span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span>  <span class="hljs-attr">selector:</span><span class="hljs-attr">app:</span> <span class="hljs-string">ng-deploy-80</span></code></pre><h4 id="1-3-2-4-TCP探针示例"><a href="#1-3-2-4-TCP探针示例" class="headerlink" title="1.3.2.4 TCP探针示例"></a>1.3.2.4 TCP探针示例</h4><pre><code class="hljs yaml"><span class="hljs-comment"># cat nginx.yaml</span><span class="hljs-comment">#apiVersion: extensions/v1beta1</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>  <span class="hljs-attr">selector:</span>  <span class="hljs-attr">matchLabels:</span> <span class="hljs-comment">#rs or deployment</span><span class="hljs-attr">app:</span> <span class="hljs-string">ng-deploy-80</span><span class="hljs-comment">#matchExpressions:</span><span class="hljs-comment"># - &#123;key: app, operator: In, values: [ng-deploy-80,ng-rs-81]&#125;</span>  <span class="hljs-attr">template:</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">ng-deploy-80</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">ng-deploy-80</span><span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.17.5</span><span class="hljs-attr">ports:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><span class="hljs-attr">livenessProbe:</span><span class="hljs-comment">#readinessProbe:</span>  <span class="hljs-attr">tcpSocket:</span><span class="hljs-attr">port:</span> <span class="hljs-number">80</span>         <span class="hljs-comment">#port: 8080</span><span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span><span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">3</span><span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span><span class="hljs-attr">successThreshold:</span> <span class="hljs-number">1</span><span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">ng-deploy-80</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">ports:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span><span class="hljs-attr">port:</span> <span class="hljs-number">81</span><span class="hljs-attr">targetPort:</span> <span class="hljs-number">80</span><span class="hljs-attr">nodePort:</span> <span class="hljs-number">40012</span><span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span>  <span class="hljs-attr">selector:</span><span class="hljs-attr">app:</span> <span class="hljs-string">ng-deploy-80</span></code></pre><h4 id="1-3-2-5：ExecAction探针"><a href="#1-3-2-5：ExecAction探针" class="headerlink" title="1.3.2.5：ExecAction探针"></a>1.3.2.5：ExecAction探针</h4><blockquote><p>可以基于指定的命令对 Pod 进行特定的状态检查</p></blockquote><pre><code class="hljs yaml"><span class="hljs-comment"># docker pull redis</span><span class="hljs-comment"># cat redis.yaml</span><span class="hljs-comment"># apiVersion: extensions/v1beta1</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">redis-deployment</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">1</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">matchLabels:</span> <span class="hljs-comment">#rs or deployment</span>      <span class="hljs-attr">app:</span> <span class="hljs-string">redis-deploy-6379</span>    <span class="hljs-comment"># matchExpressions:</span>    <span class="hljs-comment"># - &#123;key: app, operator: In, values: [redis-deploy-6379,ns-rs-81]&#125;</span>  <span class="hljs-attr">template:</span>    <span class="hljs-attr">metadata:</span>      <span class="hljs-attr">labels:</span>        <span class="hljs-attr">app:</span> <span class="hljs-string">redis-deploy-6379</span>    <span class="hljs-attr">spec:</span>      <span class="hljs-attr">containers:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">redis-deploy-6379</span>        <span class="hljs-attr">image:</span> <span class="hljs-string">redis</span>        <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">6379</span>        <span class="hljs-attr">livenessProbe:</span>        <span class="hljs-comment"># readinessProbe:</span>          <span class="hljs-attr">exec:</span>            <span class="hljs-attr">command:</span>            <span class="hljs-comment"># - /apps/redis/bin/redis-cli</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">/usr/local/bin/redis-cli</span>            <span class="hljs-bullet">-</span> <span class="hljs-string">/quit</span>          <span class="hljs-attr">initialDelaySeconds:</span> <span class="hljs-number">5</span>          <span class="hljs-attr">periodSeconds:</span> <span class="hljs-number">3</span>          <span class="hljs-attr">timeoutSeconds:</span> <span class="hljs-number">5</span>          <span class="hljs-attr">successThreshold:</span> <span class="hljs-number">1</span>          <span class="hljs-attr">failureThreshold:</span> <span class="hljs-number">3</span><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">redis-deploy-6379</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">ports:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">6379</span>    <span class="hljs-attr">nodePort:</span> <span class="hljs-number">40016</span>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">NodePort</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">redis-deploy-6379</span></code></pre><h4 id="1-3-2-6-livenessProbe-和-readinessProbe-对比"><a href="#1-3-2-6-livenessProbe-和-readinessProbe-对比" class="headerlink" title="1.3.2.6 livenessProbe 和 readinessProbe 对比"></a>1.3.2.6 livenessProbe 和 readinessProbe 对比</h4><ul><li><p>配置参数一样</p></li><li><p>livenessProbe 连续探测失败会重启、重建 Pod ，redinessProbe 不会执行重启或者重建 Pod 操作</p></li><li><p>livenessProbe 连续检测指定次数失败后会将容器置于（Crash Loop BackOff）且不可用，readinessProbe 不会</p></li><li><p>livenessProbe 连续探测失败会从 service 的 endpointd 中删除该 Pod ，livenessProbe 不具备次功能，但是会将容器挂起 livenessProbe</p></li><li><p>livenessProbe 用户控制是否重启 Pod ，readinessProbe 用于控制 Pod 是否添加至 service</p></li><li><p>建议： 两个探针都配置</p></li></ul><h3 id="1-4-Pod-重启策略"><a href="#1-4-Pod-重启策略" class="headerlink" title="1.4 Pod 重启策略"></a>1.4 Pod 重启策略</h3><ul><li><p>Kubernetes 在 Pod 出现异常的时候会自动将 Pod 重启以恢复 Pod 中的服务</p><p>restartPolicy:</p><ul><li>Always:：当容器异常时，k8s 自动重启该容器，ReplicationController/Replicaset/Deployment</li><li>OnFailure：当容器失败时（容器停止运行且退出码不为 0），k8s 自动重启该容器</li><li>Never：不论容器运行状态如何都不会重启该容器，Job 或 Cronjob</li></ul><p>示例：</p><pre><code class="hljs yaml"><span class="hljs-attr">containers:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">tomcat-app1-container</span>  <span class="hljs-attr">image:</span> <span class="hljs-string">harbor.1ch0.local/1ch0/tomcat-app1:v1</span>  <span class="hljs-comment"># command: [&quot;/apps/tomcat/bin/run_tomcat.sh&quot;]</span>  <span class="hljs-comment"># imagePullPolicy: IfNotPresent</span>  <span class="hljs-attr">imagePullPolicy:</span> <span class="hljs-string">Always</span>  <span class="hljs-attr">ports:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">8080</span>    <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>    <span class="hljs-attr">name:</span> <span class="hljs-string">http</span>  <span class="hljs-attr">env:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;password&quot;</span>    <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;123456&quot;</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">&quot;age&quot;</span>      <span class="hljs-attr">value:</span> <span class="hljs-string">&quot;18&quot;</span>  <span class="hljs-attr">resources:</span>    <span class="hljs-attr">limits:</span>      <span class="hljs-attr">cpu:</span> <span class="hljs-number">1</span>      <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;512Mi&quot;</span>    <span class="hljs-attr">requests:</span>      <span class="hljs-attr">cpu:</span> <span class="hljs-string">500m</span>      <span class="hljs-attr">memory:</span> <span class="hljs-string">&quot;512Mi&quot;</span> <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Always</span></code></pre></li></ul><h2 id="1-5-镜像拉取策略"><a href="#1-5-镜像拉取策略" class="headerlink" title="1.5 镜像拉取策略"></a><a href="https://kubernetes.io/zh/docs/concepts/configuration/overview/">1.5 镜像拉取策略</a></h2>  <pre><code class="hljs json">imagePullPolicy: IfNotPresent # node 节点没有此镜像就去指定的镜像仓库拉取，node 有就是用 node 本地镜像imagePullPolicy: Always # 每次重建 Pod 都会重新拉取镜像imagePullPolicy: Never # 从不到镜像中心拉取镜像，只使用本地镜像</code></pre>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes 资源对象</title>
    <link href="/2022/07/13/cloud/mage/2.kubernetes/Day3%EF%BC%9AKubernetes%20%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/07/13/cloud/mage/2.kubernetes/Day3%EF%BC%9AKubernetes%20%E8%B5%84%E6%BA%90%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="Kubernetes-资源对象"><a href="#Kubernetes-资源对象" class="headerlink" title="Kubernetes 资源对象"></a>Kubernetes 资源对象</h1><h2 id="1-k8s-的设计理念"><a href="#1-k8s-的设计理念" class="headerlink" title="1. k8s 的设计理念"></a>1. k8s 的设计理念</h2><h3 id="1-1-分层架构"><a href="#1-1-分层架构" class="headerlink" title="1.1 分层架构"></a>1.1 分层架构</h3><table><thead><tr><th align="center">云原生生态系统</th></tr></thead><tbody><tr><td align="center">接口层：客户端库和实用工具</td></tr><tr><td align="center">管理层：自动化和策略管理</td></tr><tr><td align="center">应用层：部署和理由</td></tr><tr><td align="center">核心层：Kubernetes API 和执行环境</td></tr></tbody></table><table><thead><tr><th align="center">容器运行时接口（CRI）</th><th align="center">容器网络接口（CNI）</th><th align="center">容器存储接口（CSI）</th><th align="center">镜像仓库</th><th align="center">云供应商</th><th align="center">身份供应商</th></tr></thead></table><h3 id="1-2-API-设计原则"><a href="#1-2-API-设计原则" class="headerlink" title="1.2 API 设计原则"></a>1.2 API 设计原则</h3><ul><li>所有 API 应该是声明式的</li><li>API 对象是彼此互补而且可组合的</li><li>高层 API 以操作意图为基础设计</li><li>低层 API 根据高层 API 的控制需要设计</li><li>尽量避免简单封装，不要有在外部 API 无法显示知道的内部隐藏的机制</li><li>API 操作复杂度与对象数量成正比</li><li>API 对象状态不能依赖于网络连接状态</li><li>尽量避免让操作机制依赖于全局状态，因为在分布式系统中要保证全局状态的同步是非常困难的</li></ul><h2 id="2-k8s-资源管理核心"><a href="#2-k8s-资源管理核心" class="headerlink" title="2. k8s 资源管理核心"></a>2. k8s 资源管理核心</h2><h3 id="2-1-API：对象（k8s-集群中的管理操作单元）"><a href="#2-1-API：对象（k8s-集群中的管理操作单元）" class="headerlink" title="2.1 API：对象（k8s 集群中的管理操作单元）"></a>2.1 API：对象（k8s 集群中的管理操作单元）</h3><h4 id="HOW"><a href="#HOW" class="headerlink" title="HOW"></a>HOW</h4><h4 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT"></a>WHAT</h4><table><thead><tr><th>类别</th><th>名称</th></tr></thead><tbody><tr><td>资源对象</td><td>Pod、ReplicaSet、ReplicationController、Deployment、StatefulSet、DaemonSet、Job、CronJob、HorizontalPodAutoscaling、Node、Namespace、Service、Ingress、Label、CustomResourceDefinition</td></tr><tr><td>存储对象</td><td>Volume、PersistentVolume、Secret、ConfigMap</td></tr><tr><td>策略对象</td><td>SecurityContext、ResourceQuota、LimitRange</td></tr><tr><td>身份对象</td><td>ServiceAccount、Role、ClusterRole</td></tr></tbody></table><h3 id="2-2-k8s-命令使用"><a href="#2-2-k8s-命令使用" class="headerlink" title="2.2 k8s 命令使用"></a>2.2 k8s 命令使用</h3><table><thead><tr><th>命令集</th><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>基础命令</td><td>create/delete/edit/get/describe//logs/exec/scale</td><td>增删改查</td></tr><tr><td></td><td>explain</td><td>命令说明</td></tr><tr><td>配置命令</td><td>Label：给 node 标记 label，实现 pod 和 node 亲和性</td><td>标签管理</td></tr><tr><td></td><td>apply</td><td>动态配置</td></tr><tr><td></td><td>cluster-info/top</td><td>集群状态</td></tr><tr><td>集群管理命令</td><td>cordon：警戒线、标记 node 不被调度<br />uncordon：取消警戒线标记为 cordon 的 node<br />drain：驱逐 node 上的 pod，用于 node 下线等场景<br />taint：给 node 标记污点，实现反亲 pod 与 node 反亲和性</td><td>node 节点管理</td></tr><tr><td></td><td>api-resources/api-versions/version</td><td>api 资源</td></tr><tr><td></td><td>config</td><td>客户端 kube-config 配置</td></tr></tbody></table><h2 id="3-k8s-—-API"><a href="#3-k8s-—-API" class="headerlink" title="3. k8s — API"></a>3. k8s — API</h2><h3 id="3-1-k8s-的几个重要概念"><a href="#3-1-k8s-的几个重要概念" class="headerlink" title="3.1 k8s 的几个重要概念"></a>3.1 k8s 的几个重要概念</h3><ul><li>对象 —— 用 k8s 是和什么打交道？ k8s 声明式 API</li><li>yaml 文件 —— 怎么打交道？   调用声明式 API</li><li>必须字段 —— 怎么声明？<ol><li>apiVersion：创建该对象所使用的 Kubernetes API 的版本</li><li>kind：想要创建的对象的类型</li><li>metadata：帮助识别对象唯一性的数据，包括一个 name 名称、可选的 namespace</li><li>spec</li><li>status：Pod 创建完成后 k8s 自动生成 status 状态</li></ol></li></ul><h4 id="Yaml-文件及必须字段"><a href="#Yaml-文件及必须字段" class="headerlink" title="Yaml 文件及必须字段"></a>Yaml 文件及必须字段</h4><ul><li>每个 API 对象都有 3 大类属性：元数据 metadata、规范 spec 和状态 status</li></ul><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1beta1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx-deployment</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">3</span>  <span class="hljs-attr">template:</span>  <span class="hljs-attr">metadata:</span>    <span class="hljs-attr">labels:</span>      <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span>  <span class="hljs-attr">spec:</span>      <span class="hljs-attr">containers:</span>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>        <span class="hljs-attr">image:</span> <span class="hljs-string">nginx:1.7.9</span>        <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span></code></pre><h4 id="Spec-和-status-的区别"><a href="#Spec-和-status-的区别" class="headerlink" title="Spec 和 status 的区别"></a>Spec 和 status 的区别</h4><ul><li>spec 是期望状态</li><li>status 是实际状态</li></ul><h3 id="3-2-Pod"><a href="#3-2-Pod" class="headerlink" title="3.2 Pod"></a>3.2 Pod</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><ol><li>Pod 是 k8s 中的最小单元</li><li>一个 pod 中可以运行一个容器，也可以运行多个容器</li><li>运行多个容器的话，这些容器是一起被调度的</li><li>Pod 的生命周期是短暂的，不会自愈，是用完就销毁的实体</li><li>一般我们是通过 Controller 来创建和管理 Pod  的</li></ol><h4 id="Pod-声明周期"><a href="#Pod-声明周期" class="headerlink" title="Pod 声明周期"></a>Pod 声明周期</h4><ul><li>初始化容器、启动前操作、就绪探针、存活探针、删除 Pod 操作</li></ul><h4 id="LivenessProbe-和-readinessProbe"><a href="#LivenessProbe-和-readinessProbe" class="headerlink" title="LivenessProbe 和 readinessProbe"></a>LivenessProbe 和 readinessProbe</h4><ul><li>livenessProbe：存活探针<ul><li>检测应用发生故障时使用，不能提供服务、超时等</li><li>检测失败重启 Pod</li></ul></li><li>readinessProbe：就绪探针<ul><li>检测 Pod 启动之后应用是否就绪，是否可以提供服务</li><li>检测成功，Pod 才开始接收流量</li></ul></li></ul><h3 id="3-3-Controller：控制器"><a href="#3-3-Controller：控制器" class="headerlink" title="3.3 Controller：控制器"></a>3.3 Controller：控制器</h3><table><thead><tr><th>控制器名称</th><th>版本</th><th>特性</th></tr></thead><tbody><tr><td>Replication Controller</td><td>第一代</td><td>= !=</td></tr><tr><td>ReplicaSet</td><td>第二代</td><td>新增 in  notin</td></tr><tr><td>Deployment</td><td>第三代</td><td>新增 滚动升级、回滚等</td></tr></tbody></table><h3 id="3-4-Service"><a href="#3-4-Service" class="headerlink" title="3.4 Service"></a>3.4 Service</h3><ul><li>Why<ul><li>Pod 重建之后 ip 就变了，Pod 之间直接访问会有问题</li></ul></li><li>What<ul><li>解耦了服务和应用</li></ul></li><li>How<ul><li>声明一个 service 对象</li></ul></li><li>一般常用的有两种<ul><li>k8s 集群内的 service：selector 指定 Pod，自动创建 Endpoints</li><li>k8s 集群外的 service：手动创建 Endpoints，指定外部服务的 ip、端口和协议</li></ul></li></ul><h4 id="Kube-proxy-和-service-的关系"><a href="#Kube-proxy-和-service-的关系" class="headerlink" title="Kube-proxy 和 service 的关系"></a>Kube-proxy 和 service 的关系</h4><ul><li>kube-proxy —watch—&gt; k8s-apiserver</li><li>kube-proxy 监听着k8s-apiserver，一旦 service 资源发生变化（调 k8-api 修改 service 信息），kube-proxy 就会生成对应的负载调度的调整，这样就保证 service 的最新状态。</li><li>kube-proxy 有三种调度模型<ul><li>userspace：k8s 1.1 之前</li><li>iptables: 1.2-k8s1.11 之前</li><li>ipvs: k8s 1.11 之后，如果没有开启 ipvs，则自动降级为 iptables</li></ul></li></ul><h3 id="3-5-Volume"><a href="#3-5-Volume" class="headerlink" title="3.5 Volume"></a>3.5 Volume</h3><ul><li>Why<ul><li>数据和镜像解耦，以及容器间的数据共享</li></ul></li><li>What<ul><li>k8s 抽象出的一个对象，用来保存数据，做存储用</li></ul></li><li>常用的几种卷<ul><li>emptyDir：本地临时卷</li><li>hostPath：本地卷</li><li>nfs 等：共享卷</li><li>configmap：配置文件</li></ul></li></ul><h4 id="EmptyDIr"><a href="#EmptyDIr" class="headerlink" title="EmptyDIr"></a>EmptyDIr</h4><ul><li>当 Pod 被分配给节点时，首先创建 emptyDir 卷，并且只要该 Pod 在该节点上运行，该卷就会存在。正如卷的名字所述，它最初是空的。Pod 中的容器可以读取和写入 emptyDir 卷中的相同文件，尽管该卷可以挂载到每个容器中的相同或不同路径上。当出于任何原因从节点中删除 Pod 时，emptyDir 中的数据将被永久性删除。</li></ul><h4 id="HostPath"><a href="#HostPath" class="headerlink" title="HostPath"></a>HostPath</h4><ul><li>hostPath 卷将主机节点的文件系统中的文件或目录挂载到集群中，Pod 删除的时候，卷不会删除。</li></ul><h4 id="Nfs-等共享存储"><a href="#Nfs-等共享存储" class="headerlink" title="Nfs 等共享存储"></a>Nfs 等共享存储</h4><ul><li>nfs 卷允许将现有的 NFS （网络文件系统）共享挂载到容器中。与 emptyDir 不同，当删除 Pod 时，nfs 卷的内容被保留，卷仅仅是被卸载。这意味着 NFS 卷可以预填充数据，并且可以在 Pod  之间”切换“数据。NFS 可以被多个写入者同时挂载。<ul><li>创建多个 Pod  测试挂载同一个 NFS</li><li>创建多个 Pod 测试每个 Pod 挂载多个 NFS</li></ul></li></ul><h4 id="Configmap"><a href="#Configmap" class="headerlink" title="Configmap"></a>Configmap</h4><ul><li>Why<ul><li>配置信息和镜像解耦</li></ul></li><li>What<ul><li>将配置信息放到 configmap 对象中，然后在 Pod 的对象中导入 configmap 对象，实现导入配置的操作</li></ul></li><li>How<ul><li>声明一个 configMap 的对象，作为 Volume 挂载到 Pod 中</li></ul></li></ul><h3 id="PV-PVC"><a href="#PV-PVC" class="headerlink" title="PV/PVC"></a>PV/PVC</h3><ul><li>PersistentVolume（PV）<ul><li>是由管理员设置的存储，它是群集的一部分。</li><li>就像节点时集群中的资源一样，PV 也是集群中的资源。</li><li>PV 是 Volume 之类的卷插件，但具有独立于使用 PV 的 Pod 的生命周期。</li><li>此 API 对象包含存储实现的细节，即 NFS、iSCSI 或特定于云供应商的存储系统</li></ul></li><li>PersistentVolumeClaim（PVC）<ul><li>是用户存储的请求。</li><li>它与 Pod 相似。Pod 消耗节点资源，PVC 消耗 PV 资源。</li><li>Pod 可以请求特定级别的资源（CPU 和内存）。PVC 可以请求特定的大小和访问模式（例如，可以以读/写一次或只读多次模式挂载）</li></ul></li></ul><h3 id="Statufulset"><a href="#Statufulset" class="headerlink" title="Statufulset"></a>Statufulset</h3><ul><li>Why<ul><li>为了解决有状态服务的问题</li></ul></li><li>What<ul><li>它所管理的 Pod 拥有固定的 Pod 名称，主机名，启停顺序</li></ul></li><li>How<ul><li>创建一个 StatefulSet 类型的 Pod ，并制定 serviceName，创建 headless 类型的 svc</li></ul></li></ul><h3 id="DaemonSet"><a href="#DaemonSet" class="headerlink" title="DaemonSet"></a>DaemonSet</h3><ul><li>DaemonSet 在当前集群中每个节点运行同一个 Pod ，当有新的节点加入集群时也会为新的节点配置相同的 Pod ，当节点从集群中移出时其 Pod 也会被 Kubernetes 回收，但是删除 DaemonSet将删除其创建的所有的 Pod 。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python核心技术与实战-进阶篇</title>
    <link href="/2022/07/13/python/Python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/note/02%E4%B8%A8Python%20%E8%BF%9B%E9%98%B6/"/>
    <url>/2022/07/13/python/Python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/note/02%E4%B8%A8Python%20%E8%BF%9B%E9%98%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="Python核心技术与实战-进阶篇"><a href="#Python核心技术与实战-进阶篇" class="headerlink" title="Python核心技术与实战-进阶篇"></a>Python核心技术与实战-进阶篇</h1><h2 id="1-Python-对象的比较、拷贝"><a href="#1-Python-对象的比较、拷贝" class="headerlink" title="1. Python 对象的比较、拷贝"></a>1. Python 对象的比较、拷贝</h2><h3 id="1-1-‘-’-VS-‘is’"><a href="#1-1-‘-’-VS-‘is’" class="headerlink" title="1.1 ‘==’ VS ‘is’"></a>1.1 ‘==’ VS ‘is’</h3><ul><li><p>等于（==）和 is 是 Python 中对象比较常用的两种方式。简单来说，’==’操作符比较对象之间的值是否相等，如下面的例子，<strong>表示比较变量 a 和 b 所指向的值是否相等</strong>。</p></li><li><p>‘is’操作符比较的是对象的身份标识是否相等，即<strong>它们是否是同一个对象，是否指向同一个内存地址</strong>。</p><p><strong>在 Python 中，每个对象的身份标识，都能通过函数 id(object) 获得。因此，’is’操作符，相当于比较对象之间 ID 是否相等</strong></p><pre><code class="hljs python">a = <span class="hljs-number">10</span>b = <span class="hljs-number">10</span>a == b<span class="hljs-literal">True</span><span class="hljs-built_in">id</span>(a)<span class="hljs-number">4427562448</span><span class="hljs-built_in">id</span>(b)<span class="hljs-number">4427562448</span>a <span class="hljs-keyword">is</span> b<span class="hljs-literal">True</span></code></pre><p>首先 Python 会为 10 这个值开辟一块内存，然后变量 a 和 b 同时指向这块内存区域，即 a 和 b 都是指向 10 个变量，因此 a 和 b 的值相等，id 也相等，a == b和a is b都返回 True。</p><p>a is b为 True 的结论，只适用于 -5 到 256 范围内的数字</p></li><li><p>出于对性能优化的考虑，Python 内部会对 -5 到 256 的整型维持一个数组，起到一个缓存的作用。这样，每次你试图创建一个 -5 到 256 范围内的整型数字时，Python 都会从这个数组中返回相对应的引用，而不是重新开辟一块新的内存空间。</p></li><li><p>当我们比较变量时，使用’==’的次数会比’is’多得多，因为我们一般更关心两个变量的值，而不是它们内部的存储地址。但是，当我们比较一个变量与一个单例（singleton）时，通常会使用’is’。一个典型的例子，就是检查一个变量是否为 None：</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:      ...<span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:      ...</code></pre></li><li><p>比较操作符’is’的速度效率，通常要优于’==’。因为’is’操作符不能被重载，这样，Python 就不需要去寻找，程序中是否有其他地方重载了比较操作符，并去调用。执行比较操作符’is’，就仅仅是比较两个变量的 ID 而已。</p></li><li><p>但是’==’操作符却不同，执行a == b相当于是去执行a.<strong>eq</strong>(b)，而 Python 大部分的数据类型都会去重载__eq__这个函数，其内部的处理通常会复杂一些。比如，对于列表，__eq__函数会去遍历列表中的元素，比较它们的顺序和值是否相等。</p></li><li><p>元组是不可变的，但元组可以嵌套，它里面的元素可以是列表类型，列表是可变的，所以如果我们修改了元组中的某个可变元素，那么元组本身也就改变了，之前用’is’或者’==’操作符取得的结果，可能就不适用了。</p></li></ul><h3 id="1-2-浅拷贝和深度拷贝"><a href="#1-2-浅拷贝和深度拷贝" class="headerlink" title="1.2 浅拷贝和深度拷贝"></a>1.2 浅拷贝和深度拷贝</h3><ul><li><p>浅拷贝。常见的浅拷贝的方法，是使用数据类型本身的构造器，比如下面两个例子</p><pre><code class="hljs python">l1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]l2 = <span class="hljs-built_in">list</span>(l1)l2[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]l1 == l2<span class="hljs-literal">True</span>l1 <span class="hljs-keyword">is</span> l2<span class="hljs-literal">False</span>s1 = <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])s2 = <span class="hljs-built_in">set</span>(s1)s2&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;s1 == s2<span class="hljs-literal">True</span>s1 <span class="hljs-keyword">is</span> s2<span class="hljs-literal">False</span></code></pre><p>l2 就是 l1 的浅拷贝，s2 是 s1 的浅拷贝。当然，对于可变的序列，我们还可以通过切片操作符’:’完成浅拷贝，比如下面这个列表的例子</p><pre><code class="hljs python">l1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]l2 = l1[:]l1 == l2<span class="hljs-literal">True</span>l1 <span class="hljs-keyword">is</span> l2<span class="hljs-literal">False</span></code></pre><p>Python 中也提供了相对应的函数 copy.copy()，适用于任何数据类型</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> copyl1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]l2 = copy.copy(l1)</code></pre><p>需要注意的是，对于元组，使用 tuple() 或者切片操作符’:’不会创建一份浅拷贝，相反，它会返回一个指向相同元组的引用</p><pre><code class="hljs python">t1 = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)t2 = <span class="hljs-built_in">tuple</span>(t1)t1 == t2<span class="hljs-literal">True</span>t1 <span class="hljs-keyword">is</span> t2<span class="hljs-literal">True</span></code></pre><p>元组 (1, 2, 3) 只被创建一次，t1 和 t2 同时指向这个元组。</p></li><li><p>浅拷贝你应该很清楚了。浅拷贝，是指重新分配一块内存，创建一个新的对象，里面的元素是原对象中子对象的引用。因此，如果原对象中的元素不可变，那倒无所谓；但如果元素可变，浅拷贝通常会带来一些副作用，尤其需要注意</p></li><li><p>深度拷贝，是指重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。因此，新对象和原对象没有任何关联。</p></li><li><p>Python 中以 copy.deepcopy() 来实现对象的深度拷贝。比如上述例子写成下面的形式，就是深度拷贝：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> copyl1 = [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], (<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)]l2 = copy.deepcopy(l1)l1.append(<span class="hljs-number">100</span>)l1[<span class="hljs-number">0</span>].append(<span class="hljs-number">3</span>)l1[[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], (<span class="hljs-number">30</span>, <span class="hljs-number">40</span>), <span class="hljs-number">100</span>]l2 [[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>], (<span class="hljs-number">30</span>, <span class="hljs-number">40</span>)]</code></pre><p>深度拷贝也不是完美的，往往也会带来一系列问题。如果被拷贝对象中存在指向自身的引用，那么程序很容易陷入无限循环</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> copyx = [<span class="hljs-number">1</span>]x.append(x)x[<span class="hljs-number">1</span>, [...]]y = copy.deepcopy(x)y[<span class="hljs-number">1</span>, [...]]</code></pre><p>深度拷贝函数 deepcopy 中会维护一个字典，记录已经拷贝的对象与其 ID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回，我们来看相对应的源码就能明白</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">deepcopy</span>(<span class="hljs-params">x, memo=<span class="hljs-literal">None</span>, _nil=[]</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;Deep copy operation on arbitrary Python objects.</span><span class="hljs-string">      </span><span class="hljs-string">  See the module&#x27;s __doc__ string for more info.</span><span class="hljs-string">  &quot;&quot;&quot;</span>      <span class="hljs-keyword">if</span> memo <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        memo = &#123;&#125;    d = <span class="hljs-built_in">id</span>(x) <span class="hljs-comment"># 查询被拷贝对象x的id</span>  y = memo.get(d, _nil) <span class="hljs-comment"># 查询字典里是否已经存储了该对象</span>  <span class="hljs-keyword">if</span> y <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> _nil:      <span class="hljs-keyword">return</span> y <span class="hljs-comment"># 如果字典里已经存储了将要拷贝的对象，则直接返回</span>        ...</code></pre></li></ul><pre><code class="hljs ad-summary">- 比较操作符&#39;&#x3D;&#x3D;&#39;表示比较对象间的值是否相等，而&#39;is&#39;表示比较对象的标识是否相等，即它们是否指向同一个内存地址。- 比较操作符&#39;is&#39;效率优于&#39;&#x3D;&#x3D;&#39;，因为&#39;is&#39;操作符无法被重载，执行&#39;is&#39;操作只是简单的获取对象的 ID，并进行比较；而&#39;&#x3D;&#x3D;&#39;操作符则会递归地遍历对象的所有值，并逐一比较。- 浅拷贝中的元素，是原对象中子对象的引用，因此，如果原对象中的元素是可变的，改变其也会影响拷贝后的对象，存在一定的副作用。- 深度拷贝则会递归地拷贝原对象中的每一个子对象，因此拷贝后的对象和原对象互不相关。另外，深度拷贝中会维护一个字典，记录已经拷贝的对象及其 ID，来提高效率并防止无限递归的发生。</code></pre><h2 id="2-参数传递"><a href="#2-参数传递" class="headerlink" title="2. 参数传递"></a>2. 参数传递</h2><h3 id="2-1-值传递和引用传递"><a href="#2-1-值传递和引用传递" class="headerlink" title="2.1 值传递和引用传递"></a>2.1 值传递和引用传递</h3><ul><li>值传递，通常就是拷贝参数的值，然后传递给函数里的新变量。这样，原变量和新变量之间互相独立，互不影响。</li><li>引用传递，通常是指把参数的引用传给新的变量，这样，原变量和新变量就会指向同一块内存地址。如果改变了其中任何一个变量的值，那么另外一个变量也会相应地随之改变。</li></ul><h3 id="2-2-Python-变量及其赋值"><a href="#2-2-Python-变量及其赋值" class="headerlink" title="2.2 Python 变量及其赋值"></a>2.2 Python 变量及其赋值</h3><ul><li><p>Python 里的变量可以被删除，但是对象无法被删除。</p><pre><code class="hljs python">l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-keyword">del</span> l</code></pre><p>del l 删除了 l 这个变量，从此以后你无法访问 l，但是对象[1, 2, 3]仍然存在。Python 程序运行时，其自带的垃圾回收系统会跟踪每个对象的引用。如果[1, 2, 3]除了 l 外，还在其他地方被引用，那就不会被回收，反之则会被回收。</p></li><li><p>变量的赋值，只是表示让变量指向了某个对象，并不表示拷贝对象给变量；</p></li><li><p>而一个对象，可以被多个变量所指向。可变对象（列表，字典，集合等等）的改变，会影响所有指向该对象的变量。</p></li><li><p>对于不可变对象（字符串、整型、元组等等），所有指向该对象的变量的值总是一样的，也不会改变。但是通过某些操作（+= 等等）更新不可变对象的值时，会返回一个新的对象。</p></li><li><p>变量可以被删除，但是对象无法被删除。</p></li></ul><h3 id="2-3-Python-函数的参数传递"><a href="#2-3-Python-函数的参数传递" class="headerlink" title="2.3 Python 函数的参数传递"></a>2.3 Python 函数的参数传递</h3><ul><li>Python 的参数传递是赋值传递 （pass by assignment），或者叫作对象的引用传递（pass by object reference）。Python 里所有的数据类型都是对象，所以参数传递时，只是让新变量与原变量指向相同的对象而已，并不存在值传递或是引用传递一说。</li><li>改变变量和重新赋值的区别<ul><li>单纯地改变了对象的值，因此函数返回后，所有指向该对象的变量都会被改变；l2.append(4)</li><li>但 my_func4() 中则创建了新的对象，并赋值给一个本地变量，因此原变量仍然不变 l2 = l2 + [4] return l2</li></ul></li></ul><pre><code class="hljs ad-summary">赋值或对象的引用传递，不是指向一个具体的内存地址，而是指向一个具体的对象。- 如果对象是可变的，当其改变时，所有指向这个对象的变量都会改变。- 如果对象不可变，简单的赋值只能改变其中一个变量的值，其余变量则不受影响。如果你想通过一个函数来改变某个变量的值，通常有两种方法- 一种是直接将可变数据类型（比如列表，字典，集合）当作参数传入，直接在其上修改- 第二种则是创建一个新变量，来保存修改后的值，然后将其返回给原变量。在实际工作中，我们更倾向于使用后者，因为其表达清晰明了，不易出错。</code></pre><h2 id="3-装饰器"><a href="#3-装饰器" class="headerlink" title="3. 装饰器"></a>3. 装饰器</h2><h3 id="3-1-函数核心"><a href="#3-1-函数核心" class="headerlink" title="3.1 函数核心"></a>3.1 函数核心</h3><ul><li>在 Python 中，函数是一等公民（first-class citizen），函数也是对象。我们可以把函数赋予变量</li><li>可以把函数当作参数，传入另一个函数中</li><li>可以在函数里定义函数，也就是函数的嵌套</li><li>函数的返回值也可以是函数对象（闭包）</li><li></li></ul><h3 id="3-2-装饰器"><a href="#3-2-装饰器" class="headerlink" title="3.2 装饰器"></a>3.2 装饰器</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_decorator</span>(<span class="hljs-params">func</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>():</span>        print(<span class="hljs-string">&#x27;wrapper of decorator&#x27;</span>)        func()    <span class="hljs-keyword">return</span> wrapper<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>():</span>    print(<span class="hljs-string">&#x27;hello&#x27;</span>)greet = my_decorator(greet)greet()</code></pre><p>变量 greet 指向了内部函数 wrapper()，而内部函数 wrapper() 中又会调用原函数 greet()，因此，最后<br>调用 greet() 时，就会先打印’wrapper ofdecorator’，然后输出’hello world’。</p><p>这里的函数 my_decorator() 就是一个装饰器，它把真正需要执行的函数 greet() 包裹在其中，并且改变了它的行为，但是原函数 greet() 不变。</p><p>上述代码在 Python 中有更简单、更优雅的表示：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_decorator</span>(<span class="hljs-params">func</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>():</span>        print(<span class="hljs-string">&#x27;wrapper of decorator&#x27;</span>)        func()    <span class="hljs-keyword">return</span> wrapper<span class="hljs-meta">@my_decorator</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>():</span>    print(<span class="hljs-string">&#x27;hello&#x27;</span>)greet()</code></pre><p>这里的@，我们称之为语法糖，@my_decorator就相当于前面的greet=my_decorator(greet)语句，只不过更加简洁.如果你的程序中有其它函数需要做类似的装饰，你只需在它们的上方加上@decorator就可以了，这样就大大提高了函数的重复利用和程序的可读性。</p><h3 id="3-3-带参数的装饰器"><a href="#3-3-带参数的装饰器" class="headerlink" title="3.3 带参数的装饰器"></a>3.3 带参数的装饰器</h3><ul><li><p>一个简单的办法，是可以在对应的装饰器函数 wrapper()上，加上相应的参数</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_decorator</span>(<span class="hljs-params">func</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">message</span>):</span>        print(<span class="hljs-string">&#x27;wrapper of decorator&#x27;</span>)        func(message)    <span class="hljs-keyword">return</span> wrapper<span class="hljs-meta">@my_decorator</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">message</span>):</span>    print(message)greet(<span class="hljs-string">&#x27;hello&#x27;</span>)</code></pre></li><li><p>把*args和*<em>kwargs，作为装饰器内部函数 wrapper() 的参数。</em>args和**kwargs，表示接受任意数量和类型的参数，因此装饰器就可以写成下面的形式：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_decorator</span>(<span class="hljs-params">func</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span>        print(<span class="hljs-string">&#x27;wrapper of decorator&#x27;</span>)        func(*args, **kwargs)    <span class="hljs-keyword">return</span> wrapper<span class="hljs-meta">@my_decorator</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">a</span>):</span>    print(a)greet(<span class="hljs-string">&#x27;hello&#x27;</span>)</code></pre></li></ul><h3 id="3-4-带有自定义参数的装饰器"><a href="#3-4-带有自定义参数的装饰器" class="headerlink" title="3.4 带有自定义参数的装饰器"></a>3.4 带有自定义参数的装饰器</h3><p>装饰器可以接受原函数任意类型和数量的参数，除此之外，它还可以接受自己定义的参数。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">repeat</span>(<span class="hljs-params">num</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_decorator</span>(<span class="hljs-params">func</span>):</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num):                print(<span class="hljs-string">&#x27;wrapper of decoraotr&#x27;</span>)                func(*args, **kwargs)        <span class="hljs-keyword">return</span> wrapper    <span class="hljs-keyword">return</span> my_decorator<span class="hljs-meta">@repeat(4)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">message</span>):</span>    print(message)greet(<span class="hljs-string">&#x27;a&#x27;</span>)</code></pre><h3 id="3-5-原函数还是原函数吗"><a href="#3-5-原函数还是原函数吗" class="headerlink" title="3.5 原函数还是原函数吗"></a>3.5 原函数还是原函数吗</h3><ul><li><p>打印 greet() 函数的元信息</p><pre><code class="hljs python">greet.__name__<span class="hljs-built_in">help</span>(greet)</code></pre><p>greet() 函数被装饰以后，它的元信息变了。元信息告诉我们“它不再是以前的那个 greet() 函数，而是被<br>wrapper() 函数取代了”。</p></li><li><p>通常使用内置的装饰器@functools.wrap，它会帮助保留原函数的元信息（也就是将原函数的元信息，拷贝到对应的装饰器函数里）</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_decorator</span>(<span class="hljs-params">func</span>):</span><span class="hljs-meta">    @functools.wraps(func)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span>        print(<span class="hljs-string">&#x27;wrapper of decorator&#x27;</span>)        func(*args,**kwargs)    <span class="hljs-keyword">return</span> wrapper<span class="hljs-meta">@my_decorator</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">greet</span>(<span class="hljs-params">message</span>):</span>    print(message)greet.__name__</code></pre></li></ul><h3 id="3-6-类装饰器"><a href="#3-6-类装饰器" class="headerlink" title="3.6 类装饰器"></a>3.6 类装饰器</h3><ul><li><p>类装饰器主要依赖于函数__call_()，每当你调用一个类的示例时，函数<strong>call</strong>()就会被执行一次。</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Count</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, func</span>):</span>        self.func = func        self.num_calls = <span class="hljs-number">0</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span>        self.num_calls += <span class="hljs-number">1</span>        print(<span class="hljs-string">&#x27;num of calls is: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(self.num_calls))        <span class="hljs-keyword">return</span> self.func(*args, **kwargs)<span class="hljs-meta">@Count</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">example</span>():</span>    print(<span class="hljs-string">&quot;hello&quot;</span>)example()</code></pre></li></ul><h3 id="3-7-装饰器的嵌套"><a href="#3-7-装饰器的嵌套" class="headerlink" title="3.7 装饰器的嵌套"></a>3.7 装饰器的嵌套</h3><ul><li><p>Python 也支持多个装饰器</p><pre><code class="hljs python"><span class="hljs-meta">@decorator1</span><span class="hljs-meta">@decorator2</span><span class="hljs-meta">@decorator3</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span>...</code></pre><p>它的执行顺序从里到外，所以上面的语句也等效于下面这行代码：</p><pre><code class="hljs python">decorator1(decorator2(decorator3(func)))</code></pre></li></ul><h3 id="3-8-装饰器用法实例"><a href="#3-8-装饰器用法实例" class="headerlink" title="3.8 装饰器用法实例"></a>3.8 装饰器用法实例</h3><h4 id="3-8-1-身份认证"><a href="#3-8-1-身份认证" class="headerlink" title="3.8.1 身份认证"></a>3.8.1 身份认证</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">authenticate</span>(<span class="hljs-params">func</span>):</span><span class="hljs-meta">    @functools.wraps(func)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span>        request = args[<span class="hljs-number">0</span>]        <span class="hljs-keyword">if</span> check_user_logged_in(request):            <span class="hljs-keyword">return</span> func(*args, **kwargs)        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;Authentication failed&#x27;</span>)    <span class="hljs-keyword">return</span> wrapper<span class="hljs-meta">@authenticate</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post_comment</span>(<span class="hljs-params">request, ...</span>):</span>    ...</code></pre><p>定义了装饰器 authenticate；而函数post_comment()，则表示发表用户对某篇文章的评论。每<br>次调用这个函数前，都会先检查用户是否处于登录状态，如果是登录状态，则允许这项操作；如果没有登录，则不允许。</p><h4 id="3-8-2-日志记录"><a href="#3-8-2-日志记录" class="headerlink" title="3.8.2 日志记录"></a>3.8.2 日志记录</h4><p>日志记录同样是很常见的一个案例。在实际工作中，如果你怀疑某些函数的耗时过长，导致整个系统的 latency（延迟）增加，所以想在线上测试某些函数的执行时间，那么，装饰器就是一种很常用的手段。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> functools<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">log_execution_time</span>(<span class="hljs-params">func</span>):</span><span class="hljs-meta">    @functools.wraps(func)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span>        start = time.perf_counter()        res = func(*args, **kwargs)        end = time.perf_counter()        print(<span class="hljs-string">&#x27;&#123;&#125; took &#123;&#125; ms&#x27;</span>.<span class="hljs-built_in">format</span>(func.__name__, (end-start)))        <span class="hljs-keyword">return</span> res    <span class="hljs-keyword">return</span> wrapper<span class="hljs-meta">@log_execution_time</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate_similarity</span>(<span class="hljs-params">items</span>):</span>    ...</code></pre><h4 id="3-8-3-输入合理性检查"><a href="#3-8-3-输入合理性检查" class="headerlink" title="3.8.3 输入合理性检查"></a>3.8.3 输入合理性检查</h4><p>调用机器集群进行模型训练前，往往会用装饰器对其输入（往往是很长的 json 文件）进行合理性检。这样就可以大大避免，输入不正确对机器造成的巨大开销。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> functools<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validation_check</span>(<span class="hljs-params"><span class="hljs-built_in">input</span></span>):</span><span class="hljs-meta">@functools.wraps(func)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">wrapper</span>(<span class="hljs-params">*args, **kwargs</span>):</span>... <span class="hljs-comment"># 检查输入是否合法</span>        <span class="hljs-meta">@validation_check</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">neural_network_training</span>(<span class="hljs-params">param1, param2, ...</span>):</span>...</code></pre><h3 id="3-9-缓存"><a href="#3-9-缓存" class="headerlink" title="3.9 缓存"></a>3.9 缓存</h3><p>以 Python 内置的 LRU cache 为例，LRU cache，在 Python 中的表示形式是@lru_cache。lru_cache会缓存进程中的函数参数和结果，当缓存满了以后，会删除 least recenly used 的数据。</p><pre><code class="hljs python"><span class="hljs-meta">@lru_cache</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">check</span>(<span class="hljs-params">param1, param2, ...</span>) # 检查用户设备类型，版本号</span><span class="hljs-function">...</span></code></pre><pre><code class="hljs ad-summary">所谓的装饰器，其实就是通过装饰器函数，来修改原函数的一些功能，使得原函数不需要修改。装饰器通常运用在身份认证、日志记录、输入合理性检查以及缓存等多个领域中。合理使用装饰器，往往能极大地提高程序的可读性以及运行效率。</code></pre><h2 id="4-metaclass"><a href="#4-metaclass" class="headerlink" title="4. metaclass"></a>4. metaclass</h2><ul><li><p>meta-class 的 meta 这个词根，起源于希腊语词汇 meta，包含下面两种意思：</p><ul><li>“Beyond”，例如技术词汇 metadata，意思是描述数据的超越数据；</li><li>“Change”，例如技术词汇 metamorphosis，意思是改变的形态。</li></ul></li><li><p><a href="https://pyyaml.org/wiki/PyYAMLDocumentation">YAML</a>是一个家喻户晓的 Python 工具，可以方便地序列化 / 逆序列化结构数据。YAMLObject 的一个<strong>超越变形能力</strong>，就是它的任意子类支持序列化和反序列化（serialization &amp; deserialization）</p><pre><code class="hljs python">  ```<span class="hljs-comment">## 5. 迭代器和生成器</span>- 迭代器（iterator）提供了一个 <span class="hljs-built_in">next</span> 的方法。调用这个方法后，你要么得到这个容器的下一个对象，要么得到一个 StopIteration 的错误  ```python  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_iterable</span>(<span class="hljs-params">param</span>):</span>      <span class="hljs-keyword">try</span>:           <span class="hljs-built_in">iter</span>(param)           <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>      <span class="hljs-keyword">except</span> TypeError:          <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>     params = [      <span class="hljs-number">1234</span>,      <span class="hljs-string">&#x27;1234&#x27;</span>,      [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>],      <span class="hljs-built_in">set</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]),      &#123;<span class="hljs-number">1</span>:<span class="hljs-number">1</span>, <span class="hljs-number">2</span>:<span class="hljs-number">2</span>, <span class="hljs-number">3</span>:<span class="hljs-number">3</span>, <span class="hljs-number">4</span>:<span class="hljs-number">4</span>&#125;,      (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)  ]        <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:      print(<span class="hljs-string">&#x27;&#123;&#125; is iterable? &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(param, is_iterable(param)))     <span class="hljs-comment">########## 输出 ##########</span>     1234 is iterable? False  1234 is iterable? True  [1, 2, 3, 4] is iterable? True  &#123;1, 2, 3, 4&#125; is iterable? True  &#123;1: 1, 2: 2, 3: 3, 4: 4&#125; is iterable? True  (1, 2, 3, 4) is iterable? True</code></pre><p><strong>除了数字 1234 之外，其它的数据类型都是可迭代的。</strong></p></li><li><p>生成器</p></li><li><p><strong>生成器是懒人版本的迭代器</strong></p></li><li><p>迭代器是一个有限集合，生成器则可以成为一个无限集。我只管调用 next()，生成器根据运算会自动生成新的元素，然后返回给你，非常便捷。</p></li><li></li></ul><pre><code class="hljs ad-summary">容器是可迭代对象，可迭代对象调用 iter() 函数，可以得到一个迭代器。迭代器可以通过 next() 函数来得到下一个元素，从而支持遍历。生成器是一种特殊的迭代器（注意这个逻辑关系反之不成立）。使用生成器，你可以写出来更加清晰的代码；合理使用生成器，可以降低内存占用、优化程序结构、提高程序速度。生成器在 Python 2 的版本上，是协程的一种重要实现方式；而 Python 3.5 引入 async await 语法糖后，生成器实现协程的方式就已经落后了。我们会在下节课，继续深入讲解 Python 协程。</code></pre><h2 id="6-Python-协程"><a href="#6-Python-协程" class="headerlink" title="6.  Python 协程"></a>6.  Python 协程</h2><h3 id="6-1-执行协程常用的三种方法"><a href="#6-1-执行协程常用的三种方法" class="headerlink" title="6.1 执行协程常用的三种方法"></a>6.1 执行协程常用的三种方法</h3><ul><li><p>首先，我们可以通过 await 来调用。await 执行的效果，和 Python 正常执行是一样的，也就是说程序会阻塞在这里，进入被调用的协程函数，执行完毕返回后再继续，而这也是 await 的字面意思。代码中 <code>await asyncio.sleep(sleep_time)</code> 会在这里休息若干秒，<code>await crawl_page(url)</code> 则会执行 crawl_page() 函数。</p></li><li><p>其次，我们可以通过 asyncio.create_task() 来创建任务，这个我们下节课会详细讲一下，你先简单知道即可。</p></li><li><p>最后，我们需要 asyncio.run 来触发运行。asyncio.run 这个函数是 Python 3.7 之后才有的特性，可以让 Python 的协程接口变得非常简单，你不用去理会事件循环怎么定义和怎么使用的问题（我们会在下面讲）。一个非常好的编程规范是，asyncio.run(main()) 作为主程序的入口函数，在程序运行周期内，只调用一次 asyncio.run。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crawl_page</span>(<span class="hljs-params">url</span>):</span>    print(<span class="hljs-string">&#x27;crawling &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url))    sleep_time = <span class="hljs-built_in">int</span>(url.split(<span class="hljs-string">&#x27;_&#x27;</span>)[<span class="hljs-number">-1</span>])    <span class="hljs-keyword">await</span> asyncio.sleep(sleep_time)    print(<span class="hljs-string">&#x27;OK &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(url)) <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">urls</span>):</span>    tasks = [asyncio.create_task(crawl_page(url)) <span class="hljs-keyword">for</span> url <span class="hljs-keyword">in</span> urls]    <span class="hljs-keyword">await</span> asyncio.gather(*tasks) %time asyncio.run(main([<span class="hljs-string">&#x27;url_1&#x27;</span>, <span class="hljs-string">&#x27;url_2&#x27;</span>, <span class="hljs-string">&#x27;url_3&#x27;</span>, <span class="hljs-string">&#x27;url_4&#x27;</span>]))</code></pre></li></ul><pre><code class="hljs ad-summary">协程和多线程的区别，主要在于两点，一是协程为单线程；二是协程由用户决定，在哪些地方交出控制权，切换到下一个任务。协程的写法更加简洁清晰，把 async &#x2F; await 语法和 create_task 结合来用，对于中小级别的并发需求已经毫无压力。写协程程序的时候，你的脑海中要有清晰的事件循环概念，知道程序在什么时候需要暂停、等待 I&#x2F;O，什么时候需要一并执行到底。</code></pre><h2 id="7-并发编程-Futures"><a href="#7-并发编程-Futures" class="headerlink" title="7. 并发编程 - Futures"></a>7. 并发编程 - Futures</h2><h3 id="7-1-并发和并行"><a href="#7-1-并发和并行" class="headerlink" title="7.1 并发和并行"></a>7.1 并发和并行</h3><p>并发（Concurrency）和并行（Parallelism）</p><ul><li>在 Python 中，并发并不是指同一时刻有多个操作（thread、task）同时进行。相反，某个特定的时刻，它只允许有一个操作发生，只不过线程 / 任务之间会互相切换，直到完成。</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABlQAAAIMCAYAAACDnEExAAAgAElEQVR4AezdCfzsU/04/nO5JOFeS30Rbt+E7FukZA8pa9KCkIoUslaISz/+fLOGskQIZStbi5uUrRDKEtnda0nKci/iJnz+j9ep95jP/pn5zMx7PjPP83hcM/Oe9/uc93me93zm7bzmnDOup6enJ9WQZsyYkSZMmFDDEY3ZtdvKnTZtWpo0aVJj8GrIpducy6qv9q3hohzFrtp3FHg1HFqWc1nl+vzWcHGMYlftOwq8Gg4ty7mscn1+a7g4RrGr9h0FXg2HluVcVrk+vzVcHKPYVfuOAq+GQ8tyLqtcn98aLo5R7Kp9R4FXw6FlOZdVrs9vDRfHKHbVvqPAq+HQRjnPUkOZdiVAgAABAgQIECBAgAABAgQIECBAgAABAgQIdKWAgEpXNrtKEyBAgAABAgQIECBAgAABAgQIECBAgAABArUIjJs6dWpNU37Vkrl9CRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKdIDDOGipDN2Oj5lYbupT+75qjsL9JM7Zo32ao9s+zLOeyyvX57X8NNGOL9m2Gav88y3Iuq1yf3/7XQDO2aN9mqPbPsyznssr1+e1/DTRji/Zthmr/PMtyLqtcn9/+10AztmjfZqj2z7Ms57LK9fntfw00Y4v2bYZq/zzLci6rXJ/f/tfASLaY8mskSvYhQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEulpAQKWrm1/lCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZEICKiMRMk+BAgQIECAAAECBAgQIECAAAECBAgQIECAQFcLCKh0dfOrPAECBAgQIECAAAECBAgQIECAAAECBAgQIDASAQGVkSjZhwABAgQIECBAgAABAgQIECBAgAABAgQIEOhqAQGVrm5+lSdAgAABAgQIECBAgAABAgQIECBAgAABAgRGIiCgMhIl+xAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJdLSCg0tXNr/IECBAgQIAAAQIECBAgQIAAAQIECBAgQIDASAQEVEaiZB8CBAgQIECAAAECBAgQIECAAAECBAgQIECgqwUEVLq6+VWeAAECBAgQIECAAAECBAgQIECAAAECBAgQGImAgMpIlOxDgAABAgQIECBAgAABAgQIECBAgAABAgQIdLWAgEpXN7/KEyBAgAABAgQIECBAgAABAgQIECBAgAABAiMREFAZiZJ9CBAgQIAAAQIECBAgQIAAAQIECBAgQIAAga4WEFDp6uZXeQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGAkAgIqI1GyDwECBAgQIECAAAECBAgQIECAAAECBAgQINDVAgIqXd38Kk+AAAECBAgQIECAAAECBAgQIECAAAECBAiMREBAZSRK9iFAgAABAgQIECBAgAABAgQIECBAgAABAgS6WkBApaubX+UJECBAgAABAgQIECBAgAABAgQIECBAgACBkQgIqIxEyT4ECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAVwsIqHR186s8AQIECBAgQIAAAQIECBAgQIAAAQIECBAgMBIBAZWRKNmHAAECBAgQIECAAAECBAgQIECAAAECBAgQ6GoBAZWubn6VJ0CAAAECBAgQIECAAAECBAgQIECAAAECBEYiIKAyEiX7ECBAgAABAgQIECBAgAABAgQIECBAgAABAl0tIKDS1c2v8gQIECBAgAABAgQIECBAgAABAgQIECBAgMBIBARURqJkHwIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCrBQRUurr5VZ4AAQIECBAgQIAAAQIECBAgQIAAAQIECBAYiYCAykiU7EOAAAECBAgQIECAAAECBAgQIECAAAECBAh0tYCASlc3v8oTIECAAAECBAgQIECAAAECBAgQIECAAAECIxEYN3369J6R7Gif1gpMnz49TZw4sbWFKq1lAtq3ZdSlFKR9S2FvWaHat2XUpRSkfUthb1mh2rdl1KUUpH1LYW9Zodq3ZdSlFKR9S2FvWaHat2XUpRSkfUthb1mh2rdl1KUUpH3rYx8/YcKEmo6cMWNGqvWYmgoYZOduKzcuaM6DXAwN3FzWdaV9G9iIQ2SlfYfAaeBbZTmXVa7PbwMvniGy0r5D4DTwrbKcyyrX57eBF88QWWnfIXAa+FZZzmWV6/PbwItniKy07xA4DXyrLOeyyvX5beDFM0RW2ncInAa+VZZzWeX6/Dbw4hkiK+07BE4D32qUsym/GtgosiJAgAABAgQIECBAgAABAgQIECBAgAABAgQ6U0BApTPbVa0IECBAgAABAgQIECBAgAABAgQIECBAgACBBgoIqDQQU1YECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAZwoIqHRmu6oVAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0EABAZUGYsqKAAECBAgQIECAAAECBAgQIECAAAECBAgQ6EwBAZXObFe1IkCAAAECBAgQIECAAAECBAgQIECAAAECBBooIKDSQExZESBAgAABAgQIECBAgAABAgQIECBAgAABAp0pIKDSme2qVgQIECBAgAABAgQIECBAgAABAgQIECBAgEADBQRUGogpKwIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAzBQRUOrNd1YoAAQIECBAgQIAAAQIECBAgQIAAAQIECBBooICASgMxZUWAAAECBAgQIECAAAECBAgQIECAAAECBAh0poCASme2q1oRIECAAAECBAgQIECAAAECBAgQIECAAAECDRQQUGkgpqwIECBAgAABAgQIECBAgAABAgQIECBAgACBzhQQUOnMdlUrAgQIECBAgAABAgQIECBAgAABAgQIECBAoIECAioNxJQVAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0JkCAiqd2a5qRYAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRQQEClgZiyIkCAAAECBAgQIECAAAECBAgQIECAAAECBDpTQEClM9tVrQgQIECAAAECBAgQIECAAAECBAgQIECAAIEGCgioNBBTVgQIECBAgAABAgQIECBAgAABAgQIECBAgEBnCgiodGa7qhUBAgQIECBAgAABAgQIECBAgAABAgQIECDQQAEBlQZiyooAAQIECBAgQIAAAQIECBAgQIAAAQIECBDoTAEBlc5sV7UiQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGiggoNJATFkRIECAAAECBAgQIECAAAECBAgQIECAAAECnSkgoNKZ7apWBAgQIECAAAECBAgQIECAAAECBAgQIECAQAMFBFQaiCkrAgQIECBAgAABAgQIECBAgAABAgQIECBAoDMFBFQ6s13VigABAgQIECBAgAABAgQIECBAgAABAgQIEGiggIBKAzFlRYAAAQIECBAgQIAAAQIECBAgQIAAAQIECHSmgIBKZ7arWhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQINFBg3ffr0ngbmJ6sGCUyfPj1NnDixQbnJpt0EtG+7tUhjz0f7Ntaz3XLTvu3WIo09H+3bWM92y037tluLNPZ8tG9jPdstN+3bbi3S2PPRvo31bLfctG+7tUhjz0f7Ntaz3XLTvu3WIo09H+1bn+f4CRMm1HTkjBkzUq3H1FTAIDt3W7lxQXMe5GJo4Oayrivt28BGHCIr7TsETgPfKsu5rHJ9fht48QyRlfYdAqeBb5XlXFa5jfr83n333enZZ5+ttMSKK66Y5p133srrvk/Kqm+3lduo9u3bfsO97jbnsuqrfYe7EhvzvvZtjONwuZTlXFa5Pr/DXRGNeV/7NsZxuFzKci6rXJ/f4a6IxryvfRvjOFwujXIeP1xB3idAgAABAgQIECBA4E2BW2+9NV111VXpiiuuSK+++mr61a9+lT784Q+/uYNnBAgQIECAAAECBAgQINCRAtZQ6chmVSkCBAgQIECAQOcI3HHHHWn55ZfPo0BmmWWWVP1v1llnTYssskhad91108EHH5xi9Eiz084775wuvPDCfD49PT0pzkEiQIAAAQIECBAgQIAAgc4XEFDp/DZWQwIECBAgQIDAmBZYaaWV0l133ZWee+65ShBju+22S3feeWf69a9/nY488si04IILpsMPPzytuuqq6YQTTmh6fceNG1cpQ0ClQuEJAQIECBAgQIAAAQIEOlrAlF8d3bwqR4AAAQIECBDoDIHqAEbUKIIYMWqlSNtvv3165zvfmY477ri0zz77pDXWWCP/K96v9/H222/P66VstNFGg2YhoDIojTcIECBAgAABAgQIECDQUQJGqHRUc6oMAQIECBAgQKA7BSLgEiNUJkyYkGIarqOOOqohEHvssUdeI2WozGIKMokAAQIECBAgQIAAAQIEOl/A//11fhurIQECBAgQIECgKwTe+ta3ptVXXz3X9YEHHhh1nWM6sZtuumnYfEYzQuWJJ55I119/fbr55ptzIGjYwpq0w2uvvZbC7LbbbksvvPDCsKW88sor6ZZbbknXXntt+sc//jHs/qPZ4dVXX01/+ctf0h//+Mf00ksvjSarER376KOPpn/961+D7hsBuwcffDC98cYb/fZ58cUX0+9///t0ww03pDBtVgqHGD0Vbfbvf/+7WcXIlwABAgQIECBAgACBPgICKn1AvCRAgAABAgQIEBi7Am95y1vyycd6K5H+7//+L6233nr536c//en8uO2226YICER67LHH0sc//vHKPltvvXX67W9/m/baa6/0uc99Lu8TC9AXefzsZz/L26r/8/rrr6ezzz47rb322imCOjFiJaYji471gVJ0tH//+99PSy+9dFpsscXSuuuumz74wQ+mJZdcMv3whz/sdcitt96a1l9//Ur50ZF/wQUX5G1zzjlnnvrsU5/6VA449DpwhC+mTp2aYrq0eeaZJ733ve/NAamJEyem+eefP22++eb9crn33nvTZz/72TwS6AMf+EA+j6jDrrvumv7+97/32j/yLdyOPfbYfI677LJLmjRpUjb63//933Tqqaem8Bsoxbo50TZxbssuu2x63/vel5+/4x3vSDvuuGM+ZL/99quUEedVnU466aS0wQYbVN6PwFWk6dOnV7bF+UXbRTrttNNSnNN73vOeHOAqzj0ef/rTn+aA1/HHH58WXXTRbPXyyy/n4+I/kUes9RN2H/rQh9I666yTllhiiXT55ZdX9olAzYc//OFK2b/73e/SL37xi/Sxj30s1yuumzjf4jwrB1Y9+fGPf5ze//735/0jr2izuObe9a53pR/84Ad5naENN9ywUkace7w+//zzK7mcccYZlfOIPGKKPIkAAQIECBAgQIAAgZEJCKiMzMleBAgQIECAAAECY0AgAg6RotM+0le/+tW06aab5pEUMQrk85//fO5cjk7oSBEMuPjii3MwJDq843mMctlyyy1zJ37sE8GOyZMn53+x6H3fdMABB+QgTAQ+ooN/ueWWS3/+859z5/jjjz/ea/cI5ESn+W677ZYieHPnnXemv/3tbzmQEqMidtppp3TYYYdVjllttdVSBAYiuBCjQQ488MB033335fPdd999c1DmoosuSqusskrqW1Ylk0GeRLAm6hMBoygzynj22WdTBI3CL15Xp/POOy8Hih555JF02WWX5c776Pz/xCc+kU4//fQcSIhgRZG++93v5uBEnHe8f+6556aFF144B6oi2DJt2rT05S9/OR1yyCHFIZXH3/zmN9l9ypQp6ZhjjkkRyImRMFFuBC3uueeevO+RRx6ZA0JRRrRvdYrp2qJuDz30UK+RNHF8BCYiMHPdddflfTbeeOM8Tdxss82WAydR/zjfCNDFPhGQWGuttdL3vve9VOxTlHXyySennXfeOc0xxxy53SNAFIGxGH0UAaFrrrkm7xrBmgjaROAp8vzWt76VR/lEG++99975uot6RxAk2qY6xaiYcNpuu+1yMPCSSy5JDz/8cLr//vvTiSeemJ588snc/vPNN1865ZRT0j//+c9c59gewaA4rkhf+MIX8nUeo3622GKLFMEuiQABAgQIECBAgACBEQr01JimT59e4xGN2b3byp06dWpj4GrMpducy6qv9q3xwqxzd+1bJ1yNh5XlXFa5Pr81XiB17q5964Sr8bCynEdT7nzzzdeTUurZcccd+9X2pptuyu/F+9/61rcq77/++us9Cy64YH5vp512qmyvfrLOOuv0HH744dWbenbYYYd8zL777ttre/GiyHPKlCk9b7zxRt4cjzNnzuxZZZVV8rH/3//3//VU1/eb3/xm3r7HHntUjinyu/fee3tmmWWWnllnnbUnnlen6rKK7VHWyy+/3LPUUkvlPI844ojirfxYXW6vN3p6embMmNGzyCKL5ONOO+20vm/3XH311T2TJk2qbH/sscd65phjjp4JEyb0qk/sEOex3nrrVepVXW6cU7THpptu2qu+cczRRx+d31tooYUq5cSTp59+umeBBRbI711xxRW93osXF1xwQc+qq65a2X7rrbfmfWebbbbKtuonSyyxRH7/kksuqd7cs88+++Ttq6++es8f/vCHfH6vvPJKz7LLLtvz6KOP5tdxncX5b7DBBj133nln3hb1W2yxxXpefPHFnr/97W89b3nLW3rGjRvX89BDD1Xyj/qdcsop+dgPfvCDvbavscYaef9q99j/tdde61l//fXzMbvsskvlmHhy+eWX52Pi+n/yySfze4VzHLv99tv3HHrooZVjfvjDH+Z84rweeOCByvbiSZhFexZ5FNtH8ljPMSPJd7h9fP8OJ9SY97VvYxyHy6Us57LK9fkd7opozPvatzGOw+VSlnNZ5fr8DndFNOZ97dsYx+FyaZSzESojDDzZjQABAgQIECBAoH0F4pf4MZVXpJj+KKbsKlJMpRRTUkWKkQnx6/3qFNNe3XjjjXmUQfX2Wp6PGzcu7x6PMaohpn2KFKM5ihTlHnfccfllTH1VHFO8H1OAxfRMMcIhRkIMl+L46nVjYoTNSNOZZ56ZR1DEqIk4l74pRknEtFVFilEMM2fOTDFt2oQJE4rN+THOI0bLRIp8q6fCqt6xur7xvMj/qaeeSrFOSpFiRM4zzzyTYkqxzTbbrNhceYypyGL6r0alZZZZJsUokTinGGUS03AtuOCCvbKP6bxWWGGFvE/UP0aShH1cTzGyKN5bfPHFK8dEXjEFWayvE+vwPP/885X3BnoS+8d1GqOhIlW3ZYxOiZFJkcI5RvlUpzh2hx12qIzKive22WabPG1bHNv3WoptZ511Vh4h1bctq/P1nAABAgQIECBAgACB/gICKv1NbCFAgAABAgQIEGhzgTvuuCNPUxVTVX3xi19M0SkendDRSR/TP80999y9avClL30pd1hH5/c555zT670IAnz0ox9NCy20UK/to3kxfvz4fHj1guGxiHsEG2LKqJgWbKAU041FivU1RpqiIz5SdVnDHRtTZ0WK9TsGShEIKNYWifevvvrqvNuKK6440O55uqp4I+p39913D7hP340RCChSdUDl0ksvzZtjGq6BUgQyYlqrZqWYBi4CK9Wp+lxjewRPwj0Who/07ne/u3r3/DzWuIngRaTqwFq/Hf+7IcoI90jVbRnXdTHF2WAmEYiL6eKKFEG9Yg2gaMe47osUeUcgKD43EgECBAgQIECAAAECtQkIqNTmZW8CBAgQIECAAIE2EIh1R2Lx+PgXa2TEGhbRuR2vi/VTqk8zRhxEp3Ok6s746PCOxbxb0blcdKovsMAC1afW63kx+uDpp5/utb3RL4r1VmLh9MFSdRChOPf/+Z//GXD3t7/97ZVgQN/F6Qc8YIiNtZ7bEFk1/a0YSRMpRjjFqJ7qf7GmzhtvvJHfrw5o1HpShUccN1R7Vecbbbf77rvnETUzZsxIP/nJTypvx5oqMTKlGCFUecMTAgQIECBAgAABAgSGFfjPT+eG3c0OBAgQIECAAAECBNpH4CMf+Uietqj6jKoDANXbi+exEHosch4Lxsei3zHNU4y8iKDKYCM1imMb8VhMNTb77LMPml2MLIg02LRZgx5Y4xvF4vFFecMdHtN9RRru3OO8R3vuL7zwQi5rpOc23Lk38/3XXnstZx8Bu4ECFMW2GPVSbyraKo6vxSTKjCDir371q3T66afnKfHiWo8RK7vttlu9p+M4AgQIECBAgAABAl0tIKDS1c2v8gQIECBAgACBsSswXAClb81iXZPoZH7sscdyB3MEVGItiRjdUkyb1feYRr5+29velrMbarRCEXSZa665Gll0v7wi/1jXI0b6jCTFFFgRVBns3KOjvgi6jPbcY6qsCMqM9NxGcv7N2qeYWi7WdDn00EObUky1Z5gMNAJroILj8xGBkwioXH/99enBBx9MYRtT4p133nkDHWIbAQIECBAgQIAAAQLDCJjyaxggbxMgQIAAAQIECHSGQHQw77nnnrkysYZELGQf0x+1YrqvKDQWgI8U00QVU0HlDVX/mTp1an5V7Fv1VkOfvutd78r5XXfddSPKtzifwYIc06ZNq9RppB3+gxVc67kNlk8rthcjT/761782rbjCIwqIwEgtabPNNksxeiYCXjFKJQKIm266aRpq2rla8rcvAQIECBAgQIAAgW4TEFDpthZXXwIECBAgQIBAFwtE8CSmTYqRIB//+MfT2muvPewv/gcLftTK+IEPfCCPEIhpou68884BD4/RA5GK9V4G3KkBG4vFzWPNmaLMobLdaKON8tt//OMfB9ytCMzEGitLL730gPuMdGNxbpdddlm66667hj2sGPkTi603qq2GLTSlvD7J+9///rxrBDqeeuqpkRxW8z6x4P173vOeHBQ58sgjBx0lNFDGsch9Mb1XTPUV/77whS8MtKttBAgQIECAAAECBAiMQEBAZQRIdiFAgAABAgQIEOgMgXnmmSd96lOfypX5wx/+MOTolIkTJ+b9brrppoZ01Md0S3vttVfO87TTTusHeumll6bbb789Rblf/vKX+73fyA3RyT7//PPnLD/5yU+m3//+90NmH+cdgaiLLrooTxVWvXMEp771rW/lTQcccEBlcfrqfWp5vu+++6a3vvWtKQIkMZriT3/605CHR8Bh/Pj/zGR83HHHDblvo9/caqutUgSRXnnllfTpT386vfjii40uIgduDj744JzvX/7yl7T55punWGh+pCmCiOETI6PiPIuA1UiPtx8BAgQIECBAgAABAm8KCKi8aeEZAQIECBAgQIBAmwrEVFjnnntu7hCOU4yF5S+88MIUHcy1jkoofrEf0x5Fh/hgqVhQ/Oabb07LL7982m+//XJAJEaY3H///enVV1/Nhz7wwAO9OrhjKrFitEJMkfX0009XivjmN7+Z1lprrRQBla9//eupGCFy1FFHpc985jM5aPGjH/2oEuyINUti9MdAZcU0TrEezD/+8Y+cf5Q12JRclRP475P55psv+0WQJ46P9WWWXXbZvHD51772tbTJJpukJZZYIj333HP5iJh2KqaMiuBJdMhffvnleWTLlVdemdZYY430yCOPZMvdd9+9UtTdd9+dHn300fw61muJfYq2inyi7YpUHTR55zvfmdt6ttlmS48//niK9UlWWGGFtMMOO6T9998/l7/MMstUTCLQUwSq4txXXHHFtN5666UYPRJrnER7RLr33nsr10+0T2H197//PUUb9l0fJo4rbGNKr4ceeqhSZnHesbbMmWeemdstRqlEcOeggw5KV1xxRTrnnHNSeOy4445596j7jTfemF544YU82iTarvraiHN64okn8r6xEH0x/Vts+OxnP1sZWRJrosQ0Xh/5yEfyFHa77rprWnPNNfNaQMV5VT/GvltssUUOzMS+ta49VJ2X5wQIECBAgAABAgS6XWBcT/yfWA0pfg01YcKEGo5ozK7dVm7MQz3a+afrke8257Lqq33ruTprP0b71m5WzxFlOZdVrs9vPVdJ7cdo39rN6jmiLOday3399dfT//t//2/QKsY6Eauuuuqg7xdvVH9+Y1qqj370o+nYY48t3h7w8ZRTTkk//OEP0y233JLe/va3pwiIrLTSSumaa67ptX90Uk+ePDlFx3sEHqpTLHgfIzciQBApgiNnnHFGLrsIOMSIjO233z4HWaJTvkgx5VWs81KdirIefvjhHHiofi8CJHvvvXcuayTOEbA44YQTclAg9l9yySXTQgstlOKcI/C0zTbbVGefp+CKaacuueSSFO0SafXVV88BjRjpEscV5UaQqFiovsgkzGP/k046KT377LPF5vwYIy9WWWWVyrYIwET7RGAiAjAR8IkgWExjFaNYIq8iRbAiAhkxJVkERsIogipf+tKX0s9+9rMceIp955133hzgiDpXp9h/4YUXroxYGqgdY5+Yemu77barPjTXN+oSLrHYe5Qf11cEOWJKua233jqPuIkAyg9+8INex0aeX/3qV7NlmFSnuF4iIFP8v1f8b9uUKVPSd77znfwY1hE0iv2iXieeeGJadNFFq7OoPP/lL3+Z4nMS7R3tO5pUtO9o8qjn2OrPbz3H13tMWfXttnK1b71XaG3HlXVdad/a2qnevbVvvXK1HVeWc1nl+vzWdn3Uu7f2rVeutuMa5SygMox7o6CHKabf2/5g9SNpygbt2xTWfpmW5VxWuT6//S6BpmzQvk1h7ZdpWc5llevz2+8SaMqGsts3RghEp3KMiogAwnCp+vdH0QFeaxqsvtX5FnnWk39xbN/Hwcrtu99A5xH7DHYuA+1fve9Iy+17HgO9Hqiswc4tPr/FIvGD7TNQGaPdVtR3oHOtdhltOcXxRTlFucX2ocr69re/nUc6/fznPy92r/uxb7l1Z1Tjgf4+1whW5+7at064Gg8ry7mscn1+a7xA6txd+9YJV+NhZTmXVa7Pb40XSJ27a9864Wo8rFHO/5lsuMbC7U6AAAECBAgQIGEZg0AAACAASURBVEBgrAqcddZZeSTESIIpUcehOqpHY9CsfGs9p1rPo9b9az2f6v1rLavW/avLGu3zVpVdlBOPxfOhzj1GEp188sl5BMtQ+3mPAAECBAgQIECAAIHhBayhMryRPQgQIECAAAECBMaoQCzyHlMtFSkWDY8pk2IqKIlAJwpceumlvaoVU9ZFiinVJAIECBAgQIAAAQIERicgoDI6P0cTIECAAAECBAi0scBtt92WDj300LwY+k033ZQ22mijNPvss+cF4Nv4tJ0agboEYjqwb3zjG+mee+5Jzz33XDr++ONTLER/yCGH5PVt6srUQQQIECBAgAABAgQIVARM+VWh8IQAAQIECBAgQKATBWKKr7PPPjtXLab5uuqqq3Qud2JDq1MWiKDK8ssvX9E48MAD0+c///nKa08IECBAgAABAgQIEKhfQEClfjtHEiBAgAABAgQItLnAxz72sXTuueemJ598Mi9Y/olPfCLNNttsbX7WTo9AfQKxpsqpp56a7r///jwqa7PNNkuLLrroiNZaqa9ERxEgQIAAAQIECBDoLgEBle5qb7UlQIAAAQIECHSVwCKLLJK23377XOdp06YJpnRV63dnZddff/0U/yQCBAgQIECAAAECBBovYA2VxpvKkQABAgQIECBAgAABAgQIECBAgAABAgQIEOgwAQGVDmtQ1SFAgAABAgQIECBAgAABAgQIECBAgAABAgQaLzBu+vTpPY3PVo6jFZg+fXqaOHHiaLNxfJsKaN82bZgGnZb2bRBkm2ajfdu0YRp0Wtq3QZBtmo32bdOGadBpad8GQbZpNtq3TRumQaelfRsE2abZaN82bZgGnZb2bRBkm2ajfdu0YRp0Wtq3PsjxEyZMqOnIGTNmpFqPqamAQXbutnLjguY8yMXQwM1lXVfat4GNOERW2ncInAa+VZZzWeX6/Dbw4hkiK+07BE4D3yrLuaxyfX4bePEMkZX2HQKngW+V5VxWuT6/Dbx4hshK+w6B08C3ynIuq1yf3wZePENkpX2HwGngW2U5l1Wuz28DL54hstK+Q+A08K1GOZvyq4GNIisCBAgQIECAAAECBAgQIECAAAECBAgQIECgMwUEVDqzXdWKAAECBAgQIECAAAECBAgQIECAAAECBAgQaKCAgEoDMWVFgAABAgQIECBAgAABAgQIECBAgAABAgQIdKaAgEpntqtaESBAgAABAgQIECBAgAABAgQIECBAgAABAg0UEFBpIKasCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgc4UEFDpzHZVKwIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCBAgIqDcSUFQECBAgQIECAAAECBAgQIECAAAECBAgQINCZAgIqndmuakWAAAECBAgQIECAAAECBAgQIECAAAECBAg0UEBApYGYsiJAgAABAgQIECBAgAABAgQIECBAgAABAgQ6U0BApTPbVa0IECBAgAABAgQIECBAgAABAgQIECBAgACBBgoIqDQQU1YECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAZwoIqHRmu6oVAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0EABAZUGYsqKAAECBAgQIECAAAECBAgQIECAAAECBAgQ6EwBAZXObFe1IkCAAAECBAgQIECAAAECBAgQIECAAAECBBooIKDSQExZESBAgAABAgQIECBAgAABAgQIECBAgAABAp0pIKDSme2qVgQIECBAgAABAgQIECBAgAABAgQIECBAgEADBQRUGogpKwIECBAgQIAAAQIECBAgQIAAAQIECBAgQKAzBQRUOrNd1YoAAQIECBAgQIAAAQIECBAgQIAAAQIECBBooICASgMxZUWAAAECBAgQIECAAAECBAgQIECAAAECBAh0poCASme2q1oRIECAAAECBAgQIECAAAECBAgQIECAAAECDRQQUGkgpqwIECBAgAABAgQIECBAgAABAgQIECBAgACBzhQQUOnMdlUrAgQIECBAgAABAgQIECBAgAABAgQIECBAoIECAioNxJQVAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0JkCAiqd2a5qRYAAAQIECBAgQIAAAQIECBAgQIAAAQIECDRQQEClgZiyIkCAAAECBAgQIECAAAECBAgQIECAAAECBDpTQEClM9tVrQgQIECAAAECBAgQIECAAAECBAgQIECAAIEGCgioNBBTVgQIECBAgAABAgQIECBAgAABAgQIECBAgEBnCgiodGa7qhUBAgQIECBAgAABAgQIECBAgAABAgQIECDQQIFxU6dO7WlgfrIiQIAAAQIECBAgQIAAAQIECBAgQIAAAQIECHScwLienp6aAiozZsxIEyZMaDlEt5U7bdq0NGnSJM5NFijrutK+TW7Y/2avfTvbWftq32YI+PvcDNX+efr89jdpxpaynMsq1+e3GVdR/zy1b3+TZmwpy7mscn1+m3EV9c9T+/Y3acaWspzLKtfntxlXUf88tW9/k2ZsKcu5rHJ9fuu7ikz5VZ+bowgQIECAAAECBAgQIECAAAECBAgQIECAAIEuEhBQ6aLGVlUCBAgQIECAAAECBAgQIECAAAECBAgQIECgPgEBlfrcHEWAAAECBAgQIECAAAECBAgQIECAAAECBAh0kYCAShc1tqoSIECAAAECBAgQIECAAAECBAgQIECAAAEC9QkIqNTn5igCBAgQIECAAAECBAgQIECAAAECBAgQIECgiwQEVLqosVWVAAECBAgQIECAAAECBAgQIECAAAECBAgQqE9AQKU+N0cRIECAAAECBAgQIECAAAECBAgQIECAAAECXSQgoNJFja2qBAgQIECAAAECBAgQIECAAAECBAgQIECAQH0CAir1uTmKAAECBAgQIECAAAECBAgQIECAAAECBAgQ6CIBAZUuamxVJUCAAAECBAgQIECAAAECBAgQIECAAAECBOoTEFCpz81RBAgQIECAAAECBAgQIECAAAECBAgQIECAQBcJCKh0UWOrKgECBAgQIECAAAECBAgQIECAAAECBAgQIFCfgIBKfW6OIkCAAAECBAgQIECAAAECBAgQIECAAAECBLpIQEClixpbVQkQIECAAAECBAgQIECAAAECBAgQIECAAIH6BARU6nNzFAECBAgQIECAAAECBAgQIECAAAECBAgQINBFAgIqXdTYqkqAAAECBAgQIECAAAECBAgQIECAAAECBAjUJyCgUp+bowgQIECAAAECBAgQIECAAAECBAgQIECAAIEuEhBQ6aLGVlUCBAgQIECAAAECBAgQIECAAAECBAgQIECgPgEBlfrcHEWAAAECBAgQIECAAAECBAgQIECAAAECBAh0kYCAShc1tqoSIECAAAECBAgQIECAAAECBAgQIECAAAEC9QkIqNTn5igCBAgQIECAAAECBAgQIECAAAECBAgQIECgiwQEVLqosVWVAAECBAgQIECAAAECBAgQIECAAAECBAgQqE9AQKU+N0cRIECAAAECBAgQIECAAAECBAgQIECAAAECXSQgoNJFja2qBAgQIECAAAECBAgQIECAAAECBAgQIECAQH0CAir1uTmKAAECBAgQIECAAAECBAgQIECAAAECBAgQ6CIBAZUuamxVJUCAAAECBAgQIECAAAECBAgQIECAAAECBOoTEFCpz81RBAgQIECAAAECBAgQIECAAAECBAgQIECAQBcJjG/3ul577bXpuuuuSzNnzkxzzDFHy0+3rHKnT5+eJk6c2DX1Lcu5rHKjfbfYYou07rrrtryNFUhgrAuU/b3g73NrrqAy/z6X9f278cYb+15ozeWlFAIECBAg0FUC7p9b29xl3ceWVW6Z/3/k/rm117bSCBD4j8D4GTNm1GxRzzE1F/LfA6ZMmZKOOuqoeg93HIG2FYgA4corr9zy82vl57e6csqt1mje825w9r3QvOtHzuUL+F5ofht0w9/JakX1rdZo3nPOzbOtzplztUbznnNunm11zq10dv9cLe95pwm4f25+i7by71V1bZRbrdG855xrtx0/YcKEmo4K5FqPqamAPjuXMSqlzyl4SaApAnFtt/KzFJVo9ee3gOu2cuMXOq1u225qX98LxSfLY6cJ+F5ofov6+9x84yihrO997at9myFQ1vXcbeX6/Dbj6n0zT/fPb1p41lkC7p+b357+PjffOEoo63tf+9bXvm0/5Vd1tWJ6JFMkVYt4PtYEYqh1/JMIEGiMgO+FxjjKpTwB3wvl2SuZAAECBAh0o4D7525s9c6qs/vnzmpPtSEwFgXGXEBl8uTJY9HZOROoCAioVCg8ITBqgfgfQt8Lo2aUQckCvhdKbgDFEyBAgACBLhJw/9xFjd3BVXX/3MGNq2oExoDALGPgHJ0iAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBUAQGVUvkVToAAAQIECBAgQIAAAQIECBAgQIAAAQIECIwFAQGVsdBKzpEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoVUBApVR+hRMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJjQUBAZSy0knMkQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEShUQUCmVX+EECBAgQIAAAQIECBAgQIAAAQIECBAgQIDAWBAQUBkLreQcCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAgVIFBFRK5Vc4AQIECBAgQIAAAQIECBAgQIAAAQIECBAgMBYEBFTGQis5RwIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBUAQGVUvkVToAAAQIECBAgQIAAAQIECBAgQIAAAQIECIwFAQGVsdBKzpEAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoVUBApVR+hRMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJjQWD8WDjJVp3jiy++mG6//fZKcRMmTEgrr7xy5fVYfXLzzTenmTNnVk5/qaWWSgsttFDldSc8ef7559Odd95ZqcoCCyyQlltuucprTwgQIFCPgO+FetTa4xjfC+3RDs6CAAECBAgQ6C4B989jt73dP4/dtnPmBAi0VsAIlSrv+OK/4IIL0u67757WW2+9tMcee1S9O3afXnPNNemUU05JW265Za7XlVdeOWxlnn766fToo48Ou1+xwxtvvJGuvfbaNGPGjGJTSx+fffbZdP7556dddtkl1/GAAw4YVfk9PT0pAlESAQLdLeB74c32973ge+HNq8EzAgQIECBAgMDAAn3vn/fcc8+BdxxjW6v7VdZff/3UDf0qBx544KhaSb/KqPgcTIBAGwsIqFQ1zsILL5xOPfXUSiBl1llnrXp37D496KCD0oUXXjiiERv/+te/0lFHHZUWX3zx9P3vf3/Elb7uuuvSRhttlGaZpZxL6j3veU8+35122mnE5zzYjrfccksembThhhsOtovtBAh0iYDvhZR8L6Tke6FLPvCqSYAAAQIECIxaoLh/jh+qRuqkfpX4Ae5IZsKovn8+44wzRmwaP1LdeOONS+9X2XHHHUd8zoPtGD9QjRlfop9IIkCAQKcJmPJriBbtlC/+oorD1efyyy9PX/3qV9O0adOKQ0b8GDcWm266aZp77rlHfEy77fjkk0+mr3/963mkS5zbXHPN1W6n6HwIEChZYLi/oyWfXs3FD1cf3wu+F2q+qBxAgAABAgQIEKgSGO5+s2rXMfF0uPpcdtllaa+99qq5XyVGc8QPYcd6v8oTTzyRvvGNb1T6VcZyH9GYuCCdJAECpQiUM5yglKr2L/TYY49Nr776av83/rtluC/KQQ9s0zcGGz0SX3jrrrtu2meffdJ2221X87oxr7/+err44ovTJz/5yV41j464v/zlL722teuLY445Jq244or5eth7773b9TSdFwECTRbwvfAfYN8LKfleaPKHTfYECBAgQIBARwi4f/5PMz7++OO5X2Xfffetu1/lkksuSdtss02v62Ks9austNJK+lV6taAXBAh0okDXBlSuvvrqtN9++w0ZUBksADFWL4TBAkSvvPJK+va3v50efvjhdMQRR6RY0L2W9Otf/zover/FFltUDnvppZdSDBO99957K9va+ckSSyyRpk6dmi666KK8Bks7n6tzI0CgOQK+F9509b2Qku+FN68HzwgQIECAAAECAwn86le/Svvvv79+lZRyn0jRr3L44Yc3pF8l1qOJac3HYr9K/GhXIkCAQKcKdO2UX4cccsiwbTpYAGLYA6t2iBEwjz32WIo1Pvqmv/71r+mhhx7K02TF3JKNThEgiV9JzDnnnGmVVVYZdO7S6DQaTYrpvj72sY+lt771rZVsjj/++NIWqK+cRA1PqoNBNRxmVwIEOkjA98Kbjel7ISXfC29eD54RIECAAAECBPoKxBRVkydP7ru53+tO6leJfpvB6jOa++diui/9Kv0uHxsIECDQlgJdN0Llt7/9bfrwhz+cYoGsSJtsskkelvmJT3yiXwPFF+V9992XvvjFL6ZJkyalcePGpXnmmSd97nOf6/ULjBiWGdH34l8EUF544YX0la98JU2cODHtsMMOlbxffvnlFFNKLbTQQumd73xnWmeddXKwY6211hrwVwcnn3xy3ifmnVxyySVTLPAWnTy/+MUvKnlWP3njjTfSmWeemVZbbbUcxFlvvfXS+9///nwesahuo9O///3v9JOf/KQy3VdME7PtttvmES9RVtxgFS6PPvpopfgjjzwyrbnmmultb3tbWnrppbNvtEEswjZQ+tnPfpbzmWOOOXI7LL744vn19ddfP9Du/bZdeeWVlfOI84m1YiQCBAiEgO+Fxl4Hvhca6yk3AgQIECBAgEC7CcT984Ybbpj7VSIYUPSr9J2uKs57sH6VnXfeedB+lejHiH6VGTNmVPpVqhdK/+c//zlgv8raa6/d1H6VeeedNzWrX+WnP/1pZbqv+GFs9KscffTRqQhcRT9GuDS6XyXyrLdfJdaKkQgQINCNAl0XUHnHO96RvvCFL1Ta+sADD0yHHnpoinku+6Y77rgjLyb29re/PQdRIrAyc+bMdPbZZ+ftxf4RCDjppJPS3Xffna677rr8fPnll09/+MMf0myzzVbslh8//vGPpxNOOCF/UT7zzDPptddeywGbG2+8MQdO/vGPf/TaP4I1iyyySIqFzR544IH85R3lxEJlsa1vipuSqN9b3vKWdNVVV6WYtiW+gCMwFPk0Ov3yl7/MdYjziTR+/Pi0yy675ABOvI51VcI3/oV9kc4///y07LLLppguLNZZueaaa9Lvfve7tNFGG/ULqsQQ4i233DKbxU1VLB4fU5NF+/T1KvLv+7jZZpvl+t91113pqKOOSt/5znf67uI1AQJdKuB7obEN73uhsZ5yI0CAAAECBAi0m0DcP3/+85/PpxU/PC36VWJd1r7pT3/604D9KmeddVYOihT7R7/KiSeemPtV4oeW0ceywgor9OtXif6NrbfeOverRH9D9KvED3qiv+aGG27IP6Ss7ieI/fv2q8QPbKNfJfoJ+varxP5Fv0r8oLO6XyX6LlrRrxL9SFGf+IFu+Bb9KvGD1aJfJc6zb79K9K9Ev8rGG2/cq18l9o1+la222qpXv0pMTVZLv0r0+0T9wy76VaJvSyJAgEA3CnTdlF/RiR9TYBUpRobMNddcxctej4suumj+8qzeGL/CiC+zH/zgB+l73/te5a0IoMw+++z5dSzSfuutt+Yvungsovbxi4MpU6akd7/73flGoTj49NNPz4GB+CL/7ne/m4MPxXsRoIiFcWNES6Q4pxjhsueee+ZfK0SgoUhxk3DOOeek+eefP0WHVoxqKVJ86VW/LraP9vHCCy9Mm2++eWW6rwUXXDDFv2L6r/COX1L0TWEei9cV5xRTou26667psMMOS8cdd1zlmH/96185+BGjc2LET5E+/elPZ7PwGUk65ZRT8qieuMGKc5IIECBQCPheKCQa8+h7oTGOciFAgAABAgQItKtA3D8X/88f5zhUv8piiy3Wr18lZg351Kc+lftVog+kSNX9KjH7RtGvEj9WLYI1Rb9KzFpR/UPJ0047rdKvEn011dORRYCiul8lzin6aWLmitg+UL9KrC0bM4MUfRZxjs3oV4lgR6zl2rdf5X/+538qxoP1q8S5VferxLRjRb9KTMNe9MUM1q/ymc98JgekaulXib6mGNGiX6W4aj0SINCNAl03QmW0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ueeem9cZ6ft+o17HYu/xC5cYYjpYKoz7+s4///z5kNdff73fDVAMH+2b4iYj3F566aVeb8Ww1DvuuCOPkFliiSV6vTfQi7POOiuvvxIBmnCSCBAgUC1Q/M2KbX3/blXv1+jnvhdS8r3Q6KtKfgQIECBAgACB5guUcf8cI0322muv3K8Sa4h87WtfG7KitfarRP4HH3xwW/WrRADjd7/7Xa961nr//MILL+Qp0EfTrxI2MTol1rV99NFH8xrAvU7KCwIECHSRQFcGVOadd94893q081ZbbZV/ERCdWtddd12eg3LatGn5EojO/FgYwUlA+QAAIABJREFUPjr/I8XaJXfddVd+Hv+588478/NYF+T++++v/OIhFj2Laaj6/opghRVWqHzpHHPMMXmExbHHHptiEbIYPhlDLk899dSc58ILL5xvFOJFnNtSSy2VF7CPPK6//vq8T/zCIhYVK9Iaa6yR5wWN+TRjYbF4vd9+++W5RWMYZwyLjRTnV/1FGl/QMafotddem+fCjOGekW666aYUwZl4/Pvf/563xX9iWGqcawwvHSyts846+a2oVzyP84jnsXBcjBKJtN1226UVV1wx1+u9731vXhMltv/zn/+snGu8jnVnYsG4U045JZ/jeeedl4M50S4HHXRQnu4l9otzDPdIMa1Y9Zosc889dz7neO/4449PF198cQqnIsUNRix2H9tjfZhI4Rvr18RonLgOop0lAgQ6U8D3gu8F3wud+dlWKwIECBAgQKA5AsX9c/QnDNSvEuvBRmp0v0r0IUyePDnnffTRR4+oXyXOsW+/yg033JDz6Nuv8oEPfCD3XcT2vv0qyy+/fO6riPyij2CwfpVYu7XoV/n973/fr18ljr/oootG3K/yne98Z8B+lcinb7/Kvffem+vVt18lXlf3q0RfT8xyEv1WBx54YK9+lWKa+tH0q1x22WUVX/0qmcJ/CBDoIIFZDz300ENrqU8EFVo5/2YEOaKjP9K6666b/9VyvoPtu8UWW6QY6RGR9QiMzDPPPCmmhjrjjDPyrxGirGWWWSYHLGadddb0rne9K3/h3XrrrZXziHVOYi2QCEZcccUVKaZuieMiABCjUMJp0UUX7XUK8X58QcdojFtuuSXXLQIccTMSc1/GwmpFihEgEUiJL+m55porRTAlRlfsuuuuKc5ptdVWy2uyRDnFGiKx7X3ve1/+xUYEFMIughgnnHBCPrfIb/bZZ8/n96EPfSgXFeuaRJAiRm9EYCHKifOMOsfi7rHoe9Q71i2JYZ277bZbOuKII9JQI0Pi+Phyj8XgwyJMtt1227xAfMwRuthii+W83va2t+WblKOOOioPG41ROXGDFCNQwiSm9grjCGSdc845KUaaxLnEGjERpNlnn31yHeJm57jjjkuRX5QdC9FHAOmDH/xgtogF7KO9472Y6zOexzFFHeILPsqI7fErlthvrbXWyucdQZoIXEVAJfIdTWrW9TzSc2r157c4r24rN4ZgV/9iq3Bo9mO3ODfrc+R74Y/J94LvhWb/nSryL+vvlb/PRQs091H7Nte3yL0s57LK9fktWr65j9q3ub5F7q12bsb9c4xYiA76Z555ptKvEv8vvf322/fqV4n+iPj/6YH6VeLHl9X9KldeeWXuV4ntjehXiXMcrl8l+k+iT6S6X2X11Vfv168S/UPx48zoK6i3X+W2226r9Kt8+ctfTocffnilT6K4NorHOPcoq7pfJfpj6ulXiX6MRvSrRLCm1n6V+P+LaEv9KkXL1v/Y6r8bxZn6/i0kmvuofZvrW+TeKOdxPfHXuYYUH6T4kmxVOuyww1IR84nH4pcIrSpfOQQaKVD29dzqz29h123lxii3SZMmFdVv2WO3OJf9OWpZgyqoKwTKvp675e9GcTH5+1xINPexrOtK+za3XYvctW8h0dzHspzLKtfnt7nXU9n3G82tndy7TaDs67msv5Nllevvc2s+Ydp3bDl35ZRfrWkipRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKdIiCg0iktqR4ECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA0wQEVJpGK2MCBAgQIECAAAECBAgQIECAAAECBAgQIECgUwQEVDqlJdWDAAECBAgQIECAAAECBAgQIECAAAECBAgQaJqAgErTaGVMgAABAgQIECBAgAABAgQIECBAgAABAgQIdIqAgEqntKR6ECBAgAABAgQIECBAgAABAgQIECBAgAABAk0TEFBpGq2MCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAgU4REFDplJZUDwIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBpAgIqTaOVMQECBAgQIECAAAECBAgQIECAAAECBAgQINApAgIqndKS6kGAAAECBAgQIECAAAECBAgQIECAAAECBAg0TUBApWm0MiZAgAABAgQIECBAgAABAgQIECBAgAABAgQ6RUBApVNaUj0IECBAgAABAgQIECBAgAABAgQIECBAgACBpgkIqDSNVsYECBAgQIAAAQIECBAgQIAAAQIECBAgQIBApwgIqHRKS6oHAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0DQBAZWm0cqYAAECBAgQIECAAAECBAgQIECAAAECBAgQ6BQBAZVOaUn1IECAAAECBAgQIECAAAECBAgQIECAAAECBJomIKDSNFoZEyBAgAABAgQIECBAgAABAgQIECBAgAABAp0iIKDSKS2pHgQIECBAgAABAgQIECBAgAABAgQIECBAgEDTBARUmkYrYwIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBTBARUOqUl1YMAAQIECBAgQIAAAQIECBAgQIAAAQIECBBomoCAStNoZUyAAAECBAgQIECAAAECBAgQIECAAAECBAh0ioCASqe0pHoQIECAAAECBAgQIECAAAECBAgQIECAAAECTRMY37Scm5Dxtdde24RcZUmgdQKu4dZZK6k7BHymuqOdO7mWruFObl11I0CAAAEC7Sfg3qP92sQZ1SbgGq7Ny94ECDReYPyMGTNqzrWeY2ou5L8HzJw5s3Jo/NH0h7PC4ckYF4hru5WfpYKrjDKjbOUWLdDcx25w9r3Q3GtI7uUJ+F5ojX03/J2sllTfao3mPefcPNvqnDlXazTvOefm2Vbn3Epn98/V8p53koD759a0Ziv/XlXXSLnVGs17zrl22/ETJkyo6ahArvWYmgros/Mcc8zRZ4uXBDpDIK7tVn6WQq3Vn9+ipbqt3OnTp7e8bbupfX0vFJ8sj50m4Huh+S3q73PzjaOEsr73ta/2bYZAWddzt5Xr89uMq/fNPN0/v2nhWWcJuH9ufnv6+9x84yihrO997Vtf+7b9lF/rrLNOOvTQQ1NEncu4CSir3LigJ06cWF+rjuKosurbbeVG+8a1LREgULtA2d8L/j7X3mb1HFHW90KZ7et7oZ4rxTEECBAgQIDAcALun4cTauz7Zd3HllWu++fGXj9yI0Cg/QXaPqCy7rrrpvhXVqSurHKnTZuWJk2a1PIrqKz6dlu5ZbVvyy8oBRJogkDZ3wtlfX677e9kWfXttvZtwkdUlgQIECBAgECbCbh/bm2DlHUfW1a57p9be30pjQCB8gVmKf8UnAEBAgQIECBAgAABAgQIECBAgAABAgQIECBAoL0FBFTau32cHQECBAgQIECAAAECBAgQIECAAAECBAgQINAGAgIqbdAIToEAAQIECBAgQIAAAQIECBAgQIAAAQIECBBobwEBlfZuH2dHgAABAgQIECBAgAABAgQIECBAgAABAgQItIGAgEobNIJTIECAAAECBAgQIECAAAECBAgQIECAAAECBNpbQEClvdvH2REgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJtICCg0gaN4BQIECBAgAABAgQIECBAgAABAgQIECBAgACB9hYQUGnv9nF2BAgQIECAAAECBAgQIECAAAECBAgQIECAQBsICKi0QSM4BQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKC9BQRU2rt9nB0BAgQIECBAgAABAgQIECBAgAABAgQIECDQBgICKm3QCE6BAAECBAgQIECAAAECBAgQIECAAAECBAgQaG8BAZX2bh9nR4AAAQIECBAgQIAAAQIECBAgQIAAAQIECLSBgIBKGzSCUyBAgAABAgQIECBAgAABAgQIECBAgAABAgTaW0BApb3bx9kRIECAAAECBAgQIECAAAECBAgQIECAAAECbSAgoNIGjeAUCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgfYWEFBp7/ZxdgQIECBAgAABAgQIECBAgAABAgQIECBAgEAbCAiotEEjOAUCBAgQIECAAAECBAgQIECAAAECBAgQIECgvQUEVNq7fZwdAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0AYCAipt0AhOgQABAgQIECBAgAABAgQIECBAgAABAgQIEGhvAQGV9m4fZ0eAAAECBAgQIECAAAECBAgQIECAAAECBAi0gYCAShs0glMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIE2ltAQKW928fZESBAgAABAgQIECBAgAABAgQIECBAgAABAm0gIKDSBo3gFAgQIECAAAECBAgQIECAAAECBAgQIECAAIH2FhBQae/2cXYECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAGwgIqLRBIzgFAgQIECBAgAABAgQIECBAgAABAgQIECBAoL0Fxrf36Tk7Ap0lcO2116brrrsuTZ8+PU2cOLHllZs5c2aaY445lNtkgW5s34033jitu+66TZaVPQECBAi0s0Bxn1PW/UY3fv92031dme3rPqed//I4NwIECBAgQIBAawXGTZ06tae1RSqNQPcKnHDCCSn+SQQ6TWCvvfZK8U8iQIAAge4VcJ/TvW3f6TV3n9PpLax+BAgQIECAAIGRC4yfNGnSyPdOKc2YMSNNmDChpmMasXO3lTtt2rRUa9twrl2g1ddVGaNSaldxBIHaBeLabvXfrFZ/fgsVf58LieY+at/m+ha5l+VcVrk+v0XLN+fRfU5zXOVavkA33ef4+9ya660s57LK9f3b2deV9tW+zRAo6+9Vt5Xr81vf1WvKr/rcHEVg1AIxPZIpkkbNKIMSBWJql/gnESBAgACBvgLuc/qKeD3WBNznjLUWc74ECBAgQIAAgdYICKi0xlkpBPoJREfD5MmT+223gcBYEhBQGUut5VwJECDQOgH3Oa2zVlLzBNznNM9WzgQIECBAgACBsSowy1g9cedNgAABAgQIECBAgAABAgQIECBAgAABAgQIEGiVgIBKq6SVQ4AAAQIECBAgQIAAAQIECBAgQIAAAQIECIxZAQGVMdt0TpwAAQIECBAgQIAAAQIECBAgQIAAAQIECBBolYCASquklUOAAAECBAgQIECAAAECBAgQIECAAAECBAiMWQEBlTHbdE6cAAECBAgQIECAAAECBAgQIECAAAECBAgQaJWAgEqrpJVDgAABAgQIECBAgAABAgQIECBAgAABAgQIjFkBAZUx23ROnAABAgQIECBAgAABAgQIECBAgAABAgQIEGiVgIBKq6SVQ4AAAQIECBAgQIAAAQIECBAgQIAAAQIECIxZAQGVMdt0TpwAAQIECBAgQIAAAQIECBAgQIAAAQIECBBolYCASquklUOAAAECBAgQIECAAAECBAgQIECAAAECBAiMWQEBlTHbdE6cAAECBAgQIECAAAECBAgQIECAAAECBAgQaJWAgEqrpJVDgAABAgQIECBAgAABAgQIECBAgAABAgQIjFmB8WP2zJ04AQJDCrz44ovp9ttvr+wzYcKEtPLKK1dej9UnN998c5o5c2bl9Jdaaqm00EILVV53wpPnn38+3XnnnZWqLLDAAmm55ZarvPaEAAECBAh0u4D7nLF7BbjPGbtt58wJECBAgAABAgRSElBxFRDoUIHoaLjgggvSjTfemO6555605ppr5udjvbrXXHNNuuuuu9KUKVPSjBkz0mmnnZZ22WWXXtV67LHH0iOPPJLGjRuX5ptvvrT44ounOeecs9c+Q71444030vXXX58DUBGIanV69tln0/nnn5+uu+669OCDD6ZNN900XXnllSM+jVdeeSX96U9/Sq+++mp6y1vekiZNmpSDTuEhESBAgACBThBwn+M+x31OJ3yS1YEAAQIECBAgMPYETPk19trMGRMYkcDCCy+cTj311LTHHnvk/WedddYRHdfuOx100EHpwgsvHHTExvve974cQNhss83SN7/5zbTzzjuneeaZJ6266qrpmGOOSa+//vqwVYxAxkYbbZRmmaWcP5Hvec970ve///200047DXuufXeIANPEiRPThz70ofTVr341HXDAAdkqRrl87nOfS1OnTu17iNcECBAgQGDMCbjPcZ/jPmfMfWydMAECBAgQIECgIwTK6S3sCDqVIDC2BDoloFKoD1afRx99NO2///4pRnnccMMN6dZbb00PP/xwmnfeefP2DTbYoNeUYUV+1Y8xsidGhcw999zVm8fE86eeeiq9613vSg888ECeNuzaa69N//jHP9KBBx6YR70sv/zyKUb5SAQIECBAoJMEBrsvGKt1HKw+7nPc54zVa9p5EyBAgAABAgQ6RUBApVNaUj26XuDYY4/NUzwNBjHY/5gPtn+7bx9q9MgXv/jFNPvss1eqEFNe/fznP8/Tf8Xokxi1MViKESwXX3xx+uQnP9lrl8svvzz95S9/6bWtXV9svPHGKUa5FCnaft9990377bdfeumll9JnPvOZFPOXSwQIECBAYKwIuM95s6Xc57jPefNq8IwAAQIECBAgQKDVAgIqrRZXHoEmCFx99dW5szzmkh4sDRWAGOyYdt4+WIBovfXWS0sssUS/U4+1RGJ0SqQf//jH/d4vNvz617/OI1i22GKLYlMOQuy4447p3nvvrWxr1ycxOiWmKxsobbLJJnlzjFgxSmUgIdsIECBAoB0F3Oe82Sruc9znvHk1eEaAAAECBAgQIFCGgEXpy1BXJoEGCxxyyCHD5jhYAGLYA6t2iIBNLPhePfqhePuvf/1reuihh/I0WSuvvHKxuWGPMW3X448/nheXX2WVVdJg9bnkkksGLbNYYD4CCq+99loaP77/n8CY7utjH/tYeutb31rJ5/jjj08zZsyovG7nJ0Otu1LUP84/pgaTCBAgQIDAWBBwn/NmK7nPGXx9Ofc5b14nnhEgQIAAAQIECDRPwAiV5tnKmUDTBX7729+mD3/4w+nmm2/OZcUIhHXXXTd94hOf6Fd2BCDuu+++FNNExBRY48aNy4u1x0Ll1SNb4n/UI4/iXwRQXnjhhfSVr3wlL3a+ww47VPJ++eWX0957750WWmih9M53vjOts846KYIda6211oCjOU4++eS8T6xNsuSSS6ZYUDZGgvziF7+o5Fn95I033khnnnlmWm211XIQJ36V+f73vz+fxy233FK964ieP/nkk3m/FVZYYcBgyr///e/0k5/8pDLd1xNPPJG23Xbb9O1vfzsfN3ny5IpLzGFepCOPPDKtueaa6W1ve1taeumls2+0QaxfMlD62c9+lvOZY445cjssvvji+fX1118/0O79tl155ZWV84h2ikVZR5KK+se+zQh6jeQc7EOAAAECBEYq4D5npFL/2a/4nnef4z6ntivH3gQIECBAgAABArUICKjUomVfAm0m8I53vCN94QtfqJxVLDx+6KGH5vUyKhv/++SOO+5Ie+21V3r729+eIogSgZWZM2ems88+O28v9o9AwEknnZTuvvvuFOuNxPNYyPwPf/hDmm222Yrd8uPHP/7xdMIJJ6RtttkmPfPMM3nUR+R744035sBJjASpThGsWWSRRdJll12WF02PoEiUEwvAx7a+aeedd871i+m6rrrqqvTKK6+knp6eHBiKfGpNMcIlUjH1V9/jf/nLX+Y6xPlEihEsu+yySw7gxOtYVyV841/YF+n8889Pyy67bIrpwmKdlZhO63e/+12eeqtvUGX//fdPW265ZTaLYFV0fhxxxBEp2qevV5F/38fNNtssO951113pqKOOSt/5znf67jLg66L+EdBaddVVB9zHRgIECBAg0C4C7nNqa4nie959jvuc2q4cexMgQIAAAQIECNQi0H++m1qOti8BAqUKRCf+nHPOWTmHGBky11xzVV5XP1l00UVzUKJ624YbbpiDBD/4wQ/S9773vcpbEUApFnWPRdpvvfXWHECIxwjKRPrpT3+apkyZkt797nenE088sXLs6aefngMDESD57ne/m4MPxZsRoDjmmGPyiJbYFucUI1z23HPPdPTRR+dAQ7FvBF/OOeecNP/886cIdEQQoEgRTKl+XWwf6jECHX/+859zUGifffYZcNcLL7wwbb755pXpvhZccMEU/4rpv8I7RoT0TWEei+UW5xRTou26667psMMOS8cdd1zlmH/96185+BGjc2LET5E+/elPZ7OBpiAr9ql+POWUU/KonhtuuCEHcqrfG+r5j370o/z2HnvsUanTUPt7jwABAgQIlCngPmfk+u5zUnKfM/LrxZ4ECBAgQIAAAQL1CxihUr+dIwmMeYGYLixSdPTHGigDpY985COV0Rgx9VaMaIl0xhln5McYpdI3xciSSDG1VXWKERwxPVh1WnHFFfPLadOmVW+uBGliNE0RqOi1Q40vDj/88HzEt771rTzVWN/DY/TLpZdeWpnuq+/7Q72OKdf6nuNA9YrRKDGt2P3335+mTp3aK8sIcsT0Z8OlCH4ddNBBqdZgSowwihFHEQA7+OCDhyvG+wQIECBAYMwLuM95swnd57xp4RkBAgQIECBAgACB0QgIqIxGz7EExrhA9YiI6OgfSVpiiSXybrfddlt+jA76vinWEonUN2jQd794XZxDrJdSpJiK7KabbsovY82U0abLL788/2px4403Tl/72tcGzO7nP/953h7TaTUiDVSvWGcmAi9R1/XXXz+P8KmlrJhabLfddqs5mPLiiy+mT33qU3lUSqy/Emu3SAQIECBAoNMFiu/iqKf7HPc5nX69qx8BAgQIECBAgEBrBEz51RpnpRDoOIFivY9YvyOmyqpOzz33XH4ZgZG+KUZnxNRhDz/8cF7DJUZa9E0RiHnttdfy5kmTJvV9u6bXMTIjptSKaUMuvvjiNMssA8eRL7jggrTVVlv1WydmpIXde++9KdaEiXVR/vnPf6bf/OY3/Q6NtWBierQYdROL2sfon1gcPhaV33bbbYcsO6ZA++xnP5vXkIlpPaI+I0nhGGu2xLzqV1xxRVpmmWVGcph9CBAgQIBAVwu4z+nd/O5zent4RYAAAQIECBAg0L0CA/csdq+HmhMgUKPA0ksvndcIibVFin8xDdjkyZPz1FRFdg8++GBac801cyDgj3/8Y4pASYwYGWiaq+eff744rN9UWpU3RvAkFm2PMmIUTQQ4+k7LVWQR02D84he/qGu6r6jLSiutlAMjEeiI9VM++tGPpk022aTIvtfjTjvtlO6+++4c5Im1Wf70pz+l2BaBlcFG9Nx+++1p++23rywkv/vuu6cZM2b0ynegFxFM+cxnPpOn+jrrrLPyeQ20n20ECBAgQIDAwALuc9znDHxl2EqAAAECBAgQINCtAuNH0inXF6eeY/rmUc9r5dajVvsxnGs3G+kRA43YGOmx7bbfnHPOmV5++eU8lVSMABkq9fT0pJjHPEZvnHzyyb0WZI/1W/qmBRZYoLIpgh31pAhCRJkf+MAH0kUXXZRi4fjBUqydEtOCRCCklhQBi4022ig9++yzeZTOJz/5ycrhg61JEzsst9xy6cc//nFeuyamGov1U+655560wQYb5JE7lUz++yQCTLEeTQRdFl988fT000+nffbZJ5155pl9d628jqlNIlgVU6f96le/ylOMVd5swpO4tsv421FGmcGn3CZcRANkyXkAlCZs4twE1AGy7AZn9znuc+LSd58zwB+AOjd1w9+Nahr1rdZo3nPOzbOtzplztUbznnNunm11zpyrNZr3nHPzbKtzboTz+AkTJlTnOezzKLTWY4bNdAQ7dFu506dP5zyC62K0u7T6uuqktStihEmMyIiF1odLTz31VA6mxH4x3dVwKdYaGTduXJ7eKkZtRCChlhSLxG+44YZ5vZH/+7//y3kNdXxM9xXTYs0222xD7dbvvah/BFMiGFMdTOm34yAbYgqwGM0TI1xiCq9HHnkkPfHEE2mRRRbpdUQEhoqFdU866aS0ww47pFicfscdd0xrr712r33jRQShYi2YcL/jjjvyaKB+OzV4Q1zbrf5uaPXntyDz97mQaO6j9m2ub5F7Wc5llevzW7R8cx7d57jPqb6y3OdUa9T+vKy/k2WV6+9z7ddIPUdo33rUaj+mLOeyyvX5rf0aqecI7VuPWu3HlOVcVrk+v7VfI3GEKb/qc3MUgbYUqF7YvdknWCwW/6Mf/WjYouKLoUivvvpq8XTQxxj9EuuLRIqRGbWka665Jk/zdeqpp6Zvf/vbwwZTYsH2q666akQBkb6+Rb1iBE78Gy5FcOj000/vt1tMSVasiRJfZkOlWEclgkWRIqDSdwRPrN8SC95HkCfWdBntGjRDnYv3CBAgQIBAKwX6fg83s2z3OW+OxnSf08wrTd4ECBAgQIAAAQJjTcCi9GOtxZwvgT4CEydOrGy58cYba562qnJwjU/23nvvdM4556RYQ2T//fdPRx999KA5xMiFWAw+OkLOPvvstNdee1X2LRZ9rWz475NDDjkkTZkyJZ177rkp1gwZySiVCKbE2iVrrbVWijVbDj300L7ZVl5HYCKmz4rF3uMXtbHWymCpMA7fbbbZprLb/PPPn5+//vrreQqvWFi+SH/729+Kp5XHCN6EW+xXPQXZn//85zySJEbILLHEEpX9B3sS66HEfhGgCafCPqZPW2edddJDDz2UpxE75phjBssiLbXUUnl9lUF38AYBAgQIEGgDgeI7OE7FfY77HPc5bfChdAoECBAgQIAAgS4XEFDp8gtA9ce+wLzzzpvnqo5O+a222iptvvnmecqomMJq+eWXT9OmTcuVjM78CDLEaIhZZ501r98Ri7YX6c4778yjGWJdkIcffjgVI0keeOCBtMwyy6SFF144B0WK/VdYYYW88HwELaLjPhZ133nnnfO+Uc51112XR1J86UtfysdGEOW4447LAYVTTjklLbTQQunMRfcfAAAgAElEQVS5555La6yxRs4yyovF2uOcI8X2mN7qK1/5SlpllVVS/FL0Qx/6UHr88cfzeiPFVGNxfi+99FIOUPz6179OsXZILEAf/4ZKH/zgB3NA5cILL0xbb731kNN9xf+833rrrenEE0/MgY/VVlstLbbYYmnPPffMo0QisLTddtulmF4s2iOCKWuuuWYuPkaM3Hfffem9731vfh3rzkQbRWAmFrqNKb6+/vWvpwjKHHzwwSmmx4j097//Pb8Xz2NasViTJdog0txzz53P+bzzzkvHH398Wn311fOUZbFfrB0T6fDDD8+Pg/1n0003FVAZDMd2AgQIEGgbAfc57nPc57TNx9GJECBAgAABAgQIpJQEVFwGBDpAIKasOuCAA9KVV16ZYoH1WG8jAhjf/e530+yzz54DH1HN888/P6233np5FMNPfvKTFMGIyZMnZ4EYaTLffPPlqatipEcslB7pmWeeSWeccUYewRELvFenODYCHxFQiWDGgQcemIMfMUJk1113zQu2F/sfe+yx6X3ve18e1RJBj1iwNEaJxLZFF100BxTinCIAUQRZvvzlL+fARSzgHgGjWIQ9AgGx5kmsNxLnHCkWuv/GN76R610EJIpyB3uM0Smx2Hucd7gNlY444ogc6Lj44ovT9ddfnxckL0aFxIibWMckzimmxFhxxRVzYGnJJZfM9Yp8470IdkWZETSJacwiGBPBq1gvJQJGEZj64he/mE8jgkvf+9730jve8Y5K+0Tb7bfffnkKsxiBEnkVbRcL2seIlwg4FduGqk+8FyNUJAIECBAgMBYE3Oe4z3GfMxY+qc6RAAECBAgQINAdAuN6RjLxf5VFWYvkdFu5MaqgjLUPus251fU97LDDKtNQRQf6SDu/qz6CnhJoG4Gyr+dWf34LeH+fC4nmPmrf5voWuZflXFa5Pr9FyzfnsezvhebUSq7dKlD29VzW38myyvX3uTWfNO3b2c7aV/s2Q8Df52ao9s/T57e/STO2NMrZovTNaB15EiBAgAABAgQIECBAgAABAgQIECBAgAABAh0lIKDSUc2pMgQIECBAgAABAgQIECBAgAABAgQIECBAgEAzBARUmqEqTwIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCjBARUOqo5VYYAAQIECBAgQIAAAQIECBAgQIAAAQIECBBohoCASjNU5UmAAAECBAgQIECAAAECBAgQIECAAAECBAh0lICASkc1p8oQIECAAAECBAgQIECAAAECBAgQIECAAAECzRAQUGmGqjwJECBAgAABAgQIECBAgAABAgQIECBAgACBjhIQUOmo5lQZAgQIECBAgAABAgQIECBAgAABAgQIECBAoBkCAirNUJUnAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0FECAiod1ZwqQ4AAAQIECBAgQIAAAQIECBAgQIAAAQIECDRDQEClGaryJECAAAECBAgQIECAAAECBAgQIECAAAECBDpKQEClo5pTZQgQIECAAAECBAgQIECAAAECBAgQIECAAIFmCAioNENVngQIECBAgAABAgQIECBAgAABAgQIECBAgEBHCQiodFRzqgwBAgQIECBAgAABAgQIECBAgAABAgQIECDQDAEBlWaoypMAAQIECBAgQIAAAQIECBAgQIAAAQIECBDoKAEBlY5qTpUhQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEmiEgoNIMVXkSIECAAAECBAgQIECAAAECBAgQIECAAAECHSUgoNJRzakyBAgQIECAAAECBAgQIECAAAECBAgQIECAQDMEBFSaoSpPAgQIECBAgAABAgQIECBAgAABAgQIECBAoKMEBFQ6qjlVhgABAgQIECBAgAABAgQIECBAgAABAgQIEGiGgIBKM1TlSeD/b+9uwOyoygMAn4SIQcCNhYqlaAAV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RbT3+uP+3Hsx12MCBAgQqE5AQqU6WzUTIECAAAECBCYsEF/YLV26dMLlFSTQjQISKt0YFcc0VQH356kK2r8bBNyfuyEKjoEAAQIEmiAwswmd0AcCBAgQIECAAAECBAgQIECAAAECBAgQIECAQJUCEipV6qqbAAECBAgQIECAAAECBAgQIECAAAECBAgQaISAhEojwqgTBAgQIECAAAECBAgQIECAAAECBAgQIECAQJUCEipV6qqbAAECBAgQIECAAAECBAgQIECAAAECBAgQaISAhEojwqgTBAgQIECAAAECBAgQIECAAAECBAgQIECAQJUCEipV6qqbAAECBAgQIECAAAECBAgQIECAAAECBAgQaISAhEojwqgTBAgQIECAAAECBAgQIECAAAECBAgQIECAQJUCEipV6qqbAAECBAgQIECAAAECBAgQIECAAAECBAgQaISAhEojwqgTBAgQIECAAAECBAgQIECAAAECBAgQIECAQJUCEipV6qqbAAECBAgQIECAAAECBAgQIECAAAECBAgQaISAhEojwqgTBAgQIECAAAECBAgQIECAAAECBAgQIECAQJUCEipV6qqbAAECBAgQIECAAAECBAgQIECAAAECBAgQaITArEb0QicIECBAgAABAgTaCjz44IPphhtuGCrT19eX5s2bN/R5ur659tpr07p164YOf8cdd0y/93u/N/S5CW/uv//+9J3vfGeoK1tuuWV60YteNPTZGwIEpreA+/P0jZ/78/SNnSMnQIAAAQKTFZBQmayc/QgQIECAAAEC00ggvrD7/Oc/n/7rv/4rrV69Ou29997pmmuumUY9GP1Qv/71r6ebbropXXHFFWlwcDB98pOfTH/2Z3+2QeEnnngirVmzJv34xz/O1j/zmc9Mz3ve89JTnvKUDcqN9SH2v/rqq7MEVCSiOr3cd9996YILLsiO4Yc//GF63etel7785S8XOowHHnggffe7382ST7Nnz06ReHrGM55RqA6FCRCoRsD92f3Z/bmaa0utBAgQIECgCgGP/KpCVZ0ECBAgQIAAgS4T2HrrrdO5556b/uqv/iqtX78+zZzZjF8DTzzxxCxRtPPOO2f9Gs6+YMGCtOmmm6YXv/jFKcqecMIJabfddkuRGDniiCNSJCjGW1atWpX222+/2swi+fOpT30qHXnkkVkfI34TXZYvX56e9axnpTlz5mSJppNPPjkddNBBaYsttki77757Ou+88yZalXIECFQk4P7s/hx/COD+XNEFploCBAgQIFCyQDP+T7pkFNURIECAAAECBJooMGPGjKFubbTRRkPvp/ub6NdY/bnlllvSW97ylnTPPfdkI3K++c1vpjvvvDO99KUvTZ/5zGfSrrvumm6++ea2BDGy58ADD0ybb75523JVbmyNXZF27rrrrjRr1qysj/HYsCuvvDL99Kc/TR/72MfSt7/97fS2t70tLVmypEiVyhIgUIFA6zU+1v2sgmYrr9L9eWxi9+exbWwhQIAAAQLdLCCh0s3RcWwECBAgQIAAgUkKfOQjH0mPPvromHs36Qu76GS7ETdvfetbs1Eq8cVe/Gy11VbpP/7jP7K5Vn71q1+lD3zgA2M6Pf744+mLX/xiOvTQQzcoE/t/73vf22Bdt36IUToxgifvf1i9613vykbrxGiXs88+O/3kJz/p1sN3XAQaJ+D+/GRI3Z/dn588G7wjQIAAAQLTQ0BCZXrEyVESIECAAAECBCYs8J//+Z/puOOOa5tQaZeAmHBDXVRwrATRPvvskz3aavihxmiTN77xjdnqGMUy1vK1r30tm3ckHpOVLw899FBavHhxNidJvq5bX7fddttsdM1ox3f44YdnqyNp9P3vf3+0ItYRIFCygPvzk6Duz+7PT54N3hEgQIAAgekjYFL66RMrR0qAAAECBAgQmJDA0qVLR51PpHXnsRIQrWXGex8jYOLxWTHHx/AlRjzcdttt2WOy5s2bN3zzlD//6Ec/yiaZf9rTnpbmz58/5iO/LrroomxkxmgN5pOyb7LJJqNtztblj/tqLROPyxoYGBhzn27aEImfsZa8/7G9tX9jlbeeAIGpC7g/P2no/uz+/OTZ4B0BAgQIEJg+AkaoTJ9YOVICBAgQIECAQFuBq666Kr3mNa9JMU9ILAcccEBauHBhevOb3zxiv0ioxKiEmAg3RjHEiJWYqP1P//RPNxjZ8q//+q9ZHVFP/EQC5YEHHsgmt48v5GOi9Hx55JFH0jHHHJNiguVtttkm9ff3Z6NDXvnKV446muPv//7vszJPf/rT04477ph+//d/Pxs18pWvfCWvcoPXJ554In36059Oe+65Z3r+85+f9t1332wulDiO6667boOy+Yd4zNVYy3e/+91s00te8pJRizz22GPp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gAABAgQIECBAgAABAgQIECDQEAEJlYYEUjcIECBAgAABAgQIECBAgAABAgQIECBAgACB6gQkVKqzVTMBAgQIECBAgAABAgQIECBAgAABAgQIECDQEAEJlYYEUjcIECBAgAABAgQIECBAgAABAgQIECBAgACB6gQkVKqzVTMBAgQIECBAgAABAgQIECBAgAABAgQIECDQEAEJlYYEUjcIECBAgAABAgQIECBAgAABAgQIECBAgACB6gQkVKqzVTMBAgQIECBAgAABAgQIECBAgAABAgQIECDQEIFZDemHbhAgQIAAAQIEprXAypUrp/XxO3gCzmHnQFMFnNtNjWzv9Ms53Dux1lMCBAgQqF5g1uDgYOFWJrNP4UZG2UG7o6BUsIpzBaijVMl5FJQKVnGuAHWUKjmPglLBKs4VoI5SZSed161bN3QE8WWHLzyGOLyZ5gJxbnfyWsq56mgz2tZuHoFqXzvp7P5cbSzVXp+A+3Nn7Dt5v2rtkXZbNap7z7k629aaObdqVPeec3HbWX19fYX2CuSi+xRqYIzCvdbuwMAA5zHOhTJX13VeiW+ZURy7LvEd26bMLXU519Wu67fMs2fsunolvrNnzx4bwRYC01ggzu1O/z+D+3NnThj35844a4VAVQLuz1XJPllvXffJutr17++Tsa/ynfhWqftk3XU519Wu6/fJ2Bd555FfRbSUJUCAAAECBAiUKLBgwYK0bNmyFH8tWkdypdfajf9hmDNnTokRnFhVveYc/Y1z20JgOgu4P3c2eu7PnfF2f+6Ms1YIECBAoNkCEirNjq/eESBAgAABAl0s0N/fn+Knrr9I6rV2165dm+bOndvxM6LXnOvqb8cDq8FGC7g/dza87s+d8XZ/7oyzVggQIECg2QIzm909vSNAgAABAgQIECBAgAABAgQIECBAgAABAgQITF1AQmXqhmogQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGi4godLwAOseAQIECBAgQIAAAQIECBAgQIAAAQIECBAgMHUBCZWpG6qBAAECBAgQIECAAAECBAgQIECAAAECBAgQaLiAhErDA6x7BAgQIECAAAECBAgQIECAAAECBAgQIECAwNQFJFSmbqgGAgQIECBAgAABAgQIECBAgAABAgQIECBAoOECEioND7DuESBAgAABAgQIECBAgAABAgQIECBAgAABAlMXkFCZuqEaCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgYYLSKg0PMC6R4AAAQIECBAgQIAAAQIECBAgQIAAAQIECExdQEJl6oZqIECAAAECBAgQIECAAAECBAgQIECAAAECBBouIKHS8ADrHgECBAgQIECAAAECBAgQIECAAAECBAgQIDB1AQmVqRuqgQABAgQIECBAgAABAgQIECBAgAABAgQIEGi4gIRKwwOsewQIECBAgAABAgQIECBAgAABAgQIECBAgMDUBSRUpm6oBgIECBAgQIAAAQIECBAgQIAAAQIECBAgQKDhAhIqDQ+w7hEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJTF5BQmbqhGggQIECAAAECBAgQIECAAAECBAgQIECAAIGGC0ioNDzAukeAAAECBAgQIECAAAECBAgQIECAAAECBAhMXUBCZeqGaiBAgAABAgQIECBAgAABAgQIECBAgAABAgQaLjCr4f3TPQIECBAgQIAAAQIECBAgQIAAAQIECBAgQGAUgaOOOiptu+22acGCBam/v3+UEla1CkiotGp4T4AAAQIECBAgQIAAAQIECBAgQIAAAQIEekRgzZo1acWKFVlvI7GyePHiNHfu3Oy1RwgKdVNCpRCXwgQIECBAgAABAgQIECBAgAABAgQIECBAoHkCkVxZtmxZ1rGTTz55KKmydOnS5nV2kj0yh8ok4exGgAABAgQIECBAgAABAgQIECBAgAABAgSaKJAnVyLBMmPGjLRw4cIUSZZeXyRUev0M0H8CBAgQIECAAAECBAgQIECAAAECBAgQINBGYOXKldnolV5PrkiotDlJbCJAgAABAgQIECBAgAABAgQIECBAgAABAgSeFGhNrmy33XY9NXJFQuXJ88A7AgQIECBAgAABAgQIECBAgAABAgQIECBAYIIC+aPBYuRKLyRXZqxfv379BG2yYoODg6mvr6/ILqWUfe9735tmz55dSl1FKlm3bl0t7Q4MDKQ5c+YUOdRSytbV315rV3xLOV3HraSu80p8xw1NKQXEtxTGcSupy7mudl2/454SpRQQ31IYx62kLue62nX9jntKlFJAfEthHLeSupzratf1O+4pUUoB8S2FcdxK6nKuq13X77inRCkFxLcUxnErqcu5rnbz63fFihUpkiJlL9tuu202qf2RRx6Z4n2+1JVfKKvdGQMDA4USKnnHO/1aR3Kh033UHgECBAgQIECAAAECBAgQIECAAAECBAgQaJLAc57znLRo0aLsJ95P52VW0dEmZWVypjOaYydAgAABAgQIECBAgAABAgQIECBAgAABAgTGF5g5c2b2FKj77rsvRUKlaE5i/BbGL1FWXmPW+E11R4n3vOc9tTx6q+4hV53Wr6u/vdZuPqROfKsVqOu8Et9q45rXLr65RLWvdTnX1a7rt9rzKa9dfHOJal/rcq6rXddvtedTXrv45hLVvtblXFe7rt9qz6e8dvHNJap9rcu5rnZdv9WeT3nt4ptLVPtal3Nd7ebXb9WP/FqwYEHq7+8fCl4kNqbzMq0SKtM5c1X0JFm7dm2aO3du0d2mXL6sTF3RA+m1dsW36BkyufJ1nVfiO7l4Fd1LfIuKTa58Xc51tev6ndx5UnQv8S0qNrnydTnX1a7rd3LnSdG9xLeo2OTK1+VcV7uu38mdJ0X3Et+iYpMrX5dzXe26fid3nhTdS3yLik2ufF3OdbWbX78rV64sbQ6VseZNmVxEunOvaZNQ6U4+R0WAAAECBAgQIECAAAECBAgQIECAAAECBHpPIBIo8RMTz8colNbJ55uqIaHS1MjqFwECBAgQIECAAAECBAgQIECAAAECBAgQKFGgNYmyePHiEmueHlVJqEyPODlKAgQIECBAgAABAgQIECBAgAABAgQIECDQcYFIosQIlJgPpReTKK3gEiqtGt4TIECAAAECBAgQIECAAAECBAgQIECAAIEeF5BEGf0EkFAZ3cVaAgQIECBAgAABAgQIECBAgAABAgQIECDQMwKSKOOHWkJlfCMlCBAgQIAAAQIECBAgQIAAAQIECBAgQIBA4wQiiRKP8conlm9cB0vukIRKyaCqI0CAAAECBAgQIECAAAECBAgQIECAAAEC00Hg/PPPnw6H2TXHOLNrjsSBECBAgAABAgQIECBAgAABAgQIECBAgAABAgS6VEBCpUsD47AIECBAgAABAgQIECBAgAABAgQIECBAgACB7hGQUOmeWDgSAgQIECBAgAABAgQIECBAgAABAgQIECBAoEsFJFS6NDAOiwABAgQIECBAgAABAgQIECBAgAABAgQIEOgeAQmV7omFIyFAgAABAgQIECBAgAABAgQIECBAgAABAgS6VEBCpUsD47AIECBAgAABAgQIECBAgAABAgQIECBAgACB7hGQUOmeWDgSAgQIECBAgAABAgQIECBAgAABAgQIECBAoEsFJFS6NDAOiwABAgQIECBAgAABAgQIECBAgAABAgQIEOgeAQmV7omFIyFAgAABAgQIECBAgAABAgQIECBAgAABAgS6VEBCpUsD47AIECBAgAABAgQIECBAgAABAgQIECBAgACB7hGQUOmeWDgSAgQIECBAgAABAgQIECBAgAABAgQIECBAoEsFJFS6NDAOiwABAgQIECBAgAABAgQIECBAgAABAgQIEOgeAQmV7omFIyFAgAABAgQIECBAgAABAgQIECBAgAABAgS6VEBCpUsD47AIECBAgAABAgQIECBAgAABAgQIECBAgACB7hGQUOmeWDgSAgQIECBAgAABAgQIECBAgAABAgQIECBAoEsFJFS6NDAOiwABAgQIECBAgAABAgQIECBAgAABAgQIEOgeAQmV7omFIyFAgAABAgQIECBAgAABAgQIECBAgAABAgS6VEBCpUsD47AIECBAgAABAgQIECBAgAABAgQIECBAgACB7hGQUOmeWDgSAgQIECBAgAABAgQIECBAgAABAgQIECBAoEsFZgwMDKzv0mPr6cMaGBhIc+bM6WmDJndefJsc3ZTEV3ybLdDs3rl+xbfZAs3unetXfJst0OzeuX7Ft9kCze6d61d8my3Q7N65ficX31l9fX2F9hwcHExF9ynUwBiFe63dOKE5j3EylLi6rvNKfEsMYpuqxLcNTomb6nKuq13Xb4knT5uqxLcNTomb6nKuq13Xb4knT5uqxLcNTomb6nKuq13Xb4knT5uqxLcNTomb6nKuq13Xb4knT5uqxLcNTomb6nKuq13Xb4knT5uqxLcNTombynL2yK8Sg6IqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKSKiUiKkqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKSKiUiKkqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKSKiUiKkqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKSKiUiKkqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKSKiUiKkqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKSKiUiKkqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKSKiUiKkqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKSKiUiKkqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKSKiUiKkqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKSKiUiKkqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKSKiUiKkqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKSKiUiKkqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKSKiUiKkqAgQIECBAgAABAgQIECBAgAABAgQIECBAoJkCEirNjKteESBAgAABAgQIECBAgAABAgQIECBAgAABAiUKzFizZs36EutTFQECBAgQIECAAAECBAgQIECAAAECBAgQIECgcQIz1q9fXyihMjg4mPr6+joO0Wvtrl27Ns2dO5dzxQJ1nVfiW3Fg/7968W22s/iKbxUC7s9VqI6s0/U70qSKNXU519Wu67eKs2hkneI70qSKNXU519Wu67eKs2hkneI70qSKNXU519Wu67eKs2hkneI70qSKNXU519Wu63dyZ5FHfk3OzV4ECBAgQIAAAQIEek7guuuuS9dff33P9VuHCRAgQIAAAQIECBAgEAISKs4DAgQIECBAgAABAg0X+OAHP5hmzpw56Z+HHnooXXXVVellL3tZ2muvvdLXvva1hovpHgECBAgQIECAAAECBEYKSKiMNLGGAAECBAgQIECAQOMEXvGKV6Qrr7wy3Xbbbenxxx/Pfh555JEUTwCOnxNOOCE98MAD6e6770633npruuGGG9L555+fbQuMjTfeeKjsXXfd1TgfHSJAgAABAgQIECBAgMB4ArPGK2A7AQIECBAgQIAAAQLTX+AlL3lJ6u/v36AjM2bMGPoc7zfbbLPsJ1+50047pcWLF2cf995773TppZem1atXp0WLFuVFvBIgQIAAAQIECBAgQKBnBCRUeibUOkqAAAECBAgQINDLAs997nMLd3/27Nlpyy23HNrvgAMOSPFjIUCAAAECBAgQIECAQC8KSKj0YtT1mQABAgQIECBAoKcE3ve+9026v/fcc09qHcky6YqmuOPPfvaz9IMf/CAbQTN//vwp1mZ3AgQIECBAgAABAgQIFBcwh0pxM3sQIECAAAECBAgQ6BmBSKasWLEivepVr0oLFy7Mfq6++uqh/q9atWpofWy/5ZZb0ic+8Yl06KGHpt/93d9NM2fOTPPmzUtXXHFF+vWvf52WL1+eXvnKV6ZNN90027bddtul448/Pts2VOn/v1m3bl067rjj0jbbbJO23nrr7JFl8eiyl7/85enmm28eXtxnAgQIECBAgAABAgQIVCogoVIpr8oJECBAgAABAgQITH+BmEflwgsvzCa0X7lyZbr33nuHOrVgwYJ01llnpWuvvTbFtsMOOyz9z//8T3rhC1+Y/vzP/zztvPPO6cYbb0z7779/2m233dLll1+e9t133yxR8prXvCatWbMmnX766enUU08dqjN/c8ghh6Qzzjgjvf71r08xQuXRRx9N73znO9M3v/nNLLkS6ywECBAgQIAAAQIECBDolIBHfnVKWjsECBAgQIAAAQIEprHAFltskTbZZJNRe7DLLrukjTbaKNv24Q9/OBudEiNb1q9fn0466aS0xx57ZCNKlixZkt7+9rcPPUIsth9zzDHpzDPPTJdddllatmzZUP2XXHJJuvTSS7PRKTHiJUa6xHL22WdnCZ1I8MT7U045ZWgfbwgQIECAAAECBAgQIFClgBEqVeqqmwABAgQIECBAgECPCUQiJZ9zJV6f+tSnpj333DNT+MlPfjK0LVbE9gMPPDDbduedd24gFY8Gi+Xggw8eSqbE59gnRszEcvHFF2ev/kOAAAECBAgQIECAAIFOCEiodEJZGwQIECBAgAABAgR6WCAfXdL6qLCcY9as3w6af+yxx/JV2esNN9yQvW6//fYbrI8Pm2++ebbujjvuGLHNCgIECBAgQIAAAQIECFQl4JFfVcmqlwABAgQIECBAgACBDQSeeOKJDT63+/CLX/wi2xyP+7rooos2KDowMJB9jknuLQQIECBAgAABAgQIEOiUgIRKp6S1Q4AAAQIECBAgQKDHBYokVH7zm99kWi94wQvS/PnzR8gddNBBKR/dMmKjFQQIECBAgAABAgQIEKhAQEKlAlRVEiBAgAABAgQIECAwUqBIAiQe63X//fenQw45JB1xxBEjK7OGAAECBAgQIECAAAECHRYwh0qHwTVHgAABAgQIECBAoFcFYoL6iS5z587Nit59990T3UU5AgQIECBAgAABAgQIVCogoVIpr8oJECBAgAABAgQIEMgFZsyYkb8d93WvvfbKynzuc59L69evH7e8AgQIECBAgAABAgQIEKhaQEKlamH1EyBAgAABAgQIECCQCRRJjBx99NEpEjC33HJLWrJkCUECBAgQIECAAAECBAjULiChUnsIHAABAgQIECBAgACBzgrE3CTXXHNNOvfcc4cavu6669KXvvSldNttt40YEfLggw+m1atXp1/96ldZ+Shz1113ZeVi3cqVK9Pjjz+ebbv99tvTvffem72PSejXrFmTfv7zn2ef4/Fd8TkvG+VuvfXWbNtjjz2Wbrzxxux9/Ccmoz/ttNOyz2eddVbaaaed0umnn56+8pWvpI9//OPp0EMPzV6HdvCGAAECBAgQIECAAAECFQuYlL5iYNUTIECAAAECBAgQ6DaBf/qnf0oDAwPZYS1dunTo8G666aYUP4sWLUo77LDD0Pqzzz47Pfroo+mtb31rti6SKMuXL08HHHBANookEionnHBCtm1wcDCdc8456dhjj82SJRdffHGaN29e9hMFVqxYkfbbb78sQRLlYtRKfgwXXXRRevjhh9Pee++d1fXud7877b777unDH/5wuuKKK9JJJ52U5s+fn/bZZ5901FFHpf333z8r5z8ECBAgQIAAAQIECBDohICESieUtUGAAAECBAgQIECgiwTicVpFlve9731ti++xxx5D2yOh0tfXl32OZEj8jLXkiZSxtsf6hQsXpv7+/hFFiszHMmJnKwgQIECAAAECBAgQIDAJAQmVSaDZhQABAgQIECBAgACBzglInnTOWksECBAgQIAAAQIECIwtYA6VsW1sIUCAAAECBAgQIECAAAECBAgQIECAAAECBAhkAhIqTgQCBAgQIECAAAECBAgQIECAAAECBAgQIECAwDgCEirjANlMgAABAgQIECBAgAABAgQIECBAgAABAgQIEJBQcQ4QIECAAAECBAgQIECAAAECBAgQIECAAAECBMYRkFAZB8hmAgQIECBAgAABAgQIECBAgAABAgQIECBAgICEinOAAAECBAgQIECAAAECBAgQIECAAAECBAgQIDCOgITKOEA2EyBAgAABAgQIECBAgAABAgQIECBAgAABAgRmDAwMrMfQfQIDAwNpzpw53XdgjqgUAfEthbFrKxHfrg1NKQcmvqUwdm0l4tu1oSnlwMS3FMaurUR8uzY0pRyY+JbC2LWViG/XhqaUAxPfUhi7thLx7drQlHJg4lsKY9dWIr6TC82svr6+QnsODg6movsUamCMwr3WbpzQnMc4GUpcXdd5Jb4lBrFNVeLbBqfETXU519Wu67fEk6dNVeLbBqfETXU519Wu67fEk6dNVeLbBqfETXU519Wu67fEk6dNVeLbBqfETXU519Wu67fEk6dNVeLbBqfETXU519Wu67fEk6dNVeLbBqfEsYkb4AAAATNJREFUTWU5e+RXiUFRFQECBAgQIECAAAECBAgQIECAAAECBAgQINBMAQmVZsZVrwgQIECAAAECBAgQIECAAAECBAgQIECAAIESBSRUSsRUFQECBAgQIECAAAECBAgQIECAAAECBAgQINBMAQmVZsZVrwgQIECAAAECBAgQIECAAAECBAgQIECAAIESBSRUSsRUFQECBAgQIECAAAECBAgQIECAAAECBAgQINBMAQmVZsZVrwgQIECAAAECBAgQIECAAAECBAgQIECAAIESBSRUSsRUFQECBAgQIECAAAECBAgQIECAAAECBAgQINBMAQmVZsZVrwgQIECAAAECBAgQIECAAAECBAgQIECAAIESBSRUSsRUFQECBAgQIECAAAECBAgQIECAAAECBAgQINBMgf8DkcxYdmDMnR4AAAAASUVORK5CYII=" alt="img"></p><p>图中出现了 thread 和 task 两种切换顺序的不同方式，分别对应 Python 中并发的两种形式——threading 和 asyncio。</p><p>对于 threading，操作系统知道每个线程的所有信息，因此它会做主在适当的时候做线程切换。很显然，这样的好处是代码容易书写，因为程序员不需要做任何切换操作的处理；但是切换线程的操作，也有可能出现在一个语句执行的过程中（比如 x += 1），这样就容易出现 race condition 的情况。</p><p>而对于 asyncio，主程序想要切换任务时，必须得到此任务可以被切换的通知，这样一来也就可以避免刚刚提到的 race condition 的情况。</p><ul><li>并行，指的才是同一时刻、同时发生。Python 中的 multi-processing 便是这个意思，对于 multi-processing，你可以简单地这么理解：比如你的电脑是 6 核处理器，那么在运行程序时，就可以强制 Python 开 6 个进程，同时执行，以加快运行速度，它的原理示意图如下：</li></ul><p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABjYAAAI2CAYAAADzb7G3AAAgAElEQVR4AezdC5BcVZ0w8JOYSAjKREA0bMmQDRSiPJIQQZaFJIjELbUKSxFhCewa10eJJeLCEhZI4ANJLGV9oLUFakHJriiUK6IoPjAUKo+gZiUIKoYMoCXycEZEAiLz1f983vlmMjNJ9zCnbzf9O1VDd98+r/s7905N7p9zzpTBwcHB1EQaGBhIPT09TZSYnKzd1m5fX1/q7e2dHLwmauk257rO1/g2cVE+i6zG91ngNVG0Lue62nX/NnFxPIusxvdZ4DVRtC7nutp1/zZxcTyLrMb3WeA1UbQu57radf82cXE8i6zG91ngNVG0Lue62nX/NnFxPIusxvdZ4DVRtC7nutp1/zZxcTyLrMZ3YnhTJ1ZMKQIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA6wUENlpvrkUCBAgQIECAAAECBAgQIECAAAECBAgQIEBgggICGxOEU4wAAQIECBAgQIAAAQIECBAgQIAAAQIECBBovYDARuvNtUiAAAECBAgQIECAAAECBAgQIECAAAECBAhMUEBgY4JwihEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKtFxDYaL25FgkQIECAAAECBAgQIECAAAECBAgQIECAAIEJCkzZtGnT4ATLKkaAAAECBAgQIECAAAECBAgQIECAAAECBAgQaKnAlMHBwaYCGwMDA6mnp6elnYzGuq3dvr6+1Nvby7mwQF3XlfEtPLB/rd74Predja/xLSHg93MJ1dF1un9Hm5Q4UpdzXe26f0tcRaPrNL6jTUocqcu5rnbdvyWuotF1Gt/RJiWO1OVcV7vu3xJX0eg6je9okxJH6nKuq91Ov38tRVXiLlAnAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUERAYKMIq0oJECBAgAABAgQIECBAgAABAgQIECBAgACBEgICGyVU1UmAAAECBAgQIECAAAECBAgQIECAAAECBAgUERDYKMKqUgIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCEgMBGCVV1EiBAgAABAgQIECBAgAABAgQIECBAgAABAkUEBDaKsKqUAAECBAgQIECAAAECBAgQIECAAAECBAgQKCEgsFFCVZ0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAEQGBjSKsKiVAgAABAgQIECBAgAABAgQIECBAgAABAgRKCAhslFBVJwECBAgQIECAAAECBAgQIECAAAECBAgQIFBEQGCjCKtKCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAgRICAhslVNVJgAABAgQIECBAgAABAgQIECBAgAABAgQIFBEQ2CjCqlICBAgQIECAAAECBAgQIECAAAECBAgQIECghIDARglVdRIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJFBAQ2irCqlAABAgQIECBAgAABAgQIECBAgAABAgQIECghILBRQlWdBAgQIECAAAECBAgQIECAAAECBAgQIECAQBEBgY0irColQIAAAQIECBAgQIAAAQIECBAgQIAAAQIESggIbJRQVScBAgQIECBAgAABAgQIECBAgAABAgQIECBQREBgowirSgkQIECAAAECBAgQIECAAAECBAgQIECAAIESAgIbJVTVSYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBQRENgowqpSAgQIECBAgAABAgQIECBAgAABAgQIECBAoISAwEYJVXUSIECAAAECBAgQIECAAAECBAgQIECAAAECRQQENoqwqpQAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoISCwUUJVnQQIECBAgAABAgQIECBAgAABAgQIECBAgEARAYGNIqwqJUCAAAECBAgQIECAAAECBAgQIECAAAECBEoICGyUUFUnAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUERAYKMIq0oJECBAgAABAgQIECBAgAABAgQIECBAgACBEgICGyVU1UmAAAECBAgQIECAAAECBAgQIECAAAECBAgUEZhWpFaVTlhg7dq16cYbb0z9/f1p1qxZE65nogU3b96cZsyYMdHiEy7Xbe0a3wlfKk0VrOu6Mr5NDdOEMxvfCdM1VbAu57radf82dXlMOLPxnTBdUwXrcq6rXfdvU5fHhDMb3wnTNVWwLue62nX/NnV5TDiz8Z0wXVMF63Kuq91uvH+XLl2aFi9e3NR1ITMBApMvMG1gYKDpWidSpulGxijQDe1ef/31afXq1WOcvUMECBAgQIAAAQIECBAgQIAAAQIECNQtMH/+/JZ3oRueiw5Hdb7DNcq972TnaT09PU3JxMk2W6apBsbJ3C3t1jFbYhxyhwkQIECAAAECBAgQIECAAAECBAgQGCYQz+5a/Wy0rueiMSOn1eca1HWdb7e12+njaymqYb+Y2u1tTGszta3dRkV/CBAgQIAAAQIECBAgQIAAAQIEukkglo6PH4kAgfYRENhon7EY1ZMIaqxcuXLUcQcIECBAgAABAgQIECBAgAABAgQIEGidgMBG66y1RKARgamNZJKHAAECBAgQIECAAAECBAgQIECAAAECBAgQINAOAgIb7TAK+kCAAAECBAgQIECAAAECBAgQIECAAAECBAg0JCCw0RCTTAQIECBAgAABAgQIECBAgAABAgQIECBAgEA7CAhstMMo6AMBAgQIECBAgAABAgQIECBAgAABAgQIECDQkIDARkNMMhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLtICCw0Q6joA8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAQwICGw0xyUSAAAECBAgQIECAAAECBAgQIECAAAECBAi0g4DARjuMgj4QIECAAAECBAgQIECAAAECBAgQIECAAAECDQkIbDTEJBMBAgQIECBAgAABAgQIECBAgAABAgQIECDQDgICG+0wCvpAgAABAgQIECBAgAABAgQIECBAgAABAgQINCQgsNEQk0wECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAOwgIbLTDKOgDAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0JCAwEZDTDIRIECAAAECBAgQIECAAAECBAgQIECAAAEC7SAgsNEOo6APBAgQIECAAAECBGoWePDBB9O9995bcy80T4AAAQIECBAgQIAAgW0LCGxs20gOAgQIECBAgACBmgXWr1+f9t133zRr1qw0ZcqUET9Tp05Nf/M3f5MWLVqUzjrrrHTHHXfU3NvOav7JJ59Mq1evTnPnzk2XXnppZ3VebwkQIECAAAECBAgQ6EoBgY2uHHYnTYAAAQIECBDoLIF58+alDRs2pP7+/rTTTjvlzp9wwgk5iHHDDTekNWvWpNmzZ6cLLrggLViwIH3sYx/rrBOsqbfXXHNN2nvvvdOKFSvS448/XlMvNEuAAAECBAgQIECAAIHmBKY1l11uAgQIECBAgAABAu0h8LznPS/P4qh6E4GOmLlx0UUXpQ984APp1a9+df6pvvf6/wUeeOCBFF73339/+sd//Mf0jW98I/3kJz/5/xm8I0CAAAECBAgQIECAQBsLmLHRxoOjawQIECBAgAABAs0JxIyNnp6eXOjCCy9srnAX5X7iiSfShz/84fSrX/0qz3LZZZdduujsnSoBAgQIECBAgAABAp0uILDR6SOo/wQIECBAgAABAkMCM2bMSAcddFD+/Mtf/nLo+HhvnnrqqXTPPfeM+XU8/L/11lvT2rVr00MPPTRmnrEO/u53v0u33HJL6uvrS88888xYWYaObd68Od12223pxhtvbOlSUHvttdeQ01BnvCFAgAABAgQIECBAgECHCAhsdMhA6SYBAgQIECBAgEBjAtttt13O+Oijj+bXq6++Oi1evHjo57777kt/+MMf0nvf+968GfmJJ544ouKf/exneZmmHXfcMS9ltWTJkvSyl70svfOd70wRtBgrRQAj9vmYM2dOeslLXpIOOeSQtMcee6Ttt98+RRDhhz/84Yhi3/rWt3KeF7zgBenggw/Ofdt9993Tpz71qRH54kPsK3LaaaelPffcM2+aHnVG8OYtb3nLqLzf+9730lFHHZVmzpyZ8/b29ua6v/a1r43K6wABAgQIECBAgAABAgQ6VUBgo1NHTr8JECBAgAABAgTGFKhmasRD/UgRAPjkJz+ZNxqPmRGf+MQn0n777ZdnSkyfPn1EHVdccUXet+Pee+9NX/3qV3NQ4fvf/3465phj0qWXXpoOPfTQfGx4oQhqvOENb0hnnHFGesUrXpG+/e1v58DJj3/84/S+970vzwipgixRLup93etel37729+mm2++Oc/qiFkhUc/JJ588IrgxMDCQ9tlnnxSBkM9+9rPpj3/8Y/rBD36QFi5cOCpYEktLHXHEESkCMXfffXcOwsQm6rHc1G9+85vhXfaeAAECBAgQIECAAAECHS1g8/COHj6dJ0CAAAECBAgQGC4QS0D9/Oc/z4ci2FClCGQ8//nPzx8jgLBu3bq066675tdTTjklH4+NtN/xjnekmKkRm2nHa6QIZsTPr3/96xQzIs4+++wcKMlfppRWrVqV87/qVa9K11xzTZo27f/9iT1//vwUP1//+terrDl4EcGOwcHBHMCIMpEWLVqUvvzlL+fAxHnnnZfe/e53p9gc/fLLL88BkHPOOSfnibwLFixIF198cdq4ceNQvfHm/PPPz+e0YsWKoeNvetObcjAkzlkiQIAAAQIECBAgQIDAc0XAjI3nykg6DwIECBAgQIBA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QIAAAQJtITBlMP53rSZSt22i0urzPffcc9OqVavyiMTrypUrmxgdWQkQIECAAAECBAgQIECAAAECBAgQmEyBup/Xtfr5ZGXX19eXent7q48te63rfLut3U4f37Hn67fsMtUQAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBxAYGNxq3kJECAAAECBAgQIECAAAECBAgQIECAAAECBGoWENioeQA0T4AAAQIECBAgQIAAAQIECBAgQIAAAQIECDQuILDRuJWcBAgQIECAAAECBAgQIECAAAECBAgQIECAQM0CAhs1D4DmCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAgcYFBDYat5KTAAECBAgQIECAAAECBAgQIECAAAECBAgQqFlAYKPmAdA8AQIECBAgQIAAAQIECBAgQIAAAQIECBAg0LiAwEbjVnISIECAAAECBAgQIECAAAECBAgQIECAAAECNQsIbNQ8AJonQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEGhcQ2GjcSk4CBAgQIECAAAECBAgQIECAAAECBAgQIECgZgGBjZoHQPMECBAgQIAAAQIECBAgQIAAAQIECBAgQIBA4wICG41byUmAAAECBAgQIECAAAECBAgQIECAAAECBAjULCCwUfMAaJ4AAQIECBAgQIAAAQIECBAgQIAAAQIECBBoXEBgo3ErOQkQIECAAAECBAgQIECAAAECBAgQIECAAIGaBQQ2ah4AzRMgQIAAAQIECBAgQIAAAQIECBAgQIAAAQKNCwhsNG4lJwECBAgQIECAAAECBAgQIECAAAECBAgQIFCzgMBGzQOgeQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBxAYGNxq3kJECAAAECBAgQIECAAAECBAgQIECAAAECBGoWENioeQA0T4AAAQIECBAgQIAAAQIECBAgQIAAAQIECDQuILDRuJWcBAgQIECAAAECBAgQIECAAAECBAgQIECAQM0CAhs1D4DmCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAgcYFBDYat5KTAAECBAgQIECAAAECBAgQIECAAAECBAgQqFlgWs3ta34rAmvXrt3Kt74iQIAAAQIECBAgQIAAAQIECBAgQKC0gGd0pYXVT6B5gWkDAwNNl5pImaYbGaNAN7S7efPmoTOPX5p+cQ5xeEOAAAECBAgQIECAAAECBAgQIECgVoF4dlfHM8o62gxo7bbmcuPcvPO0np6epkoFcrNlmmpgnMzd0u6MGTPGEXCYAAECBAgQIECAAAECBAgQIECAAIE6BeLZXaufjdb1XLS/v7/l5xpjW9f5dlu7nT6+lqKq8zfhGG0vWrQorVq1KsWFNWvWrDFylD0UUec6givd1q7xLXsdV7XXdV0Z32oEyr4a37K+Ve11OdfVrvu3Gvmyr8a3rG9Ve13OdbXr/q1Gvuyr8S3rW9Vel3Nd7bp/q5Ev+2p8y/pWtdflXFe73Xj/xrM7iQCB+gUENuofgxE9WLx4cYqfvr6+1NvbO+K7VnzotshkXedrfFtxNdcX4Te+xreEQF2/r7qtXfdviat3dJ11XVfGd/RYlDhifEuojq6zLue62nX/jr4GShwxviVUR9dZl3Nd7bp/R18DJY4Y3xKqo+usy3l0TxwhQGAqAgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBApwgIbHTKSOknAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkAQ2XAQECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAxwgIbHTMUOkoAQIECBAgQIAAAQIECBAgQIAAAQIECBAgILDhGiBAgAABAgQIECBAgAABAgQIECBAgAABAgQ6RkBgo2OGSkcJECBAgAABAgQIECBAgAABAgQIECBAgAABgQ3XAAECBAgQIECAAAECBAgQIECAAAECBAgQINAxAgIbHTNUOkqAAAECBAgQIECAAAECBAgQIECAAAECBAgIbLgGCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgY4RENjomKHSUQIECBAgQIAAAQIECBAgQIAAAQIECBAgQEBgwzVAgAABAgQIECBAgAABAgQIECBAgAABAgQIdIyAwEbHDJWOEiBAgAABAgQIECBAgAABAgQIECBAgAABAgIbrgECBAgQIECAAAECBAgQIECAAAECBAgQIECgYwQENjpmqHSUAAECBAgQIECAAAECBAgQIECAAAECBAgQENhwDRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIdIyCw0TFDpaMECBAgQIAAAQIECBAgQIAAAQIECBAgQICAwIZrgAABAgQIECBAgAABAgQIECBAgAABAgQIEOgYAYGNjhkqHSVAgAABAgQIECBAgAABAgQIECBAgAABAgQENlwDBAgQIECAAAECBAgQIECAAAECBAgQIECAQMcICGx0zFDpKAECBAgQIECAAAECBAgQIECAAAECBAgQICCw4RogQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEOkZAYKNjhkpHCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAYEN1wABAgQIECBAgAABAgQIECBAgAABAgQIECDQMQICGx0zVDpKgAABAgQIECBAgAABAgQIECBAgAABAgQICGy4BggQIECAAAECBAgQIECAAAECBAgQIECAAIGOERDY6Jih0lECBAgQIECAAAECBAgQIECAAAECBAgQIEBgyqZNmwYxECBAgAABAgQIECBAgAABAgQIECBAgAABAgQ6QWDK4OBgU4GNgYGB1NPT0/Jz67Z2+/r6Um9vL+fCAnVdV8a38MD+tXrj+9x2Nr7Gt4SA388lVEfX6f4dbVLiSF3OdbXr/i1xFY2u0/iONilxpC7nutp1/5a4ikbXaXxHm5Q4UpdzXe26f0tcRaPrNL6jTUocqcu5rnY7/f61FFWJu0CdBAgQIECAAAECBAgQIECAAAECBAgQIECAQBEBgY0irColQIAAAQIECBAgQIAAAQIECBAgQIAAAQIESggIbJRQVScBAgQIECBAgAABAgQIECBAgAABAgQIECBQREBgowirSgkQIECAAAECBAgQIECAAAECBAgQIECAAIESAgIbJVTVSYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBQRENgowqpSAgQIECBAgAABAgQIECBAgAABAgQIECBAoISAwEYJVXUSIECAAAECBAgQIECAAAECBAgQIECAAAECRQQENoqwqpQAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoISCwUUJVnQQIECBAgAABAgQIECBAgAABAgQIECBAgEARAYGNIqwqJUCAAAECBAgQIECAAAECBAgQIECAAAECBEoICGyUUFUnAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUERAYKMIq0oJECBAgAABAgQIECBAgAABAgQIECBAgACBEgICGyVU1UmAAAECBAgQIECAAAECBAgQIECAAAECBAgUERDYKMKqUgIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCEgMBGCVV1EiBAgAABAgQIECBAgAABAgQIECBAgAABAkUEBDaKsKqUAAECBAgQIECAAAECBAgQIECAAAECBAgQKCEgsFFCVZ0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAEQGBjSKsKiVAgAABAgQIECBAgAABAgQIECBAgAABAgRKCAhslFBVJwECBAgQIECAAAECBAgQIECAAAECBAgQIFBEQGCjCMuAx6EAACAASURBVKtKCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAgRICAhslVNVJgAABAgQIECBAgAABAgQIECBAgAABAgQIFBEQ2CjCqlICBAgQIECAAAECBAgQIECAAAECBAgQIECghIDARglVdRIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJFBAQ2irCqlAABAgQIECBAgAABAgQIECBAgAABAgQIECghILBRQlWdBAgQIECAAAECBAgQIECAAAECBAgQIECAQBEBgY0irColQIAAAQIECBAgQIAAAQIECBAgQIAAAQIESggIbJRQVScBAgQIECBAgAABAgQIECBAgAABAgQIECBQRGBakVpVOmGBtWvXphtvvDH19/enWbNmTbieiRbcvHlzmjFjxkSLT7hct7VrfCd8qTRVsK7ryvg2NUwTzmx8J0zXVMG6nOtq1/3b1OUx4czGd8J0TRWsy7mudt2/TV0eE85sfCdM11TBupzratf929TlMeHMxnfCdE0VrMu5rna78f5dunRpWrx4cVPXhcwECEy+wLSBgYGma51ImaYbGaNAN7R7/fXXp9WrV49x9g4RIECAAAECBAgQIECAAAECBAgQIFC3wPz581vehW54Ljoc1fkO1yj3vpOdp/X09DQlEyfbbJmmGhgnc7e0W8dsiXHIHSZAgAABAgQIECBAgAABAgQIECBAYJhAPLtr9bPRup6LxoycVp9rUNd1vt3WbqePr6Wohv1iare3Ma3N1LZ2GxX9IUCAAAECBAgQIECAAAECBAgQ6CaBWDo+fiQCBNpHQGCjfcZiVE8iqLFy5cpRxx0gQIAAAQIECBAgQIAAAQIECBAgQKB1AgIbrbPWEoFGBKY2kkkeAgQIECBAgAABAgQIECBAgAABAgQIECBAgEA7CAhstMMo6AMBAgQIECBAgAABAgQIECBAgAABAgQIECDQkIDARkNMMhEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQLtICCw0Q6joA8ECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAQwICGw0xyUSAAAECBAgQIECAAAECBAgQIECAAAECBAi0g4DARjuMgj4QIECAAAECBAgQIECAAAECBAgQIECAAAECDQkIbDTEJBMBAgQIECBAgAABAgQIECBAgAABAgQIECDQDgICG+0wCvpAgAABAgQIECBAgAABAgQIECBAgAABAgQINCQgsNEQk0wECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAOwgIbLTDKOgDAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0JCAwEZDTDIRIECAAAECBAgQIECAAAECBAgQIECAAAEC7SAgsNEOo6APBAgQIECAAAECBAgQIECAAAECBAgQIECAQEMCAhsNMclEgAABAgQIECBAgAABAgQIECBAgAABAgQItIPAtHbohD4QIECAAAECBAgQINBagfvuuy9t3LgxTZkyJe20005p7ty5aebMma3thNYIECBAgAABAgQIECAwAQGBjQmgKUKAAAECBAgQINBagfXr16cTTjghPfDAA2lgYGBE4/Fgfvbs2WnPPfdMhx12WDr22GPTfvvtNyKPDyMFFi5cmH70ox+lF7zgBWnevHlp8+bN6Sc/+Uk64IAD0nHHHZc+8IEPpOc973kjC/lEgAABAgQIECBAgACBNhGwFFWbDIRuECBAgAABAgQIjC8QD983bNiQ+vv78+yCyBmBjjvuuCPdcMMNac2aNTm4ccEFF6QFCxakj33sY+NX5pt07733ptNOOy098sgj6aabbkrr1q1Lv/rVr9KLXvSifPw1r3lNDnagIkCAAAECBAgQIECAQDsKCGy046joEwECBAgQIECAwDYFYkbBvvvumxYvXpyDHFdeeWU69dRT09NPP51nHNxyyy3brKObM/zLv/xLev7znz9E0Nvbm77+9a/nwNGNN96YVqxYMfSdNwQIECBAgAABAgQIEGgnAYGNdhoNfSFAgAABAgQIEHhWAjFjo6enJ9dx4YUXPqu6nsuFlyxZkvbaa69Rp7jddtulmK0R6Qtf+MKo7x0gQIAAAQIECBAgQIBAOwgIbLTDKOgDAQIECBAgQIDApAjMmDEjHXTQQbmuX/7yl9us86mnnkr33HPPmPmeeOKJdOutt6a1a9emhx56aMw8Yx383e9+l2K2SF9fX3rmmWfGyjJ0LPa2uO2221LMkHj88ceHjpd+c/XVV4/bRBUYinOO2S8SAQIECBAgQIAAAQIE2k1AYKPdRkR/CBAgQIAAAQIEnpVAzDqI9Oijj+bXeIgfy1VVP/fdd1/6wx/+kN773vemWbNmpRNPPHFEez/72c/y0lY77rhjevWrX51idsPLXvay9M53vjNF0GKsFAGM2Odjzpw56SUveUk65JBD0h577JG23377PDPihz/84Yhi3/rWt3Ke2Lz74IMPzn3bfffd06c+9akR+eJD7CsS+2HE5uixUXrUGcGbt7zlLaPyfu9730tHHXVUmjlzZs4by0vFeX/ta18blXe8A7/+9a/zV/vvv3+aNm3aeNkcJ0CAAAECBAgQIECAQG0CAhu10WuYAAECBAgQIECghEA1UyMe6keKAMAnP/nJvNF4zIz4xCc+kfbbb788U2L69OkjunDFFVfkfTtic+2vfvWrOajw/e9/Px1zzDHp0ksvTYceemg+NrxQBDXe8IY3pDPOOCO94hWvSN/+9rdz4OTHP/5xet/73pdnhFRBligX9b7uda9Lv/3tb9PNN9+cZ3XErJCo5+STTx4R3BgYGEj77LNPikDIZz/72fTHP/4x/eAHP0gLFy5MWwZLPvzhD6cjjjgiB2LuvvvuHISJTdRjU/Df/OY3w7u81ff3339//r5akmqrmX1JgAABAgQIECBAgACBGgT8L1g1oGuSAAECBAgQIECgjEAsAfXzn/88Vx7BhipFIKPaKDsCCOvWrUu77rprfj3llFNytnig/453vCPFTI1vfOMb+TW+iGBG/MRMhpgRcfbZZ+dASVX3qlWrcv5XvepV6Zprrhma5TB//vwUP7Ehd5Wi7Qh2DA4O5gBGlIm0aNGi9OUvfzkHJs4777z07ne/O8Xm6JdffnkOgJxzzjk5T+RdsGBBuvjii9PGjRuravPr+eefn89p+Kbfb3rTm3IwJNptJN11111pw4YNKQI+sRG7RIAAAQIECBAgQIAAgXYUMGOjHUdFnwgQIECAAAECBJoWiMDDcccdl8vFMlBVwGLLimK2RAQ1IkVg4bLLLsvvP/rRj6Ynn3wyve1tbxsKagwv+8EPfjB//NznPje0H8af/vSnFDMlIkVgYaylm2LJq5133jnnuf7661MshRVLUC1dujQfq/4TS17ttttueaZF7LsRKWaORIpyw9PUqVPTN7/5zaFDMbPjsccey2XvuOOOoePxZtmyZemkk04acWy8D3EOkSK4En2RCBAgQIAAAQIECBAg0I4CAhvtOCr6RIAAAQIECBAgsE2B9evXp5gtET8x0yKWbNq0aVOe2RBLTr3whS/cZh2RYa+99sr5YgmpSAcccEB+3fI/1abkEcyItiNdd911ORgSgYYjjzxyyyL5cywvFXtuRLr99tvza+ynETMytkyx50ekOI9IsbRVpJgJsnz58nE3MY8Nv2fPnp3zRj8if7Mpyvz3f/93DricfvrpzRaXnwABAgQIECBAgAABAi0TENhoGbWGCBAgQIAAAQIEJlMg9qiIvSniJ/aRiAf/sa9FfI7AQbOpWtopNv8eK734xS8eCkY8+OCDOUu1H8XcuXNTBDe2lR5++OGhctVm5sNfqz5s3rw554uZFvPmzcvvY6ZIbGIeQZzY4HzLVG08HhucH3300emVr3xluuSSS3LgZcu8W36OGSIxUyXKXHXVVQ2dy5Z1+EyAAAECBAgQIECAAIFWCdhjo1XS2iFAgAABAgQIEJhUgVhSqlpGajIqroIJ1V4cY9W53XbbpZixET+R+vv782scbyQ9/fTTOVvMJomAxpapOhZ7c0SKvtx6663p6quvTmvWrEk//elP8ybisZH4mWeemS644IKhKmI/jdg4PZaTivwR/HjXu96Vl8qKDcur2R9DBf76JuqMZbH+9m//Nt1www0Nz3TZsh6fCRAgQIAAAQIECBAg0CqBabEeb7NpImWabWOs/N3QbvUP6rHO3zECBAgQIECAAIFyAjNmzEjxt1jsszFWig2/q7/VYo+MSNVrzB5pJFXLY82ZMycvodVImQhuHH/88fknZoisXr06ffrTn04f+tCH8t4dwzf53nPPPXOw5zOf+UzelyM2Ko/ZLEcccUTebHzmzJkjmvzRj36Ul9CKpbK+9KUvDZ3PiEw+ECBAgAABAgQIDAnE34N1PKOso804ae0ODX3RN5yb550W6/E2kwK52TLN1D9e3m5pN/5BLREgQIAAAQIECLReIIINd911VxovSNHX15eeeeaZ3LHIGyk2KY8US0zdfffd6eUvf3n+PN5/ent781ex0flEUixFFUtOxd/jF154YbrpppvS8MBGVWdsYv76178+LVy4MM/UiKWzYjbH8P1DbrnllvTa1742vec978mzQaZMmVIV90qAAAECBAgQIDCOQDy7a/Wz0bqei8bs5Fafa7DXdb7d1m6nj++2FwIe5yZ2mAABAgQIECBAgMBzSeCoo47KpxP7dIyVYkPySLEHx7777pvfx0yIaumqs88+e6xiI44dfPDB+XNsDh77WmwrXXrppXnGxZb53vjGN+ZD1VJYjzzySLrooou2zJb7GsGNSFXeeP/d7343Lz/1n//5n3mpKkGNUXQOECBAgAABAgQIECDQxgICG208OLpGgAABAgQIECDQOoFTTjklxV4ZsSTT73//+xENP/744+m8887Lx1asWDG0ifjOO++cZzzEF7GvRSz9VO2jMaKCv35YsGBBOvTQQ/OnE044IT3wwANjZRs6tm7duvSRj3xk6HP1ptpbZJ999smHYvms008/PW05EyQCKFVAZu+99855I6jxD//wD3k2R8ziWLVq1bg/sYyVRIAAAQIECBAgQIAAgXYTsHl4u42I/hAgQIAAAQIECIwpEA/pY+mlJ554In+/YcOG9MUvfjHtv//+KR7aT5069v+zE4GGeED/1FNP5XK/+MUv8vJMu+2224gysaxUzJA46aSTUszeOOuss/LU+8ceeyxFMGPjxo0pNug++eSTR/QvNvCO2Rc333xzuvjii9Pll1+eDjrooLzs00MPPZTuvPPOdOKJJ6b3v//9uVzsf3HYYYflpaGi329/+9vzRuLRv9tvvz2tX78+z6ioGrniiitywGXJkiV5Y+/rrrsuXXLJJWnHHXfMwYwq31/+8pd0zDHHpGOPPTabxPJYcQ4R9IiAy0tf+tKc9Tvf+U7685//nDcKj83Ct5b+7u/+Ls2dO3drWXxHgAABAgQIECBAgACBlgsIbLScXIMECBAgQIAAAQLNCsRD+2qWQsxMqFLsiRE/sTTTgQceWB0e8RoBh5ilEA/3I8UD/wguLF26NMWm2cPTsmXL0rx58/LG3G9+85tTtBsplpC68sor01vf+ta05bJNO+ywQw64fP7zn8/7X0RwItqM4EHkjfpiH4sqxT4c0ec1a9bkAEUEQ6699trcl8MPPzydeeaZVda0fPnyPHvkqquuSh//+MfT9OnTc8Ak6jvttNOG9vjYZZdd0vnnn5++8pWv5GBHBElmz56d245ATHXuUfGRRx6ZAyVDjWzljaDGVnB8RYAAAQIECBAgQIBAbQJTBgcHB5tpvds2UWn1+Z577rl5KYAYk1gWYOXKlc0Mj7wECBAgQIAAAQIECBAgQIAAAQIECEyiQN3P61r9fLKi6+vrS729vdXHlr3Wdb7d1m6nj+/Y8/VbdplqiAABAgQIECBAgAABAgQIECBAgAABAgQIECDQuIDARuNWchIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI1Cwhs1DwAmidAgAABAgQIECBAgAABAgQIECBAgAABAgQaFxDYaNxKTgIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBmAYGNmgdA8wQIECBAgAABAgQIECBAgAABAgQIECBAgEDjAgIbjVvJSYAAAQIECBAgQIAAAQIECBAgQIAAAQIECNQsILBR8wBongABAgQIECBAgAABAgQIECBAgAABAgQIEGhcQGCjcSs5CRAgQIAAAQIECBAgQIAAAQIECBAgQIAAgZoFBDZqHgDNEyBAgAABAgQIECBAgAABAgQIECBAgAABAo0LCGw0biUnAQIECBAgQIAAAQIECBAgQIAAAQIECBAgULOAwEbNA6B5AgQIECBAgAABAgQIECBAgAABAgQIECBAoHEBgY3GreQkQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEahYQ2Kh5ADRPgAABAgQIECBAgAABAgQIECBAgAABAgQINC4gsNG4lZwECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAzQICGzUPgOYJECBAgAABAgQIECBAgAABAgQIECBAgACBxgUENhq3kpMAAQIECBAgQIAAAQIECBAgQIAAAQIECBCoWUBgo+YB0DwBAgQIECBAgAABAgQIECBAgAABAgQIECDQuIDARuNWchIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQI1Cwhs1DwAmidAgAABAgQIECBAgAABAgQIECBAgAABAgQaFxDYaNxKTgIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBmAYGNmgdA8wQIECBAgAABAgQIECBAgAABAgQIECBAgEDjAgIbjVvJSYAAAQIECBAgQIAAAQIECBAgQIAAAQIECNQsMK3m9jW/FYG1a9du5VtfESBAgAABAgQIECBAgAABAgQIECBQWsAzutLC6ifQvMC0gYGBpktNpEzTjYxRoBva3bx589CZxy9NvziHOLwhQIAAAQIECBAgQIAAAQIECBAgUKtAPLur4xllHW0GtHZbc7lxbt55Wk9PT1OlArnZMk01ME7mbml3xowZ4wg4TIAAAQIECBAgQIAAAQIECBAgQIBAnQLx7K7Vz0brei7a39/f8nONsa3rfLut3U4fX0tR1fmbcIy2Fy1alFatWpXiwpo1a9YYOcoeiqhzHcGVbmvX+Ja9jqva67qujG81AmVfjW9Z36r2upzratf9W4182VfjW9a3qr0u57radf9WI1/21fiW9a1qr8u5rnbdv9XIl301vmV9q9rrcq6r3W68f+PZnUSAQP0CAhv1j8GIHixevDjFT19fX+rt7R3xXSs+dFtksq7zNb6tuJrri/AbX+NbQqCu31fd1q77t8TVO7rOuq4r4zt6LEocMb4lVEfXWZdzXe26f0dfAyWOGN8SqqPrrMu5rnbdv6OvgRJHjG8J1dF11uU8uieOECAwFQEBAgQIECBAgAABAgQIECBAgAABAgQIECBAoFMEBDY6ZaT0kwABAgQIECBAgAABAgQIECBAgAABAgQIEEgCGy4CAgQIECBAgAABAgQIECBAgAABAgQIECBAoGMEBDY6Zqh0lAABAgQIECBAgAABAgQIECBAgAABAgQIEBDYcA0QIECAAAECBAgQIECAAAECBAgQIECAAAECHSMgsNExQ6WjBAgQIECAAAECBAgQIECAAAECBAgQIECAgMCGa4AAAQIECBAgQIAAAQIECBAgQIAAAQIECBDoGAGBjY4ZKh0lQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEBDZcAwQIECBAgAABAgQIECBAgAABAgQIECBAgEDHCAhsdMxQ6SgBAgQIECBAgAABAgQIECBAgAABAgQIECAgsOEaIECAAAECBAgQIECAAAECBAgQIECAAAECBDpGQGCjY4ZKRwkQIECAAAECBAgQIECAAAECBAgQIECAAAGBDdcAAQIECBAgQIAAAQIECBAgQIAAAQIECBAg0DECAhsdM1Q6SoAAAQIECBAgQIAAAQIECBAgQIAAAQIECAhsuAYIECBAgAABAgQIECBAgAABAgQIECBAgACBjhEQ2OiYodJRAgQIECBAgAABAgQIECBAgAABAgQIECBAQGDDNUCAAAECBAgQIECAAAECBAgQIECAAAECBAh0jIDARscMlY4SIECAAAECBAgQIECAAAECBAgQIECAAAECAhuuAQIECBAgQIAAAQIECBAgQIAAAQIECBAgQKBjBAQ2OmaodJQAAQIECBAgQIAAAQIECBAgQIAAAQIECBAQ2HANECBAgAABAgQIECBAgAABAgQIECBAgAABAh0jILDRMUOlowQIECBAgAABAgQIECBAgAABAgQIECBAgIDAhmuAAAECBAgQIECAAAECBAgQIECAAAECBAgQ6BgBgY2OGSodJUCAAAECBAgQIECAAAECBAgQIECAAAECBAQ2XAMECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAxwgIbHTMUOkoAQIECBAgQIAAAQIECBAgQIAAAQIECBAgMGXTpk2DGAgQIECAAAECBAgQIECAAAECBAgQIECAAAECnSAwZXBwsKnAxsDAQOrp6Wn5uXVbu319fam3t5dzYYG6rivjW3hg/1q98X1uOxtf41tCwO/nEqqj63T/jjYpcaQu57radf+WuIpG12l8R5uUOFKXc13tun9LXEWj6zS+o01KHKnLua523b8lrqLRdRrf0SYljtTlXFe7nX7/WoqqxF2gTgIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCIgMBGEVaVEiBAgAABAgQIECBAgAABAgQIECBAgAABAiUEBDZKqKqTAAECBAgQIECAAAECBAgQIECAAAECBAgQKCIgsFGEVaUECBAgQIAAAQIECBAgQIAAAQIECBAgQIBACQGBjRKq6iRAgAABAgQIECBAgAABAgQIECBAgAABAgSKCAhsFGFVKQECBAgQIECAAAECBAgQIECAAAECBAgQIFBCQGCjhKo6CRAgQIAAAQIECBAgQIAAAQIECBAgQIAAgSICAhtFWFVKgAABAgQIECBAgAABAgQIECBAgAABAgQIlBAQ2Cihqk4CBAgQIECAAAECBAgQIECAAAECBAgQIECgiIDARhFWlRIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIlBAQ2SqiqkwABAgQIECBAgAABAgQIECBAgAABAgQIECgiILBRhFWlBAgQIECAAAECBAgQIECAAAECBAgQIECAQAkBgY0SquokQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEiggIbBRhVSkBAgQIECBAgAABAgQIECBAgAABAgQIECBQQkBgo4SqOgkQIECAAAECBAgQIECAAAECBAgQIECAAIEiAgIbRVhVSoAAAQIECBAgQIAAAQIECBAgQIAAAQIECJQQENgooapOAgQIECBAgAABAgQIECBAgAABAgQIECBAoIiAwEYRVpUSIECAAAECBAgQIECAAAECBAgQIECAAAECJQQENkqoqpMAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoIiCwUYRVpQQIECBAgAABAgQIECBAgAABAgQIECBAgEAJAYGNEqrqJECAAAECBAgQIECAAAECBAgQIECAAAECBIoICGwUYVUpAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUEJAYKOEqjoJECBAgAABAgQIECBAgAABAgQIECBAgACBIgICG0VYVUqAAAECBAgQIECAAAECBAgQIECAAAECBAiUEBDYKKGqTgIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCIgMBGEVaVEiBAgAABAgQIECBAgAABAgQIECBAgAABAiUEBDZKqKqTAAECBAgQIECAAAECBAgQIECAAAECBAgQKCIwrUitKp2wwNq1a9ONN96Y+vv706xZsyZcz0QLbt68Oc2YMWOixSdcrtvaNb4TvlSaKljXdWV8mxqmCWc2vhOma6pgXc51tev+berymHBm4zthuqYK1uVcV7vu36YujwlnNr4TpmuqYF3OdbXr/m3q8phwZuM7YbqmCtblXFe73Xj/Ll26NC1evLip60JmAgQmX2DawMBA07VOpEzTjYxRoBvavf7669Pq1avHOHuHCBAgQIAAAQIECBAgQIAAAQIECBCoW2D+/Pkt70I3PBcdjup8h2uUe9/JztN6enqakomTbbZMUw2Mk7lb2q1jtsQ45A4TIECAAAECBAgQIECAAAECBAgQIDBMIJ7dtfrZaF3PRWNGTqvPNajrOt9ua7fTx9dSVMN+MbXb25jWZmpbu42K/hAgQIAAAQIECBAgQIAAAQIECHSTQCwdHz8SAQLtIyCw0T5jMaonEdRYuXLlqOMOECBAgAABAgQIECBAgAABAgQIECDQOgGBjdZZa4lAIwJTG8kkDwECBAgQIECAAAECBAgQIECAAAECBAgQIECgHQQENtphFPSBAAECBAgQIECAAAECBAgQIECAAAECBAgQaEhAYKMhJpkIECBAgAABAgQIECBAgAABAgQIECBAgACBdhAQ2GiHUdAHAgQIECBAgAABAgQIECBAgAABAgQIECBAoCEBgY2GmGQiQIAAAQIECBAgQIAAAQIECBAgQIAAAQIE2kFAYKMdRkEfCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgYYEBDYaYpKJAAECBAgQIECAAAECBAgQIECAAAECBAgQaAcBgY12GAV9IECAAAECBAgQIECAAAECBAgQIECAAAECBBoSENhoiEkmAgQIECBAgAABAgQIECBAgAABAgQIECBAoB0EBDbaYRT0gQABAgQIECBAgAABAgQIECBAgAABAgQIEGhIQGCjISaZCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgXYQENhoh1HQBwIECBAgQIAAAQIECBAgQIAAAQIEUIZwmAAAIABJREFUCBAgQKAhAYGNhphkIkCAAAECBAgQIECAAAECBAgQIECAAAECBNpBYFo7dEIfCBAgQIAAAQIECBBorcAzzzyTNm3alO6///7c8K677pr23HPPNH369NZ2RGsECBAgQIAAAQIECBBoUkBgo0kw2QkQIECAAAECBFovsH79+nTCCSekBx54IA0MDIzowJQpU9Ls2bPzQ/nDDjssHXvssWm//fYbkceHkQKHH354uu2229LUqVPT/Pnz09NPP51+8pOfpOc973npLW95SzrnnHPSXnvtNbKQTwQIECBAgAABAgQIEGgTAUtRtclA6AYBAgQIECBAgMD4AvPmzUsbNmxI/f39aaeddsoZI9Bxxx13pBtuuCGtWbMmBzcuuOCCtGDBgvSxj31s/Mp8k+688860bNmy9PDDD6cf/OAH6dZbb81Bo0MOOSRdccUVaf/998+2qAgQIECAAAECBAgQINCOAgIb7Tgq+kSAAAECBAgQILBNgZhdsO+++6bFixfn2RxXXnllOvXUU/Psgw984APplltu2WYd3Zxh+fLlaebMmUMEsRTVV7/61Rwg2rx5c/o//+f/DH3nDQECBAgQIECAAAECBNpJQGCjnUZDXwgQIECAAAECBJ6VQMzY6OnpyXVceOGFz6qu53Lhv//7v08HHnjgqFN8wQtekI4++uh8PGZ1SAQIECBAgAABAgQIEGhHAYGNdhwVfSJAgAABAgQIEJiQwIwZM9JBBx2Uy/7yl7/cZh1PPfVUuueee8bM98QTT+QlmtauXZseeuihMfOMdfB3v/tdni3S19eXYoPuraWYGRF7Xdx4443p8ccf31rWSf3ummuuGXeT8Be96EW5re23335S21QZAQIECBAgQIAAAQIEJktAYGOyJNVDgAABAgQIECDQFgLbbbdd7sejjz6aX6+++uq8XFUsWRU/9913X/rDH/6Q3vve96ZZs2alE088cUS/f/azn+WlrXbcccf06le/Oi1ZsiS97GUvS+985ztTBC3GShHAiH0+5syZk17ykpek2Ktijz32SBEciE24f/jDH44o9q1vfSvniRkSBx98cO7X7rvvnj71qU+NyBcfYl+R0047LW+OHhulR50RvIlNvrdM3/ve99JRRx2Vl5iKvL29vbnur33ta1tmHfdznH+khQsXjpvHFwQIECBAgAABAgQIEKhTQGCjTn1tEyBAgAABAgQITLpANVMjHupHigDAJz/5ybwZdsyM+MQnPpH222+/PFNi+vTpI9qPjbNj345777037zcRQYXvf//76ZhjjkmXXnppOvTQQ3OgYXihCGq84Q1vSGeccUZ6xStekb797W/nwMmPf/zj9L73vS/PCKmCLFEu9rF43etel37729+mm2++Oc/qiFkhUc/JJ588IrgxMDCQ9tlnnxSBkM9+9rPpj3/8Y97sO4IOWwZLPvzhD6cjjjgiB2LuvvvuHISJTdR/9atfpd/85jfDuzzu+3Xr1qVrr702RXDo3/7t38bN5wsCBAgQIECAAAECBAjUKTCtzsa1TYAAAQIECBAgQGAyBWLD8J///Oe5ygg2VCkCGc9//vPzxwggxAP82Cw7Xk855ZR8/P7770/veMc7UszU+MY3vpFf44sIZsTPr3/96xQzIs4+++wcKKnqXrVqVc7/qle9KsUST9Om/b8/sefPn5/i5+tf/3qVNQcvItgxODiYAxhRJtKiRYvSl7/85RyYOO+889K73/3uFJujX3755TkAcs455+Q8kXfBggXp4osvThs3bhyqN96cf/75+ZxWrFgxdPxNb3pTDobEOY+VHnnkkfS///u/KYIwERCK4M28efPS5z73uTz7ZKwyjhEgQIAAAQIECBAgQKBuATM26h4B7RMgQIAAAQIECEyKQAQejjvuuFxXLANVBSy2rDxmS0RQI1IEFi677LL8/qMf/Wh68skn09ve9rahoMbwsh/84Afzx3joX+2H8ac//SnFTIlIEVioghrDy8WSVzvvvHM+dP311+elsGIJqqVLlw7Plmda7LbbbnmmRey7ESlmjkSKcsPT1KlT0ze/+c2hQzGz47HHHstl77jjjqHj8WbZsmXppJNOGnGs+hCzPl7zmtfkpa4uueSSPPMklu6K4IZEgAABAgQIECBAgACBdhUQ2GjXkdEvAgQIECBAgACBrQqsX78+xWyJ+ImZFrFk06ZNm/LMhlhy6oUvfOFWy1dfxh4YkWIJqUgHHHBAft3yP9Wm5BHMiLYjXXfddTkYEoGGI488cssi+XMsLxV7bkS6/fbb82vspxEzMrZMsedHpDiPSLG0VaSYCbJ8+fJxNzHv6elJs2fPznmjH5G/kfTGN74xzx6JfTVuuOGGtNNOO6W5c+emww47bOgcG6lHHgIECBAgQIAAAQIECLRSQGCjldraIkCAAAECBAgQmDSB2KMi9qaIn9hHIh78x5JK8TkCB82mammn2Px7rPTiF794KBjx4IMP5iyxfFWkCAZEcGNb6eGHH85Zoly1mfnw16oPmzdvzvlipkU1eyJmisQm5hHEqTb4Ht5etfF4bHB+9NFHp1e+8pUpZmHELJRtpQgKxSbpMXvlC1/4Qt5X5LWvfW2q+rut8r4nQIAAAQIECBAgQIBAKwW2/a+vVvZGWwQIECBAgAABAgQaFIglparARux98R//8R95T4sGi4/KVgUTqr04RmVIKW+qHcdj1kak2Fw8Umy23Uh6+umnc7aYTTI8oFG9jw27V65cOXQe0Zdbb701/dd//Vfaf//9c5AiNhGPoMW///u/j2gy9tOIfTIiGLLDDjvk4Me73vWunHesQMiIwsM+xFJcMVMkghqx54ZEgAABAgQIECBAgACBdhOYFuvxNpsmUqbZNsbK3w3tVv+gHuv8HSNAgAABAgQIECgnMGPGjBR/i403wyE2/K7+Vos9MiJVrzF7pJFULY81Z86cvIRWI2UiuHH88cfnn5jpsXr16vTpT386fehDH8p7d5x66qlD1ey555551sVnPvOZvC9HbFQes1mOOOKIvNn4zJkzh/Ju7U3MQIlgSLXk1tby+o4AAQIECBAg0E0C8fdgHc8o62gzxlW7rbm6OTfvPC3W420mBXKzZZqpf7y83dJu/INaIkCAAAECBAgQaL1ABBvuuuuuNF6Qoq+vLz3zzDO5Y5E3UmxSHilmN9x9993p5S9/ef483n96e3vzV7HR+URSLEUVS07F3+MXXnhhuummm9LwwEZVZ2xi/vrXvz4tXLgwz76IpbNiNkfsH3LLLbfk4M2iRYuq7KNeH3nkkXxsxx13HPWdAwQIECBAgACBbhaIZ3etfjZa13PRmJ3c6nONa6uu8+22djt9fC1F1c2/iZ07AQIECBAgQIDAkMBRRx2V38c+HWOl2JA8UuzBse++++b3MROiWrrq7LPPHqvYiGMHH3xw/hybg992220jvhvrQywFFTMutkyx6XekaimsCERcdNFFW2bLfY3gxvC8cX4xo2O8FDNWIkgT6cADDxwvm+MECBAgQIAAAQIECBCoTUBgozZ6DRMgQIAAAQIECLSTwCmnnJL3yvjSl76Ufv/734/o2uOPP57OO++8fGzFihVDm4jvvPPO6T3veU8+fvXVV6dY+qnaR2NEBX/9sGDBgnTooYfmTyeccEJ64IEHxso2dGzdunXpIx/5yNDn6k1s8h0pNv2OFMGI008/PW05EyQCKFVAZu+99855Yzmq//mf/0n33Xdf/rzlf+I8H3300Ry8iY3KJQIECBAgQIAAAQIECLSbwLR265D+ECBAgAABAgQIEBhLIB7Sx9JLTzzxRP56w4YN6Ytf/GLeVDse2k+dOvb/sxOBhpj18NRTT+Vyv/jFL/LyTLvtttuIMrGsVMyQiM23Y/bGWWedlafeP/bYYymCGRs3bkyxQffJJ588onsXXHBBnn1x8803p4svvjhdfvnl6aCDDsrLPj300EPpzjvvTCeeeGJ6//vfn8vFbInDDjssLw0V/X7729+eNxKP/t1+++15X4vvfve7Q21cccUVOeCyZMmSFHt0XHfddemSSy5JsUxUBDOq9Je//CUdc8wx6dhjj80msTxWnEMEPSLg8tKXvjRn3X777VMEamJZqmh73rx5aZdddkn33ntvDnh85zvfSUceeWSKAE8saSURIECAAAECBAgQIECg3QT8S6XdRkR/CBAgQIAAAQIERgnEQ/tqlsLwh/mxJ0b8xNJM4y2bFAGHCBTEw/1I8cA/ggtLly5NhxxyyIi2li1blh/0x8bcb37zm1O0GymWkLryyivTW9/61jRlypQRZXbYYYcccPn85z+f97+I4ES0+ec//znnjcBBNasjCsY+HNHnNWvW5ABFBEOuvfba3JfDDz88nXnmmUP1L1++PM8eueqqq9LHP/7xNH369ByQiPpOO+20oT0+IjBx/vnnp6985Ss52BFBktmzZ+dziUBMde5RcSyfFcGSCPZEMCMCMRH8iYBHBFr+9V//NdsMdcIbAgQIECBAgAABAgQItJnAlMHBwcFm+tRtm6i0+nzPPffctGrVqjwk8bpy5cpmhkdeAgQIECBAgAABAgQIECBAgAABAgQmUaDu53Wtfj5Z0fX19aXe3t7qY8te6zrfbmu308d37Pn6LbtMNUSAAAECBAgQIECAAAECBAgQIECAAAECBAgQaFxAYKNxKzkJECBAgAABAgQIECBAgAABAgQIECBAgACBmgUENmoeAM0TIECAAAECBAgQIECAAAECBAgQIECAAAECjQsIbDRuJScBAgQIECBAgAABAgQIECBAgAABAgQIECBQs4DARs0DoHkCBAgQIECAAAECBAgQIECAAAECBAgQIECgcQGBjcat5CRAgAABAgQIECBAgAABAgQIECBAgAABAgRqFhDYqHkANE+AAAECBAgQIECAAAECBAgQIECAAAECBAg0LiCw0biVnAQIECBAgAABAgQIECBAgAABAgQIECBAgEDNAgIbNQ+A5gkQIECAAAECBAgQIECAAAECBAgQIECAAIHGBQQ2GreSkwABAgQIECBAgAABAgQIECBAgAABAgQIEKhZQGCj5gHQPAECBAgQIECAAAECBAgQIECAAAECBAgQINC4gMBG41ZyEiBAgAABAgQIECBAgAABAgQIECBAgAABAjULCGzUPACaJ0CAAAECBAgQIECAAAECBAgQIECAAAECBBoXENho3EpOAgQIECBAgAABAgQIECBAgAABAgQIECBAoGYBgY2aB0DzBAgQIECAAAECBAgQIECAAAECBAgQIECAQOMCAhuNW8lJgAABAgQIECBAgAABAgQIECBAgAABAgQI1CwgsFHzAGieAAECBAgQIECAAAECBAgQIECAAAECBAgQaFxAYKNxKzkJECBAgAABAgQIECBAgAABAgQIECBAgACBmgUENmoeAM0TIECAAAECBAgQIECAAAECBAgQIECAAAECjQsIbDRuJScBAgQIECBAgAABAgQIECBAgAABAgQIECBQs4DARs0DoHkCBAgQIECAAAECBAgQIECAAAECBAgQIECgcQGBjcat5CRAgAABAgQIECBAgAABAgQIECBAgAABAgRqFphWc/ua34rA2rVrt/KtrwgQIECAAAECBAgQIECAAAECBAgQKC3gGV1pYfUTaF5g2sDAQNOlJlKm6UbGKNAN7W7evHnozOOXpl+cQxzeECBAgAABAgQIECBAgAABAgQIEKhVIJ7d1fGMso42A1q7rbncODfvPK2np6epUoHcbJmmGhgnc7e0O2PGjHEEHCZAgAABAgQIECBAgAABAgQIECBAoE6BeHbX6mejdT0X7e/vb/m5xtjWdb7d1m6nj6+lqOr8TThG24sWLUqrVq1KcWHNmjVrjBxlD0XUuY7gSre1a3zLXsdV7XVdV8a3GoGyr8a3rG9Ve13OdbXr/q1Gvuyr8S3rW9Vel3Nd7bp/q5Ev+2p8y/pWtdflXFe77t9q5Mu+Gt+yvlXtdTnX1W433r/x7E4iQKB+AYGN+sdgRA8WL16c4qevry/19vaO+K4VH7otMlnX+RrfVlzN9UX4ja/xLSFQ1++rbmvX/Vvi6h1dZ13XlfEdPRYljhjfEqqj66zLua523b+jr4ESR4xvCdXRddblXFe77t/R10CJI8a3hOroOutyHt0TRwgQmIqAAAECBAgQIECAAAECBAgQIECAAAECBAgQINApAgIbnTJS+kmAAAECBAgQIECAAAECBAgQIECAAAECBAgkgQ0XAQECBAgQIECAAAECBAgQIECAAAECBAgQINAxAgIbHTNUOkqAAAECBAgQIECAAAECBAgQIECAAAECBAgIbLgGCBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgY4RENjomKHSUQIECBAgQIAAAQIECBAgQIAAAQIECBAgQEBgwzVAgAABAgQIECBAgAABAgQIECBAgAABAgQIdIyAwEbHDJWOEiBAgAABAgQIECBAgAABAgQIECBAgAABAgIbrgECBAgQIECAAAECBAgQIECAAAECBAgQIECgYwQENjpmqHSUAAECBAgQIECAAAECBAgQIECAAAECBAgQENhwDRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIdIyCw0TFDpaMECBAgQIAAAQIECBAgQIAAAQIECBAgQICAwIZrgAABAgQIECBAgAABAgQIECBAgAABAgQIEOgYAYGNjhkqHSVAgAABAgQIECBAgAABAgQIECBAgAABAgQENlwDBAgQIECAAAECBAgQIECAAAECBAgQIECAQMcICGx0zFDpKAECBAgQIECAAAECBAgQIECAAAECBAgQICCw4RogQIAAAQIECBAgQIAAAQIECBAgQIAAAQIEOkZAYKNjhkpHCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAAYEN1wABAgQIECBAgAABAgQIECBAgAABAgQIECDQMQICGx0zVDpKgAABAgQIECBAgAABAgQIECBAgAABAgQICGy4BggQIECAAAECBAgQIECAAAECBAgQIECAAIGOERDY6Jih0lECBAgQIECAAAECBAgQIECAAAECBAgQIEBAYMM1QIAAAQIECBAgQIAAAQIECBAgQIAAAQIECHSMgMBGxwyVjhIgQIAAAQIECBAgQIAAAQIECBAgQIAAAQICG64BAgQIECBAgAABAgQIECBAgAABAgQIECBAoGMEBDY6Zqh0lAABAgQIECBAgAABAgQIECBAgAABAgQIEJiyadOmQQwECBAgQIAAAQIECBAgQIAAAQIECBAgQIAAgU4QmDI4ONhUYGNgYCD19PS0/Ny6rd2+vr7U29vLubBAXdeV8S08sH+t3vg+t52Nr/EtIeD3cwnV0XW6f0eblDhSl3Nd7bp/S1xFo+s0vqNNShypy7mudt2/Ja6i0XUa39EmJY7U5VxXu+7fElfR6DqN72iTEkfqcq6r3U6/fy1FVeIuUCcBAgQIECBAgAABAgQIECBAgAABAgQIECBQREBgowirSgkQIECAAAECBAgQIECAAAECBAgQIECAAIESAgIbJVTVSYAAAQIECBAgQIAAAQIECBAgQIAAAQIECBQRENgowqpSAgQIECBAgAABAgQIECBAgAABAgQIECBAoISAwEYJVXUSIECAAAECBAgQIECAAAECBAgQIECAAAECRQQENoqwqpQAAQIECBAgQIAAAQIECBAgQIAAAQIECBAoISCwUUJVnQQIECBAgAABAgQIECBAgAABAgQIECBAgEARAYGNIqwqJUCAAAECBAgQIECAAAECBAgQIECAAAECBEoICGyUUFUnAQIECBAgQIAAAQIECBAgQIAAAQIECBAgUERAYKMIq0oJECBAgAABAgQIECBAgAABAgQIECBAgACBEgICGyVU1UmAAAECBAgQIECAAAECBAgQIECAAAECBAgUERDYKMKqUgIECBAgQIAAAQIECBAgQIAAAQIECBAgQKCEgMBGCVV1EiBAgAABAgQIECBAgAABAgQIECBAgAABAkUEBDaKsKqUAAECBAgQIECAAAECBAgQIECAAAECBAgQKCEgsFFCVZ0ECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAEQGBjSKsKiVAgAABAgQIECBAgAABAgQIECBAgAABAgRKCAhslFBVJwECBAgQIECAAAECBAgQIECAAAECBAgQIFBEQGCjCKtKCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAgRICAhslVNVJgAABAgQIECBAgAABAgQIECBAgAABAgQIFBEQ2CjCqlICBAgQIECAAAECBAgQIECAAAECBAgQIECghMC0EpWqkwABAgQIECBAgAABAgQIECBAgAABAgQIEGhvgX/+539Oe+yxR1q0aFFavHhxe3d2WO8ENoZheEuAAAECBAgQIECAAAECBAgQIECAAAECBLpFYNOmTemyyy7LpxsBjn/6p39Kvb29+bWdDQQ22nl09I0AAQIECBAgQIAAAQIECBAgQIAAAQIECLRAIIIcq1atyi2de+65Q8GNlStXtqD15pqwx0ZzXnITIECAAAECBAgQIECAAAECBAgQIECAAIHntEAV5IhAx5QpU9KSJUtSBDvaJQlstMtI6AcBAgQIECBAgAABAgQIECBAgAABAgQIEGhDgbVr1+bZHO0S5BDYaMOLRJcIECBAgAABAgQIECBAgAABAgQIECBAgEA7CgwPcsyZM6eWmRwCG+14ZegTAQIECBAgQIAAAQIECBAgQIAAAQIECBBoc4FqyaqYydHKIMeUwcHBwWZsBgYGUk9PTzNFJiXvihUr0owZMyalrmYq2bx5cy3t9vf3p1mzZjXT1UnJW9f5dlu7xndSLtdtVlLXdWV8tzk0k5LB+E4K4zYrqcu5rnbdv9u8JCYlg/GdFMZtVlKXc13tun+3eUlMSgbjOymM26ykLue62nX/bvOSmJQMxndSGLdZSV3OdbXr/t3mJTEpGYzvpDBus5K6nOtqt7p/L7vsshTBiclOe+yxR958/KSTTkrxvkqTFV+Y0t/f31Rgo+pAq1/reMjf6nPUHgECBAgQIECAAAECBAgQIECAAAECBAgQeC4J7L777un444/PP/F+MtK0ZmdfTFZEZTI6rw4CBAgQIECAAAECBAgQIECAAAECBAgQIECgfQWmTp2aV0V65JFHUgQ2mo1JjHVm08Y62I7HzjjjjFqWhKp7KlCrx6Ku8+22dqupXsa3rEBd15XxLTuuVe3Gt5Io+1qXc13tun/LXk9V7ca3kij7WpdzXe26f8teT1XtxreSKPtal3Nd7bp/y15PVe3Gt5Io+1qXc13tun/LXk//t717CZGrWOMAXqMhvulB3IjCiIJEVNSJRiXEjApqFETUuMhCg4IgbnzEBxFRN0GIgiRGNwGTjQsRFZSgQXDUjVHEV7LwFTMSnxHsQcVH1Lmc451mvHOnSE+f01Xd/Wto09PfOVV1fv86lwsf3T09unynJer9N5Vzqnmn79+6v4pq+fLlYWxsrBVe8cGJKh498xsbqT4pkmreiYmJMDIyUkXGbY2R6noHbV75trUt531wqn0l33lH1taJ8m2La94Hp3JONa/7d95bpa0T5dsW17wPTuWcal7377y3SlsnyrctrnkfnMo51bzu33lvlbZOlG9bXPM+OJVzqnndv/PeKm2dKN+2uOZ9cCrnVPNO378XXnhhGB8fn7fbzBPn+l2NmcdUdb0984mNmRfvNQECBAgQIECAAAECBAgQIECAAAECBAgQIJBOoGhkFM/iB8KLT2XM/JHwulelsVG3sPEJECBAgAABAgQIECBAgAABAgQIECBAgEAfCMxsZqxevTrZFWlsJKM3MQECBAgQIECAAAECBAgQIECAAAECBAgQyFugaGYUn8gofi8jZTNjppLGxkwNrwkQIECAAAECBAgQIECAAAECBAgQIECAwIAL5NjMmBmJxsZMDa8JECBAgAABAgQIECBAgAABAgQIECBAgMAACuTezJgZicbGTA2vCRAgQIAAAQIECBAgQIAAAQIECBAgQIDAgAgUzYzi66WmfwC8Vy5bY6NXkrJOAgQIECBAgAABAgQIECBAgAABAgQIECBQocBTTz1V4WjdG+qg7k1lJgIECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAZwIaG535OZsAAQIECBAgQIAAAQIECBAgQIAAAQIECBDoooDGRhexTUWAAAECBAgQIECAAAECBAgQIECAAAECBAh0JqCx0ZmfswkQIECAAAECBAgQIECAAAECBAgQIECAAIEuCmhsdBHbVAQIECBAgAABAgQIECBAgAABAgQIECBAgEBnAhobnfk5mwABAgQIECBAgAABAgQIECBAgAABAgQIEOiigMZGF7FNRYAAAQIECBAgQIAAAQIECBAgQIAAAQIECHQmoLHRmZ+zCRAgQIAAAQIECBAgQIAAAQIECBAgQIAAgS4KaGx0EdtUBAgQIECAAAECBAgQIECAAAECBAgQIECAQGcCGhud+TmbAAECBAgQIECAAAECBAgQIECAAAECBAgQ6KKAxkYXsU1FgAABAgQIECBAgAABAgQIECBAgAABAgQIdCagsdGZn7MJECBAgAABAgQIECBAgAABAgQIECBAgACBLgpobHQR21QECBAgQIAAAQIECBAgQIAAAQIECBAgQIBAZwIaG535OZsAAQIECBAgQIAAAQIECBAgQIAAAQIECBDoooDGRhexTUWAAAECBAgQIECAAAECBAgQIECAAAECBAh0JqCx0ZmfswkQIECAAAECBAgQIECAAAECBAgQIECAAIEuCmhsdBHbVAQIECBAgAABAgQIECBAgAABAgQIECBAgEBnAhobnfk5mwABAgQIECBAgAABAgQIECBAgAABAgQIEOiigMZGF7FNRYAAAQIECBAgQICWxrx2AAAZBklEQVQAAQIECBAgQIAAAQIECHQmMNRsNqc6G8LZdQg0m80wPDxcx9DGzEBAvhmEUOMS5FsjbgZDyzeDEGpcgnxrxM1gaPlmEEKNS5BvjbgZDC3fDEKocQnyrRE3g6Hlm0EINS5BvjXiZjC0fDMIocYl9Hq+CxqNRls8k5OTod1z2ppgjoMHbd5iY3GeYzNU+HaqfSXfCkOMDCXfCE6FpVTOqeZ1/1a4eSJDyTeCU2EplXOqed2/FW6eyFDyjeBUWErlnGpe92+FmycylHwjOBWWUjmnmtf9W+HmiQwl3whOhaVUzqnmdf9WuHkiQ8k3ghMp+SqqCI4SAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkJeAxkZeeVgNAQIECBAgQIAAAQIECBAgQIAAAQIECBAgEBHQ2IjgKBEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ5CWhs5JWH1RAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIRAY2NCI4SAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkJeAxkZeeVgNAQIECBAgQIAAAQIECBAgQIAAAQIECBAgEBHQ2IjgKBEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ5CWhs5JWH1RAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIRAY2NCI4SAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkJeAxkZeeVgNAQIECBAgQIAAAQIECBAgQIAAAQIECBAgEBHQ2IjgKBEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ5CWhs5JWH1RAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIRAY2NCI4SAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkJeAxkZeeVgNAQIECBAgQIAAAQIECBAgQIAAAQIECBAgEBHQ2IjgKBEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ5CWhs5JWH1RAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIRAY2NCI4SAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkJeAxkZeeVgNAQIECBAgQIAAAQIECBAgQIAAAQIECBAgEBHQ2IjgKBEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ5CWhs5JWH1RAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIRAY2NCI4SAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkJeAxkZeeVgNAQIECBAgQIAAAQIECBAgQIAAAQIECBAgEBHQ2IjgKBEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ5CWhs5JWH1RAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIRAY2NCI4SAQIECBAgQIAAAQIECBAgQIAAAQIECBAgkJeAxkZeeVgNAQIECBAgQIAAAQIECBAgQIAAAQIECBAgEBHQ2IjgKBEgQIAAAQIECBAgQIAAAQIECBAgQIAAAQJ5CWhs5JWH1RAgQIAAAQIECBAgQIAAAQIECBAgQIAAAQIRgaFmszkVqSslEmg2m2F4eDjR7KatW0C+dQunHV++af3rnl2+dQunHV++af3rnl2+dQunHV++af3rnl2+dQunHV++af3rnl2+dQunHV++af3rnl2+dQunHb/X813QaDTaEpycnAztntPWBHMcPGjzFhuL8xybocK3U+0r+VYYYmQo+UZwKiylck41r/u3ws0TGUq+EZwKS6mcU83r/q1w80SGkm8Ep8JSKudU87p/K9w8kaHkG8GpsJTKOdW87t8KN09kKPlGcCospXJONa/7t8LNExlKvhGcSMlXUUVwlAgQIECAAAECBAgQIECAAAECBAgQIECAAIG8BDQ28srDaggQIECAAAECBAgQIECAAAECBAgQIECAAIGIgMZGBEeJAAECBAgQIECAAAECBAgQIECAAAECBAgQyEtAYyOvPKyGAAECBAgQIECAAAECBAgQIECAAAECBAgQiAhobERwlAgQIECAAAECBAgQIECAAAECBAgQIECAAIG8BDQ28srDaggQIECAAAECBAgQIECAAAECBAgQIECAAIGIgMZGBEeJAAECBAgQIECAAAECBAgQIECAAAECBAgQyEtAYyOvPKyGAAECBAgQIECAAAECBAgQIECAAAECBAgQiAhobERwlAgQIECAAAECBAgQIECAAAECBAgQIECAAIG8BDQ28srDaggQIECAAAECBAgQIECAAAECBAgQIECAAIGIgMZGBEeJAAECBAgQIECAAAECBAgQIECAAAECBAgQyEtAYyOvPKyGAAECBAgQIECAAAECBAgQIECAAAECBAgQiAhobERwlAgQIECAAAECBAgQIECAAAECBAgQIECAAIG8BDQ28srDaggQIECAAAECBAgQIECAAAECBAgQIECAAIGIgMZGBEeJAAECBAgQIECAAAECBAgQIECAAAECBAgQyEtAYyOvPKyGAAECBAgQIECAAAECBAgQIECAAAECBAgQiAhobERwlAgQIECAAAECBAgQIECAAAECBAgQIECAAIG8BDQ28srDaggQIECAAAECBAgQIECAAAECBAgQIECAAIGIgMZGBEeJAAECBAgQIECAAAECBAgQIECAAAECBAgQyEtAYyOvPKyGAAECBAgQIECAAAECBAgQIECAAAECBAgQiAhobERwlAgQIECAAAECBAgQIECAAAECBAgQIECAAIG8BDQ28srDaggQIECAAAECBAgQIECAAAECBAgQIECAAIGIgMZGBEeJAAECBAgQIECAAAECBAgQIECAAAECBAgQyEtAYyOvPKyGAAECBAgQIECAAAECBAgQIECAAAECBAgQiAhobERwlAgQIECAAAECBAgQIECAAAECBAgQIECAAIG8BDQ28srDaggQIECAAAECBAgQIECAAAECBAgQIECAAIGIgMZGBEeJAAECBAgQIECAAAECBAgQIECAAAECBAgQyEtAYyOvPKyGAAECBAgQIECAAAECBAgQIECAAAECBAgQiAgM7dmzZypSVyJAgAABAgQIECBAgAABAgQIECBAgAABAgQIZCMwNDU11VZjY3JyMjQaja5fwKDNOzExEUZGRjjXLJBqX8m35mD/O7x8+9tZvvKtQ8D/PtehOntM9+9skzreSeWcal73bx27aPaY8p1tUsc7qZxTzev+rWMXzR5TvrNN6ngnlXOqed2/deyi2WPKd7ZJHe+kck41b6/fv76Kqo67wJgECBAgQIAAAQIDIbBjx47wzjvvDMS1ukgCBAgQIECAAAECBAjkIqCxkUsS1kGAAAECBAgQINA1gXXr1oWhoaF5P3/++efw2muvhfPOOy8sWbIkvPrqq11bu4kIECBAgAABAgQIECAw6AIaG4O+A1w/AQIECBAgQGBABS644IIwPj4edu/eHYpvZy2ev/32W0vj3nvvDUUD45tvvgmffvppeO+998LWrVtb9YULF7Ze7927t/XaCwIECBAgQIAAAQIECBCoV2BBvcMbnQABAgQIECBAgECeAmeffXZYvnz5nIsrPtFxxBFHlM/pgxYtWhRuuOGG8s+lS5eGbdu2hV27doVVq1ZNH+JfAgQIECBAgAABAgQIEKhZQGOjZmDDEyBAgAABAgQI5Clw0kkntb2wQw89NBxzzDGt81asWBGKpwcBAgQIECBAgAABAgQIdE9AY6N71mYiQIAAAQIECBDIRGDt2rXzXsm+ffvmfW6VJ3777bfhk08+CUceeWQYHR2tcmhjESBAgAABAgQIECBAIGsBv7GRdTwWR4AAAQIECBAgkKPAli1bwkUXXRTGxsbK5xtvvNFa5uuvv956v6jv3LkzbNq0KaxcubL8tEfxFVdnnnlm2L59e/j999/D5s2bw7Jly8Lhhx9e/pj5CSecEO66666y1hr0vy+K3wBZs2ZNOO6448Kxxx5bfpXW4sWLw/nnnx8++uij/z3c3wQIECBAgAABAgQIEOhLAY2NvozVRREgQIAAAQIECNQpsHr16vDss8+Gzz//PBSNjJmf4ih+t2Pjxo1hx44dZa34/Y233347nHrqqeGWW24Jp512Wvjggw/CZZddFs4444zwyiuvhIsvvjjcfffd4ZJLLgkTExPhkUceCevWrZt1Cddcc0149NFHw5VXXhm+//778Oeff4Zbb701vPXWW2WTo/gUhwcBAgQIECBAgAABAgT6XcBXUfV7wq6PAAECBAgQIECgFoGjjz46HHbYYf937NNPPz0cfPDBZW39+vXhuuuuax13//33h+KHy4tPWNxxxx3h5ptvbtWKF7fffnt47LHHwssvvxweeuihVu2ll14qf6z8+OOPD0888UT56Y6i+Pjjj5eNlWeeeSZs2LDh/zZEWoN4QYAAAQIECBAgQIAAgT4Q8ImNPgjRJRAgQIAAAQIECPSOwMKFC8OSJUvKBX/99dezFn7FFVeU73355Zf/qhVfWVU8rr766lZTY/qA4hMkxaNofngQIECAAAECBAgQIECg3wU0Nvo9YddHgAABAgQIECCQncBBB/3zf8NnfoXV9CIXLPjnQ9X79++ffqv899133y3/PfHEE//1fvHHUUcdVb73xRdfzKp5gwABAgQIECBAgAABAv0m4Kuo+i1R10OAAAECBAgQINAzAn///fcBr/WHH34ojy1+iPz555//13nNZrP8u/gxcg8CBAgQIECAAAECBAj0u4DGRr8n7PoIECBAgAABAgSyFWinsVH8UHjxWLRoURgdHZ11TVdddVWY/rTHrKI3CBAgQIAAAQIECBAg0EcCGht9FKZLIUCAAAECBAgQ6C2BdhoRxddN/fjjj+Haa68N119/fW9dqNUSIECAAAECBAgQIECgQgG/sVEhpqEIECBAgAABAgQItCNwyCGHHPDhIyMj5bFfffXVAZ/jQAIECBAgQIAAAQIECPSjgMZGP6bqmggQIECAAAECBHpCYGho6IDXee6555bHPv3002FqauqAz3MgAQIECBAgQIAAAQIE+k1AY6PfEnU9BAgQIECAAAECPSPQToPitttuC0UjZOfOnaF47UGAAAECBAgQIECAAIFBFdDYGNTkXTcBAgQIECBAgEBLoPjtijfffDM8+eSTrfd27NgRnnvuufDZZ5/N+oTETz/9FHbt2hV+/fXX8vjimL1795bHFe+Nj4+Hv/76q6zt3r077Nu3r3xd/Fj4nj17wnfffVf+XXytVPH39LHFcR9//HFZ279/f3j//ffL18V/ih8NX79+ffn3hg0bWn9v27YtFH+vXLmy/Ld1ghcECBAgQIAAAQIECBDoUwE/Ht6nwbosAgQIECBAgACBAxfYunVraDab5QkPPPBA68QPP/wwFM9Vq1aFk08+ufX+xo0bwx9//BFuuumm8r2imbF58+Zw+eWXl5+qKBob99xzT1mbnJwMmzZtCmvWrCmbFi+++GI466yzymdxwJYtW8Kll14aTjnllPK44r3pNbzwwgvhl19+CUuXLi3HuvPOO8PixYvDww8/HLZv3x7uu+++MDo6GpYtWxZuvPHGsGLFivI4/yFAgAABAgQIECBAgEA/C2hs9HO6ro0AAQIECBAgQOCABNr9aqe1a9dGxz3nnHNa9aKx0Wg0yr+LpkTxnOvx4IMPzlVqvT82NhaKpwcBAgQIECBAgAABAgQGVcBXUQ1q8q6bAAECBAgQIECAAAECBAgQIECAAAECBAj0oIDGRg+GZskECBAgQIAAAQIECBAgQIAAAQIECBAgQGBQBTQ2BjV5102AAAECBAgQIECAAAECBAgQIECAAAECBHpQQGOjB0OzZAIECBAgQIAAAQIECBAgQIAAAQIECBAgMKgCGhuDmrzrJkCAAAECBAgQIECAAAECBAgQIECAAAECPSigsdGDoVkyAQIECBAgQIAAAQIECBAgQIAAAQIECBAYVAGNjUFN3nUTIECAAAECBAgQIECAAAECBAgQIECAAIEeFNDY6MHQLJkAAQIECBAgQIAAAQIECBAgQIAAAQIECAyqwFCz2Zwa1IvP+bqbzWYYHh7OeYnW1oGAfDvA64FT5dsDIXWwRPl2gNcDp8q3B0LqYIny7QCvB06Vbw+E1MES5dsBXg+cKt8eCKmDJcq3A7weOFW+PRBSB0uUbwd4PXBqr+e7oNFotMU8OTkZ2j2nrQnmOHjQ5i02Fuc5NkOFb6faV/KtMMTIUPKN4FRYSuWcal73b4WbJzKUfCM4FZZSOaea1/1b4eaJDCXfCE6FpVTOqeZ1/1a4eSJDyTeCU2EplXOqed2/FW6eyFDyjeBUWErlnGpe92+FmycylHwjOJGSr6KK4CgRIECAAAECBAgQIECAAAECBAgQIECAAAECeQlobOSVh9UQIECAAAECBAgQIECAAAECBAgQIECAAAECEQGNjQiOEgECBAgQIECAAAECBAgQIECAAAECBAgQIJCXgMZGXnlYDQECBAgQIECAAAECBAgQIECAAAECBAgQIBAR0NiI4CgRIECAAAECBAgQIECAAAECBAgQIECAAAECeQlobOSVh9UQIECAAAECBAgQIECAAAECBAgQIECAAAECEQGNjQiOEgECBAgQIECAAAECBAgQIECAAAECBAgQIJCXgMZGXnlYDQECBAgQIECAAAECBAgQIECAAAECBAgQIBAR0NiI4CgRIECAAAECBAgQIECAAAECBAgQIECAAAECeQlobOSVh9UQIECAAAECBAgQIECAAAECBAgQIECAAAECEQGNjQiOEgECBAgQIECAAAECBAgQIECAAAECBAgQIJCXgMZGXnlYDQECBAgQIECAAAECBAgQIECAAAECBAgQIBAR0NiI4CgRIECAAAECBAgQIECAAAECBAgQIECAAAECeQlobOSVh9UQIECAAAECBAgQIECAAAECBAgQIECAAAECEQGNjQiOEgECBAgQIECAAAECBAgQIECAAAECBAgQIJCXgMZGXnlYDQECBAgQIECAAAECBAgQIECAAAECBAgQIBAR0NiI4CgRIECAAAECBAgQIECAAAECBAgQIECAAAECeQlobOSVh9UQIECAAAECBAgQIECAAAECBAgQIECAAAECEQGNjQiOEgECBAgQIECAAAECBAgQIECAAAECBAgQIJCXgMZGXnlYDQECBAgQIECAAAECBAgQIECAAAECBAgQIBAR0NiI4CgRIECAAAECBAgQIECAAAECBAgQIECAAAECeQlobOSVh9UQIECAAAECBAgQIECAAAECBAgQIECAAAECEQGNjQiOEgECBAgQIECAAAECBAgQIECAAAECBAgQIJCXgMZGXnlYDQECBAgQIECAAAECBAgQIECAAAECBAgQIBAR0NiI4CgRIECAAAECBAgQIECAAAECBAgQIECAAAECeQlobOSVh9UQIECAAAECBAgQIECAAAECBAgQIECAAAECEQGNjQiOEgECBAgQIECAAAECBAgQIECAAAECBAgQIJCXgMZGXnlYDQECBAgQIECAAAECBAgQIECAAAECBAgQIBARGGo2m1ORulIigWazGYaHhxPNbtq6BeRbt3Da8eWb1r/u2eVbt3Da8eWb1r/u2eVbt3Da8eWb1r/u2eVbt3Da8eWb1r/u2eVbt3Da8eWb1r/u2eVbt3Da8Xs93wWNRqMtwcnJydDuOW1NMMfBgzZvsbE4z7EZKnw71b6Sb4UhRoaSbwSnwlIq51Tzun8r3DyRoeQbwamwlMo51bzu3wo3T2Qo+UZwKiylck41r/u3ws0TGUq+EZwKS6mcU83r/q1w80SGkm8Ep8JSKudU87p/K9w8kaHkG8GJlHwVVQRHiQABAgQIECBAgAABAgQIECBAgAABAgQIEMhLQGMjrzyshgABAgQIECBAgAABAgQIECBAgAABAgQIEIgIaGxEcJQIECBAgAABAgQIECBAgAABAgQIECBAgACBvAQ0NvLKw2oIECBAgAABAgQIECBAgAABAgQIECBAgACBiIDGRgRHiQABAgQIECBAgAABAgQIECBAgAABAgQIEMhLQGMjrzyshgABAgQIECBAgAABAgQIECBAgAABAgQIEIgIaGxEcJQIECBAgAABAgQIECBAgAABAgQIECBAgACBvAQ0NvLKw2oIECBAgAABAgQIECBAgAABAgQIECBAgACBiIDGRgRHiQABAgQIECBAgAABAgQIECBAgAABAgQIEMhLQGMjrzyshgABAgQIECBAgAABAgQIECBAgAABAgQIEIgIaGxEcJQIECBAgAABAgQIECBAgAABAgQIECBAgACBvAQ0NvLKw2oIECBAgAABAgQIECBAgAABAgQIECBAgACBiIDGRgRHiQABAgQIECBAgAABAgQIECBAgAABAgQIEMhLQGMjrzyshgABAgQIECBAgAABAgQIECBAgAABAgQIEIgIaGxEcJQIECBAgAABAgQIECBAgAABAgQIECBAgACBvAQ0NvLKw2oIECBAgAABAgQIECBAgAABAgQIECBAgACBiIDGRgRHiQABAgQIECBAgAABAgQIECBAgAABAgQIEMhL4D9JKo/9kb6cvQAAAABJRU5ErkJggg==" alt="img"></p><p>对比来看，</p><ul><li>并发通常应用于 I/O 操作频繁的场景，比如你要从网站上下载多个文件，I/O 操作的时间可能会比 CPU 运行处理的时间长得多。</li><li>而并行则更多应用于 CPU heavy 的场景，比如 MapReduce 中的并行计算，为了加快运行速度，一般会用多台机器、多个处理器来完成。</li></ul><h3 id="7-2-并发编程之-Futures"><a href="#7-2-并发编程之-Futures" class="headerlink" title="7.2 并发编程之 Futures"></a>7.2 并发编程之 Futures</h3><h4 id="单线程与多线程性能比较"><a href="#单线程与多线程性能比较" class="headerlink" title="单线程与多线程性能比较"></a>单线程与多线程性能比较</h4><h5 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h5><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> time <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download_one</span>(<span class="hljs-params">url</span>):</span>    resp = requests.get(url)    print(<span class="hljs-string">&#x27;Read &#123;&#125; from &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(resp.content), url))    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download_all</span>(<span class="hljs-params">sites</span>):</span>    <span class="hljs-keyword">for</span> site <span class="hljs-keyword">in</span> sites:        download_one(site) <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    sites = [        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Arts&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:History&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Society&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Biography&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Mathematics&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Technology&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Geography&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Science&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Computer_science&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Python_(programming_language)&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Java_(programming_language)&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/PHP&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Node.js&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/The_C_Programming_Language&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Go_(programming_language)&#x27;</span>    ]    start_time = time.perf_counter()    download_all(sites)    end_time = time.perf_counter()    print(<span class="hljs-string">&#x27;Download &#123;&#125; sites in &#123;&#125; seconds&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(sites), end_time - start_time))    <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre><p>这种方式应该是最直接也最简单的：</p><ul><li>先是遍历存储网站的列表；</li><li>然后对当前网站执行下载操作；</li><li>等到当前操作完成后，再对下一个网站进行同样的操作，一直到结束。</li></ul><p>单线程的优点是简单明了，但是明显效率低下，因为上述程序的绝大多数时间，都浪费在了 I/O 等待上。程序每次对一个网站执行下载操作，都必须等到前一个网站下载完成后才能开始。如果放在实际生产环境中，我们需要下载的网站数量至少是以万为单位的，不难想象，这种方案根本行不通。</p><h5 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h5><pre><code class="hljs python"><span class="hljs-keyword">import</span> concurrent.futures<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> threading<span class="hljs-keyword">import</span> time <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download_one</span>(<span class="hljs-params">url</span>):</span>    resp = requests.get(url)    print(<span class="hljs-string">&#x27;Read &#123;&#125; from &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(resp.content), url))  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download_all</span>(<span class="hljs-params">sites</span>):</span>    <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> executor:        executor.<span class="hljs-built_in">map</span>(download_one, sites) <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    sites = [        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Arts&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:History&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Society&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Biography&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Mathematics&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Technology&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Geography&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Science&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Computer_science&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Python_(programming_language)&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Java_(programming_language)&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/PHP&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Node.js&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/The_C_Programming_Language&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Go_(programming_language)&#x27;</span>    ]    start_time = time.perf_counter()    download_all(sites)    end_time = time.perf_counter()    print(<span class="hljs-string">&#x27;Download &#123;&#125; sites in &#123;&#125; seconds&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(sites), end_time - start_time)) <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre><p>创建了一个线程池，总共有 5 个线程可以分配使用。executer.map() 与前面所讲的 Python 内置的 map() 函数类似，表示对 sites 中的每一个元素，并发地调用函数 download_one()。</p><p>顺便提一下，在 download_one() 函数中，我们使用的 requests.get() 方法是线程安全的（thread-safe），因此在多线程的环境下，它也可以安全使用，并不会出现 race condition 的情况。</p><p>虽然线程的数量可以自己定义，但是线程数并不是越多越好，因为线程的创建、维护和删除也会有一定的开销。所以如果你设置的很大，反而可能会导致速度变慢。我们往往需要根据实际的需求做一些测试，来寻找最优的线程数量。</p><p>当然，我们也可以用并行的方式去提高程序运行效率。你只需要在 download_all() 函数中，做出下面的变化即可：</p><pre><code class="hljs python"><span class="hljs-keyword">with</span> futures.ThreadPoolExecutor(workers) <span class="hljs-keyword">as</span> executor=&gt;<span class="hljs-keyword">with</span> futures.ProcessPoolExecutor() <span class="hljs-keyword">as</span> executor:</code></pre><p>在需要修改的这部分代码中，函数 ProcessPoolExecutor() 表示创建进程池，使用多个进程并行的执行程序。不过，这里我们通常省略参数 workers，因为<strong>系统会自动返回 CPU 的数量作为可以调用的进程数</strong>。</p><p><strong>并行的方式一般用在 CPU heavy 的场景中，因为对于 I/O heavy 的操作，多数时间都会用于等待，相比于多线程，使用多进程并不会提升效率。反而很多时候，因为 CPU 数量的限制，会导致其执行效率不如多线程版本。</strong></p><h4 id="到底什么是-Futures"><a href="#到底什么是-Futures" class="headerlink" title="到底什么是 Futures"></a>到底什么是 Futures</h4><p>Python 中的 Futures 模块，位于 concurrent.futures 和 asyncio 中，它们都表示带有延迟的操作。Futures 会将处于等待状态的操作包裹起来放到队列中，这些操作的状态随时可以查询，当然，它们的结果或是异常，也能够在操作完成后被获取。</p><p>通常来说，作为用户，我们不用考虑如何去创建 Futures，这些 Futures 底层都会帮我们处理好。我们要做的，实际上是去 schedule 这些 Futures 的执行。</p><p>比如，Futures 中的 Executor 类，当我们执行 executor.submit(func) 时，它便会安排里面的 func() 函数执行，并返回创建好的 future 实例，以便你之后查询调用。</p><p>这里再介绍一些常用的函数。</p><ul><li>Futures 中的方法 done()，表示相对应的操作是否完成——True 表示完成，False 表示没有完成。不过，要注意，done() 是 non-blocking 的，会立即返回结果。相对应的 add_done_callback(fn)，则表示 Futures 完成后，相对应的参数函数 fn，会被通知并执行调用。</li><li>Futures 中还有一个重要的函数 result()，它表示当 future 完成后，返回其对应的结果或异常。而 as_completed(fs)，则是针对给定的 future 迭代器 fs，在其完成后，返回完成后的迭代器。</li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> concurrent.futures<span class="hljs-keyword">import</span> requests<span class="hljs-keyword">import</span> time <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download_one</span>(<span class="hljs-params">url</span>):</span>    resp = requests.get(url)    print(<span class="hljs-string">&#x27;Read &#123;&#125; from &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(resp.content), url)) <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download_all</span>(<span class="hljs-params">sites</span>):</span>    <span class="hljs-keyword">with</span> concurrent.futures.ThreadPoolExecutor(max_workers=<span class="hljs-number">5</span>) <span class="hljs-keyword">as</span> executor:        to_do = []        <span class="hljs-keyword">for</span> site <span class="hljs-keyword">in</span> sites:            future = executor.submit(download_one, site)            to_do.append(future)                    <span class="hljs-keyword">for</span> future <span class="hljs-keyword">in</span> concurrent.futures.as_completed(to_do):            future.result()<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    sites = [        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Arts&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:History&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Society&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Biography&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Mathematics&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Technology&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Geography&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Science&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Computer_science&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Python_(programming_language)&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Java_(programming_language)&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/PHP&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Node.js&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/The_C_Programming_Language&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Go_(programming_language)&#x27;</span>    ]    start_time = time.perf_counter()    download_all(sites)    end_time = time.perf_counter()    print(<span class="hljs-string">&#x27;Download &#123;&#125; sites in &#123;&#125; seconds&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(sites), end_time - start_time)) <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre><p>future 列表中每个 future 完成的顺序，和它在列表中的顺序并不一定完全一致。到底哪个先完成、哪个后完成，取决于系统的调度和每个 future 的执行时间。</p><h5 id="为什么多线程每次只能有一个线程执行？"><a href="#为什么多线程每次只能有一个线程执行？" class="headerlink" title="为什么多线程每次只能有一个线程执行？"></a>为什么多线程每次只能有一个线程执行？</h5><p>同一时刻，Python 主程序只允许有一个线程执行，所以 Python 的并发，是通过多线程的切换完成的</p><p>Python 的解释器并不是线程安全的，为了解决由此带来的 race condition 等问题，Python 便引入了全局解释器锁，也就是同一时刻，只允许一个线程执行。当然，在执行 I/O 操作时，如果一个线程被 block 了，全局解释器锁便会被释放，从而让另一个线程能够继续执行。</p><pre><code class="hljs ad-summary">并发，通过线程和任务之间互相切换的方式实现，但同一时刻，只允许有一个线程或任务执行。而并行，则是指多个进程完全同步同时的执行。</code></pre><p>并发通常用于 I/O 操作频繁的场景，而并行则适用于 CPU heavy 的场景。</p><h2 id="8-并发编程-Asyncio"><a href="#8-并发编程-Asyncio" class="headerlink" title="8. 并发编程 - Asyncio"></a>8. 并发编程 - Asyncio</h2><blockquote><p>多线程有诸多优点且应用广泛，但也存在一定的局限性：</p><ul><li>比如，多线程运行过程容易被打断，因此有可能出现 race condition 的情况；</li><li>再如，线程切换本身存在一定的损耗，线程数不能无限增加，因此，如果你的 I/O 操作非常 heavy，多线程很有可能满足不了高效率、高质量的需求。</li></ul><p>正是为了解决这些问题，Asyncio 应运而生。</p></blockquote><h3 id="8-1-什么是-Asyncio"><a href="#8-1-什么是-Asyncio" class="headerlink" title="8.1 什么是 Asyncio"></a>8.1 什么是 Asyncio</h3><h4 id="Sync-VS-Async"><a href="#Sync-VS-Async" class="headerlink" title="Sync VS Async"></a>Sync VS Async</h4><p>Sync（同步）和 Async（异步）的概念。</p><ul><li>所谓 Sync，是指操作一个接一个地执行，下一个操作必须等上一个操作完成后才能执行。</li><li>而 Async 是指不同操作间可以相互交替执行，如果其中的某个操作被 block 了，程序并不会等待，而是会找出可执行的操作继续执行。</li></ul><p>举个简单的例子，你的老板让你做一份这个季度的报表，并且邮件发给他。</p><ul><li>如果按照 Sync 的方式，你会先向软件输入这个季度的各项数据，接下来等待 5min，等报表明细生成后，再写邮件发给他。</li><li>但如果按照 Async 的方式，再你输完这个季度的各项数据后，便会开始写邮件。等报表明细生成后，你会暂停邮件，先去查看报表，确认后继续写邮件直到发送完毕。</li></ul><h3 id="8-2-Asyncio-工作原理"><a href="#8-2-Asyncio-工作原理" class="headerlink" title="8.2 Asyncio 工作原理"></a>8.2 Asyncio 工作原理</h3><p>Asyncio 和其他 Python 程序一样，是单线程的，它只有一个主线程，但是可以进行多个不同的任务（task），这里的任务，就是特殊的 future 对象。这些不同的任务，被一个叫做 event loop 的对象所控制。你可以把这里的任务，类比成多线程版本里的多个线程。</p><p>假设任务只有两个状态：一是预备状态；二是等待状态。所谓的预备状态，是指任务目前空闲，但随时待命准备运行。而等待状态，是指任务已经运行，但正在等待外部的操作完成，比如 I/O 操作。</p><p>对于 Asyncio 来说，它的任务在运行时不会被外部的一些因素打断，因此 Asyncio 内的操作不会出现 race condition 的情况，这样你就不需要担心线程安全的问题了。</p><h3 id="8-3-Asyncio-用法"><a href="#8-3-Asyncio-用法" class="headerlink" title="8.3 Asyncio 用法"></a>8.3 Asyncio 用法</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> asyncio<span class="hljs-keyword">import</span> aiohttp<span class="hljs-keyword">import</span> time <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download_one</span>(<span class="hljs-params">url</span>):</span>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> aiohttp.ClientSession() <span class="hljs-keyword">as</span> session:        <span class="hljs-keyword">async</span> <span class="hljs-keyword">with</span> session.get(url) <span class="hljs-keyword">as</span> resp:            print(<span class="hljs-string">&#x27;Read &#123;&#125; from &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(resp.content_length, url)) <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">download_all</span>(<span class="hljs-params">sites</span>):</span>    tasks = [asyncio.create_task(download_one(site)) <span class="hljs-keyword">for</span> site <span class="hljs-keyword">in</span> sites]    <span class="hljs-keyword">await</span> asyncio.gather(*tasks) <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>    sites = [        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Arts&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:History&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Society&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Biography&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Mathematics&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Technology&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Geography&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Portal:Science&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Computer_science&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Python_(programming_language)&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Java_(programming_language)&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/PHP&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Node.js&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/The_C_Programming_Language&#x27;</span>,        <span class="hljs-string">&#x27;https://en.wikipedia.org/wiki/Go_(programming_language)&#x27;</span>    ]    start_time = time.perf_counter()    asyncio.run(download_all(sites))    end_time = time.perf_counter()    print(<span class="hljs-string">&#x27;Download &#123;&#125; sites in &#123;&#125; seconds&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">len</span>(sites), end_time - start_time))    <span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:    main()</code></pre><h3 id="8-4-多线程还是-Asyncio"><a href="#8-4-多线程还是-Asyncio" class="headerlink" title="8.4 多线程还是 Asyncio"></a>8.4 多线程还是 Asyncio</h3><ul><li>如果是 I/O bound，并且 I/O 操作很慢，需要很多任务 / 线程协同实现，那么使用 Asyncio 更合适。</li><li>如果是 I/O bound，但是 I/O 操作很快，只需要有限数量的任务 / 线程，那么使用多线程就可以了。</li><li>如果是 CPU bound，则需要使用多进程来提高程序运行效率。</li></ul><pre><code class="hljs ad-summary">不同于多线程，Asyncio 是单线程的，但其内部 event loop 的机制，可以让它并发地运行多个不同的任务，并且比多线程享有更大的自主控制权。Asyncio 中的任务，在运行过程中不会被打断，因此不会出现 race condition 的情况。尤其是在 I&#x2F;O 操作 heavy 的场景下，Asyncio 比多线程的运行效率更高。因为 Asyncio 内部任务切换的损耗，远比线程切换的损耗要小；并且 Asyncio 可以开启的任务数量，也比多线程中的线程数量多得多。但需要注意的是，很多情况下，使用 Asyncio 需要特定第三方库的支持，比如前面示例中的 aiohttp。而如果 I&#x2F;O 操作很快，并不 heavy，那么运用多线程，也能很有效地解决问题。</code></pre><h2 id="9-GIL-（全局解析器锁）"><a href="#9-GIL-（全局解析器锁）" class="headerlink" title="9. GIL （全局解析器锁）"></a>9. GIL （全局解析器锁）</h2><h3 id="9-1-GIL"><a href="#9-1-GIL" class="headerlink" title="9.1 GIL"></a>9.1 GIL</h3><p>Python 的线程，的的确确封装了底层的操作系统线程，在 Linux 系统里是 Pthread（全称为 POSIX Thread），而在 Windows 系统里是 Windows Thread。另外，Python 的线程，也完全受操作系统管理，比如协调何时执行、管理内存资源、管理中断等等。</p><p>GIL，是最流行的 Python 解释器 CPython 中的一个技术术语。它的意思是全局解释器锁，本质上是类似操作系统的 Mutex。每一个 Python 线程，在 CPython 解释器中执行时，都会先锁住自己的线程，阻止别的线程执行。</p><p>CPython 会做一些小把戏，轮流执行 Python 线程。这样一来，用户看到的就是“伪并行”——Python 线程在交错执行，来模拟真正并行的线程。</p><p>CPython 使用引用计数来管理内存，所有 Python 脚本中创建的实例，都会有一个引用计数，来记录有多少个指针指向它。当引用计数只有 0 时，则会自动释放内存。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> sysa = []b = asys.getrefcount(a)</code></pre><p>这个例子中，a 的引用计数是 3，因为有 a、b 和作为参数传递的 getrefcount 这三个地方，都引用了一个空列表。</p><p>CPython 引进 GIL 其实主要就是这么两个原因：</p><ul><li>一是设计者为了规避类似于内存管理这样的复杂的竞争风险问题（race condition）；</li><li>二是因为 CPython 大量使用 C 语言库，但大部分 C 语言库都不是原生线程安全的（线程安全会降低性能和增加复杂度）。</li></ul><h3 id="9-2-GIL-如何工作"><a href="#9-2-GIL-如何工作" class="headerlink" title="9.2 GIL 如何工作"></a>9.2 GIL 如何工作</h3><p>下面这张图，就是一个 GIL 在 Python 程序的工作示例。其中，Thread 1、2、3 轮流执行，每一个线程在开始执行时，都会锁住 GIL，以阻止别的线程执行；同样的，每一个线程执行完一段后，会释放 GIL，以允许别的线程开始利用资源。</p><p><img src="data:image/png;base64,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Zu7oRz/6jDe7ZWV7pXY4B7oCvcNZ3AtYzxwwyXj+9re/DW984xuHf/7zn8P5z3/+4WIXu1idaKMAE7zf+c53hne9613DRS5ykeFSl7rUcIxjHKPCpH5/+MMfhq9+9avDl770peGnP/1pxXmiE51oON3pTjec+9znrniPc5zjVMGtTDh35wk8fOn+zuGAPhVlSYn6sn59yCGHDD/72c9qnz3f+c5X+zvlATz39a9/vfbrC13oQsMVr3jFqmBIoyRz8Mj/hS98Yfja1742/PGPf6zlnPjEJx7OfvazDxe84AVrHz/2sY89U0xDiz4eBTVxFekKP6EpyepjLB188MHD3//+9zr20Mmlrv/617+Gb3zjG8P73//+4XKXu9xw4QtfeLNxBae8P/jBD4bPfOYzw/e///3h97//fR2/Jz3pSYfznOc8w3nPe97htKc9bY2b0tDSkvD29lOmOgnz0fiJT3yi0n2mM51puNrVrjaTScoH95vf/GY46KCDKv9vcIMbVPrDF/6f/vSn4Vvf+laVSUtLS5UPFGgy6VznOlet9ylPecpanZQbWlLH4Mv7zvLRgf6Pfexjw/e+973hzGc+83D1q199xh99iyN38QCPrnGNawz6IZd6WDTov1/+8peHr3zlK8Pvfve72sdPcpKTDGc5y1lq/91jjz1qPrDGRmQzPLuq/srubp1zoHSy7joHFpIDRUiOHq5MMmNRnMdTnepU48Me9rDxH//4R40PTJmAx2c+85ljmXTGl770pWNRTMYibCvMX//61/Htb3/7eMMb3nA8/elPPx7veMcbj3vc49anCPOxKBpjEdDjrW51q/EjH/nIWBSSsUz6M/w10H86B7aBA+mn/GJhq5iEv/vd747Xvva1x7KQGx/3uMeNRfmd9Xnp+uLTn/708YxnPONYFpAzCuDw/PCHPxwf85jHjEUpHYuyWft0WQSO+jVfnHED99LSUh0TcE7p8L4aBy6P8o2xoriPZzjDGcai4I7PeMYzZuMu+IzFxz72sWNZpI5vectbZunySvv2t789PvzhDx8vcIELVHrRfaxjHas+xz/+8ceiSI177rnn+PznP3/89a9/PaNd/tSFz622HqFttX7qDD71Lgr/eKMb3ai23b777juTGWDAg3vrW99a6T/wwANreuKlff7znx9vc5vbjGc961lH9Uy9ySfPqU996vE6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vZcA598ETMAETMAETMAETGAQAQvoQbic2ARMwARMwARMwARMoHcCFtC9lwDn3wRMwARMwARMwARMYBABC+hBuJzYBEzABEzABEzABEygdwIW0L2XAOffBEzABEzABEzABExgEAEL6EG4nNgETMAETMAETMAETKB3AhbQvZcA598ETMAETMAETMAETGAQAQvoQbic2ARMwARMwARMwARMoHcCFtC9lwDn3wRMwARMwARMwARMYBABC+hBuJzYBEzABEzABEzABEygdwIW0L2XAOffBEzABEzABEzABExgEAEL6EG4nNgETMAETMAETMAETKB3AhbQvZcA598ETMAETMAETMAETGAQAQvoQbic2ARMwARMwARMwARMoHcCFtC9lwDn3wRMwARMwARMwARMYBABC+hBuJzYBEzABEzABEzABEygdwIW0L2XAOffBEzABEzABEzABExgEAEL6EG4nNgETMAETMAETMAETKB3AhbQvZcA598ETMAETMAETMAETGAQAQvoQbic2ARMwARMwARMwARMoHcCFtC9lwDn3wRMwARMwATMLn/WAAAADUlEQVRMwARMYBCB/wE617coX0dSVgAAAABJRU5ErkJggg==" alt="img"></p><p>CPython 中还有另一个机制，叫做 check_interval，意思是 CPython 解释器会去轮询检查线程 GIL 的锁住情况。每隔一段时间，Python 解释器就会强制当前线程去释放 GIL，这样别的线程才能有执行的机会。</p><p>不同版本的 Python 中，check interval 的实现方式并不一样。早期的 Python 是 100 个 ticks，大致对应了 1000 个 bytecodes；而 Python 3 以后，interval 是 15 毫秒。当然，我们不必细究具体多久会强制释放 GIL，这不应该成为我们程序设计的依赖条件，我们只需明白，CPython 解释器会在一个“合理”的时间范围内释放 GIL 就可以了。</p><p><img src="data:image/png;base64,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NCndeuut6Tvf+U5ad9110yyzzOJlJ+7bb7+dRo8e7edXXnnlKTDh/uhspoClVCeQET/NG/z444/T1Vdf7aRw6623Tt/+9rf9OnH4CBg0aFDaaKON0vrrr+/nKQz3Uh9C1vURLbIBfxH5N998M918881p0UUXTauttlrio03yeeqpp/xanz59Uo8ePTzDqgO6XzKtT2niqdNCIIjhtBCK64FAINCmCNCBSDvE9m9/+1s65phj0ksvvZQGDx6cevfu7aQREnD//fenM888Mx155JFpmWWWqRAMOhpCEIU2FU27JCZZsUXeb731Vvr5z3+enn/++XTiiScmCAQfA2gJJ06cmDbccMM0ZsyYxIeACIXknNebdslsJDoZAmqr4K6AnB599NH0y1/+0uUGkV9xxRW9LSKvG264wX+HHnpoWmyxxRIfgRpSztNRerEtHwJBDMsnk8hRINBhEVBHQwFFFBh2QvswdOhQ1xqecMIJqWfPnt6Z3HLLLenyyy934titWzfHRfdxEB2NQ1LqP8lccvv3v//tGuKjjz7atYV8FOhj4MEHH0z77rtvuvLKK1P37t0nKxfpEEQSJ7sYB+2CADLjJ8zZJ3zwwQfpsssuS2effbaTwqOOOir98Ic/TMj2qquuSg888EA68MADU9euXSuaxDydIPjtIq42SzSIYZtBGQkFAoHAtBCgc0DjIA2CSMMnn3ziHQoaJLQMp512WlpyySX93D333JN+9atfpfnnn7+iaeQ53EuHFeRwWqjX97rIBPJin+FECMSNN96YIIeQh2OPPdYJxh/+8Ic0bNiwNHbs2LTAAgu4jMk9cuZefiIp9S1V53k6mKuNqb1S+vfeey+df/75aeTIkWm99dZz7S9zCi+88EK/1r9///T973+/IjuloS1p5GlzHKEcCAQxLIccIheBQKdAgI6AzgVyQOBY4dNPP3UNxJAhQ1Lfvn19+BhSOGHChHTQQQe5MQLxNU8piKGQa4ytZA0xYHiR3wUXXJB++9vfuob4uOOO8yHIu+++2+eVfutb36qQQOIid+6V3Buj1B0nl8hPpA4ZcPz+++/7nFC0hwMGDEh77rmna/iR1T777JO++93vVu4BCe4jDaWTp9lxkGr8kgQxbHwZRgkCgYZBQB3Bv/71L+/0pTnEEpVOAwOUAw44IF1yySVp5513ds3inXfemRZffHEf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" alt="img"></p><pre><code class="hljs python"><span class="hljs-keyword">for</span> (;;) &#123;    <span class="hljs-keyword">if</span> (--ticker &lt; <span class="hljs-number">0</span>) &#123;        ticker = check_interval;            /* Give another thread a chance */        PyThread_release_lock(interpreter_lock);            /* Other threads may run now */            PyThread_acquire_lock(interpreter_lock, <span class="hljs-number">1</span>);    &#125;     bytecode = *next_instr++;    switch (bytecode) &#123;        /* execute the <span class="hljs-built_in">next</span> instruction ... */     &#125;&#125;</code></pre><p>从这段代码中，我们可以看到，每个 Python 线程都会先检查 ticker 计数。只有在 ticker 大于 0 的情况下，线程才会去执行自己的 bytecode。</p><h3 id="9-3-线程安全"><a href="#9-3-线程安全" class="headerlink" title="9.3 线程安全"></a>9.3 线程安全</h3><pre><code class="hljs python">mport threading n = <span class="hljs-number">0</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span>    <span class="hljs-keyword">global</span> n    n += <span class="hljs-number">1</span> threads = []<span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):    t = threading.Thread(target=foo)    threads.append(t) <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:    t.start() <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> threads:    t.join() print(n)</code></pre><p>如果你执行的话，就会发现，尽管大部分时候它能够打印 100，但有时侯也会打印 99 或者 98。</p><p>这其实就是因为，<code>n+=1</code>这一句代码让线程并不安全。如果你去翻译 foo 这个函数的 bytecode，就会发现，它实际上由下面四行 bytecode 组成：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> disdis.dis(foo)</code></pre><p><strong>GIL 的设计，主要是为了方便 CPython 解释器层面的编写者，而不是 Python 应用层面的程序员</strong></p><p>作为 Python 的使用者，我们还是需要 lock 等工具，来确保线程安全。</p><pre><code class="hljs python">n = <span class="hljs-number">0</span>lock = threading.Lock() <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>():</span>    <span class="hljs-keyword">global</span> n    <span class="hljs-keyword">with</span> lock:        n += <span class="hljs-number">1</span></code></pre><h3 id="9-4-绕过-GIL"><a href="#9-4-绕过-GIL" class="headerlink" title="9.4 绕过 GIL"></a>9.4 绕过 GIL</h3><p>大部分应用情况下，你并不需要过多考虑 GIL。因为如果多线程计算成为性能瓶颈，往往已经有 Python 库来解决这个问题了。</p><p>如果你的应用真的对性能有超级严格的要求，比如 100us 就对你的应用有很大影响，那我必须要说，Python 可能不是你的最优选择。</p><p>绕过 GIL 的大致思路有这么两种就够了：</p><ol><li>绕过 CPython，使用 JPython（Java 实现的 Python 解释器）等别的实现；</li><li>把关键性能代码，放到别的语言（一般是 C++）中实现。</li></ol><h2 id="10-垃圾回收机制"><a href="#10-垃圾回收机制" class="headerlink" title="10. 垃圾回收机制"></a>10. 垃圾回收机制</h2><p>Python 程序在运行的时候，需要在内存中开辟出一块空间，用于存放运行时产生的临时变量；计算完成后，再将结果输出到永久性存储器中。如果数据量过大，内存空间管理不善就很容易出现 OOM（out of memory），俗称爆内存，程序可能被操作系统中止。</p><p>而对于服务器，这种设计为永不中断的系统来说，内存管理则显得更为重要，不然很容易引发内存泄漏。什么是内存泄漏呢？</p><ul><li>这里的泄漏，并不是说你的内存出现了信息安全问题，被恶意程序利用了，而是指程序本身没有设计好，导致程序未能释放已不再使用的内存。</li><li>内存泄漏也不是指你的内存在物理上消失了，而是意味着代码在分配了某段内存后，因为设计错误，失去了对这段内存的控制，从而造成了内存的浪费。</li></ul><h3 id="10-1-计数引用"><a href="#10-1-计数引用" class="headerlink" title="10.1 计数引用"></a>10.1 计数引用</h3><ul><li><p>Python 中一切皆对象。因此，你所看到的一切变量，本质上都是对象的一个指针。</p></li><li><p>当这个对象的引用计数（指针数）为 0 的时候，说明这个对象永不可达，自然它也就成为了垃圾，需要被回收。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-keyword">import</span> psutil <span class="hljs-comment"># 显示当前 python 程序占用的内存大小</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_memory_info</span>(<span class="hljs-params">hint</span>):</span>    pid = os.getpid()    p = psutil.Process(pid)        info = p.memory_full_info()    memory = info.uss / <span class="hljs-number">1024.</span> / <span class="hljs-number">1024</span>    print(<span class="hljs-string">&#x27;&#123;&#125; memory used: &#123;&#125; MB&#x27;</span>.<span class="hljs-built_in">format</span>(hint, memory))<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span>    show_memory_info(<span class="hljs-string">&#x27;initial&#x27;</span>)    a = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000000</span>)]    show_memory_info(<span class="hljs-string">&#x27;after a created&#x27;</span>) func()show_memory_info(<span class="hljs-string">&#x27;finished&#x27;</span>)</code></pre><p>通过这个示例，你可以看到，调用函数 func()，在列表 a 被创建之后，内存占用迅速增加到了 433 MB：而在函数调用结束后，内存则返回正常。</p><p>这是因为，函数内部声明的列表 a 是局部变量，在函数返回后，局部变量的引用会注销掉；此时，列表 a 所指代对象的引用数为 0，Python 便会执行垃圾回收，因此之前占用的大量内存就又回来了。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span>    show_memory_info(<span class="hljs-string">&#x27;initial&#x27;</span>)    <span class="hljs-keyword">global</span> a    a = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000000</span>)]    show_memory_info(<span class="hljs-string">&#x27;after a created&#x27;</span>) func()show_memory_info(<span class="hljs-string">&#x27;finished&#x27;</span>)</code></pre><p>新的这段代码中，global a 表示将 a 声明为全局变量。那么，即使函数返回后，列表的引用依然存在，于是对象就不会被垃圾回收掉，依然占用大量内存。</p><p>如果我们把生成的列表返回，然后在主程序中接收，那么引用依然存在，垃圾回收就不会被触发，大量内存仍然被占用着：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span>    show_memory_info(<span class="hljs-string">&#x27;initial&#x27;</span>)    a = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000000</span>)]    show_memory_info(<span class="hljs-string">&#x27;after a created&#x27;</span>)    <span class="hljs-keyword">return</span> aa = func()show_memory_info(<span class="hljs-string">&#x27;finished&#x27;</span>)</code></pre></li><li><p>python 内部的引用计数机制</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys a = [] <span class="hljs-comment"># 两次引用，一次来自 a，一次来自 getrefcount</span>print(sys.getrefcount(a)) <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">a</span>):</span>    <span class="hljs-comment"># 四次引用，a，python 的函数调用栈，函数参数，和 getrefcount</span>    print(sys.getrefcount(a)) func(a) <span class="hljs-comment"># 两次引用，一次来自 a，一次来自 getrefcount，函数 func 调用已经不存在</span>print(sys.getrefcount(a))</code></pre><p>sys.getrefcount() 这个函数，可以查看一个变量的引用次数。这段代码本身应该很好理解，不过别忘了，<strong>getrefcount 本身也会引入一次计数</strong>。</p></li><li><p>另一个要注意的是，在函数调用发生的时候，会产生额外的两次引用，一次来自函数栈，另一个是函数参数。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys a = [] print(sys.getrefcount(a)) <span class="hljs-comment"># 两次</span> b = a print(sys.getrefcount(a)) <span class="hljs-comment"># 三次</span> c = bd = be = cf = eg = d print(sys.getrefcount(a)) <span class="hljs-comment"># 八次</span></code></pre><p>a、b、c、d、e、f、g 这些变量全部指代的是同一个对象，而 sys.getrefcount() 函数并不是统计一个指针，而是要统计一个对象被引用的次数，所以最后一共会有八次引用。</p></li><li><p>先调用 del a 来删除一个对象；然后强制调用 gc.collect()，即可手动启动垃圾回收。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc show_memory_info(<span class="hljs-string">&#x27;initial&#x27;</span>) a = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000000</span>)] show_memory_info(<span class="hljs-string">&#x27;after a created&#x27;</span>) <span class="hljs-keyword">del</span> agc.collect() show_memory_info(<span class="hljs-string">&#x27;finish&#x27;</span>)print(a)</code></pre></li></ul><h3 id="10-2-循环引用"><a href="#10-2-循环引用" class="headerlink" title="10.2 循环引用"></a>10.2 循环引用</h3><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span>    show_memory_info(<span class="hljs-string">&#x27;initial&#x27;</span>)    a = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000000</span>)]    b = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000000</span>)]    show_memory_info(<span class="hljs-string">&#x27;after a, b created&#x27;</span>)    a.append(b)    b.append(a) func()show_memory_info(<span class="hljs-string">&#x27;finished&#x27;</span>)</code></pre><p>a 和 b 互相引用，并且，作为局部变量，在函数 func 调用结束后，a 和 b 这两个指针从程序意义上已经不存在了。但是，很明显，依然有内存占用！为什么呢？因为互相引用，导致它们的引用数都不为 0。</p><ul><li><p>可以显式调用 gc.collect() ，来启动垃圾回收。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> gc <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span>    show_memory_info(<span class="hljs-string">&#x27;initial&#x27;</span>)    a = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000000</span>)]    b = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000000</span>)]    show_memory_info(<span class="hljs-string">&#x27;after a, b created&#x27;</span>)    a.append(b)    b.append(a) func()gc.collect()show_memory_info(<span class="hljs-string">&#x27;finished&#x27;</span>)</code></pre></li></ul><h5 id="Python-使用标记清除（mark-sweep）算法和分代收集（generational），来启用针对循环引用的自动垃圾回收。"><a href="#Python-使用标记清除（mark-sweep）算法和分代收集（generational），来启用针对循环引用的自动垃圾回收。" class="headerlink" title="Python 使用标记清除（mark-sweep）算法和分代收集（generational），来启用针对循环引用的自动垃圾回收。"></a><strong>Python 使用标记清除（mark-sweep）算法和分代收集（generational），来启用针对循环引用的自动垃圾回收。</strong></h5><ul><li>先来看<strong>标记清除算法</strong>。我们先用图论来理解不可达的概念。对于一个有向图，如果从一个节点出发进行遍历，并标记其经过的所有节点；那么，在遍历结束后，所有没有被标记的节点，我们就称之为不可达节点。显而易见，这些节点的存在是没有任何意义的，自然的，我们就需要对它们进行垃圾回收。</li><li>在 Python 的垃圾回收实现中，mark-sweep 使用双向链表维护了一个数据结构，并且只考虑容器类的对象（只有容器类对象才有可能产生循环引用）。</li><li><strong>分代收集算法</strong></li><li>Python 将所有对象分为三代。刚刚创立的对象是第 0 代；经过一次垃圾回收后，依然存在的对象，便会依次从上一代挪到下一代。而每一代启动自动垃圾回收的阈值，则是可以单独指定的。当垃圾回收器中新增对象减去删除对象达到相应的阈值时，就会对这一代对象启动垃圾回收。</li><li>分代收集基于的思想是，新生的对象更有可能被垃圾回收，而存活更久的对象也有更高的概率继续存活。因此，通过这种做法，可以节约不少计算量，从而提高 Python 的性能。</li></ul><h3 id="10-3-调试内存泄漏-objgraph"><a href="#10-3-调试内存泄漏-objgraph" class="headerlink" title="10.3 调试内存泄漏 objgraph"></a>10.3 调试内存泄漏 <a href="https://mg.pov.lt/objgraph/">objgraph</a></h3><ul><li><p>show_refs()，它可以生成清晰的引用关系图。</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> objgraph a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]b = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>] a.append(b)b.append(a) objgraph.show_refs([a])</code></pre></li><li><p>show_backrefs()</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> objgraph a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]b = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>] a.append(b)b.append(a) objgraph.show_backrefs([a])</code></pre><p><a href="https://mg.pov.lt/objgraph/">https://mg.pov.lt/objgraph/</a></p></li></ul><pre><code class="hljs ad-summary">垃圾回收是 Python 自带的机制，用于自动释放不会再用到的内存空间；引用计数是其中最简单的实现，不过切记，这只是充分非必要条件，因为循环引用需要通过不可达判定，来确定是否可以回收；Python 的自动回收算法包括标记清除和分代收集，主要针对的是循环引用的垃圾收集；调试内存泄漏方面， objgraph 是很好的可视化分析工具。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes 架构原则和对象设计</title>
    <link href="/2022/07/13/cloud/cncamp/module_04/"/>
    <url>/2022/07/13/cloud/cncamp/module_04/</url>
    
    <content type="html"><![CDATA[<h1 id="4-Kubernetes-架构原则和对象设计"><a href="#4-Kubernetes-架构原则和对象设计" class="headerlink" title="4. Kubernetes 架构原则和对象设计"></a>4. Kubernetes 架构原则和对象设计</h1><h2 id="4-1-Kubernetes-架构基础"><a href="#4-1-Kubernetes-架构基础" class="headerlink" title="4.1 Kubernetes 架构基础"></a>4.1 Kubernetes 架构基础</h2><h3 id="4-1-1-Brog"><a href="#4-1-1-Brog" class="headerlink" title="4.1.1 Brog"></a>4.1.1 Brog</h3><h3 id="4-1-2-Kubernetes"><a href="#4-1-2-Kubernetes" class="headerlink" title="4.1.2 Kubernetes"></a>4.1.2 Kubernetes</h3><h2 id="4-2-了解-kubectl"><a href="#4-2-了解-kubectl" class="headerlink" title="4.2 了解 kubectl"></a>4.2 了解 kubectl</h2><h2 id="4-3-深入理解-Kubernetes"><a href="#4-3-深入理解-Kubernetes" class="headerlink" title="4.3 深入理解 Kubernetes"></a>4.3 深入理解 Kubernetes</h2><h3 id="TypeMeta"><a href="#TypeMeta" class="headerlink" title="TypeMeta"></a>TypeMeta</h3><h3 id="Metadata"><a href="#Metadata" class="headerlink" title="Metadata"></a>Metadata</h3><h2 id="4-4-核心对象概览"><a href="#4-4-核心对象概览" class="headerlink" title="4.4 核心对象概览"></a>4.4 核心对象概览</h2>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker 核心技术</title>
    <link href="/2022/07/13/cloud/cncamp/module_03/"/>
    <url>/2022/07/13/cloud/cncamp/module_03/</url>
    
    <content type="html"><![CDATA[<h1 id="3-Docker-核心技术"><a href="#3-Docker-核心技术" class="headerlink" title="3. Docker 核心技术"></a>3. Docker 核心技术</h1><h2 id="3-1-从系统架构谈起"><a href="#3-1-从系统架构谈起" class="headerlink" title="3.1 从系统架构谈起"></a>3.1 从系统架构谈起</h2><h3 id="3-1-1-传统分层架构-vs-微服务架构"><a href="#3-1-1-传统分层架构-vs-微服务架构" class="headerlink" title="3.1.1 传统分层架构 vs 微服务架构"></a>3.1.1 传统分层架构 vs 微服务架构</h3><ul><li>传统分层架构<ul><li>优点：<ul><li>易部署</li><li>易测试</li><li>易横向拓展</li></ul></li><li>缺点：<ul><li>难以理解整体</li><li>不易快速维护</li><li>启动慢</li><li>部署慢</li><li>变更引起的回归问题多</li><li>难以做持续集成和持续部署</li></ul></li></ul></li><li>微服务<ul><li>优点：<ul><li>高内聚、松耦合</li><li>复杂系统更加可维护</li><li>服务独立部署，易于持续集成和持续部署</li><li>每个微服务独立拓展</li></ul></li><li>缺点：<ul><li>增加了系统的复杂性，把集群部署变成了分布式部署。需要实现基于消息或 RPC 的进程间通讯，需要处理部署失败等分布式系统的复杂问题</li><li>微服务采用分区数据库架构，一个事务需要更新不同微服务的数据库，分布式事务更复杂（失败回滚）</li><li>测试更加复杂</li><li>部署监控更复杂<h3 id="3-1-2-微服务改造"><a href="#3-1-2-微服务改造" class="headerlink" title="3.1.2 微服务改造"></a>3.1.2 微服务改造</h3></li></ul></li></ul></li><li>分离微服务的方法建议<ul><li>审视并发现可以分离的业务逻辑</li><li>寻找天生隔离的代码模块，可以借助静态代码分析工具</li><li>不同并发规模，不同内存需求的模块都可以分理出不同的微服务，此方法可提高资源利用率，节省成本</li></ul></li><li>常用的可微服务化的组件<ul><li>用户和账户管理</li><li>授权和会话管理</li><li>系统配置</li><li>通知和通讯服务</li><li>照片、多媒体、元数据等</li></ul></li><li><strong>分解原则：基于 Size、Scope、Capabilities</strong><h3 id="3-1-3-微服务间通讯"><a href="#3-1-3-微服务间通讯" class="headerlink" title="3.1.3 微服务间通讯"></a>3.1.3 微服务间通讯</h3></li><li>点对点<ul><li>多用于系统内部多组件之间通讯</li><li>有大量的重复模块，如认证授权</li><li>缺少统一规范，如监控、审计等功能</li><li>后期维护成本高，服务和服务的依赖关系错综复杂，难以管理</li></ul></li><li><strong>API 网关</strong><ul><li>基于一个轻量级的 message gateway</li><li>新 API 通过注册至 Gateway 实现</li><li>整合实现 Common function<h2 id="3-2-理解-Docker"><a href="#3-2-理解-Docker" class="headerlink" title="3.2 理解 Docker"></a>3.2 理解 Docker</h2><h3 id="3-2-1-Docker"><a href="#3-2-1-Docker" class="headerlink" title="3.2.1 Docker"></a>3.2.1 Docker</h3>• 基于 Linux 内核的 Cgroup,  Namespace ，以 及 Union FS 等技术，对进程进行封装隔离，属于操作系统层面的虚拟化技术，由于隔离的进程独立于宿主和其它的隔离的进程，因此也称其为容器。<br>• 最初实现是基于 LXC,从 0.7 以后开始去除 LXC, 转而使用自行开发的 Lib container, 从 1.11 开始， 则进一步演进为使用 rune 和 Containerd 。<br>• Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等， 极大的简化了容器的创建和维护，使得 Docker  技术比虚拟机技术更为轻便、快捷。</li></ul></li></ul><h3 id="3-2-2-Why-Docker"><a href="#3-2-2-Why-Docker" class="headerlink" title="3.2.2 Why Docker"></a>3.2.2 Why Docker</h3><ul><li>更高效地利用系统资源</li><li>更快速的启动时间</li><li>一致的运行环境</li><li>持续交付和部署</li><li>更轻松地迁移</li><li>更轻松地维护和扩展<h3 id="3-2-3-虚拟机和容器对比"><a href="#3-2-3-虚拟机和容器对比" class="headerlink" title="3.2.3 虚拟机和容器对比"></a>3.2.3 虚拟机和容器对比</h3></li><li>运行时</li><li>性能<table><thead><tr><th>特性</th><th>容器</th><th>虚拟机</th></tr></thead><tbody><tr><td>启动</td><td>秒级</td><td>分钟级</td></tr><tr><td>硬盘使用</td><td>MB</td><td>GB</td></tr><tr><td>性能</td><td>接近原生</td><td>弱于</td></tr><tr><td>系统支持量</td><td>单机支持上千容器</td><td>一般几十个</td></tr></tbody></table></li></ul><h3 id="3-2-4-Docker-Install"><a href="#3-2-4-Docker-Install" class="headerlink" title="3.2.4 Docker Install"></a>3.2.4 Docker Install</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 备份初始源</span>cp /etc/apt/sources.list /etc/apt/sources.list_backuptee /etc/apt/sources.list &lt;&lt; EOF<span class="hljs-meta">#</span><span class="bash">  阿里源</span>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverseEOF<span class="hljs-meta">#</span><span class="bash"> 添加公钥</span>apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 40976EAF437D05B5apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3B4FE6ACC0B21F32apt-get -y update apt-get -y upgradeapt-get -y install build-essentialapt -y autoremove<span class="hljs-meta">#</span><span class="bash"> 卸载旧版</span>sudo apt-get remove docker docker-engine docker.io containerd runc<span class="hljs-meta">#</span><span class="bash"> 安装 docker 1</span>curl -fsSL https://get.docker.com | bash -s docker --mirror aliyun<span class="hljs-meta">#</span><span class="bash"> 安装 docker 2</span>curl -sSL https://get.daocloud.io/docker | sh<span class="hljs-meta">#</span><span class="bash"> 安装 docker compose</span>curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composedocker-compose -vsystemctl daemon-reloadservice docker restartservice docker status <span class="hljs-meta">#</span><span class="bash"> Install bash-completion</span>apt install -y bash-completionsource /usr/share/bash-completion/bash_completionsource /usr/share/bash-completion/completions/docker</code></pre><h3 id="3-2-5-容器操作"><a href="#3-2-5-容器操作" class="headerlink" title="3.2.5 容器操作"></a>3.2.5 容器操作</h3><table><thead><tr><th>命令</th><th>说明</th></tr></thead><tbody><tr><td>docker run<br/>    - -it 交互<br/>    - -d 后台运行<br/>    - -p 端口映射（目的：Docker内）<br/>    - -v 磁盘挂载<br/>    - –rm 退出时删除</td><td>启动</td></tr><tr><td>docker inspect</td><td><strong>查看容器细节</strong></td></tr><tr><td>docker attach<br />nsenter –target $PID –mount –uts –ipc –net –pid</td><td><strong>进入容器</strong></td></tr><tr><td>docker cp file1 <containerid>:/file-to-path</td><td>拷贝文件至容器内</td></tr><tr><td>docker start</td><td>启动已终止容器</td></tr><tr><td>docker stop</td><td>停止容器</td></tr><tr><td>docker ps</td><td>查看容器进程</td></tr></tbody></table><h2 id="3-3-Docker-核心技术"><a href="#3-3-Docker-核心技术" class="headerlink" title="3.3 Docker 核心技术"></a>3.3 Docker 核心技术</h2><h3 id="3-3-1-容器主要特性"><a href="#3-3-1-容器主要特性" class="headerlink" title="3.3.1 容器主要特性"></a>3.3.1 容器主要特性</h3><ul><li>安全性</li><li>可配额</li><li>隔离性</li><li>便携性</li></ul><h3 id="3-3-2-Namespace"><a href="#3-3-2-Namespace" class="headerlink" title="3.3.2 Namespace"></a>3.3.2 Namespace</h3><blockquote><p>Linux Namespace 是一种 Linux Kernel 提供的资源隔离方案：</p><ul><li>系统可以为进程分配不同的 Namespace</li><li>并保证不同的 Namespace 资源独立分配、进程彼此隔离，即 不同的 Namespace 下的机才能拿互不干扰</li></ul></blockquote><h4 id="3-3-2-1-Linux-内核代码中-Namespace-的实现"><a href="#3-3-2-1-Linux-内核代码中-Namespace-的实现" class="headerlink" title="3.3.2.1 Linux 内核代码中 Namespace 的实现"></a>3.3.2.1 Linux 内核代码中 Namespace 的实现</h4><ul><li><p>进程数据结构</p><pre><code class="hljs shell">struct task_struct&#123;  ...  /* namespaces */struct nsproxy *nsproxy;&#125;</code></pre></li><li><p>Namespace 数据结构</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nsproxy</span>&#123;</span>  <span class="hljs-keyword">atomic_t</span> count;  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">uts_namespace</span> *<span class="hljs-title">uts_ns</span>;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ipc_namespace</span> *<span class="hljs-title">ipc_ns</span>;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mnt_namesapce</span> *<span class="hljs-title">mnt_ns</span>;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_namespace</span> *<span class="hljs-title">pid_ns_for_children</span>;</span>  <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">net</span> *<span class="hljs-title">net_ns</span>;</span>&#125;</code></pre></li></ul><h4 id="3-3-2-2-Linux-对-Namespace-操作方法"><a href="#3-3-2-2-Linux-对-Namespace-操作方法" class="headerlink" title="3.3.2.2 Linux 对 Namespace 操作方法"></a>3.3.2.2 Linux 对 Namespace 操作方法</h4><ul><li><p>clone</p><p>在创建新进程的系统调用时，可以通过 flags 参数指定需要新建的 Namespace 类型：</p><pre><code class="hljs c++"><span class="hljs-comment">// CLONE_NEWGROUP / CLONE_NEWIPC / CLONE_NEWNS / CLONE_NEWPID / CLONE_NEWUSER / CLONE_NEWUTS</span><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">int</span> (*fn)(<span class="hljs-keyword">void</span>*), <span class="hljs-keyword">void</span> *child_stack, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">void</span> *arg)</span></span></code></pre></li><li><p>setns</p><p>该系统调用可以让调用进程加入某个已经存在的 Namespace 中：</p><p>int setns(int fd, int nstype)</p></li><li><p>unshare</p><p>该系统调用可以将调用进程移动到新的 Namespace 下：</p><p>int unshare(int flags)</p></li></ul><h4 id="3-3-2-3-隔离性"><a href="#3-3-2-3-隔离性" class="headerlink" title="3.3.2.3 隔离性"></a>3.3.2.3 隔离性</h4><table><thead><tr><th align="center">Namespace 类型</th><th align="center">隔离资源</th><th align="center">Kernel 版本</th></tr></thead><tbody><tr><td align="center">IPC</td><td align="center">System V IPC 和 POSIX 消息队列</td><td align="center">2.6.19</td></tr><tr><td align="center">Network</td><td align="center">网络设备、网络协议栈、网络端口等</td><td align="center">2.6.29</td></tr><tr><td align="center">PID</td><td align="center">进程</td><td align="center">2.6.14</td></tr><tr><td align="center">Mount</td><td align="center">挂载点</td><td align="center">2.4.19</td></tr><tr><td align="center">UTS</td><td align="center">主机名和域名</td><td align="center">2.6.19</td></tr><tr><td align="center">USR</td><td align="center">用户和用户组</td><td align="center">3.8</td></tr></tbody></table><ul><li>Pid namespace<ul><li>不同用户的进程就是通过 Pid namespace 隔离开的，且不同 namespace 中可以有相同 Pid</li><li>有了 Pid namespace，每个 namespace 中的 Pid 能够相互隔离</li></ul></li><li>net namespace<ul><li>网络隔离是通过 net namespace 实现的，每个 net namespace 有独立的 network devices,IP addresses,IP routing tables，/proc/net 目录</li><li>Docker 默认采用 veth 的方式将 container 中的虚拟网卡桶 host 上的一个 docker bridge: docker0 连接在一起</li></ul></li><li>ipc namespace<ul><li>Container 中进程交互还是采用 linux 常见的进程间交互方法（interprocess communication- IPC)，包括常见的信号量、消息队列和共享内存</li><li>container 的进程间交互实际上还是 host 上具有下载那个同 Pid namespace 中的进程间交互，因此需要在 IPC 资源申请时加入 namespace 信息 - 每个 IPC 资源有一个唯一的 32 位 ID</li></ul></li><li>mnt namespace<ul><li>mnt namespace 允许不同 namespace 的进程看到的文件结构不同，这样每个 namespace 中的进程所看到的文件目录就被隔离开了</li></ul></li><li>uts namespace<ul><li>UTS(“UNIX Time-sharing System”) namespace 允许每个 container 拥有独立的 hostname 和 domain name，使其在网络上可以被视作一个独立的节点而非 Host 上的一个进程</li></ul></li><li>user namespace<ul><li>每个 container 可以有不同的 user 和 group id，也就是说可以在 container 内部用 container 内部的用户执行程序而非 Host 上的用户</li></ul></li></ul><h4 id="3-3-2-4-关于-namespace-的常用操作"><a href="#3-3-2-4-关于-namespace-的常用操作" class="headerlink" title="3.3.2.4 关于 namespace 的常用操作"></a>3.3.2.4 关于 namespace 的常用操作</h4><table><thead><tr><th>名称</th><th>命令</th></tr></thead><tbody><tr><td>查看当前系统的 namespace</td><td>lsns -t <type></td></tr><tr><td>查看某进程的 namespace</td><td>ls -la /proc/<pid>/ns/</td></tr><tr><td>进入某 namespace 运行命令</td><td>nsenter -t <pid> -m ip addr</td></tr></tbody></table><h4 id="3-3-2-5-课后练习"><a href="#3-3-2-5-课后练习" class="headerlink" title="3.3.2.5 课后练习"></a>3.3.2.5 课后练习</h4><blockquote><ol><li><p>在新 network namespace 执行 sleep 指令</p><pre><code class="hljs shell">unshare -fn sleep 60</code></pre></li><li><p>查看进程信息</p><pre><code class="hljs shell">ps -ef|grep sleep</code></pre></li><li><p>查看网络 Namespace</p><pre><code class="hljs shell">lsns -t net</code></pre></li><li><p>进入该进程所在 Namespace 查看网络配置，与主机不一致</p><pre><code class="hljs shell">nsenter -t pid -n ip a</code></pre></li></ol></blockquote><h3 id="3-3-3-Cgroups"><a href="#3-3-3-Cgroups" class="headerlink" title="3.3.3 Cgroups"></a>3.3.3 Cgroups</h3><blockquote><ul><li><p>Cgroups(Control Groups) 是 Linux 下用于对一个或一组进程进程资源开工至和监控的机制</p></li><li><p>可以对诸如 CPU 使用时间、内存、磁盘 I/O 等进程所需的资源进程限制</p></li><li><p>不同资源的具体管理工作由相应的 Cgroup 子系统（Subsystem）来实现</p></li><li><p>针对不同类型的资源限制，只要将限制策略在不同的子系统上进程关联即可</p></li><li><p>Cgroups 在不同的系统资源管理子系统中以层级树（Hierarchy）的方式来组织管理：</p><p>每个Cgroup 都可以包含其他的子 Cgroup，因此子 Cgroup 能使员工的资源除了受本 Cgroup 配置的资源参数限制，还受到父 Cgroup 设置的资源限制</p></li></ul></blockquote><h4 id="3-3-3-1-Linux-内核代码中-Cgroups-的实现"><a href="#3-3-3-1-Linux-内核代码中-Cgroups-的实现" class="headerlink" title="3.3.3.1 Linux 内核代码中 Cgroups 的实现"></a>3.3.3.1 Linux 内核代码中 Cgroups 的实现</h4><ul><li><p>进程数据结构</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span>&#123;</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> CONFIG_CGROUPS</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">css_set_rcu</span> *<span class="hljs-title">cgroups</span>;</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span> <span class="hljs-title">cg_list</span>;</span>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span>&#125;</code></pre></li><li><p>css_set 是 cgroup_subsys_state 对象的集合数据结构</p><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">css_set</span>&#123;</span>    <span class="hljs-comment">/*</span><span class="hljs-comment">    * Set of subsystem state, one for each subsystem.This array is</span><span class="hljs-comment">    * immutable after creation apart from the init_css_set during</span><span class="hljs-comment">    * subsystem registration(at boot time).</span><span class="hljs-comment">    */</span>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cgroup_subsys_state</span> *<span class="hljs-title">subsys</span>[<span class="hljs-title">CGROUP_SUBSYS_COUNT</span>];</span>&#125;</code></pre></li></ul><h4 id="3-3-3-2-可配额-可度量"><a href="#3-3-3-2-可配额-可度量" class="headerlink" title="3.3.3.2 可配额/可度量"></a>3.3.3.2 可配额/可度量</h4><ul><li>cgroups 实现了对资源的配额和度量<ul><li>blkio：这个子系统设置限制每个块设备的输入输出控制。例如：磁盘，光盘以及 USB 等等</li><li>cpu：这个子系统使用调度程序为 cgroup 任务提供 CPU 的访问</li><li>cpuacct：产生 cgroup 任务的 CPU 资源报告</li><li>cpuset：如果是多核心的 CPU，这个子系统会为 cgroup 任务分配单独的 CPU和内存</li><li>devices：允许或拒绝 cgroup 任务对设备的访问</li><li>freezer：暂停和恢复 cgroup 任务</li><li>memory：设置每个 cgroup 的内存限制以及产生内存资源报告</li><li>net_cls：标记每个网络包以供 cgroup 方便使用</li><li>ns：名称空间子系统</li><li>pid：进程标识子系统</li></ul></li></ul><h4 id="3-3-3-3-CPU-子系统"><a href="#3-3-3-3-CPU-子系统" class="headerlink" title="3.3.3.3 CPU 子系统"></a>3.3.3.3 CPU 子系统</h4><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td>cpu.shares</td><td>可出让的能获得 CPU 使用时间的相对值</td></tr><tr><td>cpu.cfs_period_us</td><td>用来配置时间周期长度，单位为 us（微秒）</td></tr><tr><td>cpu.cfs_quota_us</td><td>用来配置当前 cgroup 在 csf_period_us 时间内最多<br />能使用的 CPU 时间数，单位为 us（微秒）</td></tr><tr><td>cpu.stat</td><td>Cgroup 内的进程使用的 CPU 时间统计</td></tr><tr><td>nr_periods</td><td>经过 cpu.cfs_period_us 的时间周期数量</td></tr><tr><td>nr_throttled</td><td>在经过的周期内，有多少次因为机才能拿在指定的时间周期<br />内用光了配额时间而受到限制</td></tr><tr><td>throttled_time</td><td>Cgroup 中的进程被限制使用 CPU 的总用时，单位为 us（微秒）</td></tr></tbody></table><h4 id="3-3-3-4-Linux-调度器"><a href="#3-3-3-4-Linux-调度器" class="headerlink" title="3.3.3.4 Linux 调度器"></a>3.3.3.4 Linux 调度器</h4><p>内核默认提供了 5 个调度器，Linux 内核使用 struct sched_class 来对调度器进程抽象</p><ul><li>Stop 调度器，stop_sched_class: 优先级最高的调度类，可以抢占其他所有进程，不能被其他进程抢占</li><li>Deadline调度器，dl_sched_class: 使用红黑树，把进程按照绝对截止期限进行排序，选择最小进程进行调度运行</li><li>RT 调度器，rt_sched_class: 实时调度器，为每个优先级维护一个队列</li><li>CFS 调度器，cfs_sched_class: 完全公平调度器，采用完全公平调度算法，引入虚拟运行使劲概念</li><li>IDLE-Task 调度器，idle_sched_class: 空闲调度器，每个 CPU 都会有一个 idle 线程，当没有其他进程可以调度时，调度运行 idle 线程。</li></ul><h4 id="3-3-3-5-CFS-调度器"><a href="#3-3-3-5-CFS-调度器" class="headerlink" title="3.3.3.5 CFS 调度器"></a>3.3.3.5 CFS 调度器</h4><ul><li>CFS 是 Completely Fair Scheduler 简称，即完全公平调度器</li><li>CFS 实现的主要思想是维护为任务提供处理器时间方面的平衡，这意味着应给进程分配相当数量的处理器</li><li>分给某个任务的时间失去平衡时，应给失去平衡的任务分配使劲，让其执行<ul><li>vruntime = 实际运行时间*1024 / 进程权重</li></ul></li><li>进程按照各自不同的速率在物理时钟街拍内前进，优先级高则权重大，其虚拟时钟比真实时钟跑得慢，但获得比较多的运行时间</li></ul><h4 id="3-3-3-6-vruntime-红黑树"><a href="#3-3-3-6-vruntime-红黑树" class="headerlink" title="3.3.3.6 vruntime 红黑树"></a>3.3.3.6 vruntime 红黑树</h4><p>CFS 调度器没有将进程维护在运行队列中，而是维护了一个以虚拟运行时间为顺序的红黑树。</p><p>红黑树的主要特点有：</p><ul><li>自平衡，树上没有一条路径会比其他路径长出两倍</li><li>O(log n) 时间复杂度，能够在树上进程快速高效地插入或删除进程</li></ul><h4 id="3-3-3-7-CFS-进程调度"><a href="#3-3-3-7-CFS-进程调度" class="headerlink" title="3.3.3.7 CFS 进程调度"></a>3.3.3.7 CFS 进程调度</h4><ul><li>在时钟周期开始时，调度器调用 _schedule() 函数来开始调度的运行</li><li>_schedule() 函数调用 pick_next_task() 让进程调度器从就绪队列中选择一个最合适的进程 next，即红黑树最左边的节点</li><li>通过 context_switch() 切换到新的地址空间，从而保证 next 进程运行</li><li>在时钟周期结束时，调度器调用 entity_tick() 函数来更新进程负载、进程状态以及 vruntime（当前 vruntime + 该时钟周期内运行的时间）</li><li>最后，将该进程的虚拟时间与就绪队列红黑树中最左边的调度实体的虚拟时间做比较，如果小于最左边的时间，则不用触发调度，继续调度当前调度实体。</li></ul><h4 id="3-3-3-8-CPU-子系统练习"><a href="#3-3-3-8-CPU-子系统练习" class="headerlink" title="3.3.3.8 CPU 子系统练习"></a>3.3.3.8 CPU 子系统练习</h4><blockquote><ol><li><p>在 cgroup cpu 子系统目录中创建目录结构</p><pre><code class="hljs shell">cd /sys/fs/cgroup/cpumkdir cpudemocd cpudemo</code></pre></li><li><p>运行 busyloop</p></li><li><p>执行 top 查看 CPU 使用情况，CPU 占用 200%</p></li><li><p>通过 cgroup 限制 CPU</p><pre><code class="hljs shell">cd /sys/fs/cgroup/cpu/cpudemo<span class="hljs-meta">#</span><span class="bash"> 把进程添加到 cgroup 进程配置组</span>ps -ef|grep busyloop|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27;&gt; cgroup.procs<span class="hljs-meta">#</span><span class="bash"> 设置 cpuquota</span>echo 10000 &gt; cpu.cfs_quota_us</code></pre></li><li><p>执行 top 查看 CPU 使用情况，CPU占用变为10%</p></li></ol></blockquote><h4 id="3-3-3-9-cpuacct-子系统"><a href="#3-3-3-9-cpuacct-子系统" class="headerlink" title="3.3.3.9 cpuacct 子系统"></a>3.3.3.9 cpuacct 子系统</h4><p>用于统计 Cgroup 及其子 Cgroup 下进程的 CPU 的使用情况</p><ul><li>cpuacct.usage：包含该 Cgroup 及其子 Cgroup 下进程使用 CPU 的时间，单位是 ns（纳秒）</li><li>cpuacct.stat：包含 Cgroup 及其子 Cgroup 下进程使用的 CPU 时间，以及用户态和内核态的时间</li></ul><h4 id="3-3-3-10-Memory-子系统"><a href="#3-3-3-10-Memory-子系统" class="headerlink" title="3.3.3.10 Memory 子系统"></a>3.3.3.10 Memory 子系统</h4><ul><li>memory.usage_in_bytes：cgroup 下进程使用的内存，包含 cgroup 及其子 cgroup 下的进程使用的内存</li><li>memory.max_usage_in_bytes：cgroup 下进程使员工内存的最大值，包含子 cgroup 的内存使用量</li><li>memory.limit_in_bytes：设置 Cgroup 下进程最多能使用的内存。如果设置为 -1，表示对该 cgroup 的内存使用不做限制</li><li>memory.oom_control：设置是否在 Cgroup 中使用 OOM（Out of Memory）Killer，默认为使用，当属于该 cgroup 的进程使用的内存超过最大的限定值时，会立刻被 OOM Killer 处理</li></ul><h4 id="3-3-3-11-Cgroup-driver"><a href="#3-3-3-11-Cgroup-driver" class="headerlink" title="3.3.3.11 Cgroup driver"></a>3.3.3.11 Cgroup driver</h4><p>systemd：</p><ul><li>当操作系统使用 systemd 作为 init system 时，初始化进程生成一个根 cgroup 目录结构并作为 cgroup 管理器</li><li>systemd 与 cgroup 紧密结合，并且为每个 systemd unit 分配 cgroup</li></ul><p>cgroupfs：</p><ul><li>docker 默认用 cgroupfs 作为 cgroup 驱动</li></ul><p>存在问题：</p><ul><li>因此，在 systemd 作为 init system 的系统中，默认并存着两套 groupdriver</li><li>这会使得系统中 docker 和 kubelet 管理的进程别 cgroupfs 驱动管，而 systemd 拉起的服务由 systemd 驱动管，让 cgroup 管理混乱且容器在资源紧张时引发问题。</li><li>因此 kubelet 会默认 –cgroup-driver=systemd，若运行时 cgroup 不一致时，kubelet 会报错</li></ul><h4 id="3-3-3-12-课后练习"><a href="#3-3-3-12-课后练习" class="headerlink" title="3.3.3.12 课后练习"></a>3.3.3.12 课后练习</h4><blockquote><ol><li>在 cgroup memory 子系统目录中创建目录结构</li></ol><pre><code class="hljs shell">cd /sys/fs/cgroup/memorymkdir memorydemocd memorydemo</code></pre><ol start="2"><li>运行 malloc</li><li>查看内存使用情况</li></ol><pre><code class="hljs shell">watch &#x27;ps -aux|grep malloc|grep -v grep&#x27;</code></pre><ol start="4"><li><p>通过 cgroup 限制 memory </p><ol><li>把进程添加到 cgroup 进程配置组</li></ol><pre><code class="hljs shell">ps -ef|grep malloc|grep -v grep|awk &#x27;&#123;print $2&#125;&#x27; &gt; cgroup.procs</code></pre><ol start="2"><li>设置 memory.limit_int_bytes</li></ol><pre><code class="hljs shell">echo 104960000 &gt; memory.limit_in_bytes</code></pre></li><li><p>等待进程被 oom kill</p></li></ol></blockquote><h4 id="3-3-3-13-文件系统"><a href="#3-3-3-13-文件系统" class="headerlink" title="3.3.3.13 文件系统"></a>3.3.3.13 文件系统</h4><blockquote><p> Union FS</p><ul><li>将不同目录挂载到同一个虚拟文件系统下（unite several directories into a single virtual filesystem）的文件系统</li><li>支持为每一个成员目录（类似 Git Branch）设定 readonly、readwrite 和 whiteout-able 权限</li><li>文件系统分层，对 readonly 权限的 branch 可以逻辑上进行修改（增量地，不影响 readonly 部分的）</li><li>通常 Union FS 有两个用途，一方面可以将多个 disk 挂到同一个目录下，另一个更常用的就是将一个 readonly 的 branch 和一个 writeable 的 branch 联合在一起</li></ul></blockquote><h4 id="3-3-3-14-容器镜像"><a href="#3-3-3-14-容器镜像" class="headerlink" title="3.3.3.14 容器镜像"></a>3.3.3.14 容器镜像</h4><ul><li>基础镜像层</li><li>通用层</li></ul><h4 id="3-3-3-15-Docker-的文件系统"><a href="#3-3-3-15-Docker-的文件系统" class="headerlink" title="3.3.3.15 Docker 的文件系统"></a>3.3.3.15 Docker 的文件系统</h4><ul><li>典型的 Linux 文件系统组成：<ul><li>Bootfs（boot file system）<ul><li>Bootloader - 引导加载 kernel</li><li>Kernel - 当 kernel 被加载到内存中后 umount bootfs</li></ul></li><li>rootfs（root file system）<ul><li>/dev , /proc , /bin , /etc 等标准目录和文件</li><li>对于不同的 linux 发行版，bootfs 基本是一致的，但 rootfs 会有差别</li></ul></li></ul></li></ul><h4 id="3-3-3-15-Docker-启动"><a href="#3-3-3-15-Docker-启动" class="headerlink" title="3.3.3.15 Docker 启动"></a>3.3.3.15 Docker 启动</h4><ul><li>Linux<ul><li>在启动后，首先将 rootfs 设置为 readonly，进行一系列检查，然后将其切换为“readwrite” 供用户使用</li></ul></li><li>Docker 启动<ul><li>初始化时也是将 rootfs 以 readonly 方式加载并检查，然而接下来利用 union mount 的方式将一个 readwrite 文件系统挂载在 readonly 的 rootfs 之上</li><li>并且允许再次将下层的 FS （file system）设定为 readonly 并且向上叠加</li><li>这样一组 readonly 和一个 writeable 的结构构成一个 container 的运行时态，每一个 FS 被称作一个 FS 层。</li></ul></li></ul><h4 id="3-3-3-16-写操作"><a href="#3-3-3-16-写操作" class="headerlink" title="3.3.3.16 写操作"></a>3.3.3.16 写操作</h4><blockquote><p>由于镜像具有共享特性，所以对容器可写层的操作需要依赖存储驱动提供的写时复制和用时分配机制，以此来支持对容器可写层的修改，进而提高对存储和内存资源的利用率。</p></blockquote><ul><li><p>写时复制</p><p>写时复制，即 Copy-on-Write。一个镜像可以被多个容器使用，但是不需要在内存和磁盘上做多个拷贝。在需要对镜像提供的文件进行修改时，该文件会从镜像的文件系统被复制到容器的可写层的文件系统进行修改，而镜像里面的文件不会改变。不同容器对文件的修改都相互独立、互不影响。</p></li><li><p>用时分配</p><p>按需分配空间，而非提前分配，即当一个文件被创建出来后，才会分配空间。</p></li></ul><h4 id="3-3-3-17-容器存储驱动"><a href="#3-3-3-17-容器存储驱动" class="headerlink" title="3.3.3.17  容器存储驱动"></a>3.3.3.17  容器存储驱动</h4><table><thead><tr><th>存储驱动</th><th>Docker</th><th>Containerd</th></tr></thead><tbody><tr><td>AUFS</td><td>在 Ubuntu 或者 Debian 上支持</td><td>不支持</td></tr><tr><td>OverlayFS</td><td>支持</td><td>支持</td></tr><tr><td>Device Mapper</td><td>支持</td><td>支持</td></tr><tr><td>Btrfs</td><td>社区版本在 Ubunntu 或者 Debian 上支持<br />企业版本在 SLES 上支持</td><td>支持</td></tr><tr><td>ZFS</td><td>支持</td><td>不支持</td></tr></tbody></table><table><thead><tr><th align="center">存储驱动</th><th align="center">优点</th><th align="center">缺点</th><th align="center">应用场景</th></tr></thead><tbody><tr><td align="center">AUFS</td><td align="center">Docker 最早支持的驱动类型，稳定性高</td><td align="center">并未进入主线的内核，因此只能在有限的场合下使用。另外在实现上具有多层结构，在层比较多的场景下，做写时复制有时会需要比较长的时间</td><td align="center">少 I/O 的场景</td></tr><tr><td align="center">OverlayFS</td><td align="center">并入主线内核，可以在目前几乎所有发行版本上使用。实现上只有两层，因此性能比 AUFS 高</td><td align="center">写时复制机制需要复制整个文件，而不是只针对修改部分进行复制，因此对大文件操作会需要比较长的时间。其中 Overlay 在 Docker 的后续版本中被移除</td><td align="center">少 I/O 的场景</td></tr><tr><td align="center">Device Mapper</td><td align="center">并入主线内核，针对块 操作，性能比较高。修改文件时只需复制需要修改的块，效率高</td><td align="center">不同容器之间不能共享缓存。在 Docker 的后续版本中会被移除</td><td align="center">I/O 密集场景</td></tr><tr><td align="center">BtrFS</td><td align="center">并入主线内核，虽然是文件级操作系统，但是可以对块进行操作</td><td align="center">需要消耗比较多的内存，稳定性相对比较差</td><td align="center">需要支持 Snapshot 等比较特殊的场景</td></tr><tr><td align="center">ZFS</td><td align="center">不同的容器之间可以共享缓存，多个容器访问相同的文件能够共享一个单一的 Page Cache</td><td align="center">在频繁写操作的场景下，会产生比较严重的磁盘碎片。需要消耗比较多的内存，另外稳定性相对比较差。</td><td align="center">容器高密度部署的场景</td></tr></tbody></table><h4 id="3-3-3-18-以-OverlayFS-为例"><a href="#3-3-3-18-以-OverlayFS-为例" class="headerlink" title="3.3.3.18  以 OverlayFS 为例"></a>3.3.3.18  以 OverlayFS 为例</h4><p>OverlayFS 也是一种与 AUFS 类似的联合文件系统，同样属于文件级的存储驱动，包含了最初的 Overlay 和 更新更稳定的 overlay2。</p><h4 id="3-3-3-19-OverlayFS-文件系统练习"><a href="#3-3-3-19-OverlayFS-文件系统练习" class="headerlink" title="3.3.3.19  OverlayFS 文件系统练习"></a>3.3.3.19  OverlayFS 文件系统练习</h4><pre><code class="hljs shel">mkdir upper lower merged workecho &quot;from lower&quot; &gt;lower&#x2F;in_lower.txtecho &quot;from upper&quot; &gt;lower&#x2F;in_upper.txtecho &quot;from lower&quot; &gt;lower&#x2F;in_both.txtecho &quot;from upper&quot; &gt;lower&#x2F;in_both.txtmount -t overlay overlay -o lowerdir&#x3D;&#96;pwd&#96;&#x2F;lower,upperdir&#x3D;&#96;pwd&#96;&#x2F;upper,workdir&#x3D;&#96;pwd&#96;&#x2F;work &#96;pwd&#96;&#x2F;mergedcat merged&#x2F;in_both.txtdelete merged&#x2F;in_both.txtdelete merged&#x2F;in_lower.txtdelete merged&#x2F;in_upper.txt</code></pre><h4 id="3-3-3-20-OCI-容器标准"><a href="#3-3-3-20-OCI-容器标准" class="headerlink" title="3.3.3.20 OCI 容器标准"></a>3.3.3.20 OCI 容器标准</h4><p> Open Container Initiative</p><ul><li>OCI 组织于 2015 年创建，是一个致力于定义容器镜像标准和运行时标准的开放式组织</li><li>OCI 定义了镜像标准（Image Specification）、运行时标准（Runtime Specification）和分发标准（Distribution Specification）<ul><li>镜像标准定义应用如何打包</li><li>运行时标准定义如何解压应用包并运行</li><li>分发标准定义如何分发容器镜像</li></ul></li></ul><h4 id="3-3-3-21-Docker-引擎架构"><a href="#3-3-3-21-Docker-引擎架构" class="headerlink" title="3.3.3.21 Docker 引擎架构"></a>3.3.3.21 Docker 引擎架构</h4><ul><li>Docker client  docker 命令行   REST</li><li>Docker server  docker daemon    GRPC</li><li>containerd  </li><li>shim</li><li>runc</li></ul><h2 id="3-4-容器网络"><a href="#3-4-容器网络" class="headerlink" title="3.4 容器网络"></a>3.4 容器网络</h2><h3 id="3-4-1-网络"><a href="#3-4-1-网络" class="headerlink" title="3.4.1 网络"></a>3.4.1 网络</h3><ul><li><p>Null 模式（–net=None）</p><ul><li>把容器放入独立的网络空阿金但不做任何网络配置</li><li>用户需要通过运行 docker network 命令来完成网络配置</li></ul></li><li><p>Host</p><ul><li>使用主机网络名空间，复用主机网络</li></ul></li><li><p>Container</p><ul><li>重用其他容器的网络</li></ul></li><li><p>Bridge（–net=bridge）</p><ul><li>使用 LInux 网桥和 iptables 提供容器互联，Docker 在每台主机上创建一个名叫 docker0 的网桥，通过 veth pair 来连接该主机的每一个 EndPoint</li></ul></li><li><p>Overlay（libnetwork,libkv）</p><ul><li>通过网络封包实现</li></ul></li><li><p>Remote(work with remote drivers)</p><ul><li>Underlay: 使用现有底层网络，为每一个容器配置可路由的网络 IP</li></ul></li><li><p>Overlay</p><ul><li>通过网络封包实现</li></ul></li></ul><h3 id="3-4-2-Null-模式"><a href="#3-4-2-Null-模式" class="headerlink" title="3.4.2 Null 模式"></a>3.4.2 Null 模式</h3><ul><li>Null 模式是一个空实现</li><li>可以通过 Null 模式启动容器并在宿主机上通过命令为容器配置网络</li></ul><pre><code class="hljs shell">mkdir -p /var/run/netsnsfind -L /var/run/netns -type | -deleteln -s /proc/$pid/ns/net /var/run/netns/$pidip link add A type veth peer name Bbrctl addif br0 Aip link set A upip link set B netns $pidip netns exec $pid ip link set dev B name eth0ip netns exec $pid ip link set eth0 upip netns exec $pid ip addr add<span class="hljs-meta">$</span><span class="bash">SETIP/<span class="hljs-variable">$SETMASK</span> dev eth0</span>ip netns exec $pid ip route add default via $GATEWAY</code></pre><h3 id="3-4-3-默认模式-网桥和-NAT"><a href="#3-4-3-默认模式-网桥和-NAT" class="headerlink" title="3.4.3 默认模式 - 网桥和 NAT"></a>3.4.3 默认模式 - 网桥和 NAT</h3><ul><li>为主机 eth0 分配 ip 192.168.0.101</li><li>启动 docker daemon，查看主机 iptables<ul><li>POSTROUTINE -A POSTROUTING -s 172.17.0.0/16 ! -o docker -j MASQUERADE</li></ul></li><li>在主机启动容器<ul><li>docker run -d –name nginx -p 8080:80 nginx</li><li>Docker 会以标准模式配置网络<ul><li>创建 veth pair</li><li>将 veth pair 的一段连接到 docker0 网桥</li><li>veth pair 的另外一段设置为容器名空间的 eth0</li><li>为容器名空间的 eth0 分配 ip</li><li>主机上的 iptables 规则： PREROUTING -A DOCKER ! -i docker0 -p tcp -m tcp –dport 2333 -j DNAT –to-destination 172.17.0.2:22</li></ul></li></ul></li></ul><h3 id="3-4-4-Underlay"><a href="#3-4-4-Underlay" class="headerlink" title="3.4.4 Underlay"></a>3.4.4 Underlay</h3><ul><li>采用 Linux 网桥设备（sbrctl）通过物理网络连通容器</li><li>创建新的网桥设备 mydr0</li><li>将主机网卡加入网桥</li><li>把主机网卡的地址配置到网桥，并把默认路由规则转移到网桥 mydr0</li><li>启动容器</li><li>创建 veth 对，并且把一个 peer 添加到网桥 mydr0</li><li>配置容器把 veth 的另一个 peer 分配给容器网卡</li></ul><h3 id="3-4-5-Docker-Libnetwork-Overlay"><a href="#3-4-5-Docker-Libnetwork-Overlay" class="headerlink" title="3.4.5 Docker Libnetwork Overlay"></a>3.4.5 Docker Libnetwork Overlay</h3><ul><li>Docker overlay 网络驱动原生支持多主机网络</li><li>Libnetwork 是一个内置的基于 VXLAN 的网络驱动</li></ul><h4 id="VXLAN"><a href="#VXLAN" class="headerlink" title="VXLAN"></a>VXLAN</h4><h4 id="Overlay-network-Sample-Flannel"><a href="#Overlay-network-Sample-Flannel" class="headerlink" title="Overlay network Sample - Flannel"></a>Overlay network Sample - Flannel</h4><h2 id="3-5-Dockerfile-的最佳实践"><a href="#3-5-Dockerfile-的最佳实践" class="headerlink" title="3.5 Dockerfile 的最佳实践"></a>3.5 Dockerfile 的最佳实践</h2><h3 id="3-5-1-创建-docker-镜像"><a href="#3-5-1-创建-docker-镜像" class="headerlink" title="3.5.1 创建 docker 镜像"></a>3.5.1 创建 docker 镜像</h3><ul><li><p>定义 Dockerfile</p><pre><code class="hljs dockerfile"><span class="hljs-comment"># Nginx image</span><span class="hljs-keyword">FROM</span> ubuntu:<span class="hljs-number">20.04</span><span class="hljs-keyword">LABEL</span><span class="bash"> <span class="hljs-string">&quot;maintainer&quot;</span>=<span class="hljs-string">&quot;1ch0 github1ch0@163.com&quot;</span></span><span class="hljs-comment"># COPY sources.list /etc/apt/sources.list</span><span class="hljs-keyword">RUN</span><span class="bash"> apt update &amp;&amp; apt install -y iproute2 ntpdate tcpdump telnet traceroute nfs-kernel-server nfs-common lrzsz tree openssl libssl-dev libpcre3 libpcre3-dev zlib1g-dev gcc openssh-server iotop unzip zip make vim &amp;&amp; mkdir -p /data/nginx</span><span class="hljs-keyword">ADD</span><span class="bash"> nginx-1.20.2.tar.gz /usr/<span class="hljs-built_in">local</span>/src</span><span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">cd</span> /usr/<span class="hljs-built_in">local</span>/src/nginx-1.20.2 &amp;&amp; ./configure --prefix=/apps/nginx &amp;&amp; make &amp;&amp; make install &amp;&amp; ln -sv /apps/nginx/sbin/nginx /usr/bin &amp;&amp; rm -rf /usr/<span class="hljs-built_in">local</span>/src/nginx-1.20.2 &amp;&amp; rm -rf /usr/<span class="hljs-built_in">local</span>/src/nginx-1.20.2.tar.gz</span><span class="hljs-comment"># ADD nginx.conf /apps/nginx/conf/nginx.conf</span><span class="hljs-comment"># ADD static.tar.gz /data/nginx/html</span><span class="hljs-keyword">RUN</span><span class="bash"> ln -sv /dev/stdout /apps/nginx/logs/access.log</span><span class="hljs-keyword">RUN</span><span class="bash"> ln -sv /dev/stderr /apps/nginx/logs/error.log</span><span class="hljs-comment"># sed -i -E &#x27;s,listen 80;,listen 80;\n listen [::]:80;,&#x27; /etc/nginx/conf.d/default.conf</span><span class="hljs-keyword">RUN</span><span class="bash"> groupadd -g 2022 nginx &amp;&amp; useradd -g nginx -s /usr/sbin/nologin -u 2022 nginx &amp;&amp; chown -R nginx.nginx /apps/nginx /data/nginx</span><span class="hljs-keyword">EXPOSE</span> <span class="hljs-number">80</span> <span class="hljs-number">443</span><span class="hljs-keyword">STOPSIGNAL</span> SIGTERM<span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;/apps/nginx/sbin/nginx&quot;</span>,<span class="hljs-string">&quot;-g&quot;</span>,<span class="hljs-string">&quot;daemon off;&quot;</span>]</span></code></pre></li><li><p>docker build</p></li></ul><h3 id="3-5-2-回顾-12-Factor-之进程"><a href="#3-5-2-回顾-12-Factor-之进程" class="headerlink" title="3.5.2 回顾 12 Factor 之进程"></a>3.5.2 回顾 12 Factor 之进程</h3><ul><li>运行环境中，应用程序通常是以一个和多个进程运行的<ul><li>12-Factor 应用的进程必须无状态（Stateless）且无共享（Share nothing）</li></ul></li><li>任何需要持久化的数据都要存储在后端服务内，比如数据库<ul><li>应在构建阶段将源代码编译成待执行应用</li></ul></li><li>Session Sticky 是 12-Factor 极力反对的<ul><li>Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中</li></ul></li></ul><p><strong>Docker 遵循以上原则管理和构建应用</strong></p><h3 id="3-5-3-理解构建上下文（Build-Context）"><a href="#3-5-3-理解构建上下文（Build-Context）" class="headerlink" title="3.5.3 理解构建上下文（Build Context）"></a>3.5.3 理解构建上下文（Build Context）</h3><ul><li>当运行 docker build 命令时，当前工作目录被称为构建上下文。</li><li>docker build 默认查找当前目录的 Dockerfile 作为构建输入，也可以通过 -f 指定 Dockerfile<ul><li>docker build -f ./Dockerfile</li></ul></li><li>当 docker build 运行时，首先会把构建上下文传输给 docker daemon，把没用的文件包含在构建上下文时，会导致传输时间长，构建需要的资源多，构建出的镜像大等问题<ul><li>试着到一个包含文件很多的目录运行下面的命令，会感受到差异</li><li>docker build -f $GOPATH/src/github.com/cncamp/golang/httpserver/Dockerfile</li><li>docker build $GOPATH/src/github.com/cncamp/golang/httpserver/Dockerfile</li><li><strong>可以通过 .dockerignore 文件从编译上下文排除某些文件</strong></li></ul></li><li>因此需要确保狗阿金上下文清晰，比如创建一个专门的目录放置 Dockerfile，并在目录中运行 docker build</li></ul><h3 id="3-5-4-Build-Cache"><a href="#3-5-4-Build-Cache" class="headerlink" title="3.5.4 Build Cache"></a>3.5.4 Build Cache</h3><blockquote><p>构建容器镜像时，Docker 依次读取 Dockerfile 中的指令，并按顺序依次执行构建指令</p><p>Docker 读取指令后，会先判断缓存中是否有可用的已存镜像，只有已存镜像不存在时才会重新构建。</p><ul><li>通常 Docker 简单判断 Dockerfile 中的指令与镜像</li><li>针对 ADD 和 COPY 指令，Docker 判断该镜像层每一个文件的内容并生成一个 checksum，与现存镜像比较时，Docker 比较的是二者的 checksum,</li><li>其他指令，比如 RUN apt-get -y update，Docker 简单比较与现存镜像中的指令字串是否一致</li><li>当某一层 cache 失效以后，所有层级的 cache 均一并失效，后续指令都重新构建镜像</li></ul></blockquote><h3 id="3-5-5-多段构建（Multi-stage-build）"><a href="#3-5-5-多段构建（Multi-stage-build）" class="headerlink" title="3.5.5 多段构建（Multi-stage build）"></a>3.5.5 多段构建（Multi-stage build）</h3><ul><li><p>有效减少镜像层级的方式</p><pre><code class="hljs shell">FROM golang:1.16-alpine AS buildRUN apk add --no-cache gitRUN go get github.com/golang/dep/cmd/depCOPY Gopkg.lock Gopkg.toml /go/src/project/WORKDIR /go/src/project/RUN dep ensure -vendor-onlyCOPY . /go/src/projectRUN go build -o /bin/projectFROM scratchCOPY --from=build /bin/project /bin/projectEXPOSE 8080ENTRYPOINT [&quot;/bin/project&quot;]CMD[&quot;-help&quot;]</code></pre></li></ul><h3 id="3-5-6-Dockerfile-常用指令"><a href="#3-5-6-Dockerfile-常用指令" class="headerlink" title="3.5.6 Dockerfile 常用指令"></a>3.5.6 Dockerfile 常用指令</h3><ul><li><p>FROM : 选择基础镜像，推荐 alpine</p><p>FROM [–platform=<platform>] <image> [@<digest>] [AS <name>]</p></li><li><p>LABELS : 按标签组织项目</p><p>LABEL multi.label1=”value1” multi.label2=”value2” other=”value3”</p><p>配合Label fitler 可过滤镜像查询结果</p><p>docker images -f label=multi.label1=”value1”</p></li><li><p>RUN : 执行命令</p><p>最常见的用法是 RUN apt-get update &amp;&amp; apt-get install，这两条命令应该永远用 &amp;&amp; 连接，如果分开执行RUN apt-get update 构建层被缓存，可能会导致新 package 无法安装</p></li><li><p>CMD：容器镜像中包含应用的运行命令，需要带参数</p><p>CMD[“executable”, “param1”, “param2”…]</p></li><li><p>EXPOSE：发布端口</p><p>EXPOSE <port> [<port>/<protocol>…]</p><ul><li>是镜像创建者和使用者的约定</li><li>在 docker run -P 时，docker 会自动映射 expose 的端口到主机大端口，如 0.0.0.0:32748 -&gt; 80/tcp</li></ul></li><li><p>ENV：设置环境变量</p><p>ENV <key>=<value>…</p></li><li><p>ADD :  从源地址（ 文件，目 录或者 URL)  复制文件到目标路径</p><p>ADD [–chown=<user>:<group>] <src >… ＜dest&gt;<br>ADD [–chown=<user>:<group>] [  “<src >“  ，…  ” <dest>“  ］ （路径中有空格时使用）</p><ul><li>ADD 支持 Go 风格的通配符， 如 ADD check* /testdir/</li><li>src  如果是文件， 则必须包含在编译上下文中， ADD 指令无法添加编译上下文之外的文件</li><li>src  如果是 URL<ul><li>如果 dest 结尾没有／， 那么 dest 是目标文件名， 如果 dest 结尾有／， 那么 dest 是目标目录名</li></ul></li><li>如果 src  是一个目录， 则所有文件都会被复制至 dest</li><li>如果 src  是一个本地压缩文件， 则在 ADD 的同时完整解压操作</li><li>如果 dest 不存在， 则 ADD 指令会创建目标目录</li><li>应尽量减少通过 ADD URL 添加 rem ote 文件， 建议使用 curl  或者 wget &amp;&amp; untar</li></ul></li><li><p>COPY  :  从源地址（ 文件，目 录或者URL)  复制文件到目标路径</p><p>COPY [–chown=<user>:<group>] <src>… <d est></p><p>COPY [–chown=<user>:<group>] [“<src>”, … “<d est> “]  / /路径中有空格时使用</p><ul><li>COPY  的使用与ADD 类似， 但有如下区别</li><li>COPY  只支持本地文件的复制， 不支持URL</li><li>COPY  不解压文件</li><li>COPY   可以用于多阶段编译场景， 可以用前一个临时镜像中拷贝文件<ul><li>COPY –from=build  /bin/project  /bin/project</li></ul></li></ul><p>COPY  语义上更直白， 复制本地文件时， 优先使用 COPY</p></li><li><p>ENTRYPOI NT:  定义可以执行的容器镜像入口命令</p><p>ENTRYPOINT  [“executable”, “paraml “, “param2”]  //  docker ru n参数追加模式 </p><p>ENTRYPOINT  command paraml  param2  / /  docker ru n 参数替换模式</p><ul><li>docker run - ent rypoint  可替换 Do cker fi le 中定义的 ENTRYPOI NT</li><li>ENTRYPOI NT 的最佳实践是用ENTRYPOI NT 定义镜像主命令， 并通过 CMD 定义主要参数， 如下所示<ul><li>ENTRYPOINT [“s3cmd”]</li><li>CMD [“–help”]</li></ul></li></ul></li><li><p>VOLUME:     将指定目录定义为外挂存储卷， Do cker fi le 中在该指令之后所有对同—目录的修改都无效</p><p>VOLUME [“/data”]等价于 docker  run  -v  / data,   可通过 docke r in sp ect 查看主机的 mount point,<br>/var /lib/ docker /volumes/<containerid>/_data</p><p> USER:   切换运行镜像的用户和用户组， 因安全性要求， 越来越多的场景要求容器应用要以 non-ro ot 身份运行</p></li><li><p>USER <user>[:<group>]</p></li></ul><ul><li><p>WORKDIR:   等价千 cd ,   切换工作目录</p><p>WORKDIR  /path/to/workdir</p></li><li><p>其他非常用指令</p></li></ul><ul><li>ARG</li><li>ONBUILD</li><li>STOPSIGNAL</li><li>HEALTHCHECK</li><li>SHELL</li></ul><h3 id="3-5-7-Dockerfile-最佳实践"><a href="#3-5-7-Dockerfile-最佳实践" class="headerlink" title="3.5.7 Dockerfile 最佳实践"></a>3.5.7 Dockerfile 最佳实践</h3><blockquote><p> <strong>目标：易管理、少漏洞、镜像小、层级少、利用缓存</strong></p></blockquote><ul><li><p>不要安装无效软件包</p></li><li><p>应简化镜像中同时运行的进程数，理想状况下，每个镜像应该只有一个进程。</p></li><li><p>当无法避免同一镜像运行多进程时，应选择合理的初始化进程（init process）</p></li><li><p>最小化层级数</p><ul><li><p>最新的 docker 只有 RUN，COPY，ADD 创建新层，其他指令创建临时层，不会增加镜像大小</p><p>比如 EXPOSE 指令就不会生成新层</p></li><li><p>多条 RUN 命令可通过连接符连接成一条指令集以减少层数</p></li><li><p>通过多段构建减少镜像层数</p></li></ul></li><li><p>把多行参数按字母排序，可以减少可能出现的重复参数，并且提高可读性</p></li><li><p>编写 Dockerfile 的时候，应该把变更频率低的编译指令优先构建以便放在镜像底层以有效利用 build cache</p></li><li><p>复制文件时，每个文件应独立复制，这确保某个文件变更时，只影响文件对应的缓存</p></li></ul><h3 id="3-5-8-多进程的容器镜像"><a href="#3-5-8-多进程的容器镜像" class="headerlink" title="3.5.8 多进程的容器镜像"></a>3.5.8 多进程的容器镜像</h3><ul><li>选择适当的 init 进程<ul><li>需要捕获 SIGTERM 信号并完成子进程的优雅终止</li><li>负责清理退出的子进程以避免僵尸进程</li></ul></li><li>开源项目 <a href="https://github.com/krallin/tini">https://github.com/krallin/tini</a></li></ul><h3 id="3-5-9-Docker-镜像管理"><a href="#3-5-9-Docker-镜像管理" class="headerlink" title="3.5.9 Docker 镜像管理"></a>3.5.9 Docker 镜像管理</h3><p>docker save/load</p><p>docker tag</p><p>docker push/pull</p><h3 id="3-5-10-基于-Docker-镜像的版本管理"><a href="#3-5-10-基于-Docker-镜像的版本管理" class="headerlink" title="3.5.10 基于 Docker 镜像的版本管理"></a>3.5.10 基于 Docker 镜像的版本管理</h3><ul><li><p>Docker tag</p><p>docker tag 命令可以为容器镜像添加标签</p><p>docker tag id hub.docker.com/user/nginx:v1.0</p><p>hub.docker.com: 镜像仓库地址，如果不填，默认为 hub.docker.com</p><p>user -&gt; 仓库 repositry</p><p>nginx -&gt; 镜像名</p><p>v1.0: tag，常用来记录版本信息</p></li></ul><h3 id="3-5-11-Docker-tag-与-github-的版本管理"><a href="#3-5-11-Docker-tag-与-github-的版本管理" class="headerlink" title="3.5.11 Docker tag 与 github 的版本管理"></a>3.5.11 Docker tag 与 github 的版本管理</h3><ul><li><p>以 Kubernetes 为例</p><ul><li><p>开发分支</p><ul><li>git checkout master</li></ul></li><li><p>Release 分支</p><ul><li>git checkout -b release-1.21</li></ul></li><li><p>在并行期，所有的变更同时进 Master 和 release branch</p></li><li><p>版本发布</p><ul><li>以 release branch 为基础构建镜像，并为镜像标记版本信息</li></ul><p>docker tag id k8s.io/kubernetes/apiserver:v1.21</p></li><li><p>在 github 中保存 release 代码快照</p><ul><li>git tag v1.21</li></ul></li></ul></li></ul><h3 id="3-5-12-镜像仓库"><a href="#3-5-12-镜像仓库" class="headerlink" title="3.5.12 镜像仓库"></a>3.5.12 镜像仓库</h3><p><a href="https://hub.docker.com/">Docker hub</a></p><p>创建私有镜像仓库</p><pre><code class="hljs shell">sudo docker run -d -p 5000:5000 registry</code></pre><h3 id="3-5-13-Docker-优势"><a href="#3-5-13-Docker-优势" class="headerlink" title="3.5.13 Docker 优势"></a>3.5.13 Docker 优势</h3><ul><li>封装性<ul><li>不需要再启动内核，所以应用扩缩容时可以秒速启动</li><li>资源利用率高，直接使用宿主机内核调度资源，性能损失小</li><li>方便的 CPU、内存资源调整</li><li>能实现秒级快速回滚</li><li>一键启动所有依赖服务，测试不用为搭建环境犯愁，PE 也不用为建站复杂担心</li><li>镜像一次编译，随处使用</li><li>测试、生产环境高度一致（数据除外）</li></ul></li><li>隔离性<ul><li>应用的运行环境和宿主机环境无关，完全由镜像控制，一台物理机上部署多种环境的镜像测试</li><li>多个应用版本可以并存在机器上</li></ul></li><li>镜像增量分发<ul><li>由于采用了 Union FS，简单来说就是支持将不同的目录挂载到同一个虚拟文件系统下，并实现一种 layer 的概念，每次发布只传输变化的部分，节约带宽</li></ul></li><li>社区活跃<ul><li>Docker 命令简单、易用，社区十分活跃，且周边组件丰富</li></ul></li></ul><h2 id="4-Docker-容器技术"><a href="#4-Docker-容器技术" class="headerlink" title="4. Docker 容器技术"></a>4. Docker 容器技术</h2><h3 id="4-1-知识点回顾"><a href="#4-1-知识点回顾" class="headerlink" title="4.1 知识点回顾"></a>4.1 知识点回顾</h3><h3 id="4-2-模块三作业"><a href="#4-2-模块三作业" class="headerlink" title="4.2 模块三作业"></a>4.2 模块三作业</h3><h3 id="4-3-Docker-技巧"><a href="#4-3-Docker-技巧" class="headerlink" title="4.3 Docker 技巧"></a>4.3 Docker 技巧</h3>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go目录结构示例</title>
    <link href="/2022/06/28/go/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <url>/2022/06/28/go/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="目录结构示例"><a href="#目录结构示例" class="headerlink" title="目录结构示例"></a>目录结构示例</h1><h2 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h2><pre><code class="hljs shell">├── api│   ├── v1│   │   ├── configCenter│   │   └── swagger├── build│   ├── ci│   ├── docker│   └── package├── CHANGELOG├── cmd├── configs├── deployments│   ├── templates│   └── ...├── docs│   ├── devel│   └── guide├── examples├── githooks├── go.mod├── go.sum├── internal│   ├── apiserver│   │   ├── api│   │   │   └── v1│   │   ├── service│   │   └── mongodb│   ├── pkg│   │   ├── code│   │   ├── logger│   │   ├── middleware│   │   └── setting│   │   └── util├── pkg│   └── ...├── scripts│   ├── lib│   └── make-rules├── test│   ├── testdata│   └── ...├── third_party├── Makefile└── README.md</code></pre><h3 id="目录结构说明"><a href="#目录结构说明" class="headerlink" title="目录结构说明"></a>目录结构说明</h3><ul><li><p>api 存放对外提供的 API 接口定义文件</p></li><li><p>build  存放与持续集成相关的文件</p><ul><li>ci  存放 CI 的配置文件和脚本</li><li>docker  存放 dockerfile 文件</li><li>package 存放系统的包配置和脚本</li></ul></li><li><p>CHANGELOG 存放更新记录，使用 git-chglog 自动生成</p></li><li><p>cmd   存放项目中组件 main 函数</p></li><li><p>configs   存放配置文件模板或默认配置</p></li><li><p>deployments 存放容器编排部署配置和模板</p><ul><li>templates</li></ul></li><li><p>docs 存放设计、开发、用户文档</p><ul><li>devel  设计、开发文档</li><li>guide 用户文档</li><li>images  存放图片</li></ul></li><li><p>examples 存放 app 或公共包的示例代码</p></li><li><p>githooks  Git Hooks，存放使用到的 git hook 文件(/hooks/.git/hooks/）</p></li><li><p>internal 存放私有应用和库代码</p><ul><li><p>apiserver  存放应用代码</p><ul><li>api     存放内部 api 代码</li><li>service  存放业务处理代码</li><li>mongodb 存放与数据库交互的代码，Create、Update、Delete、Get、List</li></ul></li><li><p>pkg    存放项目内可共享，项目外不共享的包</p><ul><li>code  状态码</li><li>logger  日志处理</li><li>middleware  HTTP 处理链</li><li>setting  读取配置</li><li>util 定义公共函数、工具</li></ul></li></ul></li><li><p>pkg   存放可以被外部应用使用的代码库</p></li><li><p>scripts   存放脚本文件</p><ul><li>lib  存放 shell 脚本</li><li>make-rules 存放 makefile 文件，实现 Makefile 文件中功能</li></ul></li><li><p>test     存放其他外部测试相关内容</p><ul><li>testdata  存放测试数据</li></ul></li><li><p>third_party  存放第三方工具</p></li><li><p>Makefile 存放重复性命令，如单元测试 go test  、编译 build，镜像打包，部署，生成API 文档（swagger）</p></li><li><p>README.md  项目介绍</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>design_parttern</title>
    <link href="/2022/06/22/go/finished/design_parttern/"/>
    <url>/2022/06/22/go/finished/design_parttern/</url>
    
    <content type="html"><![CDATA[<h1 id="design-parttern"><a href="#design-parttern" class="headerlink" title="design_parttern"></a><a href="https://github.com/senghoo/golang-design-pattern">design_parttern</a></h1><p><img src="https://raw.githubusercontent.com/1ch0/Figure-bed/main/img/design_pattern1.jpg" alt="设计原则"></p><p><img src="https://raw.githubusercontent.com/1ch0/Figure-bed/main/img/design_pattern2.jpg" alt="设计模式"></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go,github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>minikube</title>
    <link href="/2022/04/24/cloud/install/Minikube%20Install/"/>
    <url>/2022/04/24/cloud/install/Minikube%20Install/</url>
    
    <content type="html"><![CDATA[<h1 id="Minikube"><a href="#Minikube" class="headerlink" title="Minikube"></a>Minikube</h1><h2 id="1-Install"><a href="#1-Install" class="headerlink" title="1. Install"></a>1. Install</h2><h3 id="1-1-先决条件"><a href="#1-1-先决条件" class="headerlink" title="1.1 先决条件"></a>1.1 先决条件</h3><p>安装 Docker：<a href="https://www.cnblogs.com/jhxxb/p/11410816.html">https://www.cnblogs.com/jhxxb/p/11410816.html</a></p><p>安装 kubectl：<a href="https://kubernetes.io/docs/tasks/tools/">https://kubernetes.io/docs/tasks/tools/</a></p><pre><code class="hljs awk">curl -LO <span class="hljs-string">&quot;https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl&quot;</span>sudo install -o root -g root -m <span class="hljs-number">0755</span> kubectl <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>kubectlkubectl version --client</code></pre><h3 id="1-2-安装-Minikube"><a href="#1-2-安装-Minikube" class="headerlink" title="1.2 安装 Minikube"></a>1.2 安装 Minikube</h3><p><a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a></p><pre><code class="hljs awk">curl -LO https:<span class="hljs-regexp">//</span>storage.googleapis.com<span class="hljs-regexp">/minikube/</span>releases<span class="hljs-regexp">/latest/mi</span>nikube-linux-amd64sudo install minikube-linux-amd64 <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/mi</span>nikubesudo install minikube <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/mi</span>nikube</code></pre><h3 id="1-3-启动"><a href="#1-3-启动" class="headerlink" title="1.3 启动"></a>1.3 启动</h3><pre><code class="hljs routeros">sudo apt-<span class="hljs-builtin-name">get</span> install -y conntrackminikube start --force <span class="hljs-attribute">--driver</span>=docker <span class="hljs-attribute">--image-mirror-country</span>=<span class="hljs-string">&#x27;cn&#x27;</span> -p prdminikube start <span class="hljs-attribute">--driver</span>=none <span class="hljs-attribute">--image-mirror-country</span>=<span class="hljs-string">&#x27;cn&#x27;</span> -p devminikube start --force <span class="hljs-attribute">--driver</span>=docker <span class="hljs-attribute">--image-mirror-country</span>=<span class="hljs-string">&#x27;cn&#x27;</span> -p devminikube start --force <span class="hljs-attribute">--driver</span>=docker <span class="hljs-attribute">--image-mirror-country</span>=<span class="hljs-string">&#x27;cn&#x27;</span> -p prdminikube start --force <span class="hljs-attribute">--driver</span>=docker <span class="hljs-attribute">--image-mirror-country</span>=<span class="hljs-string">&#x27;cn&#x27;</span> --nodes 2 -p multicloudminikube start <span class="hljs-attribute">--driver</span>=none <span class="hljs-attribute">--image-mirror-country</span>=<span class="hljs-string">&#x27;cn&#x27;</span> -p devminikube start --force <span class="hljs-attribute">--driver</span>=docker <span class="hljs-attribute">--image-mirror-country</span>=<span class="hljs-string">&#x27;cn&#x27;</span>minikube start --force <span class="hljs-attribute">--driver</span>=docker <span class="hljs-attribute">--image-mirror-country</span>=<span class="hljs-string">&#x27;cn&#x27;</span> -p devminikube start --force <span class="hljs-attribute">--driver</span>=docker <span class="hljs-attribute">--image-mirror-country</span>=<span class="hljs-string">&#x27;cn&#x27;</span> --nodes 2 -p multicloud</code></pre><p><img src="https://img2020.cnblogs.com/blog/1595409/202109/1595409-20210902204507588-1116181331.png"></p><h4 id="安装-ingress-启用路由访问功能："><a href="#安装-ingress-启用路由访问功能：" class="headerlink" title="安装 ingress 启用路由访问功能："></a>安装 ingress 启用路由访问功能：</h4><pre><code class="hljs shell">minikube addons enable ingress -p prd</code></pre><p>默认为单节点，可添加节点，<a href="https://minikube.sigs.k8s.io/docs/commands/node">https://minikube.sigs.k8s.io/docs/commands/node</a></p><pre><code class="hljs crmsh">minikube <span class="hljs-keyword">node</span> <span class="hljs-title">list</span>minikube <span class="hljs-keyword">node</span> <span class="hljs-title">add</span></code></pre><p><img src="https://img2020.cnblogs.com/blog/1595409/202109/1595409-20210908112252205-1596529691.png"></p><p>可视化</p><pre><code class="hljs routeros">minikube dashboard --url<span class="hljs-comment"># 让其它 IP 可以访问</span>kubectl<span class="hljs-built_in"> proxy </span><span class="hljs-attribute">--port</span>=8888 <span class="hljs-attribute">--address</span>=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span> <span class="hljs-attribute">--accept-hosts</span>=<span class="hljs-string">&#x27;^.*&#x27;</span></code></pre><p><img src="https://img2020.cnblogs.com/blog/1595409/202109/1595409-20210902204543902-215726374.png"></p><p>访问：<a href="http://10.74.2.71:8888/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/overview?namespace=_all">http://10.74.2.71:8888/api/v1/namespaces/kubernetes-dashboard/services/http:kubernetes-dashboard:/proxy/#/overview?namespace=_all</a></p><p><img src="https://img2020.cnblogs.com/blog/1595409/202109/1595409-20210902204952968-2145669697.png"></p><h3 id="1-4-部署应用与访问应用"><a href="#1-4-部署应用与访问应用" class="headerlink" title="1.4 部署应用与访问应用"></a>1.4 部署应用与访问应用</h3><pre><code class="hljs routeros">kubectl create deployment nginx <span class="hljs-attribute">--image</span>=nginxkubectl expose deployment nginx <span class="hljs-attribute">--port</span>=80 <span class="hljs-attribute">--type</span>=NodePort<span class="hljs-comment"># 获取访问地址</span>minikube<span class="hljs-built_in"> service </span>--url nginx</code></pre><p><img src="https://img2020.cnblogs.com/blog/1595409/202109/1595409-20210908110419146-150818120.png"></p><pre><code class="hljs pgsql"># 也可以通过 kubectl proxy 拼接 url 访问，https://kubernetes.io/zh/docs/tasks/<span class="hljs-keyword">access</span>-application-<span class="hljs-keyword">cluster</span>/<span class="hljs-keyword">access</span>-<span class="hljs-keyword">cluster</span>/#manually-constructing-apiserver-proxy-urls# http://<span class="hljs-number">10.74</span><span class="hljs-number">.2</span><span class="hljs-number">.71</span>:<span class="hljs-number">8888</span>/api/v1/namespaces/<span class="hljs-keyword">default</span>/services/nginx:<span class="hljs-number">80</span>/proxy/</code></pre><p><img src="https://img2020.cnblogs.com/blog/1595409/202109/1595409-20210908103557167-1148701296.png"></p><p>使用负载均衡访问，Minikube 网络：<a href="https://minikube.sigs.k8s.io/docs/handbook/accessing">https://minikube.sigs.k8s.io/docs/handbook/accessing</a></p><p><a href="javascript:void(0);" title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif"></a></p><pre><code class="hljs routeros"><span class="hljs-comment"># 新开窗口运行</span>minikube tunnel <span class="hljs-attribute">--cleanup</span>=<span class="hljs-literal">true</span><span class="hljs-comment"># 重新部署</span>kubectl delete deployment nginxkubectl delete<span class="hljs-built_in"> service </span>nginxkubectl create deployment nginx <span class="hljs-attribute">--image</span>=nginxkubectl expose deployment nginx <span class="hljs-attribute">--port</span>=80 <span class="hljs-attribute">--type</span>=LoadBalancer<span class="hljs-comment"># 查看外部地址</span>kubectl <span class="hljs-builtin-name">get</span> svc</code></pre><p><a href="javascript:void(0);" title="复制代码"><img src="http://common.cnblogs.com/images/copycode.gif"></a></p><p><img src="https://img2020.cnblogs.com/blog/1595409/202109/1595409-20210908111029052-595660420.png"></p><p>通过转发访问，<a href="https://kubernetes.io/zh/docs/tasks/access-application-cluster/port-forward-access-application-cluster">https://kubernetes.io/zh/docs/tasks/access-application-cluster/port-forward-access-application-cluster</a></p><pre><code class="hljs apache"><span class="hljs-attribute">kubectl</span> port-forward pods/nginx-<span class="hljs-number">6799</span>fc<span class="hljs-number">88</span>d<span class="hljs-number">8</span>-p<span class="hljs-number">8</span>llb <span class="hljs-number">8080</span>:<span class="hljs-number">80</span> --address=&#x27;<span class="hljs-number">0.0.0.0</span>&#x27;</code></pre><p><img src="https://img2020.cnblogs.com/blog/1595409/202109/1595409-20210908114635923-979756821.png"></p><h3 id="1-5-卸载"><a href="#1-5-卸载" class="headerlink" title="1.5 卸载"></a>1.5 卸载</h3><p><a href="https://minikube.sigs.k8s.io/docs/commands/delete">https://minikube.sigs.k8s.io/docs/commands/delete</a></p><pre><code class="hljs awk">minikube stopminikube <span class="hljs-keyword">delete</span> --alldocker rmi kicbase/stable:v0.<span class="hljs-number">0.25</span>rm -rf ~<span class="hljs-regexp">/.kube ~/</span>.minikubesudo rm -rf <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>kubectl <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/mi</span>nikubedocker system prune -a</code></pre><p><strong><a href="https://github.com/AliyunContainerService/minikube/wiki">https://github.com/AliyunContainerService/minikube/wiki</a></strong></p><p><a href="https://kubernetes.io/zh/docs/tutorials/hello-minikube"><strong>https://kubernetes.io/zh/docs/tutorials/hello-minikube</strong></a></p><p>[<strong><a href="https://www.cnblogs.com/k4nz/p/14543016.html">https://www.cnblogs.com/k4nz/p/14543016.html</a></strong>](</p><p><a href="https://www.cnblogs.com/jhxxb/p/15220729.html">Reference</a></p><h2 id="Vela"><a href="#Vela" class="headerlink" title="Vela"></a>Vela</h2><pre><code class="hljs sql">curl -fsSl https://static.kubevela.net/script/<span class="hljs-keyword">install</span>-velad.sh | bash -s <span class="hljs-number">1.4</span><span class="hljs-number">.2</span>velad <span class="hljs-keyword">install</span><span class="hljs-keyword">export</span> KUBECONFIG=$(velad kubeconfig <span class="hljs-comment">--host)</span>vela compvela addon <span class="hljs-keyword">enable</span> ~/.vela/addons/velauxvelad <span class="hljs-keyword">uninstall</span>sudo mv ./vela /usr/<span class="hljs-keyword">local</span>/<span class="hljs-keyword">bin</span>/velavela <span class="hljs-keyword">install</span>vela addon <span class="hljs-keyword">enable</span> velaux serviceType=NodePort repo=acr.kubevela.net<span class="hljs-comment"># 获取映射的端口，通过该端口访问 VelaUX</span>kubectl <span class="hljs-keyword">get</span> service velaux -n vela-<span class="hljs-keyword">system</span> -o jsonpath=<span class="hljs-string">&quot;&#123;.spec.ports[0].nodePort&#125;&quot;</span></code></pre><pre><code class="hljs apache"><span class="hljs-attribute">registry</span>.aliyuncs.com/google_containers/nginx-ingress-controller:<span class="hljs-number">0</span>.<span class="hljs-number">26</span>.<span class="hljs-number">1</span></code></pre><h4 id="Get-pwd"><a href="#Get-pwd" class="headerlink" title="Get pwd"></a>Get pwd</h4><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>velapwd=$(kubectl get secret/admin -n vela-system -o yaml|grep &#x27;admin:&#x27;| awk -F &#x27;:&#x27; &#x27;&#123;print $2&#125;&#x27;)echo $velapwd | base64 -decho</code></pre><h4 id="Iptables"><a href="#Iptables" class="headerlink" title="Iptables"></a>Iptables</h4><pre><code class="hljs shell">iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to-destination 127.0.0.1:32785iptables -t nat -A POSTROUTING -p tcp -d 127.0.0.1 --dport 32785 -j SNAT --to-source 0.0.0.0:443iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to-destination 192.168.67.2:443</code></pre>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>minikube</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>运维面试题总结</title>
    <link href="/2022/01/21/cloud/tmp/interview/k8s%20%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/21/cloud/tmp/interview/k8s%20%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="运维面试题总结"><a href="#运维面试题总结" class="headerlink" title="运维面试题总结"></a>运维面试题总结</h1><h3 id="简述-ETCD-及其特点？"><a href="#简述-ETCD-及其特点？" class="headerlink" title="简述 ETCD 及其特点？"></a>简述 ETCD 及其特点？</h3><p>etcd 是 CoreOS 团队发起的开源项目，是一个管理配置信息和服务发现（service discovery）的项目，它的目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。</p><p>特点：</p><ul><li><p>简单：支持 REST 风格的 HTTP+JSON API</p></li><li><p>安全：支持 HTTPS 方式的访问</p></li><li><p>快速：支持并发 1k/s 的写操作</p></li><li><p>可靠：支持分布式结构，基于 Raft 的一致性算法，Raft 是一套通过选举主节点来实现分布式系统一致性的算法。</p></li></ul><h3 id="简述-ETCD-适应的场景？"><a href="#简述-ETCD-适应的场景？" class="headerlink" title="简述 ETCD 适应的场景？"></a>简述 ETCD 适应的场景？</h3><p>etcd 基于其优秀的特点，可广泛的应用于以下场景：</p><p><code>服务发现 (Service Discovery)</code>：服务发现主要解决在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听 udp 或 tcp 端口，并且通过名字就可以查找和连接。 <code>消息发布与订阅</code>：在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。应用中用到的一些配置信息放到 etcd 上进行集中管理。 <code>负载均衡</code>：在分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。etcd 本身分布式架构存储的信息访问支持负载均衡。etcd 集群化以后，每个 etcd 的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到 etcd 中也可以实现负载均衡的效果。 <code>分布式通知与协调</code>：与消息发布和订阅类似，都用到了 etcd 中的 Watcher 机制，通过注册与异步通知机制，实现分布式环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。 <code>分布式锁</code>：因为 etcd 使用 Raft 算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。集群监控与 Leader 竞选：通过 etcd 来进行监控实现起来非常简单并且实时性强。</p><h3 id="简述-HAProxy-及其特性？"><a href="#简述-HAProxy-及其特性？" class="headerlink" title="简述 HAProxy 及其特性？"></a>简述 HAProxy 及其特性？</h3><p>HAProxy 是可提供高可用性、负载均衡以及基于 TCP 和 HTTP 应用的代理，是免费、快速并且可靠的一种解决方案。HAProxy 非常适用于并发大（并发达 1w 以上）web 站点，这些站点通常又需要会话保持或七层处理。HAProxy 的运行模式使得它可以很简单安全的整合至当前的架构中，同时可以保护 web 服务器不被暴露到网络上。</p><p>HAProxy 的主要特性有：</p><ul><li><p>可靠性和稳定性非常好，可以与硬件级的 F5 负载均衡设备相媲美；</p></li><li><p>最高可以同时维护 40000-50000 个并发连接，单位时间内处理的最大请求数为 20000 个，最大处理能力可达 10Git/s；</p></li><li><p>支持多达 8 种负载均衡算法，同时也支持会话保持；</p></li><li><p>支持虚机主机功能，从而实现 web 负载均衡更加灵活；</p></li><li><p>支持连接拒绝、全透明代理等独特的功能；</p></li><li><p>拥有强大的 ACL 支持，用于访问控制；</p></li><li><p>其独特的弹性二叉树数据结构，使数据结构的复杂性上升到了 0(1)，即数据的查寻速度不会随着数据条目的增加而速度有所下降；</p></li><li><p>支持客户端的 keepalive 功能，减少客户端与 haproxy 的多次三次握手导致资源浪费，让多个请求在一个 tcp 连接中完成；</p></li><li><p>支持 TCP 加速，零复制功能，类似于 mmap 机制；</p></li><li><p>支持响应池（response buffering）；</p></li><li><p>支持 RDP 协议；</p></li><li><p>基于源的粘性，类似 nginx 的 ip_hash 功能，把来自同一客户端的请求在一定时间内始终调度到上游的同一服务器；</p></li><li><p>更好统计数据接口，其 web 接口显示后端集群中各个服务器的接收、发送、拒绝、错误等数据的统计信息；</p></li><li><p>详细的健康状态检测，web 接口中有关于对上游服务器的健康检测状态，并提供了一定的管理功能；</p></li><li><p>基于流量的健康评估机制；</p></li><li><p>基于 http 认证；</p></li><li><p>基于命令行的管理接口；</p></li><li><p>日志分析器，可对日志进行分析。</p></li></ul><h3 id="简述-HAProxy-常见的负载均衡策略？"><a href="#简述-HAProxy-常见的负载均衡策略？" class="headerlink" title="简述 HAProxy 常见的负载均衡策略？"></a>简述 HAProxy 常见的负载均衡策略？</h3><p>HAProxy 负载均衡策略非常多，常见的有如下 8 种：</p><ul><li><p>roundrobin：表示简单的轮询。</p></li><li><p>static-rr：表示根据权重。</p></li><li><p>leastconn：表示最少连接者先处理。</p></li><li><p>source：表示根据请求的源 IP，类似 Nginx 的 IP_hash 机制。</p></li><li><p>ri：表示根据请求的 URI。</p></li><li><p>rl_param：表示根据 HTTP 请求头来锁定每一次 HTTP 请求。</p></li><li><p>rdp-cookie(name)：表示根据据 cookie(name) 来锁定并哈希每一次 TCP 请求。</p></li></ul><h3 id="简述负载均衡四层和七层的区别？"><a href="#简述负载均衡四层和七层的区别？" class="headerlink" title="简述负载均衡四层和七层的区别？"></a>简述负载均衡四层和七层的区别？</h3><p><code>四层负载均衡器</code>也称为 4 层交换机，主要通过分析 IP 层及 TCP/UDP 层的流量实现基于 IP 加端口的负载均衡，如常见的 LVS、F5 等；</p><p><code>七层负载均衡器</code>也称为 7 层交换机，位于 OSI 的最高层，即应用层，此负载均衡器支持多种协议，如 HTTP、FTP、SMTP 等。7 层负载均衡器可根据报文内容，配合一定的负载均衡算法来选择后端服务器，即 “内容交换器”。如常见的 HAProxy、Nginx。</p><ul><li><h3 id="简述-LVS、Nginx、HAproxy-的什么异同？"><a href="#简述-LVS、Nginx、HAproxy-的什么异同？" class="headerlink" title="简述 LVS、Nginx、HAproxy 的什么异同？"></a>简述 LVS、Nginx、HAproxy 的什么异同？</h3></li><li><p>相同：三者都是软件负载均衡产品。</p></li><li><p>区别：</p></li><li><p>LVS 基于 Linux 操作系统实现软负载均衡，而 HAProxy 和 Nginx 是基于第三方应用实现的软负载均衡；</p></li><li><p>LVS 是可实现 4 层的 IP 负载均衡技术，无法实现基于目录、URL 的转发。而 HAProxy 和 Nginx 都可以实现 4 层和 7 层技术，HAProxy 可提供 TCP 和 HTTP 应用的负载均衡综合解决方案；</p></li><li><p>LVS 因为工作在 ISO 模型的第四层，其状态监测功能单一，而 HAProxy 在状监测方面功能更丰富、强大，可支持端口、URL、脚本等多种状态检测方式；</p></li><li><p>HAProxy 功能强大，但整体性能低于 4 层模式的 LVS 负载均衡。</p></li><li><p>Nginx 主要用于 Web 服务器或缓存服务器。</p></li></ul><h3 id="简述-Heartbeat？"><a href="#简述-Heartbeat？" class="headerlink" title="简述 Heartbeat？"></a>简述 Heartbeat？</h3><p>Heartbeat 是 Linux-HA 项目中的一个组件，它提供了心跳检测和资源接管、集群中服务的监测、失效切换等功能。heartbeat 最核心的功能包括两个部分，心跳监测和资源接管。心跳监测可以通过网络链路和串口进行，而且支持冗余链路，它们之间相互发送报文来告诉对方自己当前的状态，如果在指定的时间内未收到对方发送的报文，那么就认为对方失效，这时需启动资源接管模块来接管运行在对方主机上的资源或者服务。</p><h3 id="简述-Keepalived-及其工作原理？"><a href="#简述-Keepalived-及其工作原理？" class="headerlink" title="简述 Keepalived 及其工作原理？"></a>简述 Keepalived 及其工作原理？</h3><p>Keepalived 是一个基于 VRRP 协议来实现的 LVS 服务高可用方案，可以解决静态路由出现的单点故障问题。</p><p>在一个 LVS 服务集群中通常有主服务器（MASTER）和备份服务器（BACKUP）两种角色的服务器，但是对外表现为一个虚拟 IP，主服务器会发送 VRRP 通告信息给备份服务器，当备份服务器收不到 VRRP 消息的时候，即主服务器异常的时候，备份服务器就会接管虚拟 IP，继续提供服务，从而保证了高可用性。</p><h3 id="简述-Keepalived-体系主要模块及其作用？"><a href="#简述-Keepalived-体系主要模块及其作用？" class="headerlink" title="简述 Keepalived 体系主要模块及其作用？"></a>简述 Keepalived 体系主要模块及其作用？</h3><p>keepalived 体系架构中主要有三个模块，分别是 core、check 和 vrrp。</p><ul><li><p><code>core 模块</code>为 keepalived 的核心，负责主进程的启动、维护及全局配置文件的加载和解析。</p></li><li><p><code>vrrp 模块</code>是来实现 VRRP 协议的。</p></li><li><p><code>check</code>负责健康检查，常见的方式有端口检查及 URL 检查。</p></li></ul><h3 id="简述-Keepalived-如何通过健康检查来保证高可用？"><a href="#简述-Keepalived-如何通过健康检查来保证高可用？" class="headerlink" title="简述 Keepalived 如何通过健康检查来保证高可用？"></a>简述 Keepalived 如何通过健康检查来保证高可用？</h3><p>Keepalived 工作在 TCP/IP 模型的第三、四和五层，即网络层、传输层和应用层。</p><ul><li><p><code>网络层</code>，Keepalived 采用 ICMP 协议向服务器集群中的每个节点发送一个 ICMP 的数据包，如果某个节点没有返回响应数据包，则认为此节点发生了故障，Keepalived 将报告次节点失效，并从服务器集群中剔除故障节点。</p></li><li><p><code>传输层</code>，Keepalived 利用 TCP 的端口连接和扫描技术来判断集群节点是否正常。如常见的 web 服务默认端口 80，ssh 默认端口 22 等。Keepalived 一旦在传输层探测到相应端口没用响应数据返回，则认为此端口发生异常，从而将此端口对应的节点从服务器集群中剔除。</p></li><li><p><code>应用层</code>，可以运行 FTP、telnet、smtp、dns 等各种不同类型的高层协议，Keepalived 的运行方式也更加全面化和复杂化，用户可以通过自定义 Keepalived 的工作方式，来设定监测各种程序或服务是否正常，若监测结果与设定的正常结果不一致，将此服务对应的节点从服务器集群中剔除。</p></li></ul><p>Keepalived 通过完整的健康检查机制，保证集群中的所有节点均有效从而实现高可用。</p><h3 id="简述-LVS-的概念及其作用？"><a href="#简述-LVS-的概念及其作用？" class="headerlink" title="简述 LVS 的概念及其作用？"></a>简述 LVS 的概念及其作用？</h3><p>LVS 是 linux virtual server 的简写 linux 虚拟服务器，是一个虚拟的服务器集群系统，可以在 unix/linux 平台下实现负载均衡集群功能。</p><p>LVS 的主要作用是：通过 LVS 提供的负载均衡技术实现一个高性能、高可用的服务器群集。因此 LVS 主要可以实现：</p><ul><li><p>把单台计算机无法承受的大规模的并发访问或数据流量分担到多台节点设备上分别处理，减少用户等待响应的时间，提升用户体验。</p></li><li><p>单个重负载的运算分担到多台节点设备上做并行处理，每个节点设备处理结束后，将结果汇总，返回给用户，系统处理能力得到大幅度提高。</p></li><li><p>7*24 小时的服务保证，任意一个或多个设备节点设备宕机，不能影响到业务。在负载均衡集群中，所有计算机节点都应该提供相同的服务，集群负载均衡获取所有对该服务的如站请求。</p></li></ul><h3 id="简述-LVS-的工作模式及其工作过程？"><a href="#简述-LVS-的工作模式及其工作过程？" class="headerlink" title="简述 LVS 的工作模式及其工作过程？"></a>简述 LVS 的工作模式及其工作过程？</h3><p>LVS 有三种负载均衡的模式，分别是 VS/NAT（nat 模式）、VS/DR（路由模式）、VS/TUN（隧道模式）。</p><ul><li><p>NAT 模式（VS-NAT）</p></li><li><p><code>原理</code>：首先负载均衡器接收到客户的请求数据包时，根据调度算法决定将请求发送给哪个后端的真实服务器（RS）。然后负载均衡器就把客户端发送的请求数据包的目标 IP 地址及端口改成后端真实服务器的 IP 地址（RIP）。真实服务器响应完请求后，查看默认路由，把响应后的数据包发送给负载均衡器，负载均衡器在接收到响应包后，把包的源地址改成虚拟地址（VIP）然后发送回给客户端。</p></li><li><p><code>优点</code>：集群中的服务器可以使用任何支持 TCP/IP 的操作系统，只要负载均衡器有一个合法的 IP 地址。</p></li><li><p><code>缺点</code>：扩展性有限，当服务器节点增长过多时，由于所有的请求和应答都需要经过负载均衡器，因此负载均衡器将成为整个系统的瓶颈。</p></li><li><p>IP 隧道模式（VS-TUN）</p></li><li><p><code>原理</code>：首先负载均衡器接收到客户的请求数据包时，根据调度算法决定将请求发送给哪个后端的真实服务器（RS）。然后负载均衡器就把客户端发送的请求报文封装一层 IP 隧道（T-IP）转发到真实服务器（RS）。真实服务器响应完请求后，查看默认路由，把响应后的数据包直接发送给客户端，不需要经过负载均衡器。</p></li><li><p><code>优点</code>：负载均衡器只负责将请求包分发给后端节点服务器，而 RS 将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，也能处理很巨大的请求量。</p></li><li><p><code>缺点</code>：隧道模式的 RS 节点需要合法 IP，这种方式需要所有的服务器支持 “IP Tunneling”。</p></li><li><p>直接路由模式（VS-DR）</p></li><li><p><code>原理</code>：首先负载均衡器接收到客户的请求数据包时，根据调度算法决定将请求发送给哪个后端的真实服务器（RS）。然后负载均衡器就把客户端发送的请求数据包的目标 MAC 地址改成后端真实服务器的 MAC 地址（R-MAC）。真实服务器响应完请求后，查看默认路由，把响应后的数据包直接发送给客户端，不需要经过负载均衡器。</p></li><li><p><code>优点</code>：负载均衡器只负责将请求包分发给后端节点服务器，而 RS 将应答包直接发给用户。所以，减少了负载均衡器的大量数据流动，负载均衡器不再是系统的瓶颈，也能处理很巨大的请求量。</p></li><li><p><code>缺点</code>：需要负载均衡器与真实服务器 RS 都有一块网卡连接到同一物理网段上，必须在同一个局域网环境。</p></li></ul><h3 id="简述-LVS-调度器常见算法（均衡策略）？"><a href="#简述-LVS-调度器常见算法（均衡策略）？" class="headerlink" title="简述 LVS 调度器常见算法（均衡策略）？"></a>简述 LVS 调度器常见算法（均衡策略）？</h3><p>LVS 调度器用的调度方法基本分为两类：</p><ul><li><p>固定调度算法：rr，wrr，dh，sh</p></li><li><p>rr：轮询算法，将请求依次分配给不同的 rs 节点，即 RS 节点中均摊分配。适合于 RS 所有节点处理性能接近的情况。</p></li><li><p>wrr：加权轮训调度，依据不同 RS 的权值分配任务。权值较高的 RS 将优先获得任务，并且分配到的连接数将比权值低的 RS 更多。相同权值的 RS 得到相同数目的连接数。</p></li><li><p>dh：目的地址哈希调度（destination hashing）以目的地址为关键字查找一个静态 hash 表来获得所需 RS。</p></li><li><p>sh：源地址哈希调度（source hashing）以源地址为关键字查找一个静态 hash 表来获得需要的 RS。</p></li><li><p>动态调度算法：wlc，lc，lblc，lblcr</p></li><li><p>wlc：加权最小连接数调度，假设各台 RS 的权值依次为 Wi，当前 tcp 连接数依次为 Ti，依次去 Ti/Wi 为最小的 RS 作为下一个分配的 RS。</p></li><li><p>lc：最小连接数调度（least-connection），IPVS 表存储了所有活动的连接。LB 会比较将连接请求发送到当前连接最少的 RS。</p></li><li><p>lblc：基于地址的最小连接数调度（locality-based least-connection）：将来自同一个目的地址的请求分配给同一台 RS，此时这台服务器是尚未满负荷的。否则就将这个请求分配给连接数最小的 RS，并以它作为下一次分配的首先考虑。</p></li></ul><h3 id="简述-LVS、Nginx、HAProxy-各自优缺点？"><a href="#简述-LVS、Nginx、HAProxy-各自优缺点？" class="headerlink" title="简述 LVS、Nginx、HAProxy 各自优缺点？"></a>简述 LVS、Nginx、HAProxy 各自优缺点？</h3><ul><li><p>Nginx 的优点：</p></li><li><p>工作在网络的 7 层之上，可以针对 http 应用做一些分流的策略，比如针对域名、目录结构。Nginx 正则规则比 HAProxy 更为强大和灵活。</p></li><li><p>Nginx 对网络稳定性的依赖非常小，理论上能 ping 通就就能进行负载功能，LVS 对网络稳定性依赖比较大，稳定要求相对更高。</p></li><li><p>Nginx 安装和配置、测试比较简单、方便，有清晰的日志用于排查和管理，LVS 的配置、测试就要花比较长的时间了。</p></li><li><p>可以承担高负载压力且稳定，一般能支撑几万次的并发量，负载度比 LVS 相对小些。</p></li><li><p>Nginx 可以通过端口检测到服务器内部的故障，比如根据服务器处理网页返回的状态码、超时等等。</p></li><li><p>Nginx 不仅仅是一款优秀的负载均衡器 / 反向代理软件，它同时也是功能强大的 Web 应用服务器。</p></li><li><p>Nginx 作为 Web 反向加速缓存越来越成熟了，速度比传统的 Squid 服务器更快，很多场景下都将其作为反向代理加速器。</p></li><li><p>Nginx 作为静态网页和图片服务器，这方面的性能非常优秀，同时第三方模块也很多。</p></li><li><p>Nginx 的缺点：</p></li><li><p>Nginx 仅能支持 http、https 和 Email 协议，这样就在适用范围上面小些。</p></li><li><p>对后端服务器的健康检查，只支持通过端口来检测，不支持通过 url 来检测。</p></li><li><p>不支持 Session 的直接保持，需要通过 ip_hash 来解决。</p></li><li><p>LVS 的优点：</p></li><li><p>抗负载能力强、是工作在网络 4 层之上仅作分发之用，没有流量的产生。因此负载均衡软件里的性能最强的，对内存和 cpu 资源消耗比较低。</p></li><li><p>LVS 工作稳定，因为其本身抗负载能力很强，自身有完整的双机热备方案。</p></li><li><p>无流量，LVS 只分发请求，而流量并不从它本身出去，这点保证了均衡器 IO 的性能不会收到大流量的影响。</p></li><li><p>应用范围较广，因为 LVS 工作在 4 层，所以它几乎可对所有应用做负载均衡，包括 http、数据库等。</p></li><li><p>LVS 的缺点是：</p></li><li><p>软件本身不支持正则表达式处理，不能做动静分离。相对来说，Nginx/HAProxy+Keepalived 则具有明显的优势。</p></li><li><p>如果是网站应用比较庞大的话，LVS/DR+Keepalived 实施起来就比较复杂了。相对来说 Nginx/HAProxy+Keepalived 就简单多了。</p></li><li><p>HAProxy 的优点：</p></li><li><p>HAProxy 也是支持虚拟主机的。</p></li><li><p>HAProxy 的优点能够补充 Nginx 的一些缺点，比如支持 Session 的保持，Cookie 的引导，同时支持通过获取指定的 url 来检测后端服务器的状态。</p></li><li><p>HAProxy 跟 LVS 类似，本身就只是一款负载均衡软件，单纯从效率上来讲 HAProxy 会比 Nginx 有更出色的负载均衡速度，在并发处理上也是优于 Nginx 的。</p></li><li><p>HAProxy 支持 TCP 协议的负载均衡转发。</p></li></ul><h3 id="简述代理服务器的概念及其作用？"><a href="#简述代理服务器的概念及其作用？" class="headerlink" title="简述代理服务器的概念及其作用？"></a>简述代理服务器的概念及其作用？</h3><p>代理服务器是一个位于客户端和原始（资源）服务器之间的服务器，为了从原始服务器取得内容，客户端向代理服务器发送一个请求并指定目标原始服务器，然后代理服务器向原始服务器转交请求并将获得的内容返回给客户端。</p><p>其主要作用有：</p><ul><li><p>资源获取：代替客户端实现从原始服务器的资源获取；</p></li><li><p>加速访问：代理服务器可能离原始服务器更近，从而起到一定的加速作用；</p></li><li><p>缓存作用：代理服务器保存从原始服务器所获取的资源，从而实现客户端快速的获取；</p></li><li><p>隐藏真实地址：代理服务器代替客户端去获取原始服务器资源，从而隐藏客户端真实信息。</p></li></ul><h3 id="简述高可用集群可通过哪两个维度衡量高可用性，各自含义是什么？"><a href="#简述高可用集群可通过哪两个维度衡量高可用性，各自含义是什么？" class="headerlink" title="简述高可用集群可通过哪两个维度衡量高可用性，各自含义是什么？"></a>简述高可用集群可通过哪两个维度衡量高可用性，各自含义是什么？</h3><ul><li><p>RTO（Recovery Time Objective）：RTO 指服务恢复的时间，最佳的情况是 0，即服务立即恢复；最坏是无穷大，即服务永远无法恢复；</p></li><li><p>RPO（Recovery Point Objective）：RPO 指指当灾难发生时允许丢失的数据量，0 意味着使用同步的数据，大于 0 意味着有数据丢失，如 “RPO=1 d” 指恢复时使用一天前的数据，那么一天之内的数据就丢失了。因此，恢复的最佳情况是 RTO = RPO = 0，几乎无法实现。</p></li></ul><h3 id="简述什么是-CAP-理论？"><a href="#简述什么是-CAP-理论？" class="headerlink" title="简述什么是 CAP 理论？"></a>简述什么是 CAP 理论？</h3><p>CAP 理论指出了在分布式系统中需要满足的三个条件，主要包括：</p><ul><li><p>Consistency（一致性）：所有节点在同一时间具有相同的数据；</p></li><li><p>Availability（可用性）：保证每个请求不管成功或者失败都有响应；</p></li><li><p>Partition tolerance（分区容错性）：系统中任意信息的丢失或失败不影响系统的继续运行。</p></li></ul><p>CAP 理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。</p><h3 id="简述什么是-ACID-理论？"><a href="#简述什么是-ACID-理论？" class="headerlink" title="简述什么是 ACID 理论？"></a>简述什么是 ACID 理论？</h3><ul><li><p>原子性 (Atomicity)：整体不可分割性，要么全做要不全不做；</p></li><li><p>一致性 (Consistency)：事务执行前、后数据库状态均一致；</p></li><li><p>隔离性 (Isolation)：在事务未提交前，它操作的数据，对其它用户不可见；</p></li><li><p>持久性 (Durable)：一旦事务成功，将进行永久的变更，记录与 redo 日志。</p></li></ul><h3 id="简述什么是-Kubernetes？"><a href="#简述什么是-Kubernetes？" class="headerlink" title="简述什么是 Kubernetes？"></a>简述什么是 Kubernetes？</h3><p>Kubernetes 是一个全新的基于容器技术的分布式系统支撑平台。是 Google 开源的容器集群管理系统（谷歌内部: Borg）。在 Docker 技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。并且具有完备的集群管理能力，多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和发现机制、內建智能负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制以及多粒度的资源配额管理能力。</p><h3 id="简述-Kubernetes-和-Docker-的关系？"><a href="#简述-Kubernetes-和-Docker-的关系？" class="headerlink" title="简述 Kubernetes 和 Docker 的关系？"></a>简述 Kubernetes 和 Docker 的关系？</h3><ul><li><p>Docker 提供容器的生命周期管理和，Docker 镜像构建运行时容器。它的主要优点是将将软件 / 应用程序运行所需的设置和依赖项打包到一个容器中，从而实现了可移植性等优点。</p></li><li><p>Kubernetes 用于关联和编排在多个主机上运行的容器。</p></li></ul><h3 id="简述-Kubernetes-中什么是-Minikube、Kubectl、Kubelet？"><a href="#简述-Kubernetes-中什么是-Minikube、Kubectl、Kubelet？" class="headerlink" title="简述 Kubernetes 中什么是 Minikube、Kubectl、Kubelet？"></a>简述 Kubernetes 中什么是 Minikube、Kubectl、Kubelet？</h3><ul><li><p><code>Minikube</code>是一种可以在本地轻松运行一个单节点 Kubernetes 群集的工具。</p></li><li><p><code>Kubectl</code>是一个命令行工具，可以使用该工具控制 Kubernetes 集群管理器，如检查群集资源，创建、删除和更新组件，查看应用程序。</p></li><li><p><code>Kubelet</code> 是一个代理服务，它在每个节点上运行，并使从服务器与主服务器通信。</p></li></ul><h3 id="简述-Kubernetes-常见的部署方式？"><a href="#简述-Kubernetes-常见的部署方式？" class="headerlink" title="简述 Kubernetes 常见的部署方式？"></a>简述 Kubernetes 常见的部署方式？</h3><p>常见的 Kubernetes 部署方式有：</p><ul><li><p>kubeadm：也是推荐的一种部署方式；</p></li><li><p>二进制：</p></li><li><p>minikube：在本地轻松运行一个单节点 Kubernetes 群集的工具。</p></li></ul><h3 id="简述-Kubernetes-如何实现集群管理？"><a href="#简述-Kubernetes-如何实现集群管理？" class="headerlink" title="简述 Kubernetes 如何实现集群管理？"></a>简述 Kubernetes 如何实现集群管理？</h3><p>在集群管理方面，Kubernetes 将集群中的机器划分为一个 Master 节点和一群工作节点 Node。其中，在 Master 节点运行着集群管理相关的一组进程 kube-apiserver、kube-controller-manager 和 kube-scheduler，这些进程实现了整个集群的资源管理、Pod 调度、弹性伸缩、安全控制、系统监控和纠错等管理能力，并且都是全自动完成的。</p><h3 id="简述-Kubernetes-的优势、适应场景及其特点？"><a href="#简述-Kubernetes-的优势、适应场景及其特点？" class="headerlink" title="简述 Kubernetes 的优势、适应场景及其特点？"></a>简述 Kubernetes 的优势、适应场景及其特点？</h3><p>Kubernetes 作为一个完备的分布式系统支撑平台，其主要优势：</p><ul><li><p>容器编排</p></li><li><p>轻量级</p></li><li><p>开源</p></li><li><p>弹性伸缩</p></li><li><p>负载均衡</p></li></ul><p>Kubernetes 常见场景：</p><ul><li><p>快速部署应用</p></li><li><p>快速扩展应用</p></li><li><p>无缝对接新的应用功能</p></li><li><p>节省资源，优化硬件资源的使用</p></li></ul><p>Kubernetes 相关特点：</p><ul><li><p>可移植: 支持公有云、私有云、混合云、多重云（multi-cloud）。</p></li><li><p>可扩展: 模块化,、插件化、可挂载、可组合。</p></li><li><p>自动化: 自动部署、自动重启、自动复制、自动伸缩 / 扩展。</p></li></ul><h3 id="简述-Kubernetes-的缺点或当前的不足之处？"><a href="#简述-Kubernetes-的缺点或当前的不足之处？" class="headerlink" title="简述 Kubernetes 的缺点或当前的不足之处？"></a>简述 Kubernetes 的缺点或当前的不足之处？</h3><p>Kubernetes 当前存在的缺点（不足）如下：</p><ul><li><p>安装过程和配置相对困难复杂。</p></li><li><p>管理服务相对繁琐。</p></li><li><p>运行和编译需要很多时间。</p></li><li><p>它比其他替代品更昂贵。</p></li><li><p>对于简单的应用程序来说，可能不需要涉及 Kubernetes 即可满足。</p></li></ul><h3 id="简述-Kubernetes-相关基础概念？"><a href="#简述-Kubernetes-相关基础概念？" class="headerlink" title="简述 Kubernetes 相关基础概念？"></a>简述 Kubernetes 相关基础概念？</h3><ul><li><p><code>master</code>：k8s 集群的管理节点，负责管理集群，提供集群的资源数据访问入口。拥有 Etcd 存储服务（可选），运行 Api Server 进程，Controller Manager 服务进程及 Scheduler 服务进程。</p></li><li><p><code>node</code>（worker）：Node（worker）是 Kubernetes 集群架构中运行 Pod 的服务节点，是 Kubernetes 集群操作的单元，用来承载被分配 Pod 的运行，是 Pod 运行的宿主机。运行 docker eninge 服务，守护进程 kunelet 及负载均衡器 kube-proxy。</p></li><li><p><code>pod</code>：运行于 Node 节点上，若干相关容器的组合。Pod 内包含的容器运行在同一宿主机上，使用相同的网络命名空间、IP 地址和端口，能够通过 localhost 进行通信。Pod 是 Kurbernetes 进行创建、调度和管理的最小单位，它提供了比容器更高层次的抽象，使得部署和管理更加灵活。一个 Pod 可以包含一个容器或者多个相关容器。</p></li><li><p><code>label</code>：Kubernetes 中的 Label 实质是一系列的 Key/Value 键值对，其中 key 与 value 可自定义。Label 可以附加到各种资源对象上，如 Node、Pod、Service、RC 等。一个资源对象可以定义任意数量的 Label，同一个 -Label 也可以被添加到任意数量的资源对象上去。Kubernetes 通过 Label Selector（标签选择器）查询和筛选资源对象。</p></li><li><p><code>Replication Controller</code>：Replication Controller 用来管理 Pod 的副本，保证集群中存在指定数量的 Pod 副本。集群中副本的数量大于指定数量，则会停止指定数量之外的多余容器数量。反之，则会启动少于指定数量个数的容器，保证数量不变。Replication Controller 是实现弹性伸缩、动态扩容和滚动升级的核心。</p></li><li><p><code>Deployment</code>：Deployment 在内部使用了 RS 来实现目的，Deployment 相当于 RC 的一次升级，其最大的特色为可以随时获知当前 Pod 的部署进度。</p></li><li><p><code>HPA</code>（Horizontal Pod Autoscaler）：Pod 的横向自动扩容，也是 Kubernetes 的一种资源，通过追踪分析 RC 控制的所有 Pod 目标的负载变化情况，来确定是否需要针对性的调整 Pod 副本数量。</p></li><li><p><code>Service</code>：Service 定义了 Pod 的逻辑集合和访问该集合的策略，是真实服务的抽象。Service 提供了一个统一的服务访问入口以及服务代理和发现机制，关联多个相同 Label 的 Pod，用户不需要了解后台 Pod 是如何运行。</p></li><li><p><code>Volume</code>：Volume 是 Pod 中能够被多个容器访问的共享目录，Kubernetes 中的 Volume 是定义在 Pod 上，可以被一个或多个 Pod 中的容器挂载到某个目录下。</p></li><li><p><code>Namespace</code>：Namespace 用于实现多租户的资源隔离，可将集群内部的资源对象分配到不同的 Namespace 中，形成逻辑上的不同项目、小组或用户组，便于不同的 Namespace 在共享使用整个集群的资源的同时还能被分别管理。</p></li></ul><h3 id="简述-Kubernetes-集群相关组件？"><a href="#简述-Kubernetes-集群相关组件？" class="headerlink" title="简述 Kubernetes 集群相关组件？"></a>简述 Kubernetes 集群相关组件？</h3><p>Kubernetes Master 控制组件，调度管理整个系统（集群），包含如下组件:</p><ul><li><p><code>Kubernetes API Server</code>：作为 Kubernetes 系统的入口，其封装了核心对象的增删改查操作，以 RESTful API 接口方式提供给外部客户和内部组件调用，集群内各个功能模块之间数据交互和通信的中心枢纽。</p></li><li><p><code>Kubernetes Scheduler</code>：为新建立的 Pod 进行节点 (node) 选择(即分配机器)，负责集群的资源调度。</p></li><li><p><code>Kubernetes Controller</code>：负责执行各种控制器，目前已经提供了很多控制器来保证 Kubernetes 的正常运行。</p></li><li><p><code>Replication Controller</code>：管理维护 Replication Controller，关联 Replication Controller 和 - Pod，保证 Replication Controller 定义的副本数量与实际运行 Pod 数量一致。</p></li><li><p><code>Node Controller</code>：管理维护 Node，定期检查 Node 的健康状态，标识出 (失效 | 未失效) 的 Node 节点。</p></li><li><p><code>Namespace Controller</code>：管理维护 Namespace，定期清理无效的 Namespace，包括 Namesapce 下的 API 对象，比如 Pod、Service 等。</p></li><li><p><code>Service Controller</code>：管理维护 Service，提供负载以及服务代理。</p></li><li><p><code>EndPoints Controller</code>：管理维护 Endpoints，关联 Service 和 Pod，创建 Endpoints 为 Service 的后端，当 Pod 发生变化时，实时更新 Endpoints。</p></li><li><p><code>Service Account Controller</code>：管理维护 Service Account，为每个 Namespace 创建默认的 Service Account，同时为 Service Account 创建 Service Account Secret。</p></li><li><p><code>Persistent Volume Controller</code>：管理维护 Persistent Volume 和 Persistent Volume Claim，为新的 Persistent Volume Claim 分配 Persistent Volume 进行绑定，为释放的 Persistent Volume 执行清理回收。</p></li><li><p><code>Daemon Set Controller</code>：管理维护 Daemon Set，负责创建 Daemon Pod，保证指定的 Node 上正常的运行 Daemon Pod。</p></li><li><p><code>Deployment Controller</code>：管理维护 Deployment，关联 Deployment 和 Replication Controller，保证运行指定数量的 Pod。当 Deployment 更新时，控制实现 Replication Controller 和 Pod 的更新。</p></li><li><p><code>Job Controller</code>：管理维护 Job，为 Jod 创建一次性任务 Pod，保证完成 Job 指定完成的任务数目</p></li><li><p><code>Pod Autoscaler Controller</code>：实现 Pod 的自动伸缩，定时获取监控数据，进行策略匹配，当满足条件时执行 Pod 的伸缩动作。</p></li></ul><h3 id="简述-Kubernetes-RC-的机制？"><a href="#简述-Kubernetes-RC-的机制？" class="headerlink" title="简述 Kubernetes RC 的机制？"></a>简述 Kubernetes RC 的机制？</h3><p>Replication Controller 用来管理 Pod 的副本，保证集群中存在指定数量的 Pod 副本。当定义了 RC 并提交至 Kubernetes 集群中之后，Master 节点上的 Controller Manager 组件获悉，并同时巡检系统中当前存活的目标 Pod，并确保目标 Pod 实例的数量刚好等于此 RC 的期望值，若存在过多的 Pod 副本在运行，系统会停止一些 Pod，反之则自动创建一些 Pod。</p><h3 id="简述-Kubernetes-Replica-Set-和-Replication-Controller-之间有什么区别？"><a href="#简述-Kubernetes-Replica-Set-和-Replication-Controller-之间有什么区别？" class="headerlink" title="简述 Kubernetes Replica Set 和 Replication Controller 之间有什么区别？"></a>简述 Kubernetes Replica Set 和 Replication Controller 之间有什么区别？</h3><p>Replica Set 和 Replication Controller 类似，都是确保在任何给定时间运行指定数量的 Pod 副本。不同之处在于 RS 使用基于集合的选择器，而 Replication Controller 使用基于权限的选择器。</p><h3 id="简述-kube-proxy-作用？"><a href="#简述-kube-proxy-作用？" class="headerlink" title="简述 kube-proxy 作用？"></a>简述 kube-proxy 作用？</h3><p>kube-proxy 运行在所有节点上，它监听 apiserver 中 service 和 endpoint 的变化情况，创建路由规则以提供服务 IP 和负载均衡功能。简单理解此进程是 Service 的透明代理兼负载均衡器，其核心功能是将到某个 Service 的访问请求转发到后端的多个 Pod 实例上。</p><h3 id="简述-kube-proxy-iptables-原理？"><a href="#简述-kube-proxy-iptables-原理？" class="headerlink" title="简述 kube-proxy iptables 原理？"></a>简述 kube-proxy iptables 原理？</h3><p>Kubernetes 从 1.2 版本开始，将 iptables 作为 kube-proxy 的默认模式。iptables 模式下的 kube-proxy 不再起到 Proxy 的作用，其核心功能：通过 API Server 的 Watch 接口实时跟踪 Service 与 Endpoint 的变更信息，并更新对应的 iptables 规则，Client 的请求流量则通过 iptables 的 NAT 机制 “直接路由” 到目标 Pod。</p><h3 id="简述-kube-proxy-ipvs-原理？"><a href="#简述-kube-proxy-ipvs-原理？" class="headerlink" title="简述 kube-proxy ipvs 原理？"></a>简述 kube-proxy ipvs 原理？</h3><p>IPVS 在 Kubernetes1.11 中升级为 GA 稳定版。IPVS 则专门用于高性能负载均衡，并使用更高效的数据结构（Hash 表），允许几乎无限的规模扩张，因此被 kube-proxy 采纳为最新模式。</p><p>在 IPVS 模式下，使用 iptables 的扩展 ipset，而不是直接调用 iptables 来生成规则链。iptables 规则链是一个线性的数据结构，ipset 则引入了带索引的数据结构，因此当规则很多时，也可以很高效地查找和匹配。</p><p>可以将 ipset 简单理解为一个 IP（段）的集合，这个集合的内容可以是 IP 地址、IP 网段、端口等，iptables 可以直接添加规则对这个 “可变的集合” 进行操作，这样做的好处在于可以大大减少 iptables 规则的数量，从而减少性能损耗。</p><h3 id="简述-kube-proxy-ipvs-和-iptables-的异同？"><a href="#简述-kube-proxy-ipvs-和-iptables-的异同？" class="headerlink" title="简述 kube-proxy ipvs 和 iptables 的异同？"></a>简述 kube-proxy ipvs 和 iptables 的异同？</h3><p>iptables 与 IPVS 都是基于 Netfilter 实现的，但因为定位不同，二者有着本质的差别：iptables 是为防火墙而设计的；IPVS 则专门用于高性能负载均衡，并使用更高效的数据结构（Hash 表），允许几乎无限的规模扩张。</p><p>与 iptables 相比，IPVS 拥有以下明显优势：</p><ol><li><p>为大型集群提供了更好的可扩展性和性能；</p></li><li><p>支持比 iptables 更复杂的复制均衡算法（最小负载、最少连接、加权等）；</p></li><li><p>支持服务器健康检查和连接重试等功能；</p></li><li><p>可以动态修改 ipset 的集合，即使 iptables 的规则正在使用这个集合。</p></li></ol><h3 id="简述-Kubernetes-中什么是静态-Pod？"><a href="#简述-Kubernetes-中什么是静态-Pod？" class="headerlink" title="简述 Kubernetes 中什么是静态 Pod？"></a>简述 Kubernetes 中什么是静态 Pod？</h3><p>静态 pod 是由 kubelet 进行管理的仅存在于特定 Node 的 Pod 上，他们不能通过 API Server 进行管理，无法与 ReplicationController、Deployment 或者 DaemonSet 进行关联，并且 kubelet 无法对他们进行健康检查。静态 Pod 总是由 kubelet 进行创建，并且总是在 kubelet 所在的 Node 上运行。</p><h3 id="简述-Kubernetes-中-Pod-可能位于的状态？"><a href="#简述-Kubernetes-中-Pod-可能位于的状态？" class="headerlink" title="简述 Kubernetes 中 Pod 可能位于的状态？"></a>简述 Kubernetes 中 Pod 可能位于的状态？</h3><ul><li><p><code>Pending</code>：API Server 已经创建该 Pod，且 Pod 内还有一个或多个容器的镜像没有创建，包括正在下载镜像的过程。</p></li><li><p><code>Running</code>：Pod 内所有容器均已创建，且至少有一个容器处于运行状态、正在启动状态或正在重启状态。</p></li><li><p><code>Succeeded</code>：Pod 内所有容器均成功执行退出，且不会重启。</p></li><li><p><code>Failed</code>：Pod 内所有容器均已退出，但至少有一个容器退出为失败状态。</p></li><li><p><code>Unknown</code>：由于某种原因无法获取该 Pod 状态，可能由于网络通信不畅导致。</p></li></ul><h3 id="简述-Kubernetes-创建一个-Pod-的主要流程？"><a href="#简述-Kubernetes-创建一个-Pod-的主要流程？" class="headerlink" title="简述 Kubernetes 创建一个 Pod 的主要流程？"></a>简述 Kubernetes 创建一个 Pod 的主要流程？</h3><p>Kubernetes 中创建一个 Pod 涉及多个组件之间联动，主要流程如下：</p><ol><li><p>客户端提交 Pod 的配置信息（可以是 yaml 文件定义的信息）到 kube-apiserver。</p></li><li><p>Apiserver 收到指令后，通知给 controller-manager 创建一个资源对象。</p></li><li><p>Controller-manager 通过 api-server 将 pod 的配置信息存储到 ETCD 数据中心中。</p></li><li><p>Kube-scheduler 检测到 pod 信息会开始调度预选，会先过滤掉不符合 Pod 资源配置要求的节点，然后开始调度调优，主要是挑选出更适合运行 pod 的节点，然后将 pod 的资源配置单发送到 node 节点上的 kubelet 组件上。</p></li><li><p>Kubelet 根据 scheduler 发来的资源配置单运行 pod，运行成功后，将 pod 的运行信息返回给 scheduler，scheduler 将返回的 pod 运行状况的信息存储到 etcd 数据中心。</p></li></ol><h3 id="简述-Kubernetes-中-Pod-的重启策略？"><a href="#简述-Kubernetes-中-Pod-的重启策略？" class="headerlink" title="简述 Kubernetes 中 Pod 的重启策略？"></a>简述 Kubernetes 中 Pod 的重启策略？</h3><p>Pod 重启策略（RestartPolicy）应用于 Pod 内的所有容器，并且仅在 Pod 所处的 Node 上由 kubelet 进行判断和重启操作。当某个容器异常退出或者健康检查失败时，kubelet 将根据 RestartPolicy 的设置来进行相应操作。</p><p>Pod 的重启策略包括 Always、OnFailure 和 Never，默认值为 Always。</p><ul><li><p><code>Always</code>：当容器失效时，由 kubelet 自动重启该容器；</p></li><li><p><code>OnFailure</code>：当容器终止运行且退出码不为 0 时，由 kubelet 自动重启该容器；</p></li><li><p><code>Never</code>：不论容器运行状态如何，kubelet 都不会重启该容器。</p></li></ul><p>同时 Pod 的重启策略与控制方式关联，当前可用于管理 Pod 的控制器包括 ReplicationController、Job、DaemonSet 及直接管理 kubelet 管理（静态 Pod）。</p><p>不同控制器的重启策略限制如下：</p><ul><li><p>RC 和 DaemonSet：必须设置为 Always，需要保证该容器持续运行；</p></li><li><p>Job：OnFailure 或 Never，确保容器执行完成后不再重启；</p></li><li><p>kubelet：在 Pod 失效时重启，不论将 RestartPolicy 设置为何值，也不会对 Pod 进行健康检查。</p></li></ul><h3 id="简述-Kubernetes-中-Pod-的健康检查方式？"><a href="#简述-Kubernetes-中-Pod-的健康检查方式？" class="headerlink" title="简述 Kubernetes 中 Pod 的健康检查方式？"></a>简述 Kubernetes 中 Pod 的健康检查方式？</h3><p>对 Pod 的健康检查可以通过两类探针来检查：LivenessProbe 和 ReadinessProbe。</p><ul><li><p><code>LivenessProbe 探针</code>：用于判断容器是否存活（running 状态），如果 LivenessProbe 探针探测到容器不健康，则 kubelet 将杀掉该容器，并根据容器的重启策略做相应处理。若一个容器不包含 LivenessProbe 探针，kubelet 认为该容器的 LivenessProbe 探针返回值用于是 “Success”。</p></li><li><p><code>ReadineeProbe 探针</code>：用于判断容器是否启动完成（ready 状态）。如果 ReadinessProbe 探针探测到失败，则 Pod 的状态将被修改。Endpoint Controller 将从 Service 的 Endpoint 中删除包含该容器所在 Pod 的 Eenpoint。</p></li><li><p><code>startupProbe 探针</code>：启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针 kill 掉。</p></li></ul><h3 id="简述-Kubernetes-Pod-的-LivenessProbe-探针的常见方式？"><a href="#简述-Kubernetes-Pod-的-LivenessProbe-探针的常见方式？" class="headerlink" title="简述 Kubernetes Pod 的 LivenessProbe 探针的常见方式？"></a>简述 Kubernetes Pod 的 LivenessProbe 探针的常见方式？</h3><p>kubelet 定期执行 LivenessProbe 探针来诊断容器的健康状态，通常有以下三种方式：</p><ul><li><p><code>ExecAction</code>：在容器内执行一个命令，若返回码为 0，则表明容器健康。</p></li><li><p><code>TCPSocketAction</code>：通过容器的 IP 地址和端口号执行 TCP 检查，若能建立 TCP 连接，则表明容器健康。</p></li><li><p><code>HTTPGetAction</code>：通过容器的 IP 地址、端口号及路径调用 HTTP Get 方法，若响应的状态码大于等于 200 且小于 400，则表明容器健康。</p></li></ul><h3 id="简述-Kubernetes-Pod-的常见调度方式？"><a href="#简述-Kubernetes-Pod-的常见调度方式？" class="headerlink" title="简述 Kubernetes Pod 的常见调度方式？"></a>简述 Kubernetes Pod 的常见调度方式？</h3><p>Kubernetes 中，Pod 通常是容器的载体，主要有如下常见调度方式：</p><ul><li><p>Deployment 或 RC：该调度策略主要功能就是自动部署一个容器应用的多份副本，以及持续监控副本的数量，在集群内始终维持用户指定的副本数量。</p></li><li><p>NodeSelector：定向调度，当需要手动指定将 Pod 调度到特定 Node 上，可以通过 Node 的标签（Label）和 Pod 的 nodeSelector 属性相匹配。</p></li><li><p>NodeAffinity 亲和性调度：亲和性调度机制极大的扩展了 Pod 的调度能力，目前有两种节点亲和力表达：</p></li><li><p>requiredDuringSchedulingIgnoredDuringExecution：硬规则，必须满足指定的规则，调度器才可以调度 Pod 至 Node 上（类似 nodeSelector，语法不同）。</p></li><li><p>preferredDuringSchedulingIgnoredDuringExecution：软规则，优先调度至满足的 Node 的节点，但不强求，多个优先级规则还可以设置权重值。</p></li><li><p>Taints 和 Tolerations（污点和容忍）：</p></li><li><p>Taint：使 Node 拒绝特定 Pod 运行；</p></li><li><p>Toleration：为 Pod 的属性，表示 Pod 能容忍（运行）标注了 Taint 的 Node。</p></li></ul><h3 id="简述-Kubernetes-初始化容器（init-container）？"><a href="#简述-Kubernetes-初始化容器（init-container）？" class="headerlink" title="简述 Kubernetes 初始化容器（init container）？"></a>简述 Kubernetes 初始化容器（init container）？</h3><p><code>init container</code>的运行方式与应用容器不同，它们必须先于应用容器执行完成，当设置了多个 init container 时，将按顺序逐个运行，并且只有前一个 init container 运行成功后才能运行后一个 init container。当所有 init container 都成功运行后，Kubernetes 才会初始化 Pod 的各种信息，并开始创建和运行应用容器。</p><h3 id="简述-Kubernetes-deployment-升级过程？"><a href="#简述-Kubernetes-deployment-升级过程？" class="headerlink" title="简述 Kubernetes deployment 升级过程？"></a>简述 Kubernetes deployment 升级过程？</h3><ul><li><p>初始创建 Deployment 时，系统创建了一个 ReplicaSet，并按用户的需求创建了对应数量的 Pod 副本。</p></li><li><p>当更新 Deployment 时，系统创建了一个新的 ReplicaSet，并将其副本数量扩展到 1，然后将旧 ReplicaSet 缩减为 2。</p></li><li><p>之后，系统继续按照相同的更新策略对新旧两个 ReplicaSet 进行逐个调整。</p></li><li><p>最后，新的 ReplicaSet 运行了对应个新版本 Pod 副本，旧的 ReplicaSet 副本数量则缩减为 0。</p></li></ul><h3 id="简述-Kubernetes-deployment-升级策略？"><a href="#简述-Kubernetes-deployment-升级策略？" class="headerlink" title="简述 Kubernetes deployment 升级策略？"></a>简述 Kubernetes deployment 升级策略？</h3><p>在 Deployment 的定义中，可以通过 spec.strategy 指定 Pod 更新的策略，目前支持两种策略：Recreate（重建）和 RollingUpdate（滚动更新），默认值为 RollingUpdate。</p><ul><li><p><code>Recreate</code>：设置 spec.strategy.type=Recreate，表示 Deployment 在更新 Pod 时，会先杀掉所有正在运行的 Pod，然后创建新的 Pod。</p></li><li><p><code>RollingUpdate</code>：设置 spec.strategy.type=RollingUpdate，表示 Deployment 会以滚动更新的方式来逐个更新 Pod。同时，可以通过设置 spec.strategy.rollingUpdate 下的两个参数（maxUnavailable 和 maxSurge）来控制滚动更新的过程。</p></li></ul><h3 id="简述-Kubernetes-DaemonSet-类型的资源特性？"><a href="#简述-Kubernetes-DaemonSet-类型的资源特性？" class="headerlink" title="简述 Kubernetes DaemonSet 类型的资源特性？"></a>简述 Kubernetes DaemonSet 类型的资源特性？</h3><p>DaemonSet 资源对象会在每个 Kubernetes 集群中的节点上运行，并且每个节点只能运行一个 pod，这是它和 deployment 资源对象的最大也是唯一的区别。</p><p>因此，在定义 yaml 文件中，不支持定义 replicas。</p><p>它的一般使用场景如下：</p><ul><li><p>在去做每个节点的日志收集工作。</p></li><li><p>监控每个节点的的运行状态。</p></li></ul><h3 id="简述-Kubernetes-自动扩容机制？"><a href="#简述-Kubernetes-自动扩容机制？" class="headerlink" title="简述 Kubernetes 自动扩容机制？"></a>简述 Kubernetes 自动扩容机制？</h3><p>Kubernetes 使用 Horizontal Pod Autoscaler（HPA）的控制器实现基于 CPU 使用率进行自动 Pod 扩缩容的功能。</p><p>HPA 控制器周期性地监测目标 Pod 的资源性能指标，并与 HPA 资源对象中的扩缩容条件进行对比，在满足条件时对 Pod 副本数量进行调整。</p><ul><li><strong>HPA 原理</strong></li></ul><p>ubernetes 中的某个 Metrics Server（Heapster 或自定义 Metrics Server）持续采集所有 Pod 副本的指标数据。</p><p>HPA 控制器通过 Metrics Server 的 API（Heapster 的 API 或聚合 API）获取这些数据，基于用户定义的扩缩容规则进行计算，得到目标 Pod 副本数量。</p><p>当目标 Pod 副本数量与当前副本数量不同时，HPA 控制器就向 Pod 的副本控制器（Deployment、RC 或 ReplicaSet）发起 scale 操作，调整 Pod 的副本数量，完成扩缩容操作。</p><h3 id="简述-Kubernetes-Service-类型？"><a href="#简述-Kubernetes-Service-类型？" class="headerlink" title="简述 Kubernetes Service 类型？"></a>简述 Kubernetes Service 类型？</h3><p>通过创建 Service，可以为一组具有相同功能的容器应用提供一个统一的入口地址，并且将请求负载分发到后端的各个容器应用上。其主要类型有：</p><ul><li><p><code>ClusterIP</code>：虚拟的服务 IP 地址，该地址用于 Kubernetes 集群内部的 Pod 访问，在 Node 上 kube-proxy 通过设置的 iptables 规则进行转发；</p></li><li><p><code>NodePort</code>：使用宿主机的端口，使能够访问各 Node 的外部客户端通过 Node 的 IP 地址和端口号就能访问服务；</p></li><li><p><code>LoadBalancer</code>：使用外接负载均衡器完成到服务的负载分发，需要在 spec.status.loadBalancer 字段指定外部负载均衡器的 IP 地址，通常用于公有云。</p></li></ul><h3 id="简述-Kubernetes-Service-分发后端的策略？"><a href="#简述-Kubernetes-Service-分发后端的策略？" class="headerlink" title="简述 Kubernetes Service 分发后端的策略？"></a>简述 Kubernetes Service 分发后端的策略？</h3><p>Service 负载分发的策略有：RoundRobin 和 SessionAffinity</p><ul><li><p>RoundRobin：默认为轮询模式，即轮询将请求转发到后端的各个 Pod 上。</p></li><li><p>SessionAffinity：基于客户端 IP 地址进行会话保持的模式，即第 1 次将某个客户端发起的请求转发到后端的某个 Pod 上，之后从相同的客户端发起的请求都将被转发到后端相同的 Pod 上。</p></li></ul><h3 id="简述-Kubernetes-Headless-Service？"><a href="#简述-Kubernetes-Headless-Service？" class="headerlink" title="简述 Kubernetes Headless Service？"></a>简述 Kubernetes Headless Service？</h3><p>在某些应用场景中，若需要人为指定负载均衡器，不使用 Service 提供的默认负载均衡的功能，或者应用程序希望知道属于同组服务的其他实例。</p><p>Kubernetes 提供了 Headless Service 来实现这种功能，即不为 Service 设置 ClusterIP（入口 IP 地址），仅通过 Label Selector 将后端的 Pod 列表返回给调用的客户端。</p><h3 id="简述-Kubernetes-外部如何访问集群内的服务？"><a href="#简述-Kubernetes-外部如何访问集群内的服务？" class="headerlink" title="简述 Kubernetes 外部如何访问集群内的服务？"></a>简述 Kubernetes 外部如何访问集群内的服务？</h3><p>对于 Kubernetes，集群外的客户端默认情况，无法通过 Pod 的 IP 地址或者 Service 的虚拟 IP 地址: 虚拟端口号进行访问。</p><p>通常可以通过以下方式进行访问 Kubernetes 集群内的服务：</p><ul><li><p>映射 Pod 到物理机：将 Pod 端口号映射到宿主机，即在 Pod 中采用 hostPort 方式，以使客户端应用能够通过物理机访问容器应用。</p></li><li><p>映射 Service 到物理机：将 Service 端口号映射到宿主机，即在 Service 中采用 nodePort 方式，以使客户端应用能够通过物理机访问容器应用。</p></li><li><p>映射 Sercie 到 LoadBalancer：通过设置 LoadBalancer 映射到云服务商提供的 LoadBalancer 地址。这种用法仅用于在公有云服务提供商的云平台上设置 Service 的场景。</p></li></ul><h3 id="简述-Kubernetes-ingress？"><a href="#简述-Kubernetes-ingress？" class="headerlink" title="简述 Kubernetes ingress？"></a>简述 Kubernetes ingress？</h3><p>Kubernetes 的 Ingress 资源对象，用于将不同 URL 的访问请求转发到后端不同的 Service，以实现 HTTP 层的业务路由机制。</p><p>Kubernetes 使用了 Ingress 策略和 Ingress Controller，两者结合并实现了一个完整的 Ingress 负载均衡器。</p><p>使用 Ingress 进行负载分发时，Ingress Controller 基于 Ingress 规则将客户端请求直接转发到 Service 对应的后端 Endpoint（Pod）上，从而跳过 kube-proxy 的转发功能，kube-proxy 不再起作用，全过程为：ingress controller + ingress 规则 —-&gt; services。</p><p>同时当 Ingress Controller 提供的是对外服务，则实际上实现的是边缘路由器的功能。</p><h3 id="简述-Kubernetes-镜像的下载策略？"><a href="#简述-Kubernetes-镜像的下载策略？" class="headerlink" title="简述 Kubernetes 镜像的下载策略？"></a>简述 Kubernetes 镜像的下载策略？</h3><p>K8s 的镜像下载策略有三种：Always、Never、IFNotPresent。</p><ul><li><p><code>Always</code>：镜像标签为 latest 时，总是从指定的仓库中获取镜像。</p></li><li><p><code>Never</code>：禁止从仓库中下载镜像，也就是说只能使用本地镜像。</p></li><li><p><code>IfNotPresent</code>：仅当本地没有对应镜像时，才从目标仓库中下载。默认的镜像下载策略是：当镜像标签是 latest 时，默认策略是 Always；当镜像标签是自定义时（也就是标签不是 latest），那么默认策略是 IfNotPresent。</p></li></ul><h3 id="简述-Kubernetes-的负载均衡器？"><a href="#简述-Kubernetes-的负载均衡器？" class="headerlink" title="简述 Kubernetes 的负载均衡器？"></a>简述 Kubernetes 的负载均衡器？</h3><p>负载均衡器是暴露服务的最常见和标准方式之一。</p><p>根据工作环境使用两种类型的负载均衡器，即内部负载均衡器或外部负载均衡器。</p><p>内部负载均衡器自动平衡负载并使用所需配置分配容器，而外部负载均衡器将流量从外部负载引导至后端容器。</p><h3 id="简述-Kubernetes-各模块如何与-API-Server-通信？"><a href="#简述-Kubernetes-各模块如何与-API-Server-通信？" class="headerlink" title="简述 Kubernetes 各模块如何与 API Server 通信？"></a>简述 Kubernetes 各模块如何与 API Server 通信？</h3><p>Kubernetes API Server 作为集群的核心，负责集群各功能模块之间的通信。</p><p>集群内的各个功能模块通过 API Server 将信息存入 etcd，当需要获取和操作这些数据时，则通过 API Server 提供的 REST 接口（用 GET、LIST 或 WATCH 方法）来实现，从而实现各模块之间的信息交互。</p><p>如 kubelet 进程与 API Server 的交互：每个 Node 上的 kubelet 每隔一个时间周期，就会调用一次 API Server 的 REST 接口报告自身状态，API Server 在接收到这些信息后，会将节点状态信息更新到 etcd 中。</p><p>如 kube-controller-manager 进程与 API Server 的交互：kube-controller-manager 中的 Node Controller 模块通过 API Server 提供的 Watch 接口实时监控 Node 的信息，并做相应处理。</p><p>如 kube-scheduler 进程与 API Server 的交互：Scheduler 通过 API Server 的 Watch 接口监听到新建 Pod 副本的信息后，会检索所有符合该 Pod 要求的 Node 列表，开始执行 Pod 调度逻辑，在调度成功后将 Pod 绑定到目标节点上。</p><h3 id="简述-Kubernetes-Scheduler-作用及实现原理？"><a href="#简述-Kubernetes-Scheduler-作用及实现原理？" class="headerlink" title="简述 Kubernetes Scheduler 作用及实现原理？"></a>简述 Kubernetes Scheduler 作用及实现原理？</h3><p>Kubernetes Scheduler 是负责 Pod 调度的重要功能模块，Kubernetes Scheduler 在整个系统中承担了 “承上启下” 的重要功能，“承上”是指它负责接收 Controller Manager 创建的新 Pod，为其调度至目标 Node；“启下”是指调度完成后，目标 Node 上的 kubelet 服务进程接管后继工作，负责 Pod 接下来生命周期。</p><p>Kubernetes Scheduler 的作用是将待调度的 Pod（API 新创建的 Pod、Controller Manager 为补足副本而创建的 Pod 等）按照特定的调度算法和调度策略绑定（Binding）到集群中某个合适的 Node 上，并将绑定信息写入 etcd 中。</p><p>在整个调度过程中涉及<strong>三个对象</strong>：</p><p>分别是待调度 Pod 列表、可用 Node 列表，以及调度算法和策略。</p><p>Kubernetes Scheduler 通过调度算法调度为待调度 Pod 列表中的每个 Pod 从 Node 列表中选择一个最适合的 Node 来实现 Pod 的调度。</p><p>随后，目标节点上的 kubelet 通过 API Server 监听到 Kubernetes Scheduler 产生的 Pod 绑定事件，然后获取对应的 Pod 清单，下载 Image 镜像并启动容器。</p><h3 id="简述-Kubernetes-Scheduler-使用哪两种算法将-Pod-绑定到-worker-节点？"><a href="#简述-Kubernetes-Scheduler-使用哪两种算法将-Pod-绑定到-worker-节点？" class="headerlink" title="简述 Kubernetes Scheduler 使用哪两种算法将 Pod 绑定到 worker 节点？"></a>简述 Kubernetes Scheduler 使用哪两种算法将 Pod 绑定到 worker 节点？</h3><p>Kubernetes Scheduler 根据如下两种调度算法将 Pod 绑定到最合适的工作节点：</p><ul><li><p><code>预选（Predicates）</code>：输入是所有节点，输出是满足预选条件的节点。kube-scheduler 根据预选策略过滤掉不满足策略的 Nodes。如果某节点的资源不足或者不满足预选策略的条件则无法通过预选。如 “Node 的 label 必须与 Pod 的 Selector 一致”。</p></li><li><p><code>优选（Priorities）</code>：输入是预选阶段筛选出的节点，优选会根据优先策略为通过预选的 Nodes 进行打分排名，选择得分最高的 Node。例如，资源越富裕、负载越小的 Node 可能具有越高的排名。</p></li></ul><h3 id="简述-Kubernetes-kubelet-的作用？"><a href="#简述-Kubernetes-kubelet-的作用？" class="headerlink" title="简述 Kubernetes kubelet 的作用？"></a>简述 Kubernetes kubelet 的作用？</h3><p>在 Kubernetes 集群中，在每个 Node（又称 Worker）上都会启动一个 kubelet 服务进程。</p><p>该进程用于处理 Master 下发到本节点的任务，管理 Pod 及 Pod 中的容器。</p><p>每个 kubelet 进程都会在 API Server 上注册节点自身的信息，定期向 Master 汇报节点资源的使用情况，并通过 cAdvisor 监控容器和节点资源。</p><h3 id="简述-Kubernetes-kubelet-监控-Worker-节点资源是使用什么组件来实现的？"><a href="#简述-Kubernetes-kubelet-监控-Worker-节点资源是使用什么组件来实现的？" class="headerlink" title="简述 Kubernetes kubelet 监控 Worker 节点资源是使用什么组件来实现的？"></a>简述 Kubernetes kubelet 监控 Worker 节点资源是使用什么组件来实现的？</h3><p>kubelet 使用 cAdvisor 对 worker 节点资源进行监控。</p><p>在 Kubernetes 系统中，cAdvisor 已被默认集成到 kubelet 组件内，当 kubelet 服务启动时，它会自动启动 cAdvisor 服务，然后 cAdvisor 会实时采集所在节点的性能指标及在节点上运行的容器的性能指标。</p><h3 id="简述-Kubernetes-如何保证集群的安全性？"><a href="#简述-Kubernetes-如何保证集群的安全性？" class="headerlink" title="简述 Kubernetes 如何保证集群的安全性？"></a>简述 Kubernetes 如何保证集群的安全性？</h3><p>Kubernetes 通过一系列机制来实现集群的安全控制，</p><p>主要有如下不同的维度：</p><ul><li><p>基础设施方面：保证容器与其所在宿主机的隔离；</p></li><li><p>权限方面：</p></li><li><p>最小权限原则：合理限制所有组件的权限，确保组件只执行它被授权的行为，通过限制单个组件的能力来限制它的权限范围。</p></li><li><p>用户权限：划分普通用户和管理员的角色。</p></li><li><p>集群方面：</p></li><li><p>API Server 的认证授权：Kubernetes 集群中所有资源的访问和变更都是通过 Kubernetes API Server 来实现的，因此需要建议采用更安全的 HTTPS 或 Token 来识别和认证客户端身份（Authentication），以及随后访问权限的授权（Authorization）环节。</p></li><li><p>API Server 的授权管理：通过授权策略来决定一个 API 调用是否合法。对合法用户进行授权并且随后在用户访问时进行鉴权，建议采用更安全的 RBAC 方式来提升集群安全授权。</p></li><li><p>敏感数据引入 Secret 机制：对于集群敏感数据建议使用 Secret 方式进行保护。</p></li><li><p>AdmissionControl（准入机制）：对 kubernetes api 的请求过程中，顺序为：先经过认证 &amp; 授权，然后执行准入操作，最后对目标对象进行操作。</p></li></ul><h3 id="简述-Kubernetes-准入机制？"><a href="#简述-Kubernetes-准入机制？" class="headerlink" title="简述 Kubernetes 准入机制？"></a>简述 Kubernetes 准入机制？</h3><p>在对集群进行请求时，每个准入控制代码都按照一定顺序执行。</p><p>如果有一个准入控制拒绝了此次请求，那么整个请求的结果将会立即返回，并提示用户相应的 error 信息。</p><p><code>准入控制</code>（AdmissionControl）准入控制本质上为一段准入代码，在对 kubernetes api 的请求过程中，顺序为：先经过认证 &amp; 授权，然后执行准入操作，最后对目标对象进行操作。常用组件（控制代码）如下：</p><ul><li><p><code>AlwaysAdmit</code>：允许所有请求</p></li><li><p><code>AlwaysDeny</code>：禁止所有请求，多用于测试环境。</p></li><li><p><code>ServiceAccount</code>：它将 serviceAccounts 实现了自动化，它会辅助 serviceAccount 做一些事情，比如如果 pod 没有 serviceAccount 属性，它会自动添加一个 default，并确保 pod 的 serviceAccount 始终存在。</p></li><li><p><code>LimitRanger</code>：观察所有的请求，确保没有违反已经定义好的约束条件，这些条件定义在 namespace 中 LimitRange 对象中。NamespaceExists：观察所有的请求，如果请求尝试创建一个不存在的 namespace，则这个请求被拒绝。</p></li></ul><h3 id="简述-Kubernetes-RBAC-及其特点（优势）？"><a href="#简述-Kubernetes-RBAC-及其特点（优势）？" class="headerlink" title="简述 Kubernetes RBAC 及其特点（优势）？"></a>简述 Kubernetes RBAC 及其特点（优势）？</h3><p>RBAC 是基于角色的访问控制，是一种基于个人用户的角色来管理对计算机或网络资源的访问的方法。</p><p>相对于其他授权模式，RBAC 具有如下优势：</p><ul><li><p>对集群中的资源和非资源权限均有完整的覆盖。</p></li><li><p>整个 RBAC 完全由几个 API 对象完成， 同其他 API 对象一样， 可以用 kubectl 或 API 进行操作。</p></li><li><p>可以在运行时进行调整，无须重新启动 API Server。</p></li></ul><h3 id="简述-Kubernetes-Secret-作用？"><a href="#简述-Kubernetes-Secret-作用？" class="headerlink" title="简述 Kubernetes Secret 作用？"></a>简述 Kubernetes Secret 作用？</h3><p>Secret 对象，主要作用是保管私密数据，比如密码、OAuth Tokens、SSH Keys 等信息。</p><p>将这些私密信息放在 Secret 对象中比直接放在 Pod 或 Docker Image 中更安全，也更便于使用和分发。</p><h3 id="简述-Kubernetes-Secret-有哪些使用方式？"><a href="#简述-Kubernetes-Secret-有哪些使用方式？" class="headerlink" title="简述 Kubernetes Secret 有哪些使用方式？"></a>简述 Kubernetes Secret 有哪些使用方式？</h3><p>创建完 secret 之后，可通过如下三种方式使用：</p><ul><li><p>在创建 Pod 时，通过为 Pod 指定 Service Account 来自动使用该 Secret。</p></li><li><p>通过挂载该 Secret 到 Pod 来使用它。</p></li><li><p>在 Docker 镜像下载时使用，通过指定 Pod 的 spc.ImagePullSecrets 来引用它。</p></li></ul><h3 id="简述-Kubernetes-PodSecurityPolicy-机制？"><a href="#简述-Kubernetes-PodSecurityPolicy-机制？" class="headerlink" title="简述 Kubernetes PodSecurityPolicy 机制？"></a>简述 Kubernetes PodSecurityPolicy 机制？</h3><p>Kubernetes PodSecurityPolicy 是为了更精细地控制 Pod 对资源的使用方式以及提升安全策略。</p><p>在开启 PodSecurityPolicy 准入控制器后，Kubernetes 默认不允许创建任何 Pod，需要创建 PodSecurityPolicy 策略和相应的 RBAC 授权策略（Authorizing Policies），Pod 才能创建成功。</p><h3 id="简述-Kubernetes-PodSecurityPolicy-机制能实现哪些安全策略？"><a href="#简述-Kubernetes-PodSecurityPolicy-机制能实现哪些安全策略？" class="headerlink" title="简述 Kubernetes PodSecurityPolicy 机制能实现哪些安全策略？"></a>简述 Kubernetes PodSecurityPolicy 机制能实现哪些安全策略？</h3><p>在 PodSecurityPolicy 对象中可以设置不同字段来控制 Pod 运行时的各种安全策略，常见的有：</p><ul><li><p>特权模式：privileged 是否允许 Pod 以特权模式运行。</p></li><li><p>宿主机资源：控制 Pod 对宿主机资源的控制，如 hostPID：是否允许 Pod 共享宿主机的进程空间。</p></li><li><p>用户和组：设置运行容器的用户 ID（范围）或组（范围）。</p></li><li><p>提升权限：AllowPrivilegeEscalation：设置容器内的子进程是否可以提升权限，通常在设置非 root 用户（MustRunAsNonRoot）时进行设置。</p></li><li><p>SELinux：进行 SELinux 的相关配置。</p></li></ul><h3 id="简述-Kubernetes-网络模型？"><a href="#简述-Kubernetes-网络模型？" class="headerlink" title="简述 Kubernetes 网络模型？"></a>简述 Kubernetes 网络模型？</h3><p>Kubernetes 网络模型中每个 Pod 都拥有一个独立的 IP 地址，并假定所有 Pod 都在一个可以直接连通的、扁平的网络空间中。</p><p>所以不管它们是否运行在同一个 Node（宿主机）中，都要求它们可以直接通过对方的 IP 进行访问。</p><p>设计这个原则的原因是，用户不需要额外考虑如何建立 Pod 之间的连接，也不需要考虑如何将容器端口映射到主机端口等问题。</p><p>同时为每个 Pod 都设置一个 IP 地址的模型使得同一个 Pod 内的不同容器会共享同一个网络命名空间，也就是同一个 Linux 网络协议栈。这就意味着同一个 Pod 内的容器可以通过 localhost 来连接对方的端口。</p><p>在 Kubernetes 的集群里，IP 是以 Pod 为单位进行分配的。</p><p>一个 Pod 内部的所有容器共享一个网络堆栈（相当于一个网络命名空间，它们的 IP 地址、网络设备、配置等都是共享的）。</p><h3 id="简述-Kubernetes-CNI-模型？"><a href="#简述-Kubernetes-CNI-模型？" class="headerlink" title="简述 Kubernetes CNI 模型？"></a>简述 Kubernetes CNI 模型？</h3><p>CNI 提供了一种应用容器的插件化网络解决方案，定义对容器网络进行操作和配置的规范，通过插件的形式对 CNI 接口进行实现。</p><p>CNI 仅关注在创建容器时分配网络资源，和在销毁容器时删除网络资源。在 CNI 模型中只涉及两个概念：容器和网络。</p><ul><li><p><code>容器</code>（Container）：是拥有独立 Linux 网络命名空间的环境，例如使用 Docker 或 rkt 创建的容器。容器需要拥有自己的 Linux 网络命名空间，这是加入网络的必要条件。</p></li><li><p><code>网络</code>（Network）：表示可以互连的一组实体，这些实体拥有各自独立、唯一的 IP 地址，可以是容器、物理机或者其他网络设备（比如路由器）等。</p></li></ul><p>对容器网络的设置和操作都通过插件（Plugin）进行具体实现，CNI 插件包括两种类型：</p><p><strong>CNI Plugin 和 IPAM（IP Address Management）Plugin。</strong></p><p>CNI Plugin 负责为容器配置网络资源，IPAM Plugin 负责对容器的 IP 地址进行分配和管理。</p><p>IPAM Plugin 作为 CNI Plugin 的一部分，与 CNI Plugin 协同工作。</p><h3 id="简述-Kubernetes-网络策略？"><a href="#简述-Kubernetes-网络策略？" class="headerlink" title="简述 Kubernetes 网络策略？"></a>简述 Kubernetes 网络策略？</h3><p>为实现细粒度的容器间网络访问隔离策略，Kubernetes 引入 Network Policy。</p><p>Network Policy 的主要功能是对 Pod 间的网络通信进行限制和准入控制，设置允许访问或禁止访问的客户端 Pod 列表。</p><p>Network Policy 定义网络策略，配合策略控制器（Policy Controller）进行策略的实现。</p><h3 id="简述-Kubernetes-网络策略原理？"><a href="#简述-Kubernetes-网络策略原理？" class="headerlink" title="简述 Kubernetes 网络策略原理？"></a>简述 Kubernetes 网络策略原理？</h3><p>Network Policy 的工作原理主要为：policy controller 需要实现一个 API Listener，监听用户设置的 Network Policy 定义，并将网络访问规则通过各 Node 的 Agent 进行实际设置（Agent 则需要通过 CNI 网络插件实现）。</p><h3 id="简述-Kubernetes-中-flannel-的作用？"><a href="#简述-Kubernetes-中-flannel-的作用？" class="headerlink" title="简述 Kubernetes 中 flannel 的作用？"></a>简述 Kubernetes 中 flannel 的作用？</h3><p>Flannel 可以用于 Kubernetes 底层网络的实现，主要作用有：</p><ul><li><p>它能协助 Kubernetes，给每一个 Node 上的 Docker 容器都分配互相不冲突的 IP 地址。</p></li><li><p>它能在这些 IP 地址之间建立一个覆盖网络（Overlay Network），通过这个覆盖网络，将数据包原封不动地传递到目标容器内。</p></li></ul><h3 id="简述-Kubernetes-Calico-网络组件实现原理？"><a href="#简述-Kubernetes-Calico-网络组件实现原理？" class="headerlink" title="简述 Kubernetes Calico 网络组件实现原理？"></a>简述 Kubernetes Calico 网络组件实现原理？</h3><p>Calico 是一个基于 BGP 的纯三层的网络方案，与 OpenStack、Kubernetes、AWS、GCE 等云平台都能够良好地集成。</p><p>Calico 在每个计算节点都利用 Linux Kernel 实现了一个高效的 vRouter 来负责数据转发。每个 vRouter 都通过 BGP 协议把在本节点上运行的容器的路由信息向整个 Calico 网络广播，并自动设置到达其他节点的路由转发规则。</p><p>Calico 保证所有容器之间的数据流量都是通过 <strong>IP 路由的方式完成互联互通的。</strong></p><p>Calico 节点组网时可以直接利用数据中心的网络结构（L2 或者 L3），不需要额外的 NAT、隧道或者 Overlay Network，没有额外的封包解包，能够节约 CPU 运算，提高网络效率。</p><h3 id="简述-Kubernetes-共享存储的作用？"><a href="#简述-Kubernetes-共享存储的作用？" class="headerlink" title="简述 Kubernetes 共享存储的作用？"></a>简述 Kubernetes 共享存储的作用？</h3><p>Kubernetes 对于有状态的容器应用或者对数据需要持久化的应用，因此需要更加可靠的存储来保存应用产生的重要数据，以便容器应用在重建之后仍然可以使用之前的数据。因此需要使用共享存储。</p><h3 id="简述-Kubernetes-数据持久化的方式有哪些？"><a href="#简述-Kubernetes-数据持久化的方式有哪些？" class="headerlink" title="简述 Kubernetes 数据持久化的方式有哪些？"></a>简述 Kubernetes 数据持久化的方式有哪些？</h3><p>Kubernetes 通过数据持久化来持久化保存重要数据，常见的方式有：</p><ul><li><p>EmptyDir（空目录）：没有指定要挂载宿主机上的某个目录，直接由 Pod 内保部映射到宿主机上。类似于 docker 中的 manager volume。</p></li><li><p>场景：</p></li><li><p>只需要临时将数据保存在磁盘上，比如在合并 / 排序算法中；</p></li><li><p>作为两个容器的共享存储。</p></li><li><p>特性：</p></li><li><p>同个 pod 里面的不同容器，共享同一个持久化目录，当 pod 节点删除时，volume 的数据也会被删除。</p></li><li><p>emptyDir 的数据持久化的生命周期和使用的 pod 一致，一般是作为临时存储使用。</p></li><li><p>Hostpath：将宿主机上已存在的目录或文件挂载到容器内部。类似于 docker 中的 bind mount 挂载方式。</p></li><li><p>特性：增加了 pod 与节点之间的耦合。</p></li><li><p>PersistentVolume（简称 PV）：如基于 NFS 服务的 PV，也可以基于 GFS 的 PV。它的作用是统一数据持久化目录，方便管理。</p></li></ul><h3 id="简述-Kubernetes-PV-和-PVC？"><a href="#简述-Kubernetes-PV-和-PVC？" class="headerlink" title="简述 Kubernetes PV 和 PVC？"></a>简述 Kubernetes PV 和 PVC？</h3><p>PV 是对底层网络共享存储的抽象，将共享存储定义为一种 “资源”。</p><p>PVC 则是用户对存储资源的一个 “申请”。</p><h3 id="简述-Kubernetes-PV-生命周期内的阶段？"><a href="#简述-Kubernetes-PV-生命周期内的阶段？" class="headerlink" title="简述 Kubernetes PV 生命周期内的阶段？"></a>简述 Kubernetes PV 生命周期内的阶段？</h3><p>某个 PV 在生命周期中可能处于以下 4 个阶段（Phaes）之一。</p><ul><li><p>Available：可用状态，还未与某个 PVC 绑定。</p></li><li><p>Bound：已与某个 PVC 绑定。</p></li><li><p>Released：绑定的 PVC 已经删除，资源已释放，但没有被集群回收。</p></li><li><p>Failed：自动资源回收失败。</p></li></ul><h3 id="简述-Kubernetes-所支持的存储供应模式？"><a href="#简述-Kubernetes-所支持的存储供应模式？" class="headerlink" title="简述 Kubernetes 所支持的存储供应模式？"></a>简述 Kubernetes 所支持的存储供应模式？</h3><p>Kubernetes 支持两种资源的存储供应模式：静态模式（Static）和动态模式（Dynamic）。</p><ul><li><p><strong><code>静态模式</code>**</strong>：** 集群管理员手工创建许多 PV，在定义 PV 时需要将后端存储的特性进行设置。</p></li><li><p><strong><code>动态模式</code>**</strong>：** 集群管理员无须手工创建 PV，而是通过 StorageClass 的设置对后端存储进行描述，标记为某种类型。此时要求 PVC 对存储的类型进行声明，系统将自动完成 PV 的创建及与 PVC 的绑定。</p></li></ul><h3 id="简述-Kubernetes-CSI-模型？"><a href="#简述-Kubernetes-CSI-模型？" class="headerlink" title="简述 Kubernetes CSI 模型？"></a>简述 Kubernetes CSI 模型？</h3><p>Kubernetes CSI 是 Kubernetes 推出与容器对接的存储接口标准，存储提供方只需要基于标准接口进行存储插件的实现，就能使用 Kubernetes 的原生存储机制为容器提供存储服务。</p><p>CSI 使得存储提供方的代码能和 Kubernetes 代码彻底解耦，部署也与 Kubernetes 核心组件分离，显然，存储插件的开发由提供方自行维护，就能为 Kubernetes 用户提供更多的存储功能，也更加安全可靠。</p><p>CSI 包括 CSI Controller 和 CSI Node：</p><ul><li><p>CSI Controller 的主要功能是提供存储服务视角对存储资源和存储卷进行管理和操作。</p></li><li><p>CSI Node 的主要功能是对主机（Node）上的 Volume 进行管理和操作。</p></li></ul><h3 id="简述-Kubernetes-Worker-节点加入集群的过程？"><a href="#简述-Kubernetes-Worker-节点加入集群的过程？" class="headerlink" title="简述 Kubernetes Worker 节点加入集群的过程？"></a>简述 Kubernetes Worker 节点加入集群的过程？</h3><p>通常需要对 Worker 节点进行扩容，从而将应用系统进行水平扩展。</p><p>主要过程如下：</p><ul><li><p>在该 Node 上安装 Docker、kubelet 和 kube-proxy 服务；</p></li><li><p>然后配置 kubelet 和 kubeproxy 的启动参数，将 Master URL 指定为当前 Kubernetes 集群 Master 的地址，最后启动这些服务；</p></li><li><p>通过 kubelet 默认的自动注册机制，新的 Worker 将会自动加入现有的 Kubernetes 集群中；</p></li><li><p>Kubernetes Master 在接受了新 Worker 的注册之后，会自动将其纳入当前集群的调度范围。</p></li></ul><h3 id="简述-Kubernetes-Pod-如何实现对节点的资源控制？"><a href="#简述-Kubernetes-Pod-如何实现对节点的资源控制？" class="headerlink" title="简述 Kubernetes Pod 如何实现对节点的资源控制？"></a>简述 Kubernetes Pod 如何实现对节点的资源控制？</h3><p>Kubernetes 集群里的节点提供的资源主要是计算资源，计算资源是可计量的能被申请、分配和使用的基础资源。</p><p>当前 Kubernetes 集群中的计算资源主要包括 CPU、GPU 及 Memory。CPU 与 Memory 是被 Pod 使用的，因此在配置 Pod 时可以通过参数 CPU Request 及 Memory Request 为其中的每个容器指定所需使用的 CPU 与 Memory 量，Kubernetes 会根据 Request 的值去查找有足够资源的 Node 来调度此 Pod。</p><p>通常，一个程序所使用的 CPU 与 Memory 是一个动态的量，确切地说，是一个范围，跟它的负载密切相关：负载增加时，CPU 和 Memory 的使用量也会增加。</p><h3 id="简述-Kubernetes-Requests-和-Limits-如何影响-Pod-的调度？"><a href="#简述-Kubernetes-Requests-和-Limits-如何影响-Pod-的调度？" class="headerlink" title="简述 Kubernetes Requests 和 Limits 如何影响 Pod 的调度？"></a>简述 Kubernetes Requests 和 Limits 如何影响 Pod 的调度？</h3><p>当一个 Pod 创建成功时，Kubernetes 调度器（Scheduler）会为该 Pod 选择一个节点来执行。</p><p>对于每种计算资源（CPU 和 Memory）而言，每个节点都有一个能用于运行 Pod 的最大容量值。调度器在调度时，首先要确保调度后该节点上所有 Pod 的 CPU 和内存的 Requests 总和，不超过该节点能提供给 Pod 使用的 CPU 和 Memory 的最大容量值。</p><h3 id="简述-Kubernetes-Metric-Service？"><a href="#简述-Kubernetes-Metric-Service？" class="headerlink" title="简述 Kubernetes Metric Service？"></a>简述 Kubernetes Metric Service？</h3><p>在 Kubernetes 从 1.10 版本后采用 Metrics Server 作为默认的性能数据采集和监控，主要用于提供核心指标（Core Metrics），包括 Node、Pod 的 CPU 和内存使用指标。</p><p>对其他自定义指标（Custom Metrics）的监控则由 Prometheus 等组件来完成。</p><h3 id="简述-Kubernetes-中，如何使用-EFK-实现日志的统一管理？"><a href="#简述-Kubernetes-中，如何使用-EFK-实现日志的统一管理？" class="headerlink" title="简述 Kubernetes 中，如何使用 EFK 实现日志的统一管理？"></a>简述 Kubernetes 中，如何使用 EFK 实现日志的统一管理？</h3><p>在 Kubernetes 集群环境中，通常一个完整的应用或服务涉及组件过多，建议对日志系统进行集中化管理，通常采用 EFK 实现。</p><p>EFK 是 Elasticsearch、Fluentd 和 Kibana 的组合，其各组件功能如下：</p><ul><li><p>Elasticsearch：是一个搜索引擎，负责存储日志并提供查询接口；</p></li><li><p>Fluentd：负责从 Kubernetes 搜集日志，每个 node 节点上面的 fluentd 监控并收集该节点上面的系统日志，并将处理过后的日志信息发送给 Elasticsearch；</p></li><li><p>Kibana：提供了一个 Web GUI，用户可以浏览和搜索存储在 Elasticsearch 中的日志。</p></li></ul><p>通过在每台 node 上部署一个以 DaemonSet 方式运行的 fluentd 来收集每台 node 上的日志。</p><p>Fluentd 将 docker 日志目录 / var/lib/docker/containers 和 / var/log 目录挂载到 Pod 中，然后 Pod 会在 node 节点的 / var/log/pods 目录中创建新的目录，可以区别不同的容器日志输出，该目录下有一个日志文件链接到 / var/lib/docker/contianers 目录下的容器日志输出。</p><h3 id="简述-Kubernetes-如何进行优雅的节点关机维护？"><a href="#简述-Kubernetes-如何进行优雅的节点关机维护？" class="headerlink" title="简述 Kubernetes 如何进行优雅的节点关机维护？"></a>简述 Kubernetes 如何进行优雅的节点关机维护？</h3><p>由于 Kubernetes 节点运行大量 Pod，因此在进行关机维护之前，建议先使用 kubectl drain 将该节点的 Pod 进行驱逐，然后进行关机维护。</p><h3 id="简述-Kubernetes-集群联邦？"><a href="#简述-Kubernetes-集群联邦？" class="headerlink" title="简述 Kubernetes 集群联邦？"></a>简述 Kubernetes 集群联邦？</h3><p>Kubernetes 集群联邦可以将多个 Kubernetes 集群作为一个集群进行管理。</p><p>因此，可以在一个数据中心 / 云中创建多个 Kubernetes 集群，并使用集群联邦在一个地方控制 / 管理所有集群。</p><h3 id="简述-Helm-及其优势？"><a href="#简述-Helm-及其优势？" class="headerlink" title="简述 Helm 及其优势？"></a>简述 Helm 及其优势？</h3><p><code>Helm</code>是 Kubernetes 的软件包管理工具。类似 Ubuntu 中使用的 apt、Centos 中使用的 yum 或者 Python 中的 pip 一样。</p><p>Helm 能够将一组 K8S 资源打包统一管理, 是查找、共享和使用为 Kubernetes 构建的软件的最佳方式。</p><p>Helm 中通常每个包称为一个 Chart，一个 Chart 是一个目录（一般情况下会将目录进行打包压缩，形成 name-version.tgz 格式的单一文件，方便传输和存储）。</p><ul><li>Helm 优势</li></ul><p>在 Kubernetes 中部署一个可以使用的应用，需要涉及到很多的 Kubernetes 资源的共同协作。</p><p>使用 helm 则具有如下优势：</p><ul><li><p>统一管理、配置和更新这些分散的 k8s 的应用资源文件；</p></li><li><p>分发和复用一套应用模板；</p></li><li><p>将应用的一系列资源当做一个软件包管理。</p></li><li><p>对于应用发布者而言，可以通过 Helm 打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。</p></li><li><p>对于使用者而言，使用 Helm 后不用需要编写复杂的应用部署文件，可以以简单的方式在 Kubernetes 上查找、安装、升级、回滚、卸载应用程序。</p></li></ul><h3 id="简述-OpenShift-及其特性？"><a href="#简述-OpenShift-及其特性？" class="headerlink" title="简述 OpenShift 及其特性？"></a>简述 OpenShift 及其特性？</h3><p>OpenShift 是一个容器应用程序平台，用于在安全的、可伸缩的资源上部署新应用程序，而配置和管理开销最小。</p><p>OpenShift 构建于 Red Hat Enterprise Linux、Docker 和 Kubernetes 之上，为企业级应用程序提供了一个安全且可伸缩的多租户操作系统，同时还提供了集成的应用程序运行时和库。</p><p>其主要特性：</p><ul><li><p>自助服务平台：OpenShift 允许开发人员使用 Source-to-Image(S2I) 从模板或自己的源代码管理存储库创建应用程序。系统管理员可以为用户和项目定义资源配额和限制，以控制系统资源的使用。</p></li><li><p>多语言支持：OpenShift 支持 Java、Node.js、PHP、Perl 以及直接来自 Red Hat 的 Ruby。OpenShift 还支持中间件产品，如 Apache httpd、Apache Tomcat、JBoss EAP、ActiveMQ 和 Fuse。</p></li><li><p>自动化：OpenShift 提供应用程序生命周期管理功能，当上游源或容器映像发生更改时，可以自动重新构建和重新部署容器。根据调度和策略扩展或故障转移应用程序。</p></li><li><p>用户界面：OpenShift 提供用于部署和监视应用程序的 web UI，以及用于远程管理应用程序和资源的 CLi。</p></li><li><p>协作：OpenShift 允许在组织内或与更大的社区共享项目。</p></li><li><p>可伸缩性和高可用性：OpenShift 提供了容器多租户和一个分布式应用程序平台，其中包括弹性，高可用性，以便应用程序能够在物理机器宕机等事件中存活下来。OpenShift 提供了对容器健康状况的自动发现和自动重新部署。</p></li><li><p>容器可移植性：在 OpenShift 中，应用程序和服务使用标准容器映像进行打包，组合应用程序使用 Kubernetes 进行管理。这些映像可以部署到基于这些基础技术的其他平台上。</p></li><li><p>开源：没有厂商锁定。</p></li><li><p>安全性：OpenShift 使用 SELinux 提供多层安全性、基于角色的访问控制以及与外部身份验证系统 (如 LDAP 和 OAuth) 集成的能力。</p></li><li><p>动态存储管理：OpenShift 使用 Kubernetes 持久卷和持久卷声明的方式为容器数据提供静态和动态存储管理</p></li><li><p>基于云 (或不基于云)：可以在裸机服务器、活来自多个供应商的 hypervisor 和大多数 IaaS 云提供商上部署 OpenShift 容器平台。</p></li><li><p>企业级：Red Hat 支持 OpenShift、选定的容器映像和应用程序运行时。可信的第三方容器映像、运行时和应用程序由 Red Hat 认证。可以在 OpenShift 提供的高可用性的强化安全环境中运行内部或第三方应用程序。</p></li><li><p>日志聚合和 metrics：可以在中心节点收集、聚合和分析部署在 OpenShift 上的应用程序的日志信息。OpenShift 能够实时收集关于应用程序的度量和运行时信息，并帮助不断优化性能。</p></li><li><p>其他特性：OpenShift 支持微服务体系结构，OpenShift 的本地特性足以支持 DevOps 流程，很容易与标准和定制的持续集成 / 持续部署工具集成。</p></li></ul><h3 id="简述-OpenShift-projects-及其作用？"><a href="#简述-OpenShift-projects-及其作用？" class="headerlink" title="简述 OpenShift projects 及其作用？"></a>简述 OpenShift projects 及其作用？</h3><p>OpenShift 管理 projects 和 users。</p><p>一个 projects 对 Kubernetes 资源进行分组，以便用户可以使用访问权限。还可以为 projects 分配配额，从而限制了已定义的 pod、volumes、services 和其他资源。</p><p>project 允许一组用户独立于其他组组织和管理其内容，必须允许用户访问项目。如果允许创建项目，用户将自动访问自己的项目。</p><h3 id="简述-OpenShift-高可用的实现？"><a href="#简述-OpenShift-高可用的实现？" class="headerlink" title="简述 OpenShift 高可用的实现？"></a>简述 OpenShift 高可用的实现？</h3><p>OpenShift 平台集群的高可用性 (HA) 有两个不同的方面：</p><p>OpenShift 基础设施本身的 HA(即主机)；以及在 OpenShift 集群中运行的应用程序的 HA。</p><p>默认情况下，OpenShift 为 master 节点提供了完全支持的本机 HA 机制。</p><p>对于应用程序或 “pods”，如果 pod 因任何原因丢失，Kubernetes 将调度另一个副本，将其连接到服务层和持久存储。</p><p>如果整个节点丢失，Kubernetes 会为它所有的 pod 安排替换节点，最终所有的应用程序都会重新可用。pod 中的应用程序负责它们自己的状态，因此它们需要自己维护应用程序状态 (如 HTTP 会话复制或数据库复制)。</p><h3 id="简述-OpenShift-的-SDN-网络实现？"><a href="#简述-OpenShift-的-SDN-网络实现？" class="headerlink" title="简述 OpenShift 的 SDN 网络实现？"></a>简述 OpenShift 的 SDN 网络实现？</h3><p>默认情况下，Docker 网络使用仅使用主机虚机网桥 bridge，主机内的所有容器都连接至该网桥。</p><p>连接到此桥的所有容器都可以彼此通信，但不能与不同主机上的容器通信。</p><p>为了支持跨集群的容器之间的通信，OpenShift 容器平台使用了软件定义的网络 (SDN) 方法。</p><p>软件定义的网络是一种网络模型，它通过<strong>几个网络层的抽象来管理网络服务。</strong></p><p>SDN 将处理流量的软件 (称为控制平面) 和路由流量的底层机制 (称为数据平面) 解耦。SDN 支持控制平面和数据平面之间的通信。</p><p>在 OpenShift 中，可以为 pod 网络配置三个 SDN 插件:</p><ul><li><p>ovs-subnet：默认插件，子网提供了一个 flat pod 网络，其中每个 pod 可以与其他 pod 和 service 通信。</p></li><li><p>ovs-multitenant：该为 pod 和服务提供了额外的隔离层。当使用此插件时，每个 project 接收一个惟一的虚拟网络 ID (VNID)，该 ID 标识来自属于该 project 的 pod 的流量。通过使用 VNID，来自不同 project 的 pod 不能与其他 project 的 pod 和 service 通信。</p></li><li><p>ovs-network policy：此插件允许管理员使用 NetworkPolicy 对象定义自己的隔离策略。</p></li></ul><p>cluster network 由 OpenShift SDN 建立和维护，它使用 Open vSwitch 创建 overlay 网络，master 节点不能通过集群网络访问容器，除非 master 同时也为 node 节点。</p><h3 id="简述-OpenShift-角色及其作用？"><a href="#简述-OpenShift-角色及其作用？" class="headerlink" title="简述 OpenShift 角色及其作用？"></a>简述 OpenShift 角色及其作用？</h3><p>OpenShift 的角色具有不同级别的访问和策略，包括集群和本地策略。</p><p><strong>user 和 group 可以同时与多个 role 关联。</strong></p><h3 id="简述-OpenShift-支持哪些身份验证？"><a href="#简述-OpenShift-支持哪些身份验证？" class="headerlink" title="简述 OpenShift 支持哪些身份验证？"></a>简述 OpenShift 支持哪些身份验证？</h3><p>OpenShift 容器平台支持的其他认证类型包括:</p><ul><li><p>Basic Authentication (Remote)：一种通用的后端集成机制，允许用户使用针对远程标识提供者验证的凭据登录到 OpenShift 容器平台。用户将他们的用户名和密码发送到 OpenShift 容器平台，OpenShift 平台通过到服务器的请求验证这些凭据，并将凭据作为基本的 Auth 头传递。这要求用户在登录过程中向 OpenShift 容器平台输入他们的凭据。</p></li><li><p>Request Header Authentication：用户使用请求头值 (如 X-RemoteUser) 登录到 OpenShift 容器平台。它通常与身份验证代理结合使用，身份验证代理对用户进行身份验证，然后通过请求头值为 OpenShift 容器平台提供用户标识。</p></li><li><p>Keystone Authentication：Keystone 是一个 OpenStack 项目，提供标识、令牌、目录和策略服务。OpenShift 容器平台与 Keystone 集成，通过配置 OpenStack Keystone v3 服务器将用户存储在内部数据库中，从而支持共享身份验证。这种配置允许用户使用 Keystone 凭证登录 OpenShift 容器平台。</p></li><li><p>LDAP Authentication：用户使用他们的 LDAP 凭证登录到 OpenShift 容器平台。在身份验证期间，LDAP 目录将搜索与提供的用户名匹配的条目。如果找到匹配项，则尝试使用条目的专有名称 (DN) 和提供的密码进行简单绑定。</p></li><li><p>GitHub Authentication：GitHub 使用 OAuth，它允许与 OpenShift 容器平台集成使用 OAuth 身份验证来促进令牌交换流。这允许用户使用他们的 GitHub 凭证登录到 OpenShift 容器平台。为了防止使用 GitHub 用户 id 的未授权用户登录到 OpenShift 容器平台集群，可以将访问权限限制在特定的 GitHub 组织中。</p></li></ul><h3 id="简述什么是中间件？"><a href="#简述什么是中间件？" class="headerlink" title="简述什么是中间件？"></a>简述什么是中间件？</h3><p><code>中间件</code>是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。</p><p>通常位于客户机 / 服务器的操作系统中间，是<strong>连接两个独立应用程序或独立系统的软件</strong>。</p><p>通过中间件实现两个不同系统之间的信息交换。</p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes,Interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>k8s面试资料</title>
    <link href="/2022/01/20/cloud/interview/k8s%20%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2022/01/20/cloud/interview/k8s%20%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="K8S面试资料"><a href="#K8S面试资料" class="headerlink" title="K8S面试资料"></a>K8S面试资料</h1><h2 id="简述-ETCD-及其特点？"><a href="#简述-ETCD-及其特点？" class="headerlink" title="简述 ETCD 及其特点？"></a><strong>简述 ETCD 及其特点？</strong></h2><p>etcd 是 CoreOS 团队发起的开源项目，是一个管理配置信息和服务发现（service discovery）的项目，它的目标是构建一个高可用的分布式键值（key-value）数据库，基于 Go 语言实现。</p><ul><li><p>特点：</p></li><li><p>简单：支持 REST 风格的 HTTP+JSON API</p></li><li><p>安全：支持 HTTPS 方式的访问</p></li><li><p>快速：支持并发 1k/s 的写操作</p></li><li><p>可靠：支持分布式结构，基于 Raft 的一致性算法，Raft 是一套通过选举主节点来实现分布式系统一致性的算法。</p></li></ul><h2 id="简述-ETCD-适应的场景？"><a href="#简述-ETCD-适应的场景？" class="headerlink" title="简述 ETCD 适应的场景？"></a><strong>简述 ETCD 适应的场景？</strong></h2><p>etcd 基于其优秀的特点，可广泛的应用于以下场景：</p><p>服务发现 (Service Discovery)：服务发现主要解决在同一个分布式集群中的进程或服务，要如何才能找到对方并建立连接。本质上来说，服务发现就是想要了解集群中是否有进程在监听 udp 或 tcp 端口，并且通过名字就可以查找和连接。</p><p>消息发布与订阅：在分布式系统中，最适用的一种组件间通信方式就是消息发布与订阅。即构建一个配置共享中心，数据提供者在这个配置中心发布消息，而消息使用者则订阅他们关心的主题，一旦主题有消息发布，就会实时通知订阅者。通过这种方式可以做到分布式系统配置的集中式管理与动态更新。应用中用到的一些配置信息放到 etcd 上进行集中管理。</p><p>负载均衡：在分布式系统中，为了保证服务的高可用以及数据的一致性，通常都会把数据和服务部署多份，以此达到对等服务，即使其中的某一个服务失效了，也不影响使用。etcd 本身分布式架构存储的信息访问支持负载均衡。etcd 集群化以后，每个 etcd 的核心节点都可以处理用户的请求。所以，把数据量小但是访问频繁的消息数据直接存储到 etcd 中也可以实现负载均衡的效果。</p><p>分布式通知与协调：与消息发布和订阅类似，都用到了 etcd 中的 Watcher 机制，通过注册与异步通知机制，实现分布式环境下不同系统之间的通知与协调，从而对数据变更做到实时处理。</p><p>分布式锁：因为 etcd 使用 Raft 算法保持了数据的强一致性，某次操作存储到集群中的值必然是全局一致的，所以很容易实现分布式锁。锁服务有两种使用方式，一是保持独占，二是控制时序。</p><p>集群监控与 Leader 竞选：通过 etcd 来进行监控实现起来非常简单并且实时性强。</p><h2 id="简述什么是-Kubernetes？"><a href="#简述什么是-Kubernetes？" class="headerlink" title="简述什么是 Kubernetes？"></a><strong>简述什么是 Kubernetes？</strong></h2><p>Kubernetes 是一个全新的基于容器技术的分布式系统支撑平台。是 Google 开源的容器集群管理系统（谷歌内部: Borg）。在 Docker 技术的基础上，为容器化的应用提供部署运行、资源调度、服务发现和动态伸缩等一系列完整功能，提高了大规模容器集群管理的便捷性。并且具有完备的集群管理能力，多层次的安全防护和准入机制、多租户应用支撑能力、透明的服务注册和发现机制、內建智能负载均衡器、强大的故障发现和自我修复能力、服务滚动升级和在线扩容能力、可扩展的资源自动调度机制以及多粒度的资源配额管理能力。</p><h2 id="简述-Kubernetes-和-Docker-的关系？"><a href="#简述-Kubernetes-和-Docker-的关系？" class="headerlink" title="简述 Kubernetes 和 Docker 的关系？"></a><strong>简述 Kubernetes 和 Docker 的关系？</strong></h2><p>Docker 提供容器的生命周期管理和，Docker 镜像构建运行时容器。它的主要优点是将将软件 / 应用程序运行所需的设置和依赖项打包到一个容器中，从而实现了可移植性等优点。</p><p>Kubernetes 用于关联和编排在多个主机上运行的容器。</p><h2 id="简述-Kubernetes-中什么是-Minikube、Kubectl、Kubelet？"><a href="#简述-Kubernetes-中什么是-Minikube、Kubectl、Kubelet？" class="headerlink" title="简述 Kubernetes 中什么是 Minikube、Kubectl、Kubelet？"></a><strong>简述 Kubernetes 中什么是 Minikube、Kubectl、Kubelet？</strong></h2><p>Minikube 是一种可以在本地轻松运行一个单节点 Kubernetes 群集的工具。</p><p>Kubectl 是一个命令行工具，可以使用该工具控制 Kubernetes 集群管理器，如检查群集资源，创建、删除和更新组件，查看应用程序。</p><p>Kubelet 是一个代理服务，它在每个节点上运行，并使从服务器与主服务器通信。</p><h2 id="简-述-K-ubernetes-常见的部署方式？"><a href="#简-述-K-ubernetes-常见的部署方式？" class="headerlink" title="简**述 K**ubernetes 常见的部署方式？"></a><strong>简**</strong>述 K**<strong>ubernetes 常见的部署方式？</strong></h2><p>常见的 Kubernetes 部署方式有：</p><ul><li><p>kubeadm：也是推荐的一种部署方式；</p></li><li><p>二进制：CentOS 搭建 K8S，一次性成功，收藏了！</p></li><li><p>minikube：在本地轻松运行一个单节点 Kubernetes 群集的工具。</p></li><li><p>简单几步，无坑部署最小化 K8S 集群</p></li><li><p>Kubernetes 部署如此简单，看完全明白了</p></li></ul><h2 id="简述-Kubernetes-如何实现集群管理？"><a href="#简述-Kubernetes-如何实现集群管理？" class="headerlink" title="简述 Kubernetes 如何实现集群管理？"></a><strong>简述 Kubernetes 如何实现集群管理？</strong></h2><p>在集群管理方面，Kubernetes 将集群中的机器划分为一个 Master 节点和一群工作节点 Node。其中，在 Master 节点运行着集群管理相关的一组进程 kube-apiserver、kube-controller-manager 和 kube-scheduler，这些进程实现了整个集群的资源管理、Pod 调度、弹性伸缩、安全控制、系统监控和纠错等管理能力，并且都是全自动完成的。推荐大家看看：轻松管理 Kubernetes 集群的 7 个工具。</p><h2 id="简述-Kubernetes-的优势、适应场景及其特点？"><a href="#简述-Kubernetes-的优势、适应场景及其特点？" class="headerlink" title="简述 Kubernetes 的优势、适应场景及其特点？"></a><strong>简述 Kubernetes 的优势、适应场景及其特点？</strong></h2><p>Kubernetes 作为一个完备的分布式系统支撑平台，其主要优势：</p><ul><li><p>容器编排</p></li><li><p>轻量级</p></li><li><p>开源</p></li><li><p>弹性伸缩</p></li><li><p>负载均衡</p></li></ul><p>Kubernetes 常见场景：</p><ul><li><p>快速部署应用</p></li><li><p>快速扩展应用</p></li><li><p>无缝对接新的应用功能</p></li><li><p>节省资源，优化硬件资源的使用</p></li></ul><p>Kubernetes 相关特点：</p><ul><li><p>可移植: 支持公有云、私有云、混合云、多重云（multi-cloud）。</p></li><li><p>可扩展: 模块化,、插件化、可挂载、可组合。</p></li><li><p>自动化: 自动部署、自动重启、自动复制、自动伸缩 / 扩展。</p></li></ul><h2 id="简述-Kubernetes-的缺点或当前的不足之处？"><a href="#简述-Kubernetes-的缺点或当前的不足之处？" class="headerlink" title="简述 Kubernetes 的缺点或当前的不足之处？"></a><strong>简述 Kubernetes 的缺点或当前的不足之处？</strong></h2><p>Kubernetes 当前存在的缺点（不足）如下：</p><ul><li><p>安装过程和配置相对困难复杂。</p></li><li><p>管理服务相对繁琐。</p></li><li><p>运行和编译需要很多时间。</p></li><li><p>它比其他替代品更昂贵。</p></li><li><p>对于简单的应用程序来说，可能不需要涉及 Kubernetes 即可满足。</p></li></ul><h2 id="简述-Kubernetes-相关基础概念？"><a href="#简述-Kubernetes-相关基础概念？" class="headerlink" title="简述 Kubernetes 相关基础概念？"></a><strong>简述 Kubernetes 相关基础概念？</strong></h2><p>master：k8s 集群的管理节点，负责管理集群，提供集群的资源数据访问入口。拥有 Etcd 存储服务（可选），运行 Api Server 进程，Controller Manager 服务进程及 Scheduler 服务进程。</p><p>node（worker）：Node（worker）是 Kubernetes 集群架构中运行 Pod 的服务节点，是 Kubernetes 集群操作的单元，用来承载被分配 Pod 的运行，是 Pod 运行的宿主机。运行 docker eninge 服务，守护进程 kunelet 及负载均衡器 kube-proxy。</p><p>pod：运行于 Node 节点上，若干相关容器的组合 (Kubernetes 之 Pod 实现原理)。Pod 内包含的容器运行在同一宿主机上，使用相同的网络命名空间、IP 地址和端口，能够通过 localhost 进行通信。Pod 是 Kurbernetes 进行创建、调度和管理的最小单位，它提供了比容器更高层次的抽象，使得部署和管理更加灵活。一个 Pod 可以包含一个容器或者多个相关容器。</p><p>label：Kubernetes 中的 Label 实质是一系列的 Key/Value 键值对，其中 key 与 value 可自定义。Label 可以附加到各种资源对象上，如 Node、Pod、Service、RC 等。一个资源对象可以定义任意数量的 Label，同一个 Label 也可以被添加到任意数量的资源对象上去。Kubernetes 通过 Label Selector（标签选择器）查询和筛选资源对象。</p><p>Replication Controller：Replication Controller 用来管理 Pod 的副本，保证集群中存在指定数量的 Pod 副本。集群中副本的数量大于指定数量，则会停止指定数量之外的多余容器数量。反之，则会启动少于指定数量个数的容器，保证数量不变。Replication Controller 是实现弹性伸缩、动态扩容和滚动升级的核心。</p><p>Deployment：Deployment 在内部使用了 RS 来实现目的，Deployment 相当于 RC 的一次升级，其最大的特色为可以随时获知当前 Pod 的部署进度。</p><p>HPA（Horizontal Pod Autoscaler）：Pod 的横向自动扩容，也是 Kubernetes 的一种资源，通过追踪分析 RC 控制的所有 Pod 目标的负载变化情况，来确定是否需要针对性的调整 Pod 副本数量。</p><p>Service：Service(Kubernetes 之服务发现) 定义了 Pod 的逻辑集合和访问该集合的策略，是真实服务的抽象。Service 提供了一个统一的服务访问入口以及服务代理和发现机制，关联多个相同 Label 的 Pod，用户不需要了解后台 Pod 是如何运行。</p><p>Volume：Volume 是 Pod 中能够被多个容器访问的共享目录，Kubernetes 中的 Volume 是定义在 Pod 上，可以被一个或多个 Pod 中的容器挂载到某个目录下。</p><p>Namespace：Namespace 用于实现多租户的资源隔离，可将集群内部的资源对象分配到不同的 Namespace 中，形成逻辑上的不同项目、小组或用户组，便于不同的 Namespace 在共享使用整个集群的资源的同时还能被分别管理。</p><h2 id="简述-Kubernetes-集群相关组件？"><a href="#简述-Kubernetes-集群相关组件？" class="headerlink" title="简述 Kubernetes 集群相关组件？"></a><strong>简述 Kubernetes 集群相关组件？</strong></h2><p>Kubernetes Master 控制组件，调度管理整个系统（集群），包含如下组件:</p><p>Kubernetes API Server：作为 Kubernetes 系统的入口，其封装了核心对象的增删改查操作，以 RESTful API 接口方式提供给外部客户和内部组件调用，集群内各个功能模块之间数据交互和通信的中心枢纽。</p><p>Kubernetes Scheduler：为新建立的 Pod 进行节点 (node) 选择(即分配机器)，负责集群的资源调度。</p><p>Kubernetes Controller：负责执行各种控制器，目前已经提供了很多控制器来保证 Kubernetes 的正常运行。</p><p>Replication Controller：管理维护 Replication Controller，关联 Replication Controller 和 Pod，保证 Replication Controller 定义的副本数量与实际运行 Pod 数量一致。</p><p>Node Controller：管理维护 Node，定期检查 Node 的健康状态，标识出 (失效 | 未失效) 的 Node 节点。</p><p>Namespace Controller：管理维护 Namespace，定期清理无效的 Namespace，包括 Namesapce 下的 API 对象，比如 Pod、Service 等。</p><p>Service Controller：管理维护 Service，提供负载以及服务代理。</p><p>EndPoints Controller：管理维护 Endpoints，关联 Service 和 Pod，创建 Endpoints 为 Service 的后端，当 Pod 发生变化时，实时更新 Endpoints。</p><p>Service Account Controller：管理维护 Service Account，为每个 Namespace 创建默认的 Service Account，同时为 Service Account 创建 Service Account Secret。</p><p>Persistent Volume Controller：管理维护 Persistent Volume 和 Persistent Volume Claim，为新的 Persistent Volume Claim 分配 Persistent Volume 进行绑定，为释放的 Persistent Volume 执行清理回收。</p><p>Daemon Set Controller：管理维护 Daemon Set，负责创建 Daemon Pod，保证指定的 Node 上正常的运行 Daemon Pod。</p><p>Deployment Controller：管理维护 Deployment，关联 Deployment 和 Replication Controller，保证运行指定数量的 Pod。当 Deployment 更新时，控制实现 Replication Controller 和 Pod 的更新。</p><p>Job Controller：管理维护 Job，为 Jod 创建一次性任务 Pod，保证完成 Job 指定完成的任务数目</p><p>Pod Autoscaler Controller：实现 Pod 的自动伸缩，定时获取监控数据，进行策略匹配，当满足条件时执行 Pod 的伸缩动作。</p><h2 id="简述-Kubernetes-RC-的机制？"><a href="#简述-Kubernetes-RC-的机制？" class="headerlink" title="简述 Kubernetes RC 的机制？"></a><strong>简述 Kubernetes RC 的机制？</strong></h2><p>Replication Controller 用来管理 Pod 的副本，保证集群中存在指定数量的 Pod 副本。当定义了 RC 并提交至 Kubernetes 集群中之后，Master 节点上的 Controller Manager 组件获悉，并同时巡检系统中当前存活的目标 Pod，并确保目标 Pod 实例的数量刚好等于此 RC 的期望值，若存在过多的 Pod 副本在运行，系统会停止一些 Pod，反之则自动创建一些 Pod。</p><p>简述 Kubernetes Replica Set 和 Replication Controller 之间有什么区别？Replica Set 和 Replication Controller 类似，都是确保在任何给定时间运行指定数量的 Pod 副本。不同之处在于 RS 使用基于集合的选择器，而 Replication Controller 使用基于权限的选择器。</p><h2 id="简述-kube-proxy-作用？"><a href="#简述-kube-proxy-作用？" class="headerlink" title="简述 kube-proxy 作用？"></a><strong>简述 kube-proxy 作用？</strong></h2><p>kube-proxy 运行在所有节点上，它监听 apiserver 中 service 和 endpoint 的变化情况，创建路由规则以提供服务 IP 和负载均衡功能。简单理解此进程是 Service 的透明代理兼负载均衡器，其核心功能是将到某个 Service 的访问请求转发到后端的多个 Pod 实例上。</p><h2 id="简述-kube-proxy-iptables-原理？"><a href="#简述-kube-proxy-iptables-原理？" class="headerlink" title="简述 kube-proxy iptables 原理？"></a><strong>简述 kube-proxy iptables 原理？</strong></h2><p>Kubernetes 从 1.2 版本开始，将 iptables 作为 kube-proxy 的默认模式。iptables 模式下的 kube-proxy 不再起到 Proxy 的作用，其核心功能：通过 API Server 的 Watch 接口实时跟踪 Service 与 Endpoint 的变更信息，并更新对应的 iptables 规则，Client 的请求流量则通过 iptables 的 NAT 机制 “直接路由” 到目标 Pod。</p><h2 id="简述-kube-proxy-ipvs-原理？"><a href="#简述-kube-proxy-ipvs-原理？" class="headerlink" title="简述 kube-proxy ipvs 原理？"></a><strong>简述 kube-proxy ipvs 原理？</strong></h2><p>IPVS 在 Kubernetes1.11 中升级为 GA 稳定版。IPVS 则专门用于高性能负载均衡，并使用更高效的数据结构（Hash 表），允许几乎无限的规模扩张，因此被 kube-proxy 采纳为最新模式。</p><p>在 IPVS 模式下，使用 iptables 的扩展 ipset，而不是直接调用 iptables 来生成规则链。iptables 规则链是一个线性的数据结构，ipset 则引入了带索引的数据结构，因此当规则很多时，也可以很高效地查找和匹配。</p><p>可以将 ipset 简单理解为一个 IP（段）的集合，这个集合的内容可以是 IP 地址、IP 网段、端口等，iptables 可以直接添加规则对这个 “可变的集合” 进行操作，这样做的好处在于可以大大减少 iptables 规则的数量，从而减少性能损耗。</p><h2 id="简述-kube-proxy-ipvs-和-iptables-的异同？"><a href="#简述-kube-proxy-ipvs-和-iptables-的异同？" class="headerlink" title="简述 kube-proxy ipvs 和 iptables 的异同？"></a><strong>简述 kube-proxy ipvs 和 iptables 的异同？</strong></h2><p>iptables 与 IPVS 都是基于 Netfilter 实现的，但因为定位不同，二者有着本质的差别：iptables 是为防火墙而设计的；IPVS 则专门用于高性能负载均衡，并使用更高效的数据结构（Hash 表），允许几乎无限的规模扩张。</p><p>与 iptables 相比，IPVS 拥有以下明显优势：</p><ul><li><p>1、为大型集群提供了更好的可扩展性和性能；</p></li><li><p>2、支持比 iptables 更复杂的复制均衡算法（最小负载、最少连接、加权等）；</p></li><li><p>3、支持服务器健康检查和连接重试等功能；</p></li><li><p>4、可以动态修改 ipset 的集合，即使 iptables 的规则正在使用这个集合。</p></li></ul><h2 id="简述-Kubernetes-中什么是静态-Pod？"><a href="#简述-Kubernetes-中什么是静态-Pod？" class="headerlink" title="简述 Kubernetes 中什么是静态 Pod？"></a><strong>简述 Kubernetes 中什么是静态 Pod？</strong></h2><p>静态 pod 是由 kubelet 进行管理的仅存在于特定 Node 的 Pod 上，他们不能通过 API Server 进行管理，无法与 ReplicationController、Deployment 或者 DaemonSet 进行关联，并且 kubelet 无法对他们进行健康检查。静态 Pod 总是由 kubelet 进行创建，并且总是在 kubelet 所在的 Node 上运行。</p><h2 id="简述-Kubernetes-中-Pod-可能位于的状态？"><a href="#简述-Kubernetes-中-Pod-可能位于的状态？" class="headerlink" title="简述 Kubernetes 中 Pod 可能位于的状态？"></a><strong>简述 Kubernetes 中 Pod 可能位于的状态？</strong></h2><p>Pending：API Server 已经创建该 Pod，且 Pod 内还有一个或多个容器的镜像没有创建，包括正在下载镜像的过程。</p><p>Running：Pod 内所有容器均已创建，且至少有一个容器处于运行状态、正在启动状态或正在重启状态。</p><p>Succeeded：Pod 内所有容器均成功执行退出，且不会重启。</p><p>Failed：Pod 内所有容器均已退出，但至少有一个容器退出为失败状态。</p><p>Unknown：由于某种原因无法获取该 Pod 状态，可能由于网络通信不畅导致。</p><h2 id="简述-Kubernetes-创建一个-Pod-的主要流程？"><a href="#简述-Kubernetes-创建一个-Pod-的主要流程？" class="headerlink" title="简述 Kubernetes 创建一个 Pod 的主要流程？"></a><strong>简述 Kubernetes 创建一个 Pod 的主要流程？</strong></h2><p>Kubernetes 中创建一个 Pod 涉及多个组件之间联动，主要流程如下：</p><ul><li><p>1、客户端提交 Pod 的配置信息（可以是 yaml 文件定义的信息）到 kube-apiserver。</p></li><li><p>2、Apiserver 收到指令后，通知给 controller-manager 创建一个资源对象。</p></li><li><p>3、Controller-manager 通过 api-server 将 pod 的配置信息存储到 ETCD 数据中心中。</p></li><li><p>4、Kube-scheduler 检测到 pod 信息会开始调度预选，会先过滤掉不符合 Pod 资源配置要求的节点，然后开始调度调优，主要是挑选出更适合运行 pod 的节点，然后将 pod 的资源配置单发送到 node 节点上的 kubelet 组件上。</p></li><li><p>5、Kubelet 根据 scheduler 发来的资源配置单运行 pod，运行成功后，将 pod 的运行信息返回给 scheduler，scheduler 将返回的 pod 运行状况的信息存储到 etcd 数据中心。</p></li></ul><h2 id="简述-Kubernetes-中-Pod-的重启策略？"><a href="#简述-Kubernetes-中-Pod-的重启策略？" class="headerlink" title="简述 Kubernetes 中 Pod 的重启策略？"></a><strong>简述 Kubernetes 中 Pod 的重启策略？</strong></h2><p>Pod 重启策略（RestartPolicy）应用于 Pod 内的所有容器，并且仅在 Pod 所处的 Node 上由 kubelet 进行判断和重启操作。当某个容器异常退出或者健康检查失败时，kubelet 将根据 RestartPolicy 的设置来进行相应操作。</p><p>Pod 的重启策略包括 Always、OnFailure 和 Never，默认值为 Always。</p><ul><li><p>Always：当容器失效时，由 kubelet 自动重启该容器；</p></li><li><p>OnFailure：当容器终止运行且退出码不为 0 时，由 kubelet 自动重启该容器；</p></li><li><p>Never：不论容器运行状态如何，kubelet 都不会重启该容器。</p></li></ul><p>同时 Pod 的重启策略与控制方式关联，当前可用于管理 Pod 的控制器包括 ReplicationController、Job、DaemonSet 及直接管理 kubelet 管理（静态 Pod）。</p><p>不同控制器的重启策略限制如下：</p><ul><li><p>RC 和 DaemonSet：必须设置为 Always，需要保证该容器持续运行；</p></li><li><p>Job：OnFailure 或 Never，确保容器执行完成后不再重启；</p></li><li><p>kubelet：在 Pod 失效时重启，不论将 RestartPolicy 设置为何值，也不会对 Pod 进行健康检查。</p></li></ul><h2 id="简述-Kubernetes-中-Pod-的健康检查方式？"><a href="#简述-Kubernetes-中-Pod-的健康检查方式？" class="headerlink" title="简述 Kubernetes 中 Pod 的健康检查方式？"></a><strong>简述 Kubernetes 中 Pod 的健康检查方式？</strong></h2><p>对 Pod 的健康检查可以通过两类探针来检查：LivenessProbe 和 ReadinessProbe。</p><p>LivenessProbe 探针：用于判断容器是否存活（running 状态），如果 LivenessProbe 探针探测到容器不健康，则 kubelet 将杀掉该容器，并根据容器的重启策略做相应处理。若一个容器不包含 LivenessProbe 探针，kubelet 认为该容器的 LivenessProbe 探针返回值用于是 “Success”。</p><p>ReadineeProbe 探针：用于判断容器是否启动完成（ready 状态）。如果 ReadinessProbe 探针探测到失败，则 Pod 的状态将被修改。Endpoint Controller 将从 Service 的 Endpoint 中删除包含该容器所在 Pod 的 Eenpoint。</p><p>startupProbe 探针：启动检查机制，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针 kill 掉。</p><h2 id="简述-Kubernetes-Pod-的-LivenessProbe-探针的常见方式-？"><a href="#简述-Kubernetes-Pod-的-LivenessProbe-探针的常见方式-？" class="headerlink" title="简述 Kubernetes Pod 的 LivenessProbe 探针的常见方式**？**"></a><strong>简述 Kubernetes Pod 的 LivenessProbe 探针的常见方式**</strong>？**</h2><p>kubelet 定期执行 LivenessProbe 探针来诊断容器的健康状态，通常有以下三种方式：</p><p>ExecAction：在容器内执行一个命令，若返回码为 0，则表明容器健康。</p><p>TCPSocketAction：通过容器的 IP 地址和端口号执行 TCP 检查，若能建立 TCP 连接，则表明容器健康。</p><p>HTTPGetAction：通过容器的 IP 地址、端口号及路径调用 HTTP Get 方法，若响应的状态码大于等于 200 且小于 400，则表明容器健康。</p><h2 id="简述-Kubernetes-Pod-的常见调度方式？"><a href="#简述-Kubernetes-Pod-的常见调度方式？" class="headerlink" title="简述 Kubernetes Pod 的常见调度方式？"></a><strong>简述 Kubernetes Pod 的常见调度方式？</strong></h2><p>Kubernetes 中，Pod 通常是容器的载体，主要有如下常见调度方式：</p><ul><li><p>Deployment 或 RC：该调度策略主要功能就是自动部署一个容器应用的多份副本，以及持续监控副本的数量，在集群内始终维持用户指定的副本数量。</p></li><li><p>NodeSelector：定向调度，当需要手动指定将 Pod 调度到特定 Node 上，可以通过 Node 的标签（Label）和 Pod 的 nodeSelector 属性相匹配。</p></li><li><p>NodeAffinity 亲和性调度：亲和性调度机制极大的扩展了 Pod 的调度能力，目前有两种节点亲和力表达：</p></li><li><p>requiredDuringSchedulingIgnoredDuringExecution：硬规则，必须满足指定的规则，调度器才可以调度 Pod 至 Node 上（类似 nodeSelector，语法不同）。</p></li><li><p>preferredDuringSchedulingIgnoredDuringExecution：软规则，优先调度至满足的 Node 的节点，但不强求，多个优先级规则还可以设置权重值。</p></li><li><p>Taints 和 Tolerations（污点和容忍）：</p></li><li><p>Taint：使 Node 拒绝特定 Pod 运行；</p></li><li><p>Toleration：为 Pod 的属性，表示 Pod 能容忍（运行）标注了 Taint 的 Node。</p></li></ul><h2 id="简述-Kubernetes-初始化容器（init-container）？"><a href="#简述-Kubernetes-初始化容器（init-container）？" class="headerlink" title="简述 Kubernetes 初始化容器（init container）？"></a><strong>简述 Kubernetes 初始化容器（init container）？</strong></h2><p>init container 的运行方式与应用容器不同，它们必须先于应用容器执行完成，当设置了多个 init container 时，将按顺序逐个运行，并且只有前一个 init container 运行成功后才能运行后一个 init container。当所有 init container 都成功运行后，Kubernetes 才会初始化 Pod 的各种信息，并开始创建和运行应用容器。</p><h2 id="简述-Kubernetes-deployment-升级过程？"><a href="#简述-Kubernetes-deployment-升级过程？" class="headerlink" title="简述 Kubernetes deployment 升级过程？"></a><strong>简述 Kubernetes deployment 升级过程？</strong></h2><ul><li><p>初始创建 Deployment 时，系统创建了一个 ReplicaSet，并按用户的需求创建了对应数量的 Pod 副本。</p></li><li><p>当更新 Deployment 时，系统创建了一个新的 ReplicaSet，并将其副本数量扩展到 1，然后将旧 ReplicaSet 缩减为 2。</p></li><li><p>之后，系统继续按照相同的更新策略对新旧两个 ReplicaSet 进行逐个调整。</p></li><li><p>最后，新的 ReplicaSet 运行了对应个新版本 Pod 副本，旧的 ReplicaSet 副本数量则缩减为 0。</p></li></ul><h2 id="简述-Kubernetes-deployment-升级策略？"><a href="#简述-Kubernetes-deployment-升级策略？" class="headerlink" title="简述 Kubernetes deployment 升级策略？"></a><strong>简述 Kubernetes deployment 升级策略？</strong></h2><p>在 Deployment 的定义中，可以通过 spec.strategy 指定 Pod 更新的策略，目前支持两种策略：Recreate（重建）和 RollingUpdate（滚动更新），默认值为 RollingUpdate。</p><p>Recreate：设置 spec.strategy.type=Recreate，表示 Deployment 在更新 Pod 时，会先杀掉所有正在运行的 Pod，然后创建新的 Pod。</p><p>RollingUpdate：设置 spec.strategy.type=RollingUpdate，表示 Deployment 会以滚动更新的方式来逐个更新 Pod。同时，可以通过设置 spec.strategy.rollingUpdate 下的两个参数（maxUnavailable 和 maxSurge）来控制滚动更新的过程。</p><h2 id="简述-Kubernetes-DaemonSet-类型-的资源特性-？"><a href="#简述-Kubernetes-DaemonSet-类型-的资源特性-？" class="headerlink" title="简述 Kubernetes DaemonSet 类型**的资源特性**？"></a><strong>简述 Kubernetes DaemonSet 类型**</strong>的资源特性**<strong>？</strong></h2><p>DaemonSet 资源对象会在每个 Kubernetes 集群中的节点上运行，并且每个节点只能运行一个 pod，这是它和 deployment 资源对象的最大也是唯一的区别。因此，在定义 yaml 文件中，不支持定义 replicas。</p><p>它的一般使用场景如下：</p><ul><li><p>在去做每个节点的日志收集工作。</p></li><li><p>监控每个节点的的运行状态。</p></li></ul><h2 id="简述-Kubernetes-自动扩容机制？"><a href="#简述-Kubernetes-自动扩容机制？" class="headerlink" title="简述 Kubernetes 自动扩容机制？"></a><strong>简述 Kubernetes 自动扩容机制？</strong></h2><p>Kubernetes 使用 Horizontal Pod Autoscaler（HPA）的控制器实现基于 CPU 使用率进行自动 Pod 扩缩容的功能。HPA 控制器周期性地监测目标 Pod 的资源性能指标，并与 HPA 资源对象中的扩缩容条件进行对比，在满足条件时对 Pod 副本数量进行调整。</p><ul><li>HPA 原理</li></ul><p>Kubernetes 中的某个 Metrics Server（Heapster 或自定义 Metrics Server）持续采集所有 Pod 副本的指标数据。HPA 控制器通过 Metrics Server 的 API（Heapster 的 API 或聚合 API）获取这些数据，基于用户定义的扩缩容规则进行计算，得到目标 Pod 副本数量。</p><p>当目标 Pod 副本数量与当前副本数量不同时，HPA 控制器就向 Pod 的副本控制器（Deployment、RC 或 ReplicaSet）发起 scale 操作，调整 Pod 的副本数量，完成扩缩容操作。</p><h2 id="简述-Kubernetes-Service-类型？"><a href="#简述-Kubernetes-Service-类型？" class="headerlink" title="简述 Kubernetes Service 类型？"></a><strong>简述 Kubernetes Service 类型？</strong></h2><p>通过创建 Service，可以为一组具有相同功能的容器应用提供一个统一的入口地址，并且将请求负载分发到后端的各个容器应用上。其主要类型有：</p><ul><li><p>ClusterIP：虚拟的服务 IP 地址，该地址用于 Kubernetes 集群内部的 Pod 访问，在 Node 上 kube-proxy 通过设置的 iptables 规则进行转发；</p></li><li><p>NodePort：使用宿主机的端口，使能够访问各 Node 的外部客户端通过 Node 的 IP 地址和端口号就能访问服务；</p></li><li><p>LoadBalancer：使用外接负载均衡器完成到服务的负载分发，需要在 spec.status.loadBalancer 字段指定外部负载均衡器的 IP 地址，通常用于公有云。</p></li></ul><h2 id="简述-Kubernetes-Service-分发后端的策略？"><a href="#简述-Kubernetes-Service-分发后端的策略？" class="headerlink" title="简述 Kubernetes Service 分发后端的策略？"></a><strong>简述 Kubernetes Service 分发后端的策略？</strong></h2><p>Service 负载分发的策略有：RoundRobin 和 SessionAffinity</p><ul><li><p>RoundRobin：默认为轮询模式，即轮询将请求转发到后端的各个 Pod 上。</p></li><li><p>SessionAffinity：基于客户端 IP 地址进行会话保持的模式，即第 1 次将某个客户端发起的请求转发到后端的某个 Pod 上，之后从相同的客户端发起的请求都将被转发到后端相同的 Pod 上。</p></li></ul><h2 id="简述-Kubernetes-Headless-Service？"><a href="#简述-Kubernetes-Headless-Service？" class="headerlink" title="简述 Kubernetes Headless Service？"></a><strong>简述 Kubernetes Headless Service？</strong></h2><p>在某些应用场景中，若需要人为指定负载均衡器，不使用 Service 提供的默认负载均衡的功能，或者应用程序希望知道属于同组服务的其他实例。Kubernetes 提供了 Headless Service 来实现这种功能，即不为 Service 设置 ClusterIP（入口 IP 地址），仅通过 Label Selector 将后端的 Pod 列表返回给调用的客户端。</p><h2 id="简述-Kubernetes-外部如何访问集群内的服务？"><a href="#简述-Kubernetes-外部如何访问集群内的服务？" class="headerlink" title="简述 Kubernetes 外部如何访问集群内的服务？"></a><strong>简述 Kubernetes 外部如何访问集群内的服务？</strong></h2><p>对于 Kubernetes，集群外的客户端默认情况，无法通过 Pod 的 IP 地址或者 Service 的虚拟 IP 地址: 虚拟端口号进行访问。通常可以通过以下方式进行访问 Kubernetes 集群内的服务：</p><p>映射 Pod 到物理机：将 Pod 端口号映射到宿主机，即在 Pod 中采用 hostPort 方式，以使客户端应用能够通过物理机访问容器应用。</p><p>映射 Service 到物理机：将 Service 端口号映射到宿主机，即在 Service 中采用 nodePort 方式，以使客户端应用能够通过物理机访问容器应用。</p><p>映射 Sercie 到 LoadBalancer：通过设置 LoadBalancer 映射到云服务商提供的 LoadBalancer 地址。这种用法仅用于在公有云服务提供商的云平台上设置 Service 的场景。</p><h2 id="简述-Kubernetes-ingress？"><a href="#简述-Kubernetes-ingress？" class="headerlink" title="简述 Kubernetes ingress？"></a><strong>简述 Kubernetes ingress？</strong></h2><p>Kubernetes 的 Ingress 资源对象，用于将不同 URL 的访问请求转发到后端不同的 Service，以实现 HTTP 层的业务路由机制。</p><p>Kubernetes 使用了 Ingress 策略和 Ingress Controller，两者结合并实现了一个完整的 Ingress 负载均衡器。使用 Ingress 进行负载分发时，Ingress Controller 基于 Ingress 规则将客户端请求直接转发到 Service 对应的后端 Endpoint（Pod）上，从而跳过 kube-proxy 的转发功能，kube-proxy 不再起作用，全过程为：ingress controller + ingress 规则 —-&gt; services。</p><p>同时当 Ingress Controller 提供的是对外服务，则实际上实现的是边缘路由器的功能。</p><h2 id="简述-Kubernetes-镜像的下载策略？"><a href="#简述-Kubernetes-镜像的下载策略？" class="headerlink" title="简述 Kubernetes 镜像的下载策略？"></a><strong>简述</strong> <strong>Kubernetes 镜像的下载策略？</strong></h2><p>K8s 的镜像下载策略有三种：Always、Never、IFNotPresent。</p><ul><li><p>Always：镜像标签为 latest 时，总是从指定的仓库中获取镜像。</p></li><li><p>Never：禁止从仓库中下载镜像，也就是说只能使用本地镜像。</p></li><li><p>IfNotPresent：仅当本地没有对应镜像时，才从目标仓库中下载。默认的镜像下载策略是：当镜像标签是 latest 时，默认策略是 Always；当镜像标签是自定义时（也就是标签不是 latest），那么默认策略是 IfNotPresent。</p></li></ul><h2 id="简述-Kubernetes-的负载均衡器？"><a href="#简述-Kubernetes-的负载均衡器？" class="headerlink" title="简述 Kubernetes 的负载均衡器？"></a><strong>简述 Kubernetes 的负载均衡器？</strong></h2><p>负载均衡器是暴露服务的最常见和标准方式之一。</p><p>根据工作环境使用两种类型的负载均衡器，即内部负载均衡器或外部负载均衡器。内部负载均衡器自动平衡负载并使用所需配置分配容器，而外部负载均衡器将流量从外部负载引导至后端容器。</p><h2 id="简述-Kubernetes-各模块如何与-API-Server-通信？"><a href="#简述-Kubernetes-各模块如何与-API-Server-通信？" class="headerlink" title="简述 Kubernetes 各模块如何与 API Server 通信？"></a><strong>简述 Kubernetes 各模块如何与 API Server 通信？</strong></h2><p>Kubernetes API Server 作为集群的核心，负责集群各功能模块之间的通信。集群内的各个功能模块通过 API Server 将信息存入 etcd，当需要获取和操作这些数据时，则通过 API Server 提供的 REST 接口（用 GET、LIST 或 WATCH 方法）来实现，从而实现各模块之间的信息交互。</p><p>如 kubelet 进程与 API Server 的交互：每个 Node 上的 kubelet 每隔一个时间周期，就会调用一次 API Server 的 REST 接口报告自身状态，API Server 在接收到这些信息后，会将节点状态信息更新到 etcd 中。</p><p>如 kube-controller-manager 进程与 API Server 的交互：kube-controller-manager 中的 Node Controller 模块通过 API Server 提供的 Watch 接口实时监控 Node 的信息，并做相应处理。</p><p>如 kube-scheduler 进程与 API Server 的交互：Scheduler 通过 API Server 的 Watch 接口监听到新建 Pod 副本的信息后，会检索所有符合该 Pod 要求的 Node 列表，开始执行 Pod 调度逻辑，在调度成功后将 Pod 绑定到目标节点上。</p><h2 id="简述-Kubernetes-Scheduler-作用及实现原理？"><a href="#简述-Kubernetes-Scheduler-作用及实现原理？" class="headerlink" title="简述 Kubernetes Scheduler 作用及实现原理？"></a><strong>简述 Kubernetes Scheduler 作用及实现原理？</strong></h2><p>Kubernetes Scheduler 是负责 Pod 调度的重要功能模块，Kubernetes Scheduler 在整个系统中承担了 “承上启下” 的重要功能，“承上”是指它负责接收 Controller Manager 创建的新 Pod，为其调度至目标 Node；“启下”是指调度完成后，目标 Node 上的 kubelet 服务进程接管后继工作，负责 Pod 接下来生命周期。</p><p>Kubernetes Scheduler 的作用是将待调度的 Pod（API 新创建的 Pod、Controller Manager 为补足副本而创建的 Pod 等）按照特定的调度算法和调度策略绑定（Binding）到集群中某个合适的 Node 上，并将绑定信息写入 etcd 中。</p><p>在整个调度过程中涉及三个对象，分别是待调度 Pod 列表、可用 Node 列表，以及调度算法和策略。</p><p>Kubernetes Scheduler 通过调度算法调度为待调度 Pod 列表中的每个 Pod 从 Node 列表中选择一个最适合的 Node 来实现 Pod 的调度。随后，目标节点上的 kubelet 通过 API Server 监听到 Kubernetes Scheduler 产生的 Pod 绑定事件，然后获取对应的 Pod 清单，下载 Image 镜像并启动容器。</p><h2 id="简述-Kubernetes-Scheduler-使用哪两种算法将-Pod-绑定到-worker-节点？"><a href="#简述-Kubernetes-Scheduler-使用哪两种算法将-Pod-绑定到-worker-节点？" class="headerlink" title="简述 Kubernetes Scheduler 使用哪两种算法将 Pod 绑定到 worker 节点？"></a><strong>简述 Kubernetes Scheduler 使用哪两种算法将 Pod 绑定到 worker 节点？</strong></h2><p>Kubernetes Scheduler 根据如下两种调度算法将 Pod 绑定到最合适的工作节点：</p><p>预选（Predicates）：输入是所有节点，输出是满足预选条件的节点。kube-scheduler 根据预选策略过滤掉不满足策略的 Nodes。如果某节点的资源不足或者不满足预选策略的条件则无法通过预选。如 “Node 的 label 必须与 Pod 的 Selector 一致”。</p><p>优选（Priorities）：输入是预选阶段筛选出的节点，优选会根据优先策略为通过预选的 Nodes 进行打分排名，选择得分最高的 Node。例如，资源越富裕、负载越小的 Node 可能具有越高的排名。</p><h2 id="简述-Kubernetes-kubelet-的作用？"><a href="#简述-Kubernetes-kubelet-的作用？" class="headerlink" title="简述 Kubernetes kubelet 的作用？"></a><strong>简述 Kubernetes kubelet 的作用？</strong></h2><p>在 Kubernetes 集群中，在每个 Node（又称 Worker）上都会启动一个 kubelet 服务进程。该进程用于处理 Master 下发到本节点的任务，管理 Pod 及 Pod 中的容器。每个 kubelet 进程都会在 API Server 上注册节点自身的信息，定期向 Master 汇报节点资源的使用情况，并通过 cAdvisor 监控容器和节点资源。</p><h2 id="简述-Kubernetes-kubelet-监控-Worker-节点资源是使用什么组件来实现的？"><a href="#简述-Kubernetes-kubelet-监控-Worker-节点资源是使用什么组件来实现的？" class="headerlink" title="简述 Kubernetes kubelet 监控 Worker 节点资源是使用什么组件来实现的？"></a><strong>简述 Kubernetes kubelet 监控 Worker 节点资源是使用什么组件来实现的？</strong></h2><p>kubelet 使用 cAdvisor 对 worker 节点资源进行监控。在 Kubernetes 系统中，cAdvisor 已被默认集成到 kubelet 组件内，当 kubelet 服务启动时，它会自动启动 cAdvisor 服务，然后 cAdvisor 会实时采集所在节点的性能指标及在节点上运行的容器的性能指标。</p><h2 id="简述-Kubernetes-如何保证集群的安全性？"><a href="#简述-Kubernetes-如何保证集群的安全性？" class="headerlink" title="简述 Kubernetes 如何保证集群的安全性？"></a><strong>简述 Kubernetes 如何保证集群的安全性？</strong></h2><p>Kubernetes 通过一系列机制来实现集群的安全控制，主要有如下不同的维度：</p><ul><li><p>基础设施方面：保证容器与其所在宿主机的隔离；</p></li><li><p>权限方面：</p></li><li><p>最小权限原则：合理限制所有组件的权限，确保组件只执行它被授权的行为，通过限制单个组件的能力来限制它的权限范围。</p></li><li><p>用户权限：划分普通用户和管理员的角色。</p></li><li><p>集群方面：</p></li><li><p>API Server 的认证授权：Kubernetes 集群中所有资源的访问和变更都是通过 Kubernetes API Server 来实现的，因此需要建议采用更安全的 HTTPS 或 Token 来识别和认证客户端身份（Authentication），以及随后访问权限的授权（Authorization）环节。</p></li><li><p>API Server 的授权管理：通过授权策略来决定一个 API 调用是否合法。对合法用户进行授权并且随后在用户访问时进行鉴权，建议采用更安全的 RBAC 方式来提升集群安全授权。</p></li><li><p>敏感数据引入 Secret 机制：对于集群敏感数据建议使用 Secret 方式进行保护。</p></li><li><p>AdmissionControl（准入机制）：对 kubernetes api 的请求过程中，顺序为：先经过认证 &amp; 授权，然后执行准入操作，最后对目标对象进行操作。</p></li></ul><h2 id="简述-Kubernetes-准入机制？"><a href="#简述-Kubernetes-准入机制？" class="headerlink" title="简述 Kubernetes 准入机制？"></a><strong>简述 Kubernetes 准入机制？</strong></h2><p>在对集群进行请求时，每个准入控制代码都按照一定顺序执行。如果有一个准入控制拒绝了此次请求，那么整个请求的结果将会立即返回，并提示用户相应的 error 信息。</p><p>准入控制（AdmissionControl）准入控制本质上为一段准入代码，在对 kubernetes api 的请求过程中，顺序为：先经过认证 &amp; 授权，然后执行准入操作，最后对目标对象进行操作。常用组件（控制代码）如下：</p><ul><li><p>AlwaysAdmit：允许所有请求</p></li><li><p>AlwaysDeny：禁止所有请求，多用于测试环境。</p></li><li><p>ServiceAccount：它将 serviceAccounts 实现了自动化，它会辅助 serviceAccount 做一些事情，比如如果 pod 没有 serviceAccount 属性，它会自动添加一个 default，并确保 pod 的 serviceAccount 始终存在。</p></li><li><p>LimitRanger：观察所有的请求，确保没有违反已经定义好的约束条件，这些条件定义在 namespace 中 LimitRange 对象中。</p></li><li><p>NamespaceExists：观察所有的请求，如果请求尝试创建一个不存在的 namespace，则这个请求被拒绝。</p></li></ul><h2 id="简述-Kubernetes-RBAC-及其特点（优势）？"><a href="#简述-Kubernetes-RBAC-及其特点（优势）？" class="headerlink" title="简述 Kubernetes RBAC 及其特点（优势）？"></a><strong>简述 Kubernetes RBAC 及其特点（优势）？</strong></h2><p>RBAC 是基于角色的访问控制，是一种基于个人用户的角色来管理对计算机或网络资源的访问的方法。</p><p>相对于其他授权模式，RBAC 具有如下优势：</p><ul><li><p>对集群中的资源和非资源权限均有完整的覆盖。</p></li><li><p>整个 RBAC 完全由几个 API 对象完成， 同其他 API 对象一样， 可以用 kubectl 或 API 进行操作。</p></li><li><p>可以在运行时进行调整，无须重新启动 API Server。</p></li></ul><h2 id="简述-Kubernetes-Secret-作用？"><a href="#简述-Kubernetes-Secret-作用？" class="headerlink" title="简述 Kubernetes Secret 作用？"></a><strong>简述 Kubernetes Secret 作用？</strong></h2><p>Secret 对象，主要作用是保管私密数据，比如密码、OAuth Tokens、SSH Keys 等信息。将这些私密信息放在 Secret 对象中比直接放在 Pod 或 Docker Image 中更安全，也更便于使用和分发。</p><h2 id="简述-Kubernetes-Secret-有哪些使用方式？"><a href="#简述-Kubernetes-Secret-有哪些使用方式？" class="headerlink" title="简述 Kubernetes Secret 有哪些使用方式？"></a><strong>简述 Kubernetes Secret 有哪些使用方式？</strong></h2><p>创建完 secret 之后，可通过如下三种方式使用：</p><ul><li><p>在创建 Pod 时，通过为 Pod 指定 Service Account 来自动使用该 Secret。</p></li><li><p>通过挂载该 Secret 到 Pod 来使用它。</p></li><li><p>在 Docker 镜像下载时使用，通过指定 Pod 的 spc.ImagePullSecrets 来引用它。</p></li></ul><h2 id="简述-Kubernetes-PodSecurityPolicy-机制？"><a href="#简述-Kubernetes-PodSecurityPolicy-机制？" class="headerlink" title="简述 Kubernetes PodSecurityPolicy 机制？"></a><strong>简述 Kubernetes PodSecurityPolicy 机制？</strong></h2><p>Kubernetes PodSecurityPolicy 是为了更精细地控制 Pod 对资源的使用方式以及提升安全策略。在开启 PodSecurityPolicy 准入控制器后，Kubernetes 默认不允许创建任何 Pod，需要创建 PodSecurityPolicy 策略和相应的 RBAC 授权策略（Authorizing Policies），Pod 才能创建成功。</p><h2 id="简述-Kubernetes-PodSecurityPolicy-机制能实现哪些安全策略？"><a href="#简述-Kubernetes-PodSecurityPolicy-机制能实现哪些安全策略？" class="headerlink" title="简述 Kubernetes PodSecurityPolicy 机制能实现哪些安全策略？"></a><strong>简述 Kubernetes PodSecurityPolicy 机制能实现哪些安全策略？</strong></h2><p>在 PodSecurityPolicy 对象中可以设置不同字段来控制 Pod 运行时的各种安全策略，常见的有：</p><ul><li><p>特权模式：privileged 是否允许 Pod 以特权模式运行。</p></li><li><p>宿主机资源：控制 Pod 对宿主机资源的控制，如 hostPID：是否允许 Pod 共享宿主机的进程空间。</p></li><li><p>用户和组：设置运行容器的用户 ID（范围）或组（范围）。</p></li><li><p>提升权限：AllowPrivilegeEscalation：设置容器内的子进程是否可以提升权限，通常在设置非 root 用户（MustRunAsNonRoot）时进行设置。</p></li><li><p>SELinux：进行 SELinux 的相关配置。</p></li></ul><h2 id="简述-Kubernetes-网络模型？"><a href="#简述-Kubernetes-网络模型？" class="headerlink" title="简述 Kubernetes 网络模型？"></a><strong>简述 Kubernetes 网络模型？</strong></h2><p>Kubernetes 网络模型中每个 Pod 都拥有一个独立的 IP 地址，并假定所有 Pod 都在一个可以直接连通的、扁平的网络空间中。所以不管它们是否运行在同一个 Node（宿主机）中，都要求它们可以直接通过对方的 IP 进行访问。设计这个原则的原因是，用户不需要额外考虑如何建立 Pod 之间的连接，也不需要考虑如何将容器端口映射到主机端口等问题。</p><p>同时为每个 Pod 都设置一个 IP 地址的模型使得同一个 Pod 内的不同容器会共享同一个网络命名空间，也就是同一个 Linux 网络协议栈。这就意味着同一个 Pod 内的容器可以通过 localhost 来连接对方的端口。</p><p>在 Kubernetes 的集群里，IP 是以 Pod 为单位进行分配的。一个 Pod 内部的所有容器共享一个网络堆栈（相当于一个网络命名空间，它们的 IP 地址、网络设备、配置等都是共享的）。</p><h2 id="简述-Kubernetes-CNI-模型？"><a href="#简述-Kubernetes-CNI-模型？" class="headerlink" title="简述 Kubernetes CNI 模型？"></a><strong>简述 Kubernetes CNI 模型？</strong></h2><p>CNI 提供了一种应用容器的插件化网络解决方案，定义对容器网络进行操作和配置的规范，通过插件的形式对 CNI 接口进行实现。CNI 仅关注在创建容器时分配网络资源，和在销毁容器时删除网络资源。在 CNI 模型中只涉及两个概念：容器和网络。</p><p>容器（Container）：是拥有独立 Linux 网络命名空间的环境，例如使用 Docker 或 rkt 创建的容器。容器需要拥有自己的 Linux 网络命名空间，这是加入网络的必要条件。</p><p>网络（Network）：表示可以互连的一组实体，这些实体拥有各自独立、唯一的 IP 地址，可以是容器、物理机或者其他网络设备（比如路由器）等。</p><p>对容器网络的设置和操作都通过插件（Plugin）进行具体实现，CNI 插件包括两种类型：CNI Plugin 和 IPAM（IP Address  Management）Plugin。CNI Plugin 负责为容器配置网络资源，IPAM Plugin 负责对容器的 IP 地址进行分配和管理。IPAM Plugin 作为 CNI Plugin 的一部分，与 CNI Plugin 协同工作。</p><h2 id="简述-Kubernetes-网络策略？"><a href="#简述-Kubernetes-网络策略？" class="headerlink" title="简述 Kubernetes 网络策略？"></a><strong>简述 Kubernetes 网络策略？</strong></h2><p>为实现细粒度的容器间网络访问隔离策略，Kubernetes 引入 Network Policy。</p><p>Network Policy 的主要功能是对 Pod 间的网络通信进行限制和准入控制，设置允许访问或禁止访问的客户端 Pod 列表。Network Policy 定义网络策略，配合策略控制器（Policy Controller）进行策略的实现。</p><h2 id="简述-Kubernetes-网络策略原理？"><a href="#简述-Kubernetes-网络策略原理？" class="headerlink" title="简述 Kubernetes 网络策略原理？"></a><strong>简述 Kubernetes 网络策略原理？</strong></h2><p>Network Policy 的工作原理主要为：policy controller 需要实现一个 API Listener，监听用户设置的 Network Policy 定义，并将网络访问规则通过各 Node 的 Agent 进行实际设置（Agent 则需要通过 CNI 网络插件实现）。</p><h2 id="简述-Kubernetes-中-flannel-的作用？"><a href="#简述-Kubernetes-中-flannel-的作用？" class="headerlink" title="简述 Kubernetes 中 flannel 的作用？"></a><strong>简述 Kubernetes 中 flannel 的作用？</strong></h2><p>Flannel 可以用于 Kubernetes 底层网络的实现，主要作用有：</p><ul><li><p>它能协助 Kubernetes，给每一个 Node 上的 Docker 容器都分配互相不冲突的 IP 地址。</p></li><li><p>它能在这些 IP 地址之间建立一个覆盖网络（Overlay Network），通过这个覆盖网络，将数据包原封不动地传递到目标容器内。</p></li></ul><h2 id="简述-Kubernetes-Calico-网络组件实现原理？"><a href="#简述-Kubernetes-Calico-网络组件实现原理？" class="headerlink" title="简述 Kubernetes Calico 网络组件实现原理？"></a><strong>简述 Kubernetes Calico 网络组件实现原理？</strong></h2><p>Calico 是一个基于 BGP 的纯三层的网络方案，与 OpenStack、Kubernetes、AWS、GCE 等云平台都能够良好地集成。</p><p>Calico 在每个计算节点都利用 Linux Kernel 实现了一个高效的 vRouter 来负责数据转发。每个 vRouter 都通过 BGP 协议把在本节点上运行的容器的路由信息向整个 Calico 网络广播，并自动设置到达其他节点的路由转发规则。</p><p>Calico 保证所有容器之间的数据流量都是通过 IP 路由的方式完成互联互通的。Calico 节点组网时可以直接利用数据中心的网络结构（L2 或者 L3），不需要额外的 NAT、隧道或者 Overlay Network，没有额外的封包解包，能够节约 CPU 运算，提高网络效率。</p><h2 id="简述-Kubernetes-共享存储的作用？"><a href="#简述-Kubernetes-共享存储的作用？" class="headerlink" title="简述 Kubernetes 共享存储的作用？"></a><strong>简述 Kubernetes 共享存储的作用？</strong></h2><p>Kubernetes 对于有状态的容器应用或者对数据需要持久化的应用，因此需要更加可靠的存储来保存应用产生的重要数据，以便容器应用在重建之后仍然可以使用之前的数据。因此需要使用共享存储。</p><h2 id="简述-Kubernetes-数据持久化的方式有哪些？"><a href="#简述-Kubernetes-数据持久化的方式有哪些？" class="headerlink" title="简述 Kubernetes 数据持久化的方式有哪些？"></a><strong>简述 Kubernetes 数据持久化的方式有哪些？</strong></h2><p>Kubernetes 通过数据持久化来持久化保存重要数据，常见的方式有：</p><p>EmptyDir（空目录）：没有指定要挂载宿主机上的某个目录，直接由 Pod 内保部映射到宿主机上。类似于 docker 中的 manager volume。</p><ul><li><p>场景：</p></li><li><p>只需要临时将数据保存在磁盘上，比如在合并 / 排序算法中；</p></li><li><p>作为两个容器的共享存储。</p></li><li><p>特性：</p></li><li><p>同个 pod 里面的不同容器，共享同一个持久化目录，当 pod 节点删除时，volume 的数据也会被删除。</p></li><li><p>emptyDir 的数据持久化的生命周期和使用的 pod 一致，一般是作为临时存储使用。</p></li></ul><p>Hostpath：将宿主机上已存在的目录或文件挂载到容器内部。类似于 docker 中的 bind mount 挂载方式。</p><ul><li>特性：增加了 pod 与节点之间的耦合。</li></ul><p>PersistentVolume（简称 PV）：如基于 NFS 服务的 PV，也可以基于 GFS 的 PV。它的作用是统一数据持久化目录，方便管理。</p><h2 id="简述-Kubernetes-PV-和-PVC？"><a href="#简述-Kubernetes-PV-和-PVC？" class="headerlink" title="简述 Kubernetes PV 和 PVC？"></a><strong>简述 Kubernetes PV 和 PVC？</strong></h2><p>PV 是对底层网络共享存储的抽象，将共享存储定义为一种 “资源”。</p><p>PVC 则是用户对存储资源的一个 “申请”。</p><h2 id="简述-Kubernetes-PV-生命周期内的阶段？"><a href="#简述-Kubernetes-PV-生命周期内的阶段？" class="headerlink" title="简述 Kubernetes PV 生命周期内的阶段？"></a><strong>简述 Kubernetes PV 生命周期内的阶段？</strong></h2><p>某个 PV 在生命周期中可能处于以下 4 个阶段（Phaes）之一。</p><ul><li><p>Available：可用状态，还未与某个 PVC 绑定。</p></li><li><p>Bound：已与某个 PVC 绑定。</p></li><li><p>Released：绑定的 PVC 已经删除，资源已释放，但没有被集群回收。</p></li><li><p>Failed：自动资源回收失败。</p></li></ul><h2 id="简述-Kubernetes-所支持的存储供应模式？"><a href="#简述-Kubernetes-所支持的存储供应模式？" class="headerlink" title="简述 Kubernetes 所支持的存储供应模式？"></a><strong>简述 Kubernetes 所支持的存储供应模式？</strong></h2><p>Kubernetes 支持两种资源的存储供应模式：静态模式（Static）和动态模式（Dynamic）。</p><p>静态模式：集群管理员手工创建许多 PV，在定义 PV 时需要将后端存储的特性进行设置。</p><p>动态模式：集群管理员无须手工创建 PV，而是通过 StorageClass 的设置对后端存储进行描述，标记为某种类型。此时要求 PVC 对存储的类型进行声明，系统将自动完成 PV 的创建及与 PVC 的绑定。</p><h2 id="简述-Kubernetes-CSI-模型？"><a href="#简述-Kubernetes-CSI-模型？" class="headerlink" title="简述 Kubernetes CSI 模型？"></a><strong>简述 Kubernetes CSI 模型？</strong></h2><p>Kubernetes CSI 是 Kubernetes 推出与容器对接的存储接口标准，存储提供方只需要基于标准接口进行存储插件的实现，就能使用 Kubernetes 的原生存储机制为容器提供存储服务。CSI 使得存储提供方的代码能和 Kubernetes 代码彻底解耦，部署也与 Kubernetes 核心组件分离，显然，存储插件的开发由提供方自行维护，就能为 Kubernetes 用户提供更多的存储功能，也更加安全可靠。</p><p>CSI 包括 CSI Controller 和 CSI Node：</p><ul><li><p>CSI Controller 的主要功能是提供存储服务视角对存储资源和存储卷进行管理和操作。</p></li><li><p>CSI Node 的主要功能是对主机（Node）上的 Volume 进行管理和操作。</p></li></ul><h2 id="简述-Kubernetes-Worker-节点加入集群的过程？"><a href="#简述-Kubernetes-Worker-节点加入集群的过程？" class="headerlink" title="简述 Kubernetes Worker 节点加入集群的过程？"></a><strong>简述 Kubernetes Worker 节点加入集群的过程？</strong></h2><p>通常需要对 Worker 节点进行扩容，从而将应用系统进行水平扩展。主要过程如下：</p><ul><li><p>1、在该 Node 上安装 Docker、kubelet 和 kube-proxy 服务；</p></li><li><p>2、然后配置 kubelet 和 kubeproxy 的启动参数，将 Master URL 指定为当前 Kubernetes 集群 Master 的地址，最后启动这些服务；</p></li><li><p>3、通过 kubelet 默认的自动注册机制，新的 Worker 将会自动加入现有的 Kubernetes 集群中；</p></li><li><p>4、Kubernetes Master 在接受了新 Worker 的注册之后，会自动将其纳入当前集群的调度范围。</p></li></ul><h2 id="简述-Kubernetes-Pod-如何实现对节点的资源控制？"><a href="#简述-Kubernetes-Pod-如何实现对节点的资源控制？" class="headerlink" title="简述 Kubernetes Pod 如何实现对节点的资源控制？"></a><strong>简述 Kubernetes Pod 如何实现对节点的资源控制？</strong></h2><p>Kubernetes 集群里的节点提供的资源主要是计算资源，计算资源是可计量的能被申请、分配和使用的基础资源。当前 Kubernetes 集群中的计算资源主要包括 CPU、GPU 及 Memory。CPU 与 Memory 是被 Pod 使用的，因此在配置 Pod 时可以通过参数 CPU Request 及 Memory Request 为其中的每个容器指定所需使用的 CPU 与 Memory 量，Kubernetes 会根据 Request 的值去查找有足够资源的 Node 来调度此 Pod。</p><p>通常，一个程序所使用的 CPU 与 Memory 是一个动态的量，确切地说，是一个范围，跟它的负载密切相关：负载增加时，CPU 和 Memory 的使用量也会增加。</p><h2 id="简-述-Kubernetes-Requests-和-Limits-如何影响-Pod-的调度？"><a href="#简-述-Kubernetes-Requests-和-Limits-如何影响-Pod-的调度？" class="headerlink" title="简**述 Kubernetes Requests 和 Limits 如何影响 Pod 的调度？**"></a><strong>简**</strong>述 Kubernetes Requests 和 Limits 如何影响 Pod 的调度？**</h2><p>当一个 Pod 创建成功时，Kubernetes 调度器（Scheduler）会为该 Pod 选择一个节点来执行。对于每种计算资源（CPU 和 Memory）而言，每个节点都有一个能用于运行 Pod 的最大容量值。调度器在调度时，首先要确保调度后该节点上所有 Pod 的 CPU 和内存的 Requests 总和，不超过该节点能提供给 Pod 使用的 CPU 和 Memory 的最大容量值。</p><h2 id="简述-Kubernetes-Metric-Service？"><a href="#简述-Kubernetes-Metric-Service？" class="headerlink" title="简述 Kubernetes Metric Service？"></a><strong>简述 Kubernetes Metric Service？</strong></h2><p>在 Kubernetes 从 1.10 版本后采用 Metrics Server 作为默认的性能数据采集和监控，主要用于提供核心指标（Core Metrics），包括 Node、Pod 的 CPU 和内存使用指标。</p><p>对其他自定义指标（Custom Metrics）的监控则由 Prometheus 等组件来完成。</p><h2 id="简述-Kubernetes-中，如何使用-EFK-实现日志的统一管理？"><a href="#简述-Kubernetes-中，如何使用-EFK-实现日志的统一管理？" class="headerlink" title="简述 Kubernetes 中，如何使用 EFK 实现日志的统一管理？"></a><strong>简述 Kubernetes 中，如何使用 EFK 实现日志的统一管理？</strong></h2><p>在 Kubernetes 集群环境中，通常一个完整的应用或服务涉及组件过多，建议对日志系统进行集中化管理，通常采用 EFK 实现。</p><p>EFK 是 Elasticsearch、Fluentd 和 Kibana 的组合，其各组件功能如下：</p><ul><li><p>Elasticsearch：是一个搜索引擎，负责存储日志并提供查询接口；</p></li><li><p>Fluentd：负责从 Kubernetes 搜集日志，每个 node 节点上面的 fluentd 监控并收集该节点上面的系统日志，并将处理过后的日志信息发送给 Elasticsearch；</p></li><li><p>Kibana：提供了一个 Web GUI，用户可以浏览和搜索存储在 Elasticsearch 中的日志。</p></li></ul><p>通过在每台 node 上部署一个以 DaemonSet 方式运行的 fluentd 来收集每台 node 上的日志。Fluentd 将 docker 日志目录 / var/lib/docker/containers 和 / var/log 目录挂载到 Pod 中，然后 Pod 会在 node 节点的 / var/log/pods 目录中创建新的目录，可以区别不同的容器日志输出，该目录下有一个日志文件链接到 / var/lib/docker/contianers 目录下的容器日志输出。</p><h2 id="简述-Kubernetes-如何进行优雅的节点关机维护？"><a href="#简述-Kubernetes-如何进行优雅的节点关机维护？" class="headerlink" title="简述 Kubernetes 如何进行优雅的节点关机维护？"></a><strong>简述 Kubernetes 如何进行优雅的节点关机维护？</strong></h2><p>由于 Kubernetes 节点运行大量 Pod，因此在进行关机维护之前，建议先使用 kubectl drain 将该节点的 Pod 进行驱逐，然后进行关机维护。</p><h2 id="简述-Kubernetes-集群联邦？"><a href="#简述-Kubernetes-集群联邦？" class="headerlink" title="简述 Kubernetes 集群联邦？"></a><strong>简述 Kubernetes 集群联邦？</strong></h2><p>Kubernetes 集群联邦可以将多个 Kubernetes 集群作为一个集群进行管理。因此，可以在一个数据中心 / 云中创建多个 Kubernetes 集群，并使用集群联邦在一个地方控制 / 管理所有集群。</p><h2 id="简述-Helm-及其优势？"><a href="#简述-Helm-及其优势？" class="headerlink" title="简述 Helm 及其优势？"></a><strong>简述 Helm 及其优势？</strong></h2><p>Helm 是 Kubernetes 的软件包管理工具。类似 Ubuntu 中使用的 apt、Centos 中使用的 yum 或者 Python 中的 pip 一样。</p><p>Helm 能够将一组 K8S 资源打包统一管理, 是查找、共享和使用为 Kubernetes 构建的软件的最佳方式。</p><p>Helm 中通常每个包称为一个 Chart，一个 Chart 是一个目录（一般情况下会将目录进行打包压缩，形成 name-version.tgz 格式的单一文件，方便传输和存储）。</p><h5 id="Helm-优势"><a href="#Helm-优势" class="headerlink" title="Helm 优势"></a>Helm 优势</h5><p>在 Kubernetes 中部署一个可以使用的应用，需要涉及到很多的 Kubernetes 资源的共同协作。使用 helm 则具有如下优势：</p><ul><li><p>统一管理、配置和更新这些分散的 k8s 的应用资源文件；</p></li><li><p>分发和复用一套应用模板；</p></li><li><p>将应用的一系列资源当做一个软件包管理。</p></li><li><p>对于应用发布者而言，可以通过 Helm 打包应用、管理应用依赖关系、管理应用版本并发布应用到软件仓库。</p></li><li><p>对于使用者而言，使用 Helm 后不用需要编写复杂的应用部署文件，可以以简单的方式在 Kubernetes 上查找、安装、升级、回滚、卸载应用程序。</p></li></ul><blockquote><p>文章转自：Go 语言圣经  </p><p>原文链接：<a href="https://mp.weixin.qq.com/s/m3uaAIAQCwKadqc-qm2ZRg">https://mp.weixin.qq.com/s/m3uaAIAQCwKadqc-qm2ZRg</a></p></blockquote><p><em><strong>End</strong></em></p><p>[</p><p>面试必备之排序算法（golang 实现）</p><p>2022-01-18</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/56U6KCydWqm22n1ouYReM45Xf1KAf4R4icHJlBsQ53eBkAG4RwduZWPtQGrghCqVMaB6E7lQOacibhQN8JthxJiaA/640?wx_fmt=jpeg"></p><p>](<a href="https://mp.weixin.qq.com/s?__biz=Mzg5NTYxMTAzOQ==&amp;mid=2247493324&amp;idx=1&amp;sn=fbf22ee2e92afc27d58e2f23f4115cbf&amp;chksm=c00f1f3cf778962a819b7325b5d7d540ee698adab646d70bd69383b49ddbf2fb362fc0327342&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg5NTYxMTAzOQ==&amp;mid=2247493324&amp;idx=1&amp;sn=fbf22ee2e92afc27d58e2f23f4115cbf&amp;chksm=c00f1f3cf778962a819b7325b5d7d540ee698adab646d70bd69383b49ddbf2fb362fc0327342&amp;scene=21#wechat_redirect</a>)</p><p>[</p><p>从入门到精通的 Docker 学习指南</p><p>2022-01-17</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/56U6KCydWqkgGy6nib0O8kjtRiaOwaNmlSY5M9iar2RBAFFTiaYUGvGgVZL7d3Dutut57YHTZ4COmEIzo7PHLBHBHg/640?wx_fmt=jpeg"></p><p>](<a href="https://mp.weixin.qq.com/s?__biz=Mzg5NTYxMTAzOQ==&amp;mid=2247493246&amp;idx=1&amp;sn=f65cbbcce4b0bb0494d524f5416fefbf&amp;chksm=c00f1f8ef77896982f722064dc3eded6cfd88a41ad4407e3572b351860f149481b2c02ffd734&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg5NTYxMTAzOQ==&amp;mid=2247493246&amp;idx=1&amp;sn=f65cbbcce4b0bb0494d524f5416fefbf&amp;chksm=c00f1f8ef77896982f722064dc3eded6cfd88a41ad4407e3572b351860f149481b2c02ffd734&amp;scene=21#wechat_redirect</a>)</p><p>[</p><p>【资源】Docker 从入门到实践. pdf</p><p>2022-01-17</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/9autpibOEiaVIzS5XaYcrEuxdyAmJVQaKW1rqbO8bSuhpAcwia7xCpwrFfVRq3rVfncB0M9TicQvb0QXYRw6viaa9XA/640?wx_fmt=jpeg"></p><p>](<a href="https://mp.weixin.qq.com/s?__biz=Mzg5NTYxMTAzOQ==&amp;mid=2247493246&amp;idx=2&amp;sn=440e4bd20cc72aa2019e67a8aadea8a4&amp;chksm=c00f1f8ef7789698c44eaa46cd59eff687028c8d728e21c3bd7edc4be032462dc3325ce9940b&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg5NTYxMTAzOQ==&amp;mid=2247493246&amp;idx=2&amp;sn=440e4bd20cc72aa2019e67a8aadea8a4&amp;chksm=c00f1f8ef7789698c44eaa46cd59eff687028c8d728e21c3bd7edc4be032462dc3325ce9940b&amp;scene=21#wechat_redirect</a>)</p><p>[</p><p>数据库整理合集：含 MySQL、Redis、Mongodb 等常见数据库教程</p><p>2022-01-14</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/56U6KCydWqk98UnkTWibCOnTdAia3m1kuricqBSXibicJ7jnEVWovoM2xicvEbWCZUCFaAn88UnesII4cHcXg4tyfwibw/640?wx_fmt=jpeg"></p><p>](<a href="https://mp.weixin.qq.com/s?__biz=Mzg5NTYxMTAzOQ==&amp;mid=2247493206&amp;idx=2&amp;sn=c597e1756ea3512ce1e804fcbbd2d32d&amp;chksm=c00f1fa6f77896b036d4a00bc0f61046bf612cac79131c297792fd53a5469b0a2955087fe9a2&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg5NTYxMTAzOQ==&amp;mid=2247493206&amp;idx=2&amp;sn=c597e1756ea3512ce1e804fcbbd2d32d&amp;chksm=c00f1fa6f77896b036d4a00bc0f61046bf612cac79131c297792fd53a5469b0a2955087fe9a2&amp;scene=21#wechat_redirect</a>)</p><p>[</p><p>Golang 服务常用组件 GORM, Sqlx, MySQL, MongoDB</p><p>2022-01-14</p><p><img src="https://mmbiz.qpic.cn/mmbiz_jpg/IgylNib7ZE2JLzmPzvNzxPInicHrKaN9NLqwKyp5ab4AMWklQKgeickF9EiaQLZ2Rhj5vfe8cvKoSZJCc6Uyorrr3g/640?wx_fmt=jpeg"></p><p>](<a href="https://mp.weixin.qq.com/s?__biz=Mzg5NTYxMTAzOQ==&amp;mid=2247493206&amp;idx=1&amp;sn=f1764546588d5fa21d99d6740674f6ef&amp;chksm=c00f1fa6f77896b0e898b73c80346328a40c517771fcebb34b0cc1544d5752b6efe1b4980e2b&amp;scene=21#wechat_redirect">https://mp.weixin.qq.com/s?__biz=Mzg5NTYxMTAzOQ==&amp;mid=2247493206&amp;idx=1&amp;sn=f1764546588d5fa21d99d6740674f6ef&amp;chksm=c00f1fa6f77896b0e898b73c80346328a40c517771fcebb34b0cc1544d5752b6efe1b4980e2b&amp;scene=21#wechat_redirect</a>)</p><p><img src="https://mmbiz.qpic.cn/mmbiz_gif/6aVaON9Kibf5ibKRPQgZ9XgbVNsIeQUnfKSiaErmr8dtdicicS3A8m6TiavR6ZB0Eah3pD0kjQg8ACyNb1x5ibdqRg2jA/640?wx_fmt=gif"></p><p>戳原文，更有料！</p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes,interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python核心技术与实战-基础篇</title>
    <link href="/2022/01/12/python/Python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/note/01%E4%B8%A8Python%20%E5%9F%BA%E7%A1%80/"/>
    <url>/2022/01/12/python/Python%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E4%B8%8E%E5%AE%9E%E6%88%98/note/01%E4%B8%A8Python%20%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Python核心技术与实战-基础篇"><a href="#Python核心技术与实战-基础篇" class="headerlink" title="Python核心技术与实战-基础篇"></a>Python核心技术与实战-基础篇</h1><h2 id="1-列表和元组"><a href="#1-列表和元组" class="headerlink" title="1. 列表和元组"></a>1. 列表和元组</h2><h3 id="1-1-基础"><a href="#1-1-基础" class="headerlink" title="1.1 基础"></a>1.1 基础</h3><ul><li>列表是动态的，长度大小不固定，可以随意地增加、删减或者改变元素（mutable）。</li><li>而元组是静态的，长度大小固定，无法增加删减或者改变（immutable）。</li><li>Python 中的列表和元组都支持负数索引，-1 表示最后一个元<br>素，-2 表示倒数第二个元素，以此类推。</li><li>列表和元组都支持切片操作</li><li>列表和元组都可以随意嵌套</li><li>两者也可以通过 list() 和 tuple() 函数相互转换</li></ul><h3 id="1-2-存储方式的差异"><a href="#1-2-存储方式的差异" class="headerlink" title="1.2 存储方式的差异"></a>1.2 存储方式的差异</h3><ul><li>列表是动态的、可变的，而元组是静态的、不可变的</li><li>由于列表是动态的，所以它需要存储指针，来指向对应的元素（上述例子中，对于int 型，8 字节）。另外，由于列表可变，所以需要额外存储已经分配的长度大小（8 字节），这样才可以实时追踪列表空间的使用情况，当空间不足时，及时分配额外空间。</li></ul><h3 id="1-3-性能"><a href="#1-3-性能" class="headerlink" title="1.3 性能"></a>1.3 性能</h3><ul><li><p>元组要比列表更加轻量级一些，所以总体上来说，元组的性能速度要略优于列表。</p></li><li><p>Python 会在后台，对静态数据做一些资源缓存（resource caching）。对于一些静态变量，比如元组，如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。这样，下次我们再创建同样大小的元组时，Python 就可以不用再向操作系统发出请求，去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。</p></li><li><p>元组的初始化速度，要比列表快 5 倍。</p><pre><code class="hljs python">python3 -m timeit <span class="hljs-string">&#x27;x=(1,2,3,4,5,6)&#x27;</span><span class="hljs-number">20000000</span> loops, best of <span class="hljs-number">5</span>: <span class="hljs-number">9.97</span> nsec per looppython3 -m timeit <span class="hljs-string">&#x27;x=[1,2,3,4,5,6]&#x27;</span><span class="hljs-number">5000000</span> loops, best of <span class="hljs-number">5</span>: <span class="hljs-number">50.1</span> nsec per loop</code></pre></li><li><p>如果是索引操作的话，两者的速度差别非常小，几乎可以忽略不计。</p><pre><code class="hljs python">python3 -m timeit -s <span class="hljs-string">&#x27;x=[1,2,3,4,5,6]&#x27;</span> <span class="hljs-string">&#x27;y=x[3]&#x27;</span><span class="hljs-number">10000000</span> loops, best of <span class="hljs-number">5</span>: <span class="hljs-number">22.2</span> nsec per looppython3 -m timeit -s <span class="hljs-string">&#x27;x=(1,2,3,4,5,6)&#x27;</span> <span class="hljs-string">&#x27;y=x[3]&#x27;</span><span class="hljs-number">10000000</span> loops, best of <span class="hljs-number">5</span>: <span class="hljs-number">21.9</span> nsec per loop</code></pre></li></ul><h3 id="1-4-使用场景"><a href="#1-4-使用场景" class="headerlink" title="1.4 使用场景"></a>1.4 使用场景</h3><ol><li>如果存储的数据和数量不变，选用元组更合适。</li><li>如果存储的数据或数量是可变的，用列表更合适。</li></ol><pre><code class="hljs ad_summary">总的来说，列表和元组都是有序的，可以存储任意数据类型的集合，区别主要在于下面这两点。- 列表是动态的，长度可变，可以随意的增加、删减或改变元素。列表的存储空间略大于元组，性能略逊于元组。- 元组是静态的，长度大小固定，不可以对元素进行增加、删减或者改变操作。元组相对于列表更加轻量级，性能稍优。元素不需要改变时:两三个元素，使用 tuple，元素多一点使用namedtuple。元素需要改变时:需要高效随机读取，使用list。需要关键字高效查找，采用 dict。去重，使用 set。大型数据节省空间，使用标准库 array。大型数据高效操作，使用 numpy.array。</code></pre><h2 id="2-字典和集合"><a href="#2-字典和集合" class="headerlink" title="2. 字典和集合"></a>2. 字典和集合</h2><h3 id="2-1-基础"><a href="#2-1-基础" class="headerlink" title="2.1 基础"></a>2.1 基础</h3><ul><li>字典是一系列由键（key）和值（value）配对组成的元素的集合，在 Python3.7+，字典被确定为有序（注意：在 3.6 中，<strong>字典有序</strong>是一个implementation detail，在 3.7 才正式成为语言特性，因此 3.6 中无法 100% 确保其有序性），而 3.6 之前是无序的，其长度大小可变，元素可以任意地删减和改变。</li><li>相比于列表和元组，字典的性能更优，特别是对于查找、添加和删除操作，字典都能在常数<br>时间复杂度内完成。</li><li>集合和字典基本相同，唯一的区别，就是<strong>集合没有键和值的配对，是一系列无序的、唯一的元素组合</strong>。</li><li><strong>Python 中字典和集合，无论是键还是值，都可以是混合类型。</strong></li><li></li></ul><h4 id="2-1-1-元素访问"><a href="#2-1-1-元素访问" class="headerlink" title="2.1.1 元素访问"></a>2.1.1 元素访问</h4><ul><li><p>字典访问可以直接索引键，如果不存在，就会抛出异常</p><p>使用 get(key, default) 函数来进行索引。如果键不存在，调用 get() 函数可以返回一个默认值</p></li><li><p>集合并不支持索引操作，因为集合本质上是一个哈希表，和列表不一样</p><p>判断一个元素在不在字典或集合内，我们可以用 value in dict/set 来判断</p></li><li><p>字典和集合也同样支持增加、删除、更新等操作</p><pre><code class="hljs python">d = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;jason&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>&#125;d[<span class="hljs-string">&#x27;gender&#x27;</span>] = <span class="hljs-string">&#x27;male&#x27;</span> <span class="hljs-comment"># 增加元素对&#x27;gender&#x27;: &#x27;male&#x27;</span>d[<span class="hljs-string">&#x27;dob&#x27;</span>] = <span class="hljs-string">&#x27;1999-02-01&#x27;</span> <span class="hljs-comment"># 增加元素对&#x27;dob&#x27;: &#x27;1999-02-01&#x27;</span>d&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;jason&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-string">&#x27;dob&#x27;</span>: <span class="hljs-string">&#x27;1999-02-01&#x27;</span>&#125;d[<span class="hljs-string">&#x27;dob&#x27;</span>] = <span class="hljs-string">&#x27;1998-01-01&#x27;</span> <span class="hljs-comment"># 更新键&#x27;dob&#x27;对应的值</span>d.pop(<span class="hljs-string">&#x27;dob&#x27;</span>) <span class="hljs-comment"># 删除键为&#x27;dob&#x27;的元素对</span><span class="hljs-string">&#x27;1998-01-01&#x27;</span>d&#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;jason&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>, <span class="hljs-string">&#x27;gender&#x27;</span>: <span class="hljs-string">&#x27;male&#x27;</span>&#125;s = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;s.add(<span class="hljs-number">4</span>) <span class="hljs-comment"># 增加元素 4 到集合</span>s&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;s.remove(<span class="hljs-number">4</span>) <span class="hljs-comment"># 从集合中删除元素 4</span>s&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;</code></pre></li><li><p>集合的 pop() 操作是删除集合中最后一个元素，可是集合本身是无序的，你<br>无法知道会删除哪个元素，因此这个操作得谨慎使用</p></li></ul><h4 id="2-1-2-排序"><a href="#2-1-2-排序" class="headerlink" title="2.1.2 排序"></a>2.1.2 排序</h4><ul><li><p>对于字典，我们通常会根据键或值，进行升序或降序排序</p><pre><code class="hljs python">d = &#123;<span class="hljs-string">&#x27;b&#x27;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;c&#x27;</span>: <span class="hljs-number">10</span>&#125;d_sorted_by_key = <span class="hljs-built_in">sorted</span>(d.items(), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">0</span>]) <span class="hljs-comment"># 根据字典键的升序排序</span>d_sorted_by_value = <span class="hljs-built_in">sorted</span>(d.items(), key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>]) <span class="hljs-comment"># 根据字典值的升序排序</span>d_sorted_by_key[(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">10</span>)]d_sorted_by_value[(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">1</span>), (<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">2</span>), (<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">10</span>)]</code></pre></li><li><p>对于集合，其排序和前面讲过的列表、元组很类似，直接调用 sorted(set) 即可，结果会返回一个排好序的列表</p><pre><code class="hljs python">s = &#123;<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>&#125;<span class="hljs-built_in">sorted</span>(s) <span class="hljs-comment"># 对集合的元素进行升序排序</span></code></pre></li></ul><h3 id="2-2-性能"><a href="#2-2-性能" class="headerlink" title="2.2 性能"></a>2.2 性能</h3><blockquote><p>字典和集合是进行过性能高度优化的数据结构，特别是对于查找、添加和删除操作</p></blockquote><p>假设列表有 n 个元素，而查找的过程要遍历列表，那么时间复杂度就为 O(n)。即使我们先对列表进行排序，然后使用二分查找，也会需要 O(logn) 的时间复杂度，更何况，列表的排序还需要 O(nlogn) 的时间。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">find_product_price</span>(<span class="hljs-params">products, product_id</span>):</span>    <span class="hljs-keyword">for</span> <span class="hljs-built_in">id</span>, price <span class="hljs-keyword">in</span> products:        <span class="hljs-keyword">if</span> <span class="hljs-built_in">id</span> == product_id:            <span class="hljs-keyword">return</span> price    <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>products = [    (<span class="hljs-number">143121312</span>, <span class="hljs-number">100</span>),    (<span class="hljs-number">432314553</span>, <span class="hljs-number">30</span>),    (<span class="hljs-number">32421912367</span>, <span class="hljs-number">150</span>)]print(<span class="hljs-string">&#x27;The price of product 432314553 is &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(find_product_price(products,<span class="hljs-number">432314553</span>)))</code></pre><p>但如果我们用字典来存储这些数据，那么查找就会非常便捷高效，只需 O(1) 的时间复杂度就可以完成。原因也很简单，刚刚提到过的，字典的内部组成是一张哈希表，你可以直接通过键的哈希值，找到其对应的值。</p><pre><code class="hljs python">products = &#123;<span class="hljs-number">143121312</span>: <span class="hljs-number">100</span>,<span class="hljs-number">432314553</span>: <span class="hljs-number">30</span>,<span class="hljs-number">32421912367</span>: <span class="hljs-number">150</span>&#125;print(<span class="hljs-string">&#x27;The price of product 432314553 is &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(products[<span class="hljs-number">432314553</span>]))</code></pre><h3 id="2-3-工作原理"><a href="#2-3-工作原理" class="headerlink" title="2.3 工作原理"></a>2.3 工作原理</h3><ul><li><p>不同于其他数据结构，字典和集合的内部结构都是一张哈希表</p><ul><li>对于字典而言，这张表存储了哈希值（hash）、键和值这 3 个元素。</li><li>对集合来说，区别就是哈希表内没有键和值的配对，只有单一的元素了。</li></ul></li><li><p>为了提高存储空间的利用率，现在的哈希表除了字典本身的结构，会把索引和哈希值、键、值单独分开，也就是下面这样新的结构</p><pre><code class="hljs shell">Indices----------------------------------------------------None | index | None | None | index | None | index ...----------------------------------------------------Entries--------------------hash0 key0 value0---------------------hash1 key1 value1---------------------hash2 key2 value2---------------------...---------------------</code></pre></li></ul><h3 id="2-4-插入操作"><a href="#2-4-插入操作" class="headerlink" title="2.4 插入操作"></a>2.4 插入操作</h3><p>每次向字典或集合插入一个元素时，Python 会首先计算键的哈希值（hash(key)），再和mask = PyDicMinSize - 1 做与操作，计算这个元素应该插入哈希表的位置 index =hash(key) &amp; mask。如果哈希表中此位置是空的，那么这个元素就会被插入其中。</p><p>而如果此位置已被占用，Python 便会比较两个元素的哈希值和键是否相等。</p><ul><li>若两者都相等，则表明这个元素已经存在，如果值不同，则更新值。</li><li>若两者中有一个不相等，这种情况我们通常称为哈希冲突（hash collision），意思是两个元素的键不相等，但是哈希值相等。这种情况下，Python 便会继续寻找表中空余的位置，直到找到位置为止。</li></ul><p>值得一提的是，通常来说，遇到这种情况，最简单的方式是线性寻找，即从这个位置开始，挨个往后寻找空位。当然，Python 内部对此进行了优化</p><h3 id="2-5-查找操作"><a href="#2-5-查找操作" class="headerlink" title="2.5 查找操作"></a>2.5 查找操作</h3><p>和前面的插入操作类似，Python 会根据哈希值，找到其应该处于的位置；然后，比较哈希表这个位置中元素的哈希值和键，与需要查找的元素是否相等。如果相等，则直接返回；如果不等，则继续查找，直到找到空位或者抛出异常为止。</p><h3 id="2-6-删除操作"><a href="#2-6-删除操作" class="headerlink" title="2.6 删除操作"></a>2.6 删除操作</h3><p>对于删除操作，Python 会暂时对这个位置的元素，赋于一个特殊的值，等到重新调整哈希表的大小时，再将其删除。</p><p>不难理解，哈希冲突的发生，往往会降低字典和集合操作的速度。因此，为了保证其高效性，字典和集合内的哈希表，通常会保证其至少留有 1/3 的剩余空间。随着元素的不停插入，当剩余空间小于 1/3 时，Python 会重新获取更大的内存空间，扩充哈希表。不过，这种情况下，表内所有的元素位置都会被重新排放。</p><p>虽然哈希冲突和哈希表大小的调整，都会导致速度减缓，但是这种情况发生的次数极少。所以，平均情况下，这仍能保证插入、查找和删除的时间复杂度为 O(1)。</p><pre><code class="hljs ad-summary">字典在 Python3.7+ 是有序的数据结构，而集合是无序的，其内部的哈希表存储结构，保证了其查找、插入、删除操作的高效性。所以，字典和集合通常运用在对元素的高效查找、去重等场景。</code></pre><h2 id="3-字符串"><a href="#3-字符串" class="headerlink" title="3. 字符串"></a>3. 字符串</h2><h3 id="3-1-基础"><a href="#3-1-基础" class="headerlink" title="3.1 基础"></a>3.1 基础</h3><ul><li><p>字符串是由独立字符组成的一个序列，通常包含在单引号（’’）双引号（””）或者三引号之中（’’’ ‘’’或””” “””，两者一样）</p></li><li><p>Python 中单引号、双引号和三引号的字符串是一模一样的，没有区别</p></li><li><p>Python 也支持转义字符。所谓的转义字符，就是用反斜杠开头的字符串，来表示一<br>些特定意义的字符</p><table><thead><tr><th>转义字符</th><th>说明</th></tr></thead><tbody><tr><td>\newline</td><td>接下一行</td></tr><tr><td>\\</td><td>表示 \</td></tr><tr><td>\‘</td><td>表示单引号’</td></tr><tr><td>\“</td><td>表示双引号</td></tr><tr><td>\n</td><td>换行</td></tr><tr><td>\t</td><td>横向制表符</td></tr><tr><td>\b</td><td>退格</td></tr><tr><td>\v</td><td>纵向制表符</td></tr></tbody></table></li></ul><h3 id="3-2-常用操作"><a href="#3-2-常用操作" class="headerlink" title="3.2 常用操作"></a>3.2 常用操作</h3><ul><li><p>字符串的索引同样从 0 开始，index=0 表示第一个元素（字符），[index:index+2] 则表示第 index 个元素到 index+1 个元素组成的子字符串。</p></li><li><p>遍历字符串同样很简单，相当于遍历字符串中的每个字符。</p></li><li><p>Python 的字符串是不可变的（immutable）。因此，用下面的操作，来改变一个字符串内部的字符是错误的，不允许的。</p></li><li><p>Python 中字符串的改变，通常只能通过创建新的字符串来完成。比如上述例子中，想把’hello’的第一个字符’h’，改为大写的’H’，我们可以采用下面的做法：</p><pre><code class="hljs python">s = <span class="hljs-string">&#x27;H&#x27;</span> + s[<span class="hljs-number">1</span>:]s = s.replace(<span class="hljs-string">&#x27;h&#x27;</span>, <span class="hljs-string">&#x27;H&#x27;</span>)</code></pre><ul><li>第一种方法，是直接用大写的’H’，通过加号’+’操作符，与原字符串切片操作的子字符串拼接而成新的字符串。</li><li>第二种方法，是直接扫描原字符串，把小写的’h’替换成大写的’H’，得到新的字符串。</li></ul></li><li><p>使用加法操作符’+=’的字符串拼接方法,在写程序遇到字符串拼接时，如果使用’+=’更方便，就放心地去用吧，不用过分担心效率问题了</p></li><li><p>除了使用加法操作符，我们还可以使用字符串内置的 join 函数。string.join(iterable)，表示把每个元素都按照指定的格式连接起来</p></li><li><p>常见的函数还有：</p><ul><li>string.strip(str)，表示去掉首尾的 str 字符串；</li><li>string.lstrip(str)，表示只去掉开头的 str 字符串；</li><li>string.rstrip(str)，表示只去掉尾部的 str 字符串。</li><li>从文件读进来的字符串中，开头和结尾都含有空字符，我们需要去掉它们，就可以用 strip() 函数</li><li>Python 中字符串还有很多常用操作，比如，string.find(sub, start, end)，表示从start 到 end 查找字符串中子字符串 sub 的位置</li></ul></li></ul><h3 id="3-3-格式化"><a href="#3-3-格式化" class="headerlink" title="3.3 格式化"></a>3.3 格式化</h3><ul><li><p>使用一个字符串作为模板，模板中会有格式符。这些格式符为后续真实值预留位置，以呈现出真实值应该呈现的格式。字符串的格式化，通常会用在程序的输出、logging等场景。</p><pre><code class="hljs python">print(<span class="hljs-string">&#x27;no data available for person with id: &#123;&#125;, name: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">id</span>, name))</code></pre><p>其中的 string.format()，就是所谓的格式化函数；而大括号{}就是所谓的格式符，用来为后面的真实值——变量 name 预留位置</p></li><li><p>string.format() 是最新的字符串格式函数与规范。自然，我们还有其他的表示方法，比如在 Python 之前版本中，字符串格式化通常用 % 来表示</p><pre><code class="hljs python">print(<span class="hljs-string">&#x27;no data available for person with id: %s, name: %s&#x27;</span> % (<span class="hljs-built_in">id</span>, name))</code></pre><p>其中 %s 表示字符串型，%d 表示整型等等，这些属于常识</p><p>推荐使用 format 函数，毕竟这是最新规范，也是官方文档推荐的规范。</p></li><li><p>使用格式化函数，更加清晰、易读，并且更加规范，不易出错。</p></li></ul><pre><code class="hljs ad_summary">Python 中字符串使用单引号、双引号或三引号表示，三者意义相同，并没有什么区别。其中，三引号的字符串通常用在多行字符串的场景。Python 中字符串是不可变的（前面所讲的新版本 Python 中拼接操作’+&#x3D;&#39;是个例外）。因此，随意改变字符串中字符的值，是不被允许的。Python 新版本（2.5+）中，字符串的拼接变得比以前高效了许多，你可以放心使用。Python 中字符串的格式化（string.format）常常用在输出、日志的记录等场景。</code></pre><h2 id="4-输入与输出"><a href="#4-输入与输出" class="headerlink" title="4. 输入与输出"></a>4. 输入与输出</h2><blockquote><p>在互联网上，没人知道你是一条狗。互联网刚刚兴起时，一根网线链接到你家，信息通过这条高速线缆直达你的屏幕，你通过键盘飞速回应朋友的消息，信息再次通过网线飞入错综复杂的虚拟世界，再进入朋友家。抽象来看，一台台的电脑就是一个个黑箱，黑箱有了输入和输出，就拥有了图灵机运作的必要条件。</p></blockquote><h3 id="4-1-基础"><a href="#4-1-基础" class="headerlink" title="4.1 基础"></a>4.1 基础</h3><ul><li>input() 函数暂停程序运行，同时等待键盘输入；直到回车被按下，函数的参数即为提示语，输入的类型永远是字符串型（str）</li><li>print() 函数则接受字符串、数字、字典、列表甚至一些自定义类的输出。</li><li><strong>把 str 强制转换为 int 请用 int()，转为浮点数请用 float()。而在生产环境中使用强制转换时，请记得加上 try except（即错误和异常处理）</strong></li><li>Python 对 int 类型没有最大限制（相比之下， C++ 的 int 最大为 2147483647，超过这个数字会产生溢出），但是对 float 类型依然有精度限制。这些特点，除了在一些算法竞赛中要注意，在生产环境中也要时刻提防，避免因为对边界条件判断不清而造成 bug 甚至0day（危重安全漏洞）。</li></ul><h3 id="4-2-文件输入输出"><a href="#4-2-文件输入输出" class="headerlink" title="4.2 文件输入输出"></a>4.2 文件输入输出</h3><ul><li>命令行的输入输出，只是 Python 交互的最基本方式，适用一些简单小程序的交互。而生产级别的 Python 代码，大部分 I/O 则来自于文件、网络、其他进程的消息等等。</li><li>计算机中文件访问的基础知识<ul><li>事实上，计算机内核（kernel）对文件的处理相对比较复杂，涉及到内核模式、虚拟文件系统、锁和指针等一系列概念</li><li>先要用 open() 函数拿到文件的指针。其中，第一个参数指定文件位置（相对位置或者绝对位置）；第二个参数，如果是 ‘r’表示读取，如果是’w’ 则表示写入，当然也可以用’rw’ ，表示读写都要。a 则是一个不太常用（但也很有用）的参数，表示追加（append），这样打开的文件，如果需要写入，会从原始文件的最末尾开始写入。</li><li><strong>代码权限管理非常重要。如果你只需要读取文件，就不要请求写入权限。这样在某种程度上可以降低 bug 对整个系统带来的风险。</strong></li><li>拿到指针后，我们可以通过 read() 函数，来读取文件的全部内容。代码 text = fin.read() ，即表示把文件所有内容读取到内存中，并赋值给变量 text。这么做自然也是有利有弊：<ul><li>优点是方便，接下来我们可以很方便地调用 parse 函数进行分析；</li><li>缺点是如果文件过大，一次性读取可能造成内存崩溃。</li></ul></li><li>给 read 指定参数 size ，用来表示读取的最大长度。还可以通过 readline()函数，每次读取一行，这种做法常用于数据挖掘（Data Mining）中的数据清洗，在写一些小的程序时非常轻便。如果每行之间没有关联，这种做法也可以降低内存的压力。而write() 函数，可以把参数中的字符串输出到文件中</li><li>with 语句。open() 函数对应于 close() 函数，也就是说，如果你打开了文件，在完成读取任务后，就应该立刻关掉它。而如果你使用了with 语句，就不需要显式调用 close()。在 with 的语境下任务执行完毕后，close() 函数会被自动调用，代码也简洁很多</li><li>所有 I/O 都应该进行错误处理。因为 I/O 操作可能会有各种各样的情况出现，而一个健壮（robust）的程序，需要能应对各种情况的发生，而不应该崩溃（故意设计的情况除外）。</li></ul></li></ul><h3 id="4-3-JSON-序列化与实战"><a href="#4-3-JSON-序列化与实战" class="headerlink" title="4.3 JSON 序列化与实战"></a>4.3 JSON 序列化与实战</h3><ul><li><p>JSON（JavaScript Object Notation）是一种轻量级的数据交换格式，它的设计意图是把所有事情都用设计的字符串来表示，这样既方便在互联网上传递信息，也方便人进行阅读（相比一些 binary 的协议）</p><ul><li>第一种，输入这些杂七杂八的信息，比如 Python 字典，输出一个字符串；</li><li>第二种，输入这个字符串，可以输出包含原始信息的 Python 字典。</li></ul></li><li><p>json.dumps() 这个函数，接受 Python 的基本数据类型，然后将其序列化为 string；</p></li><li><p>json.loads() 这个函数，接受一个合法字符串，然后将其反序列化为 Python 的基本数据类型。</p></li><li><p>输出字符串到文件，从文件中读取 JSON 字符串</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> jsonparams = &#123;<span class="hljs-string">&#x27;symbol&#x27;</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,<span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;limit&#x27;</span>,<span class="hljs-string">&#x27;price&#x27;</span>: <span class="hljs-number">123.4</span>,<span class="hljs-string">&#x27;amount&#x27;</span>: <span class="hljs-number">23</span>&#125;<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;params.json&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>) <span class="hljs-keyword">as</span> fout:params_str = json.dump(params, fout)<span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;params.json&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> fin:original_params = json.load(fin)    print(<span class="hljs-string">&#x27;after json deserialization&#x27;</span>)print(<span class="hljs-string">&#x27;type of original_params = &#123;&#125;, original_params = &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">type</span>(original_params)</code></pre></li><li><p>当开发一个第三方应用程序时，你可以通过 JSON 将用户的个人配置输出到文件，方便下次程序启动时自动读取。这也是现在普遍运用的成熟做法。</p></li><li><p>Google，有类似的工具叫做 Protocol Buffer，相比于 JSON，它的优点是生成优化后的二进制文件，因此性能更好。但与此同时，生成的二进制序列，是不能直接阅读的。它在 TensorFlow 等很多对性能有要求的系统中都有广泛的应用。</p></li></ul><pre><code class="hljs ad-summary">I&#x2F;O 操作需谨慎，一定要进行充分的错误处理，并细心编码，防止出现编码漏洞；编码时，对内存占用和磁盘占用要有充分的估计，这样在出错时可以更容易找到原因；JSON 序列化是很方便的工具，要结合实战多多练习；代码尽量简洁、清晰</code></pre><h2 id="5-条件与循环"><a href="#5-条件与循环" class="headerlink" title="5. 条件与循环"></a>5. 条件与循环</h2><h3 id="5-1-条件语句"><a href="#5-1-条件语句" class="headerlink" title="5.1 条件语句"></a>5.1 条件语句</h3><pre><code class="hljs python"><span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">0</span>:y = -x<span class="hljs-keyword">else</span>:y = x</code></pre><ul><li><p>在条件语句的末尾必须加上冒号（:）</p></li><li><p>Python 中的表达是elif。</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> condition_1:statement_1<span class="hljs-keyword">elif</span> condition_2:statement_2...<span class="hljs-keyword">elif</span> condition_i:statement_i<span class="hljs-keyword">else</span>:statement_n</code></pre><p>整个条件语句是顺序执行的，如果遇到一个条件满足，比如 condition_i 满足时，在执行完statement_i 后，便会退出整个 if、elif、else 条件语句，而不会继续向下执行</p></li><li><p>关于省略判断条件的常见用法</p><table><thead><tr><th>数据类型</th><th>结果</th></tr></thead><tbody><tr><td>String</td><td>空字符串解析为False，其余为True</td></tr><tr><td>Int</td><td>0解析为False，其余为True</td></tr><tr><td>Bool</td><td>True为True，False为False</td></tr><tr><td>list/tuple/dict/set</td><td>Iterable为空解析为False，其余为True</td></tr><tr><td>Object</td><td>None解析为False，其余为True</td></tr></tbody></table><p>在实际写代码时，建议除了 boolean 类型的数据，条件判断最好是显性的</p></li></ul><h3 id="5-2-循环语句"><a href="#5-2-循环语句" class="headerlink" title="5.2 循环语句"></a>5.2 循环语句</h3><ul><li><p>Python 中的循环一般通过 for 循环和 while 循环实现</p><pre><code class="hljs python">l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]<span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> l:print(item)</code></pre></li><li><p>Python 中的数据结构只要是可迭代的（iterable），比如列表、集合等等，那么都可以通过下面这种方式遍历</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> &lt;iterable&gt;:...</code></pre></li><li><p>字典本身只有键是可迭代的，如果我们要遍历它的值或者是键值对，就需要通过其内置的函数 values() 或者 items() 实现。其中，values() 返回字典的值的集合，items() 返回键值对的集合。</p></li><li><p>通常通过 range() 这个函数，拿到索引，再去遍历访问集合中的元素</p><pre><code class="hljs python">l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-keyword">for</span> index <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(l)):<span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">5</span>:print(l[index])</code></pre></li><li><p>Python 内置的函数enumerate()。用它来遍历集合，不仅返回每个元素，并且还返回其对应的索引</p><pre><code class="hljs python">l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>]<span class="hljs-keyword">for</span> index, item <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(l):<span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">5</span>:print(item)</code></pre></li><li><p>在循环语句中，我们还常常搭配 continue 和 break 一起使用。所谓 continue，就是让程序跳过当前这层循环，继续执行下面的循环；而 break 则是指完全跳出所在的整个循环体。在循环中适当加入 continue 和 break，往往能使程序更加简洁、易读。</p><pre><code class="hljs python"><span class="hljs-comment"># name_price: 产品名称 (str) 到价格 (int) 的映射字典</span><span class="hljs-comment"># name_color: 产品名字 (str) 到颜色 (list of str) 的映射字典</span><span class="hljs-keyword">for</span> name, price <span class="hljs-keyword">in</span> name_price.items():<span class="hljs-keyword">if</span> price &lt; <span class="hljs-number">1000</span>:<span class="hljs-keyword">if</span> name <span class="hljs-keyword">in</span> name_color:<span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> name_color[name]:<span class="hljs-keyword">if</span> color != <span class="hljs-string">&#x27;red&#x27;</span>:print(<span class="hljs-string">&#x27;name: &#123;&#125;, color: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, color))<span class="hljs-keyword">else</span>:print(<span class="hljs-string">&#x27;name: &#123;&#125;, color: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, <span class="hljs-string">&#x27;None&#x27;</span>))</code></pre><p>加入 continue 后，代码显然清晰了很多</p><pre><code class="hljs python"><span class="hljs-comment"># name_price: 产品名称 (str) 到价格 (int) 的映射字典</span><span class="hljs-comment"># name_color: 产品名字 (str) 到颜色 (list of str) 的映射字典</span><span class="hljs-keyword">for</span> name, price <span class="hljs-keyword">in</span> name_price.items():<span class="hljs-keyword">if</span> price &gt;= <span class="hljs-number">1000</span>:<span class="hljs-keyword">continue</span><span class="hljs-keyword">if</span> name <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> name_color:print(<span class="hljs-string">&#x27;name: &#123;&#125;, color: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, <span class="hljs-string">&#x27;None&#x27;</span>))<span class="hljs-keyword">continue</span><span class="hljs-keyword">for</span> color <span class="hljs-keyword">in</span> name_color[name]:<span class="hljs-keyword">if</span> color == <span class="hljs-string">&#x27;red&#x27;</span>:<span class="hljs-keyword">continue</span>print(<span class="hljs-string">&#x27;name: &#123;&#125;, color: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(name, color))</code></pre></li><li><p>很多时候，for 循环和 while 循环可以互相转换,如果你只是遍历一个已知的集合，找出满足条件的元素，并进行相应的操作，那么使用 for 循环更加简洁。但如果你需要在满足某个条件前，不停地重复某些操作，并且没有特定的集合需要去遍历，那么一般则会使用 while 循环</p><p>比如，某个交互式问答系统，用户输入文字，系统会根据内容做出相应的回答。为了实现这<br>个功能，我们一般会使用 while 循环，大致代码如下</p><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<span class="hljs-keyword">try</span>:text = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;Please enter your questions, enter &quot;q&quot; to exit&#x27;</span>)<span class="hljs-keyword">if</span> text == <span class="hljs-string">&#x27;q&#x27;</span>:print(<span class="hljs-string">&#x27;Exit system&#x27;</span>)<span class="hljs-keyword">break</span>......print(response)<span class="hljs-keyword">except</span> <span class="hljs-keyword">as</span> err:    print(<span class="hljs-string">&#x27;Encountered error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))<span class="hljs-keyword">break</span></code></pre></li><li><p>for 循环的效率更胜一筹,range() 函数是直接由 C 语言写的，调用它速度非常快。while 循环中的“i+= 1”这个操作，得通过 Python 的解释器间接调用底层的 C 语言；并且这个简单的操作，又涉及到了对象的创建和删除（因为 i 是整型，是 immutable，i += 1 相当于 i =new int(i + 1)）</p></li></ul><h3 id="5-3-条件与循环的复用"><a href="#5-3-条件与循环的复用" class="headerlink" title="5.3 条件与循环的复用"></a>5.3 条件与循环的复用</h3><ul><li><p>在阅读代码的时候，你应该常常会发现，有很多将条件与循环并做一行的操作</p><pre><code class="hljs python">expression1 <span class="hljs-keyword">if</span> condition <span class="hljs-keyword">else</span> expression2 <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iterable</code></pre><p>将这个表达式分解开来，其实就等同于下面这样的嵌套结构：</p><pre><code class="hljs python"><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iterable:<span class="hljs-keyword">if</span> condition:expression1<span class="hljs-keyword">else</span>:expression2</code></pre><p>而如果没有 else 语句，则需要写成：</p><pre><code class="hljs python">expression <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> iterable <span class="hljs-keyword">if</span> condition</code></pre><p>比如我们要绘制 y = 2*|x| + 5 的函数图像，给定集合 x 的数据点，需要计算出y 的数据集合，那么只用一行代码，就可以很轻松地解决问题了</p><pre><code class="hljs python">y = [value * <span class="hljs-number">2</span> + <span class="hljs-number">5</span> <span class="hljs-keyword">if</span> value &gt; <span class="hljs-number">0</span> <span class="hljs-keyword">else</span> -value * <span class="hljs-number">2</span> + <span class="hljs-number">5</span> <span class="hljs-keyword">for</span> value <span class="hljs-keyword">in</span> x]</code></pre><p>在处理文件中的字符串时，常常遇到的一个场景：将文件中逐行读取的一个完整语句，按逗号分割单词，去掉首位的空字符，并过滤掉长度小于等于 3 的单词，最后返回由单词组成的列表。这同样可以简洁地表达成一行</p><pre><code class="hljs python">text = <span class="hljs-string">&#x27; Today, is, Sunday&#x27;</span>text_list = [s.strip() <span class="hljs-keyword">for</span> s <span class="hljs-keyword">in</span> text.split(<span class="hljs-string">&#x27;,&#x27;</span>) <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(s.strip()) &gt; <span class="hljs-number">3</span>]print(text_list)</code></pre><p>这样的复用并不仅仅局限于一个循环。比如，给定两个列表 x、y，要求返回 x、y 中<br>所有元素对组成的元祖，相等情况除外</p><pre><code class="hljs python">[(xx, yy) <span class="hljs-keyword">for</span> xx <span class="hljs-keyword">in</span> x <span class="hljs-keyword">for</span> yy <span class="hljs-keyword">in</span> y <span class="hljs-keyword">if</span> xx != yy]<span class="hljs-comment"># 等价于</span>l = []<span class="hljs-keyword">for</span> xx <span class="hljs-keyword">in</span> x:<span class="hljs-keyword">for</span> yy <span class="hljs-keyword">in</span> y:<span class="hljs-keyword">if</span> xx != yy:l.append((xx, yy))</code></pre><pre><code class="hljs ad-summary">在条件语句中，if 可以单独使用，但是 elif 和 else 必须和 if 同时搭配使用；而 If 条件语句的判断，除了 boolean 类型外，其他的最好显示出来。在 for 循环中，如果需要同时访问索引和元素，你可以使用 enumerate() 函数来简化代码。写条件与循环时，合理利用 continue 或者 break 来避免复杂的嵌套，是十分重要的。要注意条件与循环的复用，简单功能往往可以用一行直接完成，极大地提高代码质量与效率。</code></pre></li></ul><h2 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h2><h3 id="6-1-错误与异常"><a href="#6-1-错误与异常" class="headerlink" title="6.1 错误与异常"></a>6.1 错误与异常</h3><ul><li><p>程序中的错误至少包括两种，一种是语法错误，另一种则是异常。</p><ul><li>语法错误，代码不符合编程规范，无法被识别与执行，invalid syntax</li><li>异常则是指程序的语法正确，也可以被执行，但在执行过程中遇到了错误，抛出了异常</li></ul><p>ZeroDivisionError NameError和TypeError，就是三种常见的异常类型</p><p><a href="https://docs.python.org/3/library/exceptions.html#bltin-exceptions">Python 中还有很多其他异常类型</a></p></li></ul><h3 id="6-2-处理异常"><a href="#6-2-处理异常" class="headerlink" title="6.2 处理异常"></a>6.2 处理异常</h3><ul><li><p>异常处理，通常使用 try 和 except 来解决</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:s = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;please enter two numbers separated by comma: &#x27;</span>)num1 = <span class="hljs-built_in">int</span>(s.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">0</span>].strip())num2 = <span class="hljs-built_in">int</span>(s.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">1</span>].strip())...<span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> err:print(<span class="hljs-string">&#x27;Value Error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))print(<span class="hljs-string">&#x27;continue&#x27;</span>)</code></pre><p>except block 只接受与它相匹配的异常类型并执行，如果程序抛出的异常并不匹配，那么程序照样会终止并退出。</p></li><li><p>在 except block 中加入多种异常的类型，比如下面这样的写法</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:s = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;please enter two numbers separated by comma: &#x27;</span>)num1 = <span class="hljs-built_in">int</span>(s.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">0</span>].strip())num2 = <span class="hljs-built_in">int</span>(s.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">1</span>].strip())...<span class="hljs-keyword">except</span> (ValueError, IndexError) <span class="hljs-keyword">as</span> err:print(<span class="hljs-string">&#x27;Error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))    print(<span class="hljs-string">&#x27;continue&#x27;</span>)...</code></pre><p>或者第二种写法：</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:s = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;please enter two numbers separated by comma: &#x27;</span>)num1 = <span class="hljs-built_in">int</span>(s.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">0</span>].strip())num2 = <span class="hljs-built_in">int</span>(s.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">1</span>].strip())    ...<span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> err:print(<span class="hljs-string">&#x27;Value Error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))<span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> err:print(<span class="hljs-string">&#x27;Index Error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))    print(<span class="hljs-string">&#x27;continue&#x27;</span>)...</code></pre><p>每次程序执行时，except block 中只要有一个 exception 类型与实际匹配即可</p></li><li><p><strong>更通常的做法，是在最后一个 except block，声明其处理的异常类型是 Exception。Exception 是其他所有非系统异常的基类，能够匹配任意非系统异常</strong></p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:s = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;please enter two numbers separated by comma: &#x27;</span>)num1 = <span class="hljs-built_in">int</span>(s.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">0</span>].strip())num2 = <span class="hljs-built_in">int</span>(s.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">1</span>].strip())...<span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> err:print(<span class="hljs-string">&#x27;Value Error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))<span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> err:print(<span class="hljs-string">&#x27;Index Error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))<span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> err:print(<span class="hljs-string">&#x27;Other error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))print(<span class="hljs-string">&#x27;continue&#x27;</span>)...</code></pre><p>也可以在 except 后面省略异常类型，这表示与任意异常相匹配（包括系统异常等）</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:s = <span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;please enter two numbers separated by comma: &#x27;</span>)num1 = <span class="hljs-built_in">int</span>(s.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">0</span>].strip())num2 = <span class="hljs-built_in">int</span>(s.split(<span class="hljs-string">&#x27;,&#x27;</span>)[<span class="hljs-number">1</span>].strip())...<span class="hljs-keyword">except</span> ValueError <span class="hljs-keyword">as</span> err:    print(<span class="hljs-string">&#x27;Value Error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))<span class="hljs-keyword">except</span> IndexError <span class="hljs-keyword">as</span> err:print(<span class="hljs-string">&#x27;Index Error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))<span class="hljs-keyword">except</span>:print(<span class="hljs-string">&#x27;Other error&#x27;</span>)print(<span class="hljs-string">&#x27;continue&#x27;</span>)...</code></pre></li><li><p>当程序中存在多个 except block 时，最多只有一个 except block 会被执行。换句话说，如果多个 except 声明的异常类型都与实际相匹配，那么只有最前面的 exceptblock 会被执行，其他则被忽略。</p></li><li><p>异常处理中，还有一个很常见的用法是 finally，经常和 try、except 放在一起来用。无论发生什么情况，finally block 中的语句都会被执行，哪怕前面的 try 和 excep block 中使用了 return 语句。\</p><p>一个常见的应用场景，便是文件的读取</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<span class="hljs-keyword">try</span>:f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;file.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>).... <span class="hljs-comment"># some data processing</span><span class="hljs-keyword">except</span> OSError <span class="hljs-keyword">as</span> err:print(<span class="hljs-string">&#x27;OS error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))<span class="hljs-keyword">except</span>:print(<span class="hljs-string">&#x27;Unexpected error:&#x27;</span>, sys.exc_info()[<span class="hljs-number">0</span>])<span class="hljs-keyword">finally</span>:f.close()</code></pre><p>try block 尝试读取 file.txt 这个文件，并对其中的数据进行一系列的处理，到最后，无论是读取成功还是读取失败，程序都会执行 finally 中的语句——关闭这个文件流，确保文件的完整性。因此，在 finally 中，我们通常会放一些无论如何都要执行的语句。</p></li></ul><h3 id="6-3-用户自定义异常"><a href="#6-3-用户自定义异常" class="headerlink" title="6.3 用户自定义异常"></a>6.3 用户自定义异常</h3><ul><li><p>下面这个例子，我们创建了自定义的异常类型 MyInputError，定义并实现了初始化函数和 str 函数（直接 print 时调用）</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyInputError</span>(<span class="hljs-params">Exception</span>):</span><span class="hljs-string">&quot;&quot;&quot;Exception raised when there&#x27;re errors in input&quot;&quot;&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, value</span>):</span> <span class="hljs-comment"># 自定义异常类型的初始化</span>self.value = value<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__str__</span>(<span class="hljs-params">self</span>):</span> <span class="hljs-comment"># 自定义异常类型的 string 表达形式</span><span class="hljs-keyword">return</span> (<span class="hljs-string">&quot;&#123;&#125; is invalid input&quot;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">repr</span>(self.value)))<span class="hljs-keyword">try</span>:<span class="hljs-keyword">raise</span> MyInputError(<span class="hljs-number">1</span>) <span class="hljs-comment"># 抛出 MyInputError 这个异常</span><span class="hljs-keyword">except</span> MyInputError <span class="hljs-keyword">as</span> err:print(<span class="hljs-string">&#x27;error: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))</code></pre></li></ul><h3 id="6-4-异常的使用场景与注意点"><a href="#6-4-异常的使用场景与注意点" class="headerlink" title="6.4 异常的使用场景与注意点"></a>6.4 异常的使用场景与注意点</h3><ul><li><p>不确定某段代码能否成功执行，往往这个地方就需要使用异常处理</p><p>大型社交网站的后台，需要针对用户发送的请求返回相应记录。用户记录往往储存在 keyvalue结构的数据库中，每次有请求过来后，我们拿到用户的 ID，并用 ID 查询数据库中此人的记录，就能返回相应的结果。</p><p>而数据库返回的原始数据，往往是 json string 的形式，这就需要我们首先对 json string进行 decode（解码），你可能很容易想到下面的方法：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> jsonraw_data = queryDB(uid) <span class="hljs-comment"># 根据用户的 id，返回相应的信息</span>data = json.loads(raw_data)</code></pre><p>在 json.loads() 函数中，输入的字符串如果不符合其规范，那么便无法解码，就会抛出异常，因此加上异常处理十分必要。</p><pre><code class="hljs python"><span class="hljs-keyword">try</span>:data = json.loads(raw_data)....<span class="hljs-keyword">except</span> JSONDecodeError <span class="hljs-keyword">as</span> err:print(<span class="hljs-string">&#x27;JSONDecodeError: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))</code></pre><p>当你想要查找字典中某个键对应的值时，绝不能写成下面这种形式：</p><pre><code class="hljs python">d = &#123;<span class="hljs-string">&#x27;name&#x27;</span>: <span class="hljs-string">&#x27;jason&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>: <span class="hljs-number">20</span>&#125;<span class="hljs-keyword">try</span>:value = d[<span class="hljs-string">&#x27;dob&#x27;</span>]...<span class="hljs-keyword">except</span> KeyError <span class="hljs-keyword">as</span> err:print(<span class="hljs-string">&#x27;KeyError: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(err))</code></pre><p>字典这个例子，写成下面这样就很好</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;dob&#x27;</span> <span class="hljs-keyword">in</span> d:value = d[<span class="hljs-string">&#x27;dob&#x27;</span>]...</code></pre></li></ul><pre><code class="hljs ad-summary">异常，通常是指程序运行的过程中遇到了错误，终止并退出。我们通常使用 try except语句去处理异常，这样程序就不会被终止，仍能继续执行。处理异常时，如果有必须执行的语句，比如文件打开后必须关闭等等，则可以放在finally block 中。异常处理，通常用在你不确定某段代码能否成功执行，也无法轻易判断的情况下，比如数据库的连接、读取等等。正常的 flow-control 逻辑，不要使用异常处理，直接用条件语句解决就可以了。</code></pre><h2 id="7-自定义函数"><a href="#7-自定义函数" class="headerlink" title="7. 自定义函数"></a>7. 自定义函数</h2><h3 id="7-1-函数基础"><a href="#7-1-函数基础" class="headerlink" title="7.1 函数基础"></a>7.1 函数基础</h3><ul><li><p>函数就是为了实现某一功能的代码段，只要写好以后，就可以重复利用</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_func</span>(<span class="hljs-params">message</span>):</span>    print(<span class="hljs-string">&#x27;Got a message: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(message))my_func(<span class="hljs-string">&#x27;Hello&#x27;</span>)</code></pre><p>def 是函数的声明；<br>my_func 是函数的名称；<br>括号里面的 message 则是函数的参数；<br>而 print 那行则是函数的主体部分，可以执行相应的语句；<br>在函数最后，你可以返回调用结果（return 或 yield），也可以不返回。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">name</span>(<span class="hljs-params">param1, param2, ..., paramN</span>):</span>statements<span class="hljs-keyword">return</span>/<span class="hljs-keyword">yield</span> value <span class="hljs-comment"># optional</span></code></pre></li><li><p>和其他需要编译的语言（比如 C 语言）不一样的是，def 是可执行语句，这意味着函数直到被调用前，都是不存在的。当程序调用函数时，def 语句才会创建一个新的函数对象，并赋予其名字。</p></li><li><p>主程序调用函数时，必须保证这个函数此前已经定义过，不然就会报错</p></li><li><p>但是，如果我们在函数内部调用其他函数，函数间哪个声明在前、哪个在后就无所谓，因为def 是可执行语句，函数在调用之前都不存在，我们只需保证调用时，所需的函数都已经声明定义</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_func</span>(<span class="hljs-params">message</span>):</span>my_sub_func(message) <span class="hljs-comment"># 调用 my_sub_func() 在其声明之前不影响程序执行</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">my_sub_func</span>(<span class="hljs-params">message</span>):</span>print(<span class="hljs-string">&#x27;Got a message: &#123;&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(message))my_func(<span class="hljs-string">&#x27;hello world&#x27;</span>)</code></pre></li><li><p>Python 函数的参数可以设定默认值</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">param = <span class="hljs-number">0</span></span>):</span>...</code></pre><p>在调用函数 func() 时，如果参数 param 没有传入，则参数默认为 0；而如果传入了参数 param，其就会覆盖默认值。</p></li><li><p><strong>Python 是 dynamically typed 的，可以接受任何数据类型（整型，浮点，字符串等等）</strong></p></li><li><p>Python 不用考虑输入的数据类型，而是将其交给具体的代码去判断执行，同样的一个函数（比如这边的相加函数 my_sum()），可以同时应用在整型、列表、字符串等等的操作中。</p></li><li><p><strong>多态</strong>，必要时请你在开头加上数据的类型检查</p></li><li><p>Python 支持函数的嵌套。所谓的函数嵌套，就是指函数里面又有函数，比如：</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f1</span>():</span>print(<span class="hljs-string">&#x27;hello&#x27;</span>)<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">f2</span>():</span>print(<span class="hljs-string">&#x27;world&#x27;</span>)f2()f1()</code></pre></li><li><p>函数嵌套</p><ul><li><p>第一，函数的嵌套能够保证内部函数的隐私。内部函数只能被外部函数所调用和访问，不会暴露在全局作用域，因此，如果你的函数内部有一些隐私数据（比如数据库的用户、密码等），不想暴露在外，那你就可以使用函数的的嵌套，将其封装在内部函数中，只通过外部函数来访问。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">connect_DB</span>():</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_DB_configuration</span>():</span>...<span class="hljs-keyword">return</span> host, username, passwordconn = connector.connect(get_DB_configuration())<span class="hljs-keyword">return</span> conn</code></pre></li><li><p>第二，合理的使用函数嵌套，能够提高程序的运行效率</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">factorial</span>(<span class="hljs-params"><span class="hljs-built_in">input</span></span>):</span><span class="hljs-comment"># validation check</span><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(<span class="hljs-built_in">input</span>, <span class="hljs-built_in">int</span>):<span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;input must be an integer.&#x27;</span>)<span class="hljs-keyword">if</span> <span class="hljs-built_in">input</span> &lt; <span class="hljs-number">0</span>:<span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;input must be greater or equal to 0&#x27;</span> )...    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner_factorial</span>(<span class="hljs-params"><span class="hljs-built_in">input</span></span>):</span><span class="hljs-keyword">if</span> <span class="hljs-built_in">input</span> &lt;= <span class="hljs-number">1</span>:<span class="hljs-keyword">return</span> <span class="hljs-number">1</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">input</span> * inner_factorial(<span class="hljs-built_in">input</span><span class="hljs-number">-1</span>)<span class="hljs-keyword">return</span> inner_factorial(<span class="hljs-built_in">input</span>)print(factorial(<span class="hljs-number">5</span>))</code></pre></li></ul></li></ul><h3 id="7-2-函数变量作用域"><a href="#7-2-函数变量作用域" class="headerlink" title="7.2 函数变量作用域"></a>7.2 函数变量作用域</h3><ul><li><p>Python 函数中变量的作用域和其他语言类似。如果变量是在函数内部定义的，就称为局部变量，只在函数内部有效。一旦函数执行完毕，局部变量就会被回收，无法访问</p></li><li><p>全局变量则是定义在整个文件层次上的</p></li><li><p><strong>不能在函数内部随意改变全局变量的值</strong></p></li><li><p>Python 的解释器会默认函数内部的变量为局部变量，但是又发现局部变量MIN_VALUE 并没有声明，因此就无法执行相关操作。所以，如果我们一定要在函数内部改变全局变量的值，就必须加上 global 这个声明：</p><pre><code class="hljs python">MIN_VALUE = <span class="hljs-number">1</span>MAX_VALUE = <span class="hljs-number">10</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validation_check</span>(<span class="hljs-params">value</span>):</span><span class="hljs-keyword">global</span> MIN_VALUE...MIN_VALUE += <span class="hljs-number">1</span>...validation_check(<span class="hljs-number">5</span>)</code></pre><p>这里的 global 关键字，并不表示重新创建了一个全局变量 MIN_VALUE，而是告诉Python 解释器，函数内部的变量 MIN_VALUE，就是之前定义的全局变量，并不是新的全局变量，也不是局部变量。这样，程序就可以在函数内部访问全局变量，并修改它的值了。</p></li><li><p>如果遇到函数内部局部变量和全局变量同名的情况，那么在函数内部，局部变量会覆盖全局变量，比如下面这种</p><pre><code class="hljs python">MIN_VALUE = <span class="hljs-number">1</span>MAX_VALUE = <span class="hljs-number">10</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">validation_check</span>(<span class="hljs-params">value</span>):</span>MIN_VALUE = <span class="hljs-number">3</span>...</code></pre></li><li><p>对于嵌套函数来说，内部函数可以访问外部函数定义的变量，但是无法修改，若要修改，必须加上 <strong>nonlocal</strong> 这个关键字</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer</span>():</span>x = <span class="hljs-string">&quot;local&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>():</span><span class="hljs-keyword">nonlocal</span> x <span class="hljs-comment"># nonlocal 关键字表示这里的 x 就是外部函数 outer 定义的变量 x</span>x = <span class="hljs-string">&#x27;nonlocal&#x27;</span>print(<span class="hljs-string">&quot;inner:&quot;</span>, x)inner()print(<span class="hljs-string">&quot;outer:&quot;</span>, x)outer()</code></pre></li><li><p>如果不加上 nonlocal 这个关键字，而内部函数的变量又和外部函数变量同名，那么同样的，内部函数变量会覆盖外部函数的变量。</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer</span>():</span>x = <span class="hljs-string">&quot;local&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>():</span>x = <span class="hljs-string">&#x27;nonlocal&#x27;</span> <span class="hljs-comment"># 这里的 x 是 inner 这个函数的局部变量</span>print(<span class="hljs-string">&quot;inner:&quot;</span>, x)inner()print(<span class="hljs-string">&quot;outer:&quot;</span>, x)outer()</code></pre></li></ul><h3 id="7-3-闭包"><a href="#7-3-闭包" class="headerlink" title="7.3 闭包"></a>7.3 闭包</h3><ul><li><p>闭包其实和刚刚讲的嵌套函数类似，不同的是，这里外部函数返回的是一个函数，而不是一个具体的值。返回的函数通常赋于一个变量，这个变量可以在后面被继续执行调用。</p><p>计算一个数的 n 次幂</p><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">nth_power</span>(<span class="hljs-params">exponent</span>):</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">exponent_of</span>(<span class="hljs-params">base</span>):</span><span class="hljs-keyword">return</span> base ** exponent<span class="hljs-keyword">return</span> exponent_of <span class="hljs-comment"># 返回值是 exponent_of 函数</span>square = nth_power(<span class="hljs-number">2</span>) <span class="hljs-comment"># 计算一个数的平方</span>cube = nth_power(<span class="hljs-number">3</span>) <span class="hljs-comment"># 计算一个数的立方</span>squarecubeprint(square(<span class="hljs-number">2</span>)) <span class="hljs-comment"># 计算 2 的平方</span>print(cube(<span class="hljs-number">2</span>)) <span class="hljs-comment"># 计算 2 的立方</span></code></pre><p>这里外部函数 nth_power() 返回值，是函数 exponent_of()，而不是一个具体的数值。需要注意的是，在执行完square = nth_power(2)和cube = nth_power(3)后，外部函数 nth_power() 的参数 exponent，仍然会被内部函数 exponent_of() 记住。这样，之后我们调用 square(2) 或者 cube(2) 时，程序就能顺利地输出结果，而不会报错说参数exponent 没有定义了。</p></li><li><p><strong>使用闭包的一个原因，是让程序变得更简洁易读</strong></p></li></ul><pre><code class="hljs ad-summary">1. Python 中函数的参数可以接受任意的数据类型，使用起来需要注意，必要时请在函数开头加入数据类型的检查；2. 和其他语言不同，Python 中函数的参数可以设定默认值；3. 嵌套函数的使用，能保证数据的隐私性，提高程序运行效率；4. 合理地使用闭包，则可以简化程序的复杂度，提高可读性。</code></pre><h2 id="8-匿名函数"><a href="#8-匿名函数" class="headerlink" title="8. 匿名函数"></a>8. 匿名函数</h2><h3 id="8-1-基础"><a href="#8-1-基础" class="headerlink" title="8.1 基础"></a>8.1 基础</h3><ul><li><p>匿名函数的格式：<code>lambda argument1, argument2,... argumentN : expression</code></p></li><li><p>匿名函数的关键字是 lambda，之后是一系列的参数，然后用冒号隔开，最后则是由这些参数组成的表达式</p><pre><code class="hljs python">square = <span class="hljs-keyword">lambda</span> x: x**<span class="hljs-number">2</span>square(<span class="hljs-number">3</span>)</code></pre></li><li><p>与常规函数区别</p><ul><li><p>第一，lambda 是一个表达式（expression），并不是一个语句（statement）。lambda 可以用在一些常规函数 def 不能用的地方，比如，lambda 可以用在列表内部，而常规函数却不能</p><pre><code class="hljs python">[(<span class="hljs-keyword">lambda</span> x: x*x)(x) <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)]</code></pre><p>lambda 可以被用作某些函数的参数，而常规函数 def 也不能</p><pre><code class="hljs python">l = [(<span class="hljs-number">1</span>, <span class="hljs-number">20</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">0</span>), (<span class="hljs-number">9</span>, <span class="hljs-number">10</span>), (<span class="hljs-number">2</span>, <span class="hljs-number">-1</span>)]l.sort(key=<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>]) <span class="hljs-comment"># 按列表中元祖的第二个元素排序</span>print(l)</code></pre><p>常规函数 def 必须通过其函数名被调用，因此必须首先被定义。但是作为一个表达式的<br>lambda，返回的函数对象就不需要名字了。</p></li><li><p>第二，lambda 的主体是只有一行的简单表达式，并不能扩展成一个多行的代码块。</p><p>这其实是出于设计的考虑。Python 之所以发明 lambda，就是为了让它和常规函数各司其职：lambda 专注于简单的任务，而常规函数则负责更复杂的多行逻辑</p></li></ul></li></ul><h3 id="8-2-为什么使用匿名函数"><a href="#8-2-为什么使用匿名函数" class="headerlink" title="8.2 为什么使用匿名函数"></a>8.2 为什么使用匿名函数</h3><ul><li>使用匿名函数 lambda，可以帮助我们大大简化代码的复杂度，提高代码的可读性。</li></ul><h3 id="8-3-函数式编程"><a href="#8-3-函数式编程" class="headerlink" title="8.3 函数式编程"></a>8.3 函数式编程</h3><ul><li><p>函数式编程，是指代码中每一块都是不可变的（immutable），都由纯函数（purefunction）的形式组成。这里的纯函数，是指函数本身相互独立、互不影响，对于相同的输入，总会有相同的输出，没有任何副作用。</p></li><li><p>函数式编程的优点，主要在于其纯函数和不可变的特性使程序更加健壮，易于调试（debug）和测试；缺点主要在于限制多，难写。</p></li><li><p>map(function, iterable) 函数</p><ul><li><p>对 iterable 中的每个元素，都运用 function 这个函数，最后返回一个新的可遍历的集合。</p><p>要对列表中的每个元素乘以 2，那么用 map 就可以表示为下面这样</p><pre><code class="hljs python">l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]new_list = <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x * <span class="hljs-number">2</span>, l) <span class="hljs-comment"># [2， 4， 6， 8， 10]</span></code></pre><p>我们可以以 map() 函数为例，看一下 Python 提供的函数式编程接口的性能。还是同样的列表例子，它还可以用 for 循环和 list comprehension（目前没有统一中文叫法，你也可以直译为列表理解等）实现，我们来比较一下它们的速度：</p><pre><code class="hljs shell">python3 -mtimeit -s&#x27;xs=range(1000000)&#x27; &#x27;map(lambda x: x*2, xs)&#x27;python3 -mtimeit -s&#x27;xs=range(1000000)&#x27; &#x27;[x * 2 for x in xs]&#x27;python3 -mtimeit -s&#x27;xs=range(1000000)&#x27; &#x27;l = []&#x27; &#x27;for i in xs: l.append(i * 2)&#x27;</code></pre><p><strong>map() 是最快的。因为 map() 函数直接由 C 语言写的，运行时不需要通过Python 解释器间接调用，并且内部做了诸多优化，所以运行速度最快。</strong></p></li></ul></li><li><p>filter(function, iterable) 函数</p><ul><li><p>它和 map 函数类似，function 同样表示一个函数对象。filter() 函数表示对 iterable 中的每个元素，都使用 function 判断，并返回True 或者 False，最后将返回 True 的元素组成一个新的可遍历的集合。</p><p>返回一个列表中的所有偶数，可以写成下面这样</p><pre><code class="hljs python">l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]new_list = <span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, l) <span class="hljs-comment"># [2, 4]</span></code></pre></li></ul></li><li><p>reduce(function, iterable) 函数</p><ul><li><p>function 同样是一个函数对象，规定它有两个参数，表示对 iterable 中的每个元素以及上一次调用后的结果，运用 function 进行计算，所以最后返回的是一个单独的数值。</p><pre><code class="hljs python">l = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]product = reduce(<span class="hljs-keyword">lambda</span> x, y: x * y, l) <span class="hljs-comment"># 1*2*3*4*5 = 120</span></code></pre></li></ul></li></ul><pre><code class="hljs ad-summary">匿名函数 lambda，它的主要用途是减少代码的复杂度。需要注意的是 lambda 是一个表达式，并不是一个语句；它只能写成一行的表达形式，语法上并不支持多行。匿名函数通常的使用场景是：程序中需要使用一个函数完成一个简单的功能，并且该函数只调用一次。Python 的函数式编程，主要了解了常见的 map()，fiilter() 和reduce() 三个函数，并比较了它们与其他形式（for 循环，comprehension）的性能，显然，它们的性能效率是最优的。</code></pre><h2 id="9-面向对象"><a href="#9-面向对象" class="headerlink" title="9. 面向对象"></a>9. 面向对象</h2><h3 id="9-1-基础"><a href="#9-1-基础" class="headerlink" title="9.1 基础"></a>9.1 基础</h3><ul><li>基本概念<ul><li>类，一群有着相同属性和函数的对象的集合。</li><li>对象：集合中的一个事物，这里对应由 class 生成的某一个 object。</li><li>属性：对象的某个静态特征。</li><li>函数：对象的某个动态能力。</li></ul></li></ul><h3 id="9-2-代码示例"><a href="#9-2-代码示例" class="headerlink" title="9.2 代码示例"></a>9.2 代码示例</h3><ul><li><p>如何在一个类中定义一些常量，每个对象都可以方便访问这些常量而不用重新构造？</p><p>在 Python 的类里，你只需要和函数并列地声明并赋值，就可以实现这一点，例如这段代码中的 WELCOME_STR。一种很常规的做法，是用全大写来表示常量，因此我们可以在类中使用 self.WELCOME_STR ，或者在类外使用 Entity.WELCOME_STR ，来表达这个字符串。</p></li><li><p>如果一个函数不涉及到访问修改这个类的属性，而放到类外面有点不恰当，怎么做才能更优雅呢？</p><p>提出了类函数、成员函数和静态函数三个概念。它们其实很好理解，前两者产生的影响是动态的，能够访问或者修改对象的属性；而静态函数则与类没有什么关联，最明显的特征便是，静态函数的第一个参数没有任何特殊性。</p><pre><code class="hljs python"><span class="hljs-comment"># 类函数</span><span class="hljs-meta">@classmethod</span><span class="hljs-comment"># 静态函数</span><span class="hljs-meta">@staticmethod</span></code></pre><ul><li><p>一般而言，静态函数可以用来做一些简单独立的任务，既方便测试，也能优化代码结构。静态函数还可以通过在函数前一行加上 @staticmethod 来表示</p></li><li><p>类函数的第一个参数一般为 cls，表示必须传一个类进来。类函数最常用的功能是实现不同的 init 构造函数,类函数需要装饰器 @classmethod 来声明</p></li><li><p>成员函数则是我们最正常的类的函数，它不需要任何装饰器声明，第一个参数 self 代表当前对象的引用，可以通过此函数，来实现想要的查询 / 修改类的属性等功能。</p></li></ul></li><li><p>既然类是一群相似的对象的集合，那么可不可以是一群相似的类的集合呢？</p></li></ul><h3 id="9-3-继承"><a href="#9-3-继承" class="headerlink" title="9.3 继承"></a>9.3 继承</h3><ul><li>类的继承，顾名思义，指的是一个类既拥有另一个类的特征，也拥有不同于另一个类的独特特征。在这里的第一个类叫做子类，另一个叫做父类，特征其实就是类的属性和函数。</li><li>首先需要注意的是构造函数。每个类都有构造函数，继承类在生成对象的时候，是不会自动调用父类的构造函数的，因此你必须在 init() 函数中显式调用父类的构造函数。它们的执行顺序是 子类的构造函数 -&gt; 父类的构造函数。</li><li>减少重复的代码，降低系统的熵值（即复杂度）。</li><li>抽象类是一种特殊的类，它生下来就是作为父类存在的，一旦对象化就会报错。同样，抽象函数定义在抽象类之中，子类必须重写该函数才能使用。相应的抽象函数，则是使用装饰器@abstractmethod 来表示。</li><li><strong>软件工程中一个很重要的概念，定义接口</strong></li><li><strong>抽象类就是这么一种存在，它是一种自上而下的设计风范，你只需要用少量的代码描述清楚要做的事情，定义好接口，然后就可以交给不同开发人员去开发和对接。</strong></li></ul><pre><code class="hljs ad-summary">面向对象编程是软件工程中重要的思想。正如动态规划是算法中的重要思想一样，它不是某一种非常具体的技术，而是一种综合能力的体现，是将大型工程解耦化、模块化的重要方法。在实践中要多想，尤其是抽象地想，才能更快掌握这个技巧。</code></pre><h2 id="10-面向对象-实现一个搜索引擎"><a href="#10-面向对象-实现一个搜索引擎" class="headerlink" title="10. 面向对象 - 实现一个搜索引擎"></a>10. 面向对象 - 实现一个搜索引擎</h2><h3 id="10-1-基础"><a href="#10-1-基础" class="headerlink" title="10.1 基础"></a>10.1 基础</h3><ul><li>一个搜索引擎由搜索器、索引器、检索器和用户接口四个部分组成。</li><li>搜索器，通俗来讲就是我们常提到的爬虫（scrawler），它能在互联网上大量爬取各类网站的内容，送给索引器。索引器拿到网页和内容后，会对内容进行处理，形成索引（index），存储于内部的数据库等待检索。</li></ul><h3 id="10-2-Bag-of-Words-和-Inverted-Index"><a href="#10-2-Bag-of-Words-和-Inverted-Index" class="headerlink" title="10.2 Bag of Words 和 Inverted Index"></a>10.2 Bag of Words 和 Inverted Index</h3><ul><li>BOW Model，即 <a href="https://en.wikipedia.org/wiki/Bag-of-words_model">Bag of Words Model</a>，词袋模型</li><li>Inverted Index Model，即倒序索引，是非常有名的搜索引擎方法</li></ul><h3 id="10-3-LRU-和多重继承"><a href="#10-3-LRU-和多重继承" class="headerlink" title="10.3 LRU 和多重继承"></a>10.3 LRU 和多重继承</h3><ul><li>LRU 缓存是一种很经典的缓存（同时，LRU 的实现也是硅谷大厂常考的算法面试题，这里为了简单，我直接使用 pylru 这个包），它符合自然界的局部性原理，可以保留最近使用过的对象，而逐渐淘汰掉很久没有被用过的对象。</li><li>多重继承有两种初始化方法<ul><li>第一种，super(BOWInvertedIndexEngineWithCache, self).<strong>init</strong>()直接初始化该类的第一个父类，不过使用这种方法时，要求继承链的最顶层父类必须要继承object；</li><li>第二种，对于多重继承，如果有多个构造函数需要调用， 我们就必须用传统的方法LRUCache.<strong>init</strong>(self) </li></ul></li><li></li></ul><h2 id="11-Python-模块化"><a href="#11-Python-模块化" class="headerlink" title="11. Python 模块化"></a>11. Python 模块化</h2><h3 id="11-1-简单模块化"><a href="#11-1-简单模块化" class="headerlink" title="11.1 简单模块化"></a>11.1 简单模块化</h3><ul><li>最简单的模块化方式，你可以把函数、类、常量拆分到不同的文件，把它们放在同一个文件夹，然后使用 from your_file import function_name, class_name 的方式调用。之后，这些函数和类就可以在文件内直接使用了。</li><li>import 同一个模块只会被执行一次，这样就可以防止重复导入模块出现问题。当然，良好的编程习惯应该杜绝代码多次导入的情况。在 Facebook 的编程规范中，除了一些极其特殊的情况，import 必须位于程序的最前端。</li><li>在 Python 3 规范中，<strong>init</strong>.py 并不是必须的</li></ul><h3 id="11-2-项目模块化"><a href="#11-2-项目模块化" class="headerlink" title="11.2 项目模块化"></a>11.2 项目模块化</h3><ul><li><p>固定一个确定路径对大型工程来说是非常必要的</p></li><li><p>事实上，在 Facebook 和 Google，整个公司都只有一个代码仓库，全公司的代码都放在这个库里</p><ul><li>第一个优点，简化依赖管理。整个公司的代码模块，都可以被你写的任何程序所调用，而你写的库和模块也会被其他人调用。调用的方式，都是从代码的根目录开始索引，也就是前面提到过的相对的绝对路径。这样极大地提高了代码的分享共用能力，你不需要重复造轮子，只需要在写之前，去搜一下有没有已经实现好的包或者框架就可以了。</li><li>第二个优点，版本统一。不存在使用了一个新模块，却导致一系列函数崩溃的情况；并且所有的升级都需要通过单元测试才可以继续。</li><li>第三个优点，代码追溯。你可以很容易追溯，一个 API 是从哪里被调用的，它的历史版本是怎样迭代开发，产生变化的。</li></ul></li><li><p>Python 解释器在遇到 import 的时候，它会在一个特定的列表中寻找模块。这个特定的列表，可以用下面的方式拿到：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> sysprint(sys.path)</code></pre><p>它的第一项为空。其实，Pycharm 做的一件事，就是将第一项设置为项目根目录的绝对地址。这样，每次你无论怎么运行 main.py，import 函数在执行的时候，都会去项目根目录中找相应的包。</p></li><li><p>使得普通的 Python 运行环境也能做到？这里有两种方法可以做到：</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> syssys.path[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;/home/ubuntu/workspace/your_projects&#x27;</span></code></pre><p>第一种方法，“大力出奇迹”，我们可以强行修改这个位置，这样，你的 import 接下来肯定就畅通无阻了。但这显然不是最佳解决方案，把绝对路径写到代码里，是我非常不推荐的方式（你可以写到配置文件中，但找配置文件也需要路径寻找，于是就会进入无解的死循环）。</p><p>第二种方法，是修改 PYTHONHOME。这里我稍微提一下 Python 的 Virtual Environment（虚拟运行环境）</p><p>回到第二种修改方法上。在一个 Virtual Environment 里，你能找到一个文件叫activate，在这个文件的末尾，填上下面的内容：</p><pre><code class="hljs python">export PYTHONPATH=<span class="hljs-string">&quot;/home/ubuntu/workspace/your_projects&quot;</span></code></pre><p>这样，每次你通过 activate 激活这个运行时环境的时候，它就会自动将项目的根目录添加到搜索路径中去。</p></li></ul><h3 id="11-3-神奇的-if-name-‘main‘"><a href="#11-3-神奇的-if-name-‘main‘" class="headerlink" title="11.3 神奇的 if name == ‘main‘"></a>11.3 神奇的 if <strong>name</strong> == ‘<strong>main</strong>‘</h3><ul><li><p>Python 是脚本语言，和 C++、Java 最大的不同在于，不需要显式提供 main() 函数入口</p></li><li><p>import 在导入文件的时候，会自动把所有暴露在外面的代码全都执行一遍。因此，如果你要把一个东西封装成模块，又想让它可以执行的话，你必须将要执行的代码放在 if _<em>name__ == ‘_<em>main</em></em>‘下面。</p></li><li><p>__name__ 作为 Python 的魔术内置参数，本质上是模块对象的一个属性。我们使用 import 语句时，<strong>name</strong> 就会被赋值为该模块的名字，自然就不等于__main__了。</p><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span></code></pre></li></ul><pre><code class="hljs ad-summary">1. 通过绝对路径和相对路径，我们可以 import 模块；2. 在大型工程中模块化非常重要，模块的索引要通过绝对路径来做，而绝对路径从程序的根目录开始；3. 记着巧用if __name__ &#x3D;&#x3D; &#39;__main__&#39;来避开 import 时执行。</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>02 Kubernetes</title>
    <link href="/2022/01/07/cloud/K8S/K8S-M/02%20Kubernetes/"/>
    <url>/2022/01/07/cloud/K8S/K8S-M/02%20Kubernetes/</url>
    
    <content type="html"><![CDATA[<h1 id="02-Kubernetes"><a href="#02-Kubernetes" class="headerlink" title="02 Kubernetes"></a>02 <a href="https://kubernetes.io/">Kubernetes</a></h1><blockquote><p><a href="https://cncf.io/">CNCF</a></p><p><a href="https://landscape.cncf.io/">生态图</a></p></blockquote><h2 id="1-基于dockerfile构建nginx镜像"><a href="#1-基于dockerfile构建nginx镜像" class="headerlink" title="1. 基于dockerfile构建nginx镜像"></a>1. 基于dockerfile构建nginx镜像</h2><h3 id="1-1-编写-dockerfile"><a href="#1-1-编写-dockerfile" class="headerlink" title="1.1 编写 dockerfile"></a>1.1 编写 dockerfile</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> Nginx image</span>FROM ubuntu:20.04LABEL &quot;maintainer&quot;=&quot;1ch0 github1ch0@163.com&quot;<span class="hljs-meta">#</span><span class="bash"> COPY sources.list /etc/apt/sources.list</span>RUN apt update &amp;&amp; apt install -y iproute2 ntpdate tcpdump telnet traceroute nfs-kernel-server nfs-common lrzsz tree openssl libssl-dev libpcre3 libpcre3-dev zlib1g-dev gcc openssh-server iotop unzip zip make vim &amp;&amp; mkdir -p /data/nginxADD nginx-1.20.2.tar.gz /usr/local/srcRUN cd /usr/local/src/nginx-1.20.2 &amp;&amp; ./configure --prefix=/apps/nginx &amp;&amp; make &amp;&amp; make install &amp;&amp; ln -sv /apps/nginx/sbin/nginx /usr/bin &amp;&amp; rm -rf /usr/local/src/nginx-1.20.2 &amp;&amp; rm -rf /usr/local/src/nginx-1.20.2.tar.gz<span class="hljs-meta">#</span><span class="bash"> ADD nginx.conf /apps/nginx/conf/nginx.conf</span><span class="hljs-meta">#</span><span class="bash"> ADD static.tar.gz /data/nginx/html</span>RUN ln -sv /dev/stdout /apps/nginx/logs/access.logRUN ln -sv /dev/stderr /apps/nginx/logs/error.log<span class="hljs-meta">#</span><span class="bash"> sed -i -E <span class="hljs-string">&#x27;s,listen 80;,listen 80;\n listen [::]:80;,&#x27;</span> /etc/nginx/conf.d/default.conf</span>RUN groupadd -g 2022 nginx &amp;&amp; useradd -g nginx -s /usr/sbin/nologin -u 2022 nginx &amp;&amp; chown -R nginx.nginx /apps/nginx /data/nginxEXPOSE 80 443STOPSIGNAL SIGTERMCMD [&quot;/apps/nginx/sbin/nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></pre><h3 id="1-2-编写-build-image-sh"><a href="#1-2-编写-build-image-sh" class="headerlink" title="1.2 编写 build_image.sh"></a>1.2 编写 build_image.sh</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash">***********************************************************************</span><span class="hljs-meta">#</span><span class="bash">         Author:            1ch0</span><span class="hljs-meta">#</span><span class="bash">         Date:              2022-01-07</span><span class="hljs-meta">#</span><span class="bash">         FileName:          build_image.sh</span><span class="hljs-meta">#</span><span class="bash">         Description:       1ch0 script</span><span class="hljs-meta">#</span><span class="bash">         Blog:               https://1ch0.github.io/</span><span class="hljs-meta">#</span><span class="bash">         Copyright (C): 2022 All rights reserved</span><span class="hljs-meta">#</span><span class="bash">***********************************************************************</span><span class="hljs-meta">#</span><span class="bash"> TAG=<span class="hljs-variable">$1</span></span><span class="hljs-meta">#</span><span class="bash"> docker image build -t nginx:<span class="hljs-variable">$&#123;TAG&#125;</span> ./</span>images=(    &#x27;1ch0/nginx:ubuntu20.04&#x27;)for image in $&#123;images[@]&#125;; do    docker build -t &quot;$image&quot; .    docker push &quot;$image&quot;done</code></pre><h3 id="1-3-docker-test-sh"><a href="#1-3-docker-test-sh" class="headerlink" title="1.3 docker_test.sh"></a>1.3 docker_test.sh</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>image=$(grep -m 1 1ch0 build_image.sh | awk &#x27;&#123;print $1&#125;&#x27;)<span class="hljs-meta">#</span><span class="bash"> 删除字符中的首尾单引号</span>eval image=$imageecho -e &quot;running docker image: $image\n&quot;docker run -it --rm -p 8080:80 &quot;$image&quot; bash</code></pre><h2 id="2-资源限制"><a href="#2-资源限制" class="headerlink" title="2. 资源限制"></a>2. 资源限制</h2><h3 id="2-1-内存限制"><a href="#2-1-内存限制" class="headerlink" title="2.1 内存限制"></a>2.1 内存限制</h3><ul><li>-m</li></ul><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 限制容器最多使用 256M 内存</span>docker run -it --rm -m 256m --name 1ch0-test lorel/docker-stress-ng --vm 2 --vm-bytes 256M</code></pre><h3 id="2-2-CPU-限制"><a href="#2-2-CPU-限制" class="headerlink" title="2.2 CPU 限制"></a>2.2 CPU 限制</h3><ul><li>–cpus</li></ul><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 限制容器最多使用 2 核 CPU</span>docker run -it --rm --cpus 2 --name 1ch0-test lorel/docker-stress-ng --cpu 4 --vm 4</code></pre><h2 id="3-整理k8s-master和node节点各组件的功能"><a href="#3-整理k8s-master和node节点各组件的功能" class="headerlink" title="3. 整理k8s master和node节点各组件的功能"></a>3. 整理k8s master和node节点各组件的功能</h2><h3 id="3-1-kube-apiserver"><a href="#3-1-kube-apiserver" class="headerlink" title="3.1 kube-apiserver"></a><a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-apiserver/">3.1 kube-apiserver</a></h3><blockquote><p>Kubernetes API server 提供了 k8s 各类资源对象的增删改查及 watch 等 HTTP Rest 接口，这些对象包括 pods、services、replication、controllers 等，API server 为 REST 操作提供服务，并为集群的共享状态提供前端，所有其他组件都通过该前端进行交互</p></blockquote><ul><li><p>默认端口  6443，通过启动参数 “ –secure-port ” 的值来修改默认值</p></li><li><p>默认 IP 地址为非本地（Non-Localhost） 网络端口，通过启动参数 “–bind-address” 设置该值</p></li><li><p>该端口用于接收客户端、dashboard 等外部 HTTPS 请求</p></li><li><p>用于基于 Token 文案或客户端证书及 HTTP Base 的认证</p></li><li><p>用于基于策略的授权</p></li><li><p>整个 Kubernetes 集群入口，负责鉴权</p></li><li><p>与 node 节点持续交互</p></li><li><p>Kubernetes API 测试</p><pre><code class="hljs shell">curl --cacert /etc/kubernetes/ssl/ca.pem -H &quot;Authorization: Bearer $&#123;TOKEN&#125;&quot; https://172.16.0.4:6443curl 127.0.0.1:6443/ #返回所有的API列表curl 127.0.0.1:6443/apis #分组 APIcurl 127.0.0.1:6443/api/v1 # 带具体版本号的APIcurl 127.0.0.1:6443/version # API 版本信息curl 127.0.0.1:6443/healthz/etcd # 与 etcd 的心跳监测curl 127.0.0.1:6443/apis/autoscaling/v1 # API 的详细信息curl 127.0.0.1:6443/metrics # 指标数据</code></pre></li></ul><h3 id="3-3-kube-scheduler"><a href="#3-3-kube-scheduler" class="headerlink" title="3.3 kube-scheduler"></a><a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-scheduler/">3.3 kube-scheduler</a></h3><blockquote><p> Kubernetes 调度器是一个控制面进程，负责将 Pods 指派到节点上。</p></blockquote><ul><li>通过调度算法为待调度 Pod 列表的每个 Pod 从可用 Node 列表中选择一个最适合的 Node，并将信息写入 etcd 中</li><li>node 节点上的 kubelet 通过 API Server 监听到 Kubernetes Scheduler 产生的 Pod 绑定信息，然后获取对应的 Pod 清单，下载 Image，并启动容器。</li><li>策略：<ul><li>LeastRequestedPriority：优先从备选节点列表汇总选择资源消耗最小的节点（CPU+内存）<ol><li>先配出不符合条件的节点</li><li>在剩余的可用选出一个最符合条件的节点</li></ol></li><li>CalculateNodeLabelPriority：优先选择含有指定 Label 的节点</li><li>BalancedResourceAllocation：优先从备选节点列表中选择各项资源使用率最均衡的节点</li></ul></li></ul><h3 id="3-2-kube-controller-manager"><a href="#3-2-kube-controller-manager" class="headerlink" title="3.2 kube-controller-manager"></a><a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kube-controller-manager/">3.2 kube-controller-manager</a></h3><blockquote><p>Controller Manager 还包括一些子控制器（副本控制器、节点控制器、命名开工阿金开工至器和服务账号控制器等），控制器作为集群内部的管理控制中心，负责集群内的 Node、Pod 副本、服务端点（Endpoint）、命名空间（Namespace）、服务账号（ServiceAccount）、资源定额（ResourceQuota）的管理，当某个 Node 意外宕机时， Controller Manager 会即使发现并执行自动化修复流程，确保集群中的 pod 副本始终处于与其的工作状态。</p></blockquote><ul><li>Controller Manager 每间隔 5 秒检查一次节点的状态</li><li>如果 Controller Manager 控制器没有收到自节点的心跳，则将该 node 节点被标记位不可达。</li><li>Controller Manager 将在标记为无法访问之前等待 40 秒</li><li>如果该 node 节点被标记为无法访问后 5 分钟还没有恢复，Controller Manager 会删除当前 node 节点的所有 pod 并在其它可用节点重建这些 pod </li><li>pod 高考用机制<ul><li>ndoe monitor period：节点监视周期 5s</li><li>node monitor grace period：节点监视器宽限期 40s</li><li>pod eviction timeout：pod 驱逐超时时间 5m</li></ul></li></ul><h3 id="3-4-kube-proxy"><a href="#3-4-kube-proxy" class="headerlink" title="3.4 kube-proxy"></a><a href="https://kubernetes.io/docs/reference/config-api/">3.4 kube-proxy</a></h3><blockquote><p>Kubernetes 网络代理运行在 node 上，它反映了 node 上 Kubernetes API 中定义的服务，并可以通过一组后盾进行简单的 TCP、UDP 和 SCTP 流转发或者在一组后端进行循环 TCP、UDP 和 SCTP 转发，yognhu8必须使用 apiserver API 创建一个服务来配置代理，其实就是 kube proxy 通过在主机上维护网络规则并执行廉洁转发来实现 Kubernetes 服务访问</p></blockquote><ul><li><p>kube proxy 运行在每个节点上，监听 API Server 中服务对象的变化，再通过管理 IPtables 或者 IPVS 规则来实现网络的转发</p></li><li><p>和 apiserver 进行交互，将请求写到 etcd，用来维护网络规则</p></li><li><p>kube proxy 不同的版本可支持三种工作模式</p><ul><li>UserSpace：k8s v1.1之前使员工，k8s 1.2及以后就已经淘汰</li><li>IPtables：k8s 1.1版本开始支持，1.2 开始为默认</li><li>IPVS：k8s 1.9 引入到 1.11 为正式版本，需要安装 ipvsadm、ipset 工具包和加载 ip_vs 内核模块</li></ul></li><li><p>IPVS 相对 IPTables 效率会更高一些，使用 IPVS 模式需要在运行 kube proxy 的节点上安装 ipvsadm 、ipset 工具包和加载 ip_vs 内核模块，当 kube proxy 以 IPVS 代理模式启动时，kube proxy 将验证节点上是否安装了 IPVS 模块，如果未安装，则 kube proxy 将回退到 IPTables 代理模式</p></li><li><p>使用 IPVS 模式，kube proxy 会监视 Kubernetes Service 对象和 Endpoints，调用宿主机内核 Netlink 接口以相应地创建 IPVS 规则并定期与 Kubernetes Service 对象 Endpoints 对象同步 IPVS 规则，以确保 IPVS 状态与期望一直，访问服务时，流量将被重定向到其中一个后端 Pod，IPVS 规则，以确保 IPVS 状态与期望一致，访问服务时，流量将被重定向到其中一个后端 Pod，IPVS 使用哈希表作为底层数据结构并在内核开工阿金中工作，这意味着 IPVS 可以更快的重定向流量，兵器在同步代理规则时具有更好的性能，此外，IPVS 为负载均衡算法提供了更多选项，例如：rr（轮训调度）、lc（最小连接数）、dh（目标哈希）、sh（源哈希）、sed（最短期望延迟）、nq（不排队调度）等</p></li><li><p><a href="https://kubernetes.io/docs/reference/config-api/kube-proxy-config.v1alpha1/#ClientConnectionConfiguration">配置使用 IPVS 及制定调度算法</a></p><p>kube-proxy-config.yaml</p><pre><code class="hljs shell">kind: KubeProxyConfigurationapiVersion: Kubeproxy.config.k8s.io/v1alpha1bindAddress: 172.31.7.111clientConnectino:  kubeconfig: &quot;/etc/kubernetes/kube-proxy.kubeconfig&quot;clusterCIDR: &quot;10.100.0.0/16&quot;conntrack:  maxPerCore: 32768  min: 131072  tcpCloseWaitTimeout: 1h0m0s  tcpEstablishedTimeout: 24h0m0shealthzBinAddress: 172.31.7.111:10256hostnameOverride: &quot;172.31.7.111&quot;metricsBindAddress: 172.31.7.111:10249mode: &quot;ipvs&quot; # 指定使用 ipvs 及调度算法ipvs:  scheduler: sh</code></pre></li><li><p>开启会话保持</p><p>nginx-service.yaml</p><pre><code class="hljs shell">kind: ServiceapiVersion: v1metadata:  labels:    app: nginx-service-label  name: nginx-service  namespace: echocspec:  type: NOdePort  ports:  - name: http    port: 80    protocol: TCP    targetPort: 80    nodePort: 30004  selector:    app: nginx  sessionAffinity: ClientIP  sessionAffinityConfig:    clientIP:      timeoutSeconds: 1800</code></pre></li></ul><h3 id="3-5-kubelet"><a href="#3-5-kubelet" class="headerlink" title="3.5 kubelet"></a><a href="https://kubernetes.io/zh/docs/reference/command-line-tools-reference/kubelet/">3.5 kubelet</a></h3><blockquote><p>kubelet 是运行在每个 worker 节点的代理组件，它会监视已分配给节点的 pod</p><p>是一个通过命令行对 Kubernetes 集群进行管理的客户端工具</p></blockquote><ul><li>向 master 汇报 node 节点的状态信息</li><li>接收指令并在 pod 中创建 docker 容器</li><li>准备 pod 所需的数据卷</li><li>返回 pod 的运行状态</li></ul><h3 id="3-6-etcd"><a href="#3-6-etcd" class="headerlink" title="3.6 etcd"></a>3.6 etcd</h3><ul><li>在 node 节点执行容器健康检查</li></ul><h3 id="3-6-etcd-1"><a href="#3-6-etcd-1" class="headerlink" title="3.6 etcd"></a><a href="https://kubernetes.io/docs/tasks/administer-cluster/configure-upgrade-etcd/">3.6 etcd</a></h3><blockquote><p>etcd 是 CoreOS 公司开发，目前是 Kubernetes 默认使用 的 key-value 数据存储系统，用于保存 Kubernetes 的所有集群数据，etcd 支持分布式集群功能，生产环境使用时需要为 etcd 数据提供定期备份机制。</p><p>官网：<a href="https://etcd.io/">https://etcd.io/</a></p><p>github: <a href="https://github.com/etcd-io/etcd">https://github.com/etcd-io/etcd</a></p></blockquote><h3 id="3-7-组件"><a href="#3-7-组件" class="headerlink" title="3.7 组件"></a>3.7 组件</h3><h4 id="3-7-1-DNS"><a href="#3-7-1-DNS" class="headerlink" title="3.7.1 DNS"></a><a href="https://kubernetes.io/zh/docs/concepts/services-networking/dns-pod-service/">3.7.1 DNS</a></h4><blockquote><p>DNS 负责为整个集群提供 DNS 服务，从而实现服务之间的访问</p><p>coredns</p><p>kube-dns: 1.18</p><p>sky-dns</p></blockquote><h4 id="3-7-2-Dashboard"><a href="#3-7-2-Dashboard" class="headerlink" title="3.7.2 Dashboard"></a>3.7.2 Dashboard</h4><blockquote><p>Dashboard 是基于网页的 Kubernetes 用户界面，可以使用 Dashboard 获取运行在集群中的应用的概览信息，也可以创建或者修改 Kubernetes 资源（如 Deployment、Job、DaemonSet 等等），也可以对 Deployment 实现弹性伸缩、发起滚动升级、重启 Pod 或者使用向导创建新的应用。</p></blockquote><h2 id="4-部署高可用的k8s集群"><a href="#4-部署高可用的k8s集群" class="headerlink" title="4. 部署高可用的k8s集群"></a>4. 部署高可用的k8s集群</h2><h3 id="4-1-使用-sealos-安装k8s"><a href="#4-1-使用-sealos-安装k8s" class="headerlink" title="4.1 使用 sealos 安装k8s"></a>4.1 使用 sealos 安装k8s</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 下载并安装sealos, sealos是个golang的二进制工具，直接下载拷贝到bin目录即可, release页面也可下载</span>wget -c https://sealyun.oss-cn-beijing.aliyuncs.com/latest/sealos &amp;&amp; \    chmod +x sealos &amp;&amp; mv sealos /usr/bin<span class="hljs-meta">#</span><span class="bash"> 下载离线资源包</span>wget -c https://sealyun.oss-cn-beijing.aliyuncs.com/05a3db657821277f5f3b92d834bbaf98-v1.22.0/kube1.22.0.tar.gz<span class="hljs-meta">#</span><span class="bash"> 安装一个三master的kubernetes集群</span>sealos init --passwd &#x27;123456&#x27; \--master 192.168.0.2  --master 192.168.0.3  --master 192.168.0.4  \--node 192.168.0.5 \--pkg-url /root/kube1.22.0.tar.gz \--version v1.22.0</code></pre><p>安装结果</p><p><img src="https://raw.githubusercontent.com/1ch0/Figure-bed/main/img/k8s_M_demo.png"></p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>shell脚本</title>
    <link href="/2022/01/05/linux/tmp/shell/shell%E8%84%9A%E6%9C%AC/"/>
    <url>/2022/01/05/linux/tmp/shell/shell%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h1 id="Shell-脚本"><a href="#Shell-脚本" class="headerlink" title="Shell 脚本"></a>Shell 脚本</h1><h2 id="1-基础入门及变量使用"><a href="#1-基础入门及变量使用" class="headerlink" title="1. 基础入门及变量使用"></a>1. 基础入门及变量使用</h2><h3 id="1-1-正则元字符"><a href="#1-1-正则元字符" class="headerlink" title="1.1 正则元字符"></a>1.1 正则元字符</h3><table><thead><tr><th>符号</th><th>描述</th><th>示例</th></tr></thead><tbody><tr><td>.</td><td>任意一个字符</td><td>—</td></tr><tr><td>*</td><td>前面的字符重复任意次</td><td>x*     xxxxx…</td></tr><tr><td>()*</td><td>字符串重复任意次</td><td>(shell)* shellshell…</td></tr><tr><td>+ 或 {1,}</td><td>前面字符重复一次以上</td><td>x+</td></tr><tr><td>?</td><td>前面字符重复0次或1次</td><td>x?</td></tr><tr><td>^</td><td>行首</td><td>—</td></tr><tr><td>$</td><td>行尾</td><td>—</td></tr><tr><td>&lt; 或 \b</td><td>单词词首</td><td>—</td></tr><tr><td>&gt; 或 \b</td><td>单词词尾</td><td>—</td></tr><tr><td>[]</td><td>字符中任意一个字符</td><td>[shell]  -&gt; s h e l l</td></tr><tr><td>[^.]</td><td>除了 . 之外的字符</td><td>—</td></tr><tr><td>[:alpha:]</td><td>关键字</td><td>—</td></tr><tr><td>|</td><td>或</td><td>a|bx,  (a|b)xy</td></tr><tr><td>{n,}</td><td>最少多少次</td><td>—</td></tr><tr><td>{,n}</td><td>最多多少次</td><td>—</td></tr><tr><td>{m,n}</td><td>m 次到 n 次</td><td>—</td></tr><tr><td>{m}</td><td>精确匹配多少次</td><td></td></tr><tr><td>(expr1)(expr2) \1 \2</td><td></td><td></td></tr><tr><td>&amp;</td><td>前面表达式的结果</td><td></td></tr></tbody></table><h4 id="1-1-1-示例"><a href="#1-1-1-示例" class="headerlink" title="1.1.1 示例"></a>1.1.1 示例</h4><pre><code class="hljs shell">ifconfig|egrep -o &quot;\&lt;(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.)&#123;3&#125;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&quot;ifconfig eth0|egrep -o &quot;\&lt;(([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.)&#123;3&#125;([0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\&gt;&quot;</code></pre><table><thead><tr><th>内容</th><th>正则</th></tr></thead><tbody><tr><td>0-9</td><td>[0-9]</td></tr><tr><td>10-99</td><td>[1-9][0-9]</td></tr><tr><td>100-199</td><td>1[0-9][0-9]</td></tr><tr><td>200-249</td><td>2[0-4][0-9]</td></tr><tr><td>250-255</td><td>25[0-5]</td></tr></tbody></table><h3 id="1-2-执行脚本的方法"><a href="#1-2-执行脚本的方法" class="headerlink" title="1.2 执行脚本的方法"></a>1.2 执行脚本的方法</h3><ul><li><p>bash hello.sh</p></li><li><p>cat hello | bash</p></li></ul><h4 id="1-2-1-将脚本放到-PATH-变量目录下"><a href="#1-2-1-将脚本放到-PATH-变量目录下" class="headerlink" title="1.2.1 将脚本放到 $PATH 变量目录下"></a>1.2.1 将脚本放到 $PATH 变量目录下</h4><ul><li>echo $PATH（ubuntu下移动后执行提示 permission denied）</li><li>第一次执行加载到系统 hash</li><li>后续脚本文件夹移动系统hash不变会出错，需要删除 hash ， hash -d hello.sh</li></ul><h4 id="1-2-2-修改-vimrc"><a href="#1-2-2-修改-vimrc" class="headerlink" title="1.2.2 修改 .vimrc"></a>1.2.2 修改 .vimrc</h4><pre><code class="hljs shell">git clone --depth=1 https://hub.fastgit.org/amix/vimrc.git ~/.vim_runtimesh ~/.vim_runtime/install_awesome_vimrc.shgit clone https://hub.fastgit.org/k-takata/minpac.git \    ~/.vim/pack/minpac/opt/minpac    tee -a ~/.vimrc &lt;&lt; EOFif exists(&#x27;g:loaded_minpac&#x27;)  &quot; Minpac is loaded.  call minpac#init()  call minpac#add(&#x27;k-takata/minpac&#x27;, &#123;&#x27;type&#x27;: &#x27;opt&#x27;&#125;)  &quot; Other pluginsendifif has(&#x27;eval&#x27;)  &quot; Minpac commands  command! PackUpdate packadd minpac | source $MYVIMRC | call minpac#update()  command! PackClean packadd minpac | source $MYVIMRC | call minpac#clean()  command! PackStatus packadd minpac | source $MYVIMRC | call minpac#status()endifEOF</code></pre><h3 id="1-3-错误类型"><a href="#1-3-错误类型" class="headerlink" title="1.3 错误类型"></a>1.3 错误类型</h3><h4 id="1-3-1-命令错误"><a href="#1-3-1-命令错误" class="headerlink" title="1.3.1 命令错误"></a>1.3.1 命令错误</h4><p>命令继续执行</p><h4 id="1-3-2-语法错误"><a href="#1-3-2-语法错误" class="headerlink" title="1.3.2 语法错误"></a>1.3.2 语法错误</h4><p>错误不继续执行</p><h4 id="1-3-3-脚本调试"><a href="#1-3-3-脚本调试" class="headerlink" title="1.3.3 脚本调试"></a>1.3.3 脚本调试</h4><pre><code class="hljs shell">bash -n # 检测语法错误bash -x # 调试执行</code></pre><h3 id="1-4-变量"><a href="#1-4-变量" class="headerlink" title="1.4 变量"></a>1.4 变量</h3><pre><code class="hljs shell">name=`hostname` # 将命令执行结果赋值给变量，但是结果只有一行，输出时 &quot;$name&quot; 保留格式</code></pre><h4 id="1-4-1-命名规则："><a href="#1-4-1-命名规则：" class="headerlink" title="1.4.1 命名规则："></a>1.4.1 命名规则：</h4><ul><li>bash 不支持浮点数</li><li>不要使用保留字</li><li>不能以数字开头，只能数字、字母、下划线</li><li>统一命名规则：驼峰命名法</li></ul><h4 id="1-4-2-变量的种类"><a href="#1-4-2-变量的种类" class="headerlink" title="1.4.2 变量的种类"></a>1.4.2 变量的种类</h4><ul><li>局部变量  在当前进程有效，子进程定义的变量不能传给父进程</li><li>全局变量 父进程可以传给子进程。</li><li>环境变量 export name=</li></ul><pre><code class="hljs shell">echo $PIDecho $$echo $PPIDpstree -p</code></pre><h4 id="1-4-3-变量引用"><a href="#1-4-3-变量引用" class="headerlink" title="1.4.3 变量引用"></a>1.4.3 变量引用</h4><ul><li>${name}  $name</li><li>“ “ : 弱引用，其中的变量引用会被替换为变量值</li></ul><h4 id="1-4-4-变量删除"><a href="#1-4-4-变量删除" class="headerlink" title="1.4.4 变量删除"></a>1.4.4 变量删除</h4><ul><li>局部变量退出子进程</li><li>unset name</li></ul><h2 id="2-脚本编程及变量详解"><a href="#2-脚本编程及变量详解" class="headerlink" title="2. 脚本编程及变量详解"></a>2. 脚本编程及变量详解</h2><h3 id="2-1-脚本编写"><a href="#2-1-脚本编写" class="headerlink" title="2.1 脚本编写"></a>2.1 脚本编写</h3><h4 id="2-1-1-脚本编写"><a href="#2-1-1-脚本编写" class="headerlink" title="2.1.1 脚本编写"></a>2.1.1 脚本编写</h4><pre><code class="hljs shell">lsblk|grep &quot;^vd&quot;|tr -s &quot; &quot;|cut -d&quot; &quot; -f4echo $SHLVL  #查看嵌套深度</code></pre><h3 id="2-2-变量"><a href="#2-2-变量" class="headerlink" title="2.2 变量"></a>2.2 变量</h3><h4 id="2-2-1-常量定义"><a href="#2-2-1-常量定义" class="headerlink" title="2.2.1 常量定义"></a>2.2.1 常量定义</h4><pre><code class="hljs shell">readonly name=testdeclare -xs<span class="hljs-meta">#</span><span class="bash"> 查看常量</span>declare -rreadonly -p<span class="hljs-meta">#</span><span class="bash"> () 用法  开启子shell（不是子进程 pid与父pid值相等），不影响其他程序</span>(umask 666;touch /data/test)(cd /data/; rm -rf *)(name=test; echo $name)<span class="hljs-meta">#</span><span class="bash"> &#123;&#125;,  大括号不开启shell，影响其他程序</span></code></pre><h4 id="2-2-2-位置变量"><a href="#2-2-2-位置变量" class="headerlink" title="2.2.2 位置变量"></a>2.2.2 位置变量</h4><table><thead><tr><th>符号</th><th>意义</th></tr></thead><tbody><tr><td>$#</td><td>参数个数</td></tr><tr><td>$?</td><td>前一条命令是否成功。<br />0 成功，1-255 失败，<br />若为脚本，判断脚本最后一条命令<br />exit 10，返回10</td></tr><tr><td>$*</td><td>所有参数，全部参数合为一个字符串</td></tr><tr><td>$@</td><td>所有参数，每个参数为独立字符串</td></tr><tr><td>$0</td><td>命令本身，<br />加 `basename` 去除路径名<br />ln 软连接后显示软连接后文件名</td></tr><tr><td>$1</td><td>第一个字符串</td></tr><tr><td>${10}</td><td>第十个字符串</td></tr><tr><td>set –</td><td>清空位置参数</td></tr><tr><td>shift</td><td>丢弃第一个参数，参数整体左移一位</td></tr></tbody></table><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span><span class="hljs-meta">#</span><span class="hljs-meta">#</span><span class="bash">***********************************************************************</span><span class="hljs-meta">#</span><span class="bash">         Author:        1ch0</span><span class="hljs-meta">#</span><span class="bash">         Date:          2022-01-04</span><span class="hljs-meta">#</span><span class="bash">         FileName:      test.sh</span><span class="hljs-meta">#</span><span class="bash">         Description:   1ch0 script</span><span class="hljs-meta">#</span><span class="bash">         Copyright (C):2022 All rights reserved</span><span class="hljs-meta">#</span><span class="bash">***********************************************************************</span>echo &quot;1st arg is $1&quot;echo &quot;2st arg is $2&quot;echo &quot;name is `basename $0`&quot;echo &quot;name is $@&quot;shiftecho &quot;1st arg is $1&quot;echo &quot;2st arg is $2&quot;echo &quot;name is `basename $0`&quot;echo &quot;name is $@&quot;</code></pre><pre><code class="hljs shell">echo &#123;a..z&#125;<span class="hljs-meta">#</span><span class="bash"> 示例</span>scp $* root@ip:/bin/datascp.sh a test.sh</code></pre><h2 id="3-脚本逻辑运算和参数传递"><a href="#3-脚本逻辑运算和参数传递" class="headerlink" title="3. 脚本逻辑运算和参数传递"></a>3. 脚本逻辑运算和参数传递</h2><h3 id="3-1-逻辑运算"><a href="#3-1-逻辑运算" class="headerlink" title="3.1 逻辑运算"></a>3.1 逻辑运算</h3><h4 id="3-1-1-算术运算"><a href="#3-1-1-算术运算" class="headerlink" title="3.1.1 算术运算"></a>3.1.1 算术运算</h4><table><thead><tr><th>符号</th><th>名称</th></tr></thead><tbody><tr><td>+</td><td></td></tr><tr><td>-</td><td></td></tr><tr><td>*</td><td></td></tr><tr><td>/</td><td></td></tr><tr><td>%</td><td></td></tr><tr><td>**</td><td></td></tr><tr><td>++</td><td></td></tr><tr><td>–</td><td></td></tr><tr><td>^</td><td>异或</td></tr><tr><td>&amp;&amp;</td><td>短路与</td></tr><tr><td>||</td><td>短路或</td></tr></tbody></table><pre><code class="hljs shell">+ - * / %取模（取余） **（乘方）++ --  ^   &amp;&amp; 短路与，前面为0后面不执行  || 短路或help letlet var=expritionvar=$[expr]var=$((expr))var=$(expr arg1 arg2 arg3) // expr 1 + 2  expr 4 \* 3declare -i var=数组echo &#x27;expr&#x27;|bc乘法符号有些场景中需要转义，如 *bash 有内建的随机数生成器:<span class="hljs-meta">$</span><span class="bash">RANDOM(0-32767)</span>echo $[$RANDOM%50]: 0-49 之间随机数</code></pre><h4 id="3-1-2-逻辑运算"><a href="#3-1-2-逻辑运算" class="headerlink" title="3.1.2 逻辑运算"></a>3.1.2 逻辑运算</h4><ul><li><p>test 命令，help test</p></li><li><p>字符串比较  </p><table><thead><tr><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>相等</td></tr><tr><td>!=</td><td>不等</td></tr><tr><td>[]</td><td>是否为空l</td></tr><tr><td>=~</td><td>正则表达式</td></tr><tr><td>-w</td><td>可写</td></tr><tr><td>-d</td><td>是否为文件夹</td></tr><tr><td>-L</td><td>是否为软连接</td></tr></tbody></table><pre><code class="hljs shell">str1=aaastr2=bbbtest $str1 = $str2echo $?x=hh;y=hh;[ &quot;$x&quot; = &quot;$y&quot; ] &amp;&amp; echo equal || echo no equalx=11;y=22;[ &quot;$x&quot; -eq &quot;$y&quot; ] &amp;&amp; echo equal || echo no equal<span class="hljs-meta">#</span><span class="bash"> 判断数字为正数</span>[[ &quot;$n&quot; =~ ^[[:digit:]]+$ ]] &amp;&amp; echo digit || echo no digit[[ ! &quot;$n&quot; =~ ^[[:digit:]]+$ ]] &amp;&amp; echo digit || echo no digit</code></pre></li></ul><h3 id="3-2-示例"><a href="#3-2-示例" class="headerlink" title="3.2 示例"></a>3.2 示例</h3><pre><code class="hljs shell">ping -c4 ip &amp;&gt; /dev/nullecho $?</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 随机颜色</span>COLOR=$[RANDOM%7+31];echo -e &quot;\e[1;$&#123;COLOR&#125;mcolor\e[0m&quot;</code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>[[ &quot;$1&quot; =~ ^[[:digit:]]+$ ]] &amp;&amp; echo $1 no digit &amp;&amp; exit [[ &quot;$2&quot; =~ ^[[:digit:]]+$ ]] &amp;&amp; echo $2 no digit &amp;&amp; exit [ $# -ne 2] &amp;&amp; echo arg number is 2 &amp;&amp; exit a=&quot;`head -n$1 /etc/passwd | tail -n1| cut -d: -f3`&quot;b=&quot;`head -n$2 /etc/passwd | tail -n1| cut -d: -f3`&quot;let c=a+becho $c</code></pre><ul><li><p>判断是否为 sh后缀</p><pre><code class="hljs shell">[[ $filename =~ .+\.sh$ ]] &amp;&amp; echo sh &amp;&amp; echo no sh</code></pre></li><li><p>创建用户</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>id $1 &amp;&gt; /dev/null[ $? -eq 0 ] &amp;&amp; echo user is exist &amp;&amp; exituseradd $1echo test | passwd --stdin $2 &amp;&gt; /dev/nullecho &quot;$1 is created&quot;</code></pre></li><li><p>退出脚本要用 {} 而不是 ()</p></li></ul><h2 id="4-文本处理"><a href="#4-文本处理" class="headerlink" title="4. 文本处理"></a>4. 文本处理</h2><h3 id="4-1-cat-amp-paste"><a href="#4-1-cat-amp-paste" class="headerlink" title="4.1 cat &amp; paste"></a>4.1 cat &amp; paste</h3><h4 id="4-1-1-cat"><a href="#4-1-1-cat" class="headerlink" title="4.1.1 cat"></a>4.1.1 cat</h4><ul><li>横向合并</li></ul><h4 id="4-1-2-paste"><a href="#4-1-2-paste" class="headerlink" title="4.1.2 paste"></a>4.1.2 paste</h4><ul><li>纵向合并</li><li>-s 合并为一行</li><li>-d 指定分隔符</li></ul><h3 id="4-2-分析文本的工具"><a href="#4-2-分析文本的工具" class="headerlink" title="4.2 分析文本的工具"></a>4.2 分析文本的工具</h3><h4 id="4-2-1-文本数据统计-wc"><a href="#4-2-1-文本数据统计-wc" class="headerlink" title="4.2.1 文本数据统计  wc"></a>4.2.1 文本数据统计  wc</h4><ul><li>几行  几个单词（空格分隔）  几个字节 文件名</li><li>ls | wc</li><li>-c bytes</li><li>-m chars</li><li>-l  lines </li><li>-w  words</li><li>-L 打印最长的长度</li></ul><h4 id="4-2-2-整理文本-sort"><a href="#4-2-2-整理文本-sort" class="headerlink" title="4.2.2 整理文本   sort"></a>4.2.2 整理文本   sort</h4><ul><li>-t  指定分隔符</li><li>-n 指定数字</li><li>-r 倒序排</li><li>-u 去重</li><li>-R 随机排序</li></ul><h4 id="4-2-3-uniq"><a href="#4-2-3-uniq" class="headerlink" title="4.2.3 uniq"></a>4.2.3 uniq</h4><ul><li>将相邻重复行合并成一行</li><li>-c 合并了哪行</li><li>-u  只显示相邻不重复行</li><li>默认读取键盘输入</li></ul><h4 id="4-2-4-比较文件-diff-和-patch"><a href="#4-2-4-比较文件-diff-和-patch" class="headerlink" title="4.2.4 比较文件  diff 和 patch"></a>4.2.4 比较文件  diff 和 patch</h4><ul><li>diff   比较文件区别</li><li>diff -u   多出时间<ul><li>diff -u  a  b &gt;  c</li></ul></li><li>patch  根据 diff 内容恢复文件</li><li>patch -b   做备份  .orig<ul><li>patch b c</li></ul></li></ul><h4 id="4-2-5-示例"><a href="#4-2-5-示例" class="headerlink" title="4.2.5 示例"></a>4.2.5 示例</h4><ul><li><p>sort</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> pv page view</span>cat /var/log/httpd/access_log|wc -lsort -t: -k3 /etc/passwd</code></pre></li><li><p>分区磁盘占用最大值</p><pre><code class="hljs shell">df | tr -s &#x27; &#x27; %| cut -d% -f5 | sort -nr| head -n1</code></pre></li><li><p>查看连接数</p><pre><code class="hljs shell">last|tr -s &#x27; &#x27;|cut -d &#x27; &#x27; -f3|sort|uniq -c|sort -n -rlastb|tr -s &#x27; &#x27;|cut -d &#x27; &#x27; -f3|sort|uniq -c|sort -n -rlastb|tr -s &#x27; &#x27;|cut -d &#x27; &#x27; -f3|sort|uniq -c|sort -n -r|tr -s &#x27; &#x27;|cut -d &#x27; &#x27; -f3vim /etc/hosts.denytee -a /etc/hosts.deny &lt;&lt; EOFsshd: 120.246.107.20sshd: 111.9.176.12sshd: 220.174.25.172sshd: 200.239.5.165sshd: 120.246.107.20sshd: 180.76.146.237EOF</code></pre></li><li><p>seq</p><pre><code class="hljs shell">seq 100 | sort -R | head -n1</code></pre></li><li><p>cut</p><pre><code class="hljs shell">cut -d: -f1,3 /etc/passwd | sort -t: -k2 -nr</code></pre></li><li><p>uniq</p><pre><code class="hljs shell">cat /var/log/httpd/access_log|cut -d&quot; &quot; -f1 | sort|uniq -c |sort -nr |head</code></pre></li></ul><h2 id="5-Linux-文本处理三剑客"><a href="#5-Linux-文本处理三剑客" class="headerlink" title="5. Linux 文本处理三剑客"></a>5. Linux 文本处理三剑客</h2><h3 id="5-1-grep"><a href="#5-1-grep" class="headerlink" title="5.1 grep"></a>5.1 grep</h3><h3 id="5-2-sed"><a href="#5-2-sed" class="headerlink" title="5.2 sed"></a>5.2 sed</h3><ul><li>用于文本内容做替换</li></ul><pre><code class="hljs sh">sed <span class="hljs-string">&#x27;/user1/s/user1/u1/&#x27;</span> /etc/passwd</code></pre><ul><li><p>基本工作方式</p><ul><li>将文件以行为单位读取到内存（模式空间）</li><li>使用 sed 的每个脚本对该行进行操作</li><li>处理完成后输出该行</li></ul></li><li><p>替换命令 s</p><ul><li>sed ‘s/lod/new/‘ filename</li><li>sed -e ‘s/lod/new/‘ -e ‘s/lod/new/‘ filename …</li><li>sed -i  ‘s/lod/new/‘ ‘s/lod/new/‘ filename … 替换并写入</li></ul></li><li><p>带正则表达式的替换命令 s</p><ul><li>sed ‘s/正则表达式/new/‘ filename</li><li>sed -r ‘s/扩展正则表达式/new/‘ filename</li></ul></li></ul><h3 id="5-3-awk"><a href="#5-3-awk" class="headerlink" title="5.3 awk"></a>5.3 awk</h3><ul><li>用于对文本内容进行统计、按需要的格式进行输出</li></ul><pre><code class="hljs sh">awk -F: <span class="hljs-string">&#x27;/wd$/&#123;print$1&#125;&#x27;</span> /etc/passwd</code></pre><pre><code class="hljs ad-summayl">ifconfig eth0| grep --color &quot;\([0-9]\&#123;1,3\&#125;\.\)\&#123;3\&#125;[0-9]\&#123;1,3\&#125;&quot;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令</title>
    <link href="/2022/01/05/linux/tmp/shell/Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/01/05/linux/tmp/shell/Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="1-Linux-命令-amp-工具"><a href="#1-Linux-命令-amp-工具" class="headerlink" title="1. Linux 命令 &amp; 工具"></a>1. Linux 命令 &amp; 工具</h1><h2 id="汇总表"><a href="#汇总表" class="headerlink" title="汇总表"></a>汇总表</h2><table><thead><tr><th>命令</th><th>解释</th></tr></thead><tbody><tr><td>curl cip.cc</td><td>查询外网出口 ip</td></tr><tr><td>screenfetch</td><td>查看系统信息</td></tr><tr><td>nohup command &amp;</td><td>后台运行</td></tr><tr><td>&amp; disown</td><td>后台运行命令</td></tr><tr><td>ps -aux | grep</td><td>查看后台命令</td></tr><tr><td>pstree -p</td><td>查看进程父子关系</td></tr><tr><td>sudo tail /proc/<pid>/fd/1 <code>1</code> = stdout, <code>2</code> = stderr</td><td>查看后台进程输出</td></tr><tr><td>reptyr <PID></td><td>查看后台输出</td></tr><tr><td>dmesg | grep -i xeon</td><td></td></tr><tr><td>bash -x</td><td>单步执行</td></tr><tr><td>export</td><td>查看环境变量</td></tr><tr><td>declare -x  (-x=export 可以跟不同选项)</td><td>查看环境变量</td></tr><tr><td>env   或 printenv</td><td>查看环境变量</td></tr><tr><td>free -m</td><td>查看内存</td></tr><tr><td>cat /proc/meminfo</td><td>查看内存,第一行</td></tr><tr><td>hostnamectl</td><td>查看虚拟机的信息</td></tr><tr><td>lspci |grep -i vga</td><td>查看显卡信息</td></tr><tr><td>hostnamectl set-hostname</td><td>修改主机名</td></tr><tr><td>uname -a</td><td>查看系统</td></tr><tr><td>nslookup</td><td></td></tr><tr><td>scp</td><td></td></tr><tr><td>wall</td><td>警报</td></tr><tr><td>ln</td><td>软连接</td></tr><tr><td>rsync</td><td></td></tr><tr><td>wc</td><td>统计总数</td></tr><tr><td>pstree -g</td><td>进程的树状结构</td></tr><tr><td>lscpu</td><td>查看cpu信息</td></tr><tr><td>lsblk</td><td>查看硬盘大小</td></tr><tr><td>lsblk</td><td>查看磁盘情况</td></tr><tr><td>df -hT -x tmpfs -x devtmpfs</td><td>查看磁盘情况</td></tr><tr><td>curl</td><td>curl miyip.ipip.net</td></tr><tr><td>fio 工具</td><td>测试系统盘性能</td></tr><tr><td>iperf3 工具</td><td>网络吞吐能力测试</td></tr><tr><td>ufw</td><td>防火墙</td></tr></tbody></table><ul><li>开启 ssh，关闭密码验证<br><a href="https://blog.csdn.net/qq_43228568/article/details/110824158">https://blog.csdn.net/qq_43228568/article/details/110824158</a></li></ul><h2 id="1-1-curl"><a href="#1-1-curl" class="headerlink" title="1.1 curl"></a>1.1 curl</h2><pre><code class="hljs shell">curl-X/--request [GET|POST|PUT|DELETE|…]  指定请求的 HTTP 方法-H/--header                           指定请求的 HTTP Header-d/--data                             指定请求的 HTTP 消息体（Body）-v/--verbose                          输出详细的返回信息-u/--user                             指定账号、密码-b/--cookie                           读取 cookie</code></pre><h2 id="1-2-tee"><a href="#1-2-tee" class="headerlink" title="1.2 tee"></a>1.2 tee</h2><h3 id="1-2-1-追加"><a href="#1-2-1-追加" class="headerlink" title="1.2.1 追加"></a>1.2.1 追加</h3><pre><code class="hljs shell">tee -a $HOME/.bashrc &lt;&lt; &#x27;EOF&#x27;<span class="hljs-meta">#</span><span class="bash"> Alias <span class="hljs-keyword">for</span> quick access</span>export GOWORK=&quot;$WORKSPACE/golang/src&quot;export IAM_ROOT=&quot;$GOWORK/github.com/marmotedu/iam&quot;alias mm=&quot;cd $GOWORK/github.com/marmotedu&quot;alias i=&quot;cd $GOWORK/github.com/marmotedu/iam&quot;EOF</code></pre><h3 id="1-2-2-新建"><a href="#1-2-2-新建" class="headerlink" title="1.2.2 新建"></a>1.2.2 新建</h3><pre><code class="hljs shell">tee ca-csr.json &lt;&lt; EOF&#123;  &quot;CN&quot;: &quot;iam-ca&quot;,  &quot;key&quot;: &#123;    &quot;algo&quot;: &quot;rsa&quot;,    &quot;size&quot;: 2048  &#125;,  &quot;names&quot;: [    &#123;      &quot;C&quot;: &quot;CN&quot;,      &quot;ST&quot;: &quot;BeiJing&quot;,      &quot;L&quot;: &quot;BeiJing&quot;,      &quot;O&quot;: &quot;marmotedu&quot;,      &quot;OU&quot;: &quot;iam&quot;    &#125;  ],  &quot;ca&quot;: &#123;    &quot;expiry&quot;: &quot;876000h&quot;  &#125;&#125;EOF</code></pre><h2 id="1-3-Alias-别名永久有效"><a href="#1-3-Alias-别名永久有效" class="headerlink" title="1.3 Alias 别名永久有效"></a>1.3 Alias 别名永久有效</h2><pre><code class="hljs shell">cat &lt;&lt;EOF&gt;&gt; ~/.bashrcalias k=&#x27;kubectl&#x27;EOFsource ~/.bashrc</code></pre><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/</span>redhat-release</code></pre><pre><code class="hljs awk">cat <span class="hljs-regexp">/etc/i</span>ssue</code></pre><h2 id="1-4-查看系统版本"><a href="#1-4-查看系统版本" class="headerlink" title="1.4 查看系统版本"></a>1.4 查看系统版本</h2><ul><li>使用  screenfetch 工具</li></ul><pre><code class="hljs livecodeserver">uname  <span class="hljs-comment"># 英文全称: unix name</span>uname -<span class="hljs-keyword">a</span>uname -s <span class="hljs-comment"># 内核名称</span>uname -n <span class="hljs-comment"># 主机名:</span>uname -r <span class="hljs-comment"># 内核发行版(不同的内核打包版本) </span>uname -v <span class="hljs-comment"># 内核版本信息(该内核建立的时间和CPU架构)</span>uname -m <span class="hljs-comment"># CPU位数</span></code></pre><h2 id="1-5-scp拷贝文件"><a href="#1-5-scp拷贝文件" class="headerlink" title="1.5 scp拷贝文件"></a>1.5 scp拷贝文件</h2><pre><code class="hljs bash">scp file user@ip folder</code></pre><h1 id="2-ubuntu-20-04"><a href="#2-ubuntu-20-04" class="headerlink" title="2. ubuntu 20.04"></a>2. ubuntu 20.04</h1><h2 id="2-0-安装-k8s"><a href="#2-0-安装-k8s" class="headerlink" title="2.0 安装 k8s"></a><a href="https://github.com/cncamp/101/blob/master/k8s-install/k8s-by-kubeadm/3.k8s-install.md#add-the-kubernetes-apt-repository">2.0 安装 k8s</a></h2><h3 id="2-0-1-关闭-swapoff"><a href="#2-0-1-关闭-swapoff" class="headerlink" title="2.0.1 关闭 swapoff"></a>2.0.1 关闭 swapoff</h3><pre><code class="hljs shell">swapoff -ased -i &#x27;/ swap / s/^\(.*\)$/#\1/g&#x27; /etc/fstabvi /etc/fstabremove the line with swap keyword</code></pre><h3 id="2-0-2-安装-docker"><a href="#2-0-2-安装-docker" class="headerlink" title="2.0.2 安装 docker"></a>2.0.2 安装 docker</h3><pre><code class="hljs shell">apt install -y docker.iovi /etc/docker/daemon.json&#123;  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]&#125;systemctl daemon-reloadsystemctl restart docker</code></pre><h3 id="2-0-3-安装-k8s"><a href="#2-0-3-安装-k8s" class="headerlink" title="2.0.3 安装 k8s"></a>2.0.3 安装 k8s</h3><h4 id="Letting-iptables-see-bridged-traffic"><a href="#Letting-iptables-see-bridged-traffic" class="headerlink" title="Letting iptables see bridged traffic"></a>Letting iptables see bridged traffic</h4><pre><code class="hljs shell">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.confbr_netfilterEOFcat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.confnet.bridge.bridge-nf-call-ip6tables = 1net.bridge.bridge-nf-call-iptables = 1EOFsudo sysctl --system</code></pre><h4 id="Update-the-apt-package-index-and-install-packages-needed-to-use-the-Kubernetes-apt-repository"><a href="#Update-the-apt-package-index-and-install-packages-needed-to-use-the-Kubernetes-apt-repository" class="headerlink" title="Update the apt package index and install packages needed to use the Kubernetes apt repository"></a>Update the apt package index and install packages needed to use the Kubernetes apt repository</h4><pre><code class="hljs shell">sudo apt-get updatesudo apt-get install -y apt-transport-https ca-certificates curl</code></pre><h4 id="Install-kubeadm"><a href="#Install-kubeadm" class="headerlink" title="Install kubeadm"></a>Install kubeadm</h4><pre><code class="hljs shell">sudo curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -</code></pre><h4 id="Add-the-Kubernetes-apt-repository"><a href="#Add-the-Kubernetes-apt-repository" class="headerlink" title="Add the Kubernetes apt repository"></a>Add the Kubernetes apt repository</h4><pre><code class="hljs shell">sudo tee /etc/apt/sources.list.d/kubernetes.list &lt;&lt;-&#x27;EOF&#x27;deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial mainEOF</code></pre><h4 id="kubeadm-init"><a href="#kubeadm-init" class="headerlink" title="kubeadm init"></a>kubeadm init</h4><pre><code class="hljs shell">echo &quot;192.168.34.2 cncamp.com&quot; &gt;&gt; /etc/hostskubeadm init \--image-repository registry.aliyuncs.com/google_containers \--kubernetes-version v1.22.2 \--pod-network-cidr=192.168.0.0/16 \--apiserver-advertise-address=192.168.34.2</code></pre><h4 id="Copy-kubeconfig"><a href="#Copy-kubeconfig" class="headerlink" title="Copy kubeconfig"></a>Copy kubeconfig</h4><pre><code class="hljs shell">mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config</code></pre><h4 id="Untaint-master"><a href="#Untaint-master" class="headerlink" title="Untaint master"></a>Untaint master</h4><pre><code class="hljs shell">kubectl taint nodes --all node-role.kubernetes.io/master-</code></pre>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Interview</title>
    <link href="/2022/01/04/go/Interview/interview_00/"/>
    <url>/2022/01/04/go/Interview/interview_00/</url>
    
    <content type="html"><![CDATA[<h1 id="go面试资料整理"><a href="#go面试资料整理" class="headerlink" title="go面试资料整理"></a>go面试资料整理</h1><h3 id="go语言基础"><a href="#go语言基础" class="headerlink" title="go语言基础"></a>go语言基础</h3><p>熟悉语法，撸个百十道基础面试题就差不多了。</p><h3 id="go语言进阶"><a href="#go语言进阶" class="headerlink" title="go语言进阶"></a>go语言进阶</h3><p>go中有哪些锁？</p><p>sync.Mutex 互斥锁<br>sync.RWMutex  读写锁</p><p>CSP并发模型？</p><p>CSP并发模型它并不关注发送消息的实体，而关注的是发送消息时使用的channel，<br>go语言借用了process和channel这两个概念，process表现为go里面的goroutine，<br>是实际并发执行的实体，每个实体之间是通过channel来进行匿名传递消息使之解藕，<br>从而达到通讯来实现数据共享。<br>​<br>不要通过共享内存来通信，而要通过通信来实现内存共享。<br>​<br>1、sync.mutex 互斥锁（获取锁和解锁可以不在同一个协程，当获取到锁之后，<br>未解锁，此时再次获取锁将会阻塞）<br>2、通过channel通信<br>3、sync.WaitGroup</p><p>GPM模型指的是什么？goroutine的调度时机有哪些？如果syscall阻塞会发生什么？</p><p>在go中是通过channel通信来共享内存的。<br>​<br>G：指的是Goroutine，也就是协程，go中的协程做了优化处理，内存占用仅几kb<br>且调度灵活，切换成本低。<br>P：指的是processor,也就是处理器，感觉也可理解为协程调度器。<br>M：指的是thread，内核线程。<br>​<br>调度器的设计策略：<br>1、线程复用：当本线程无可运行的G时，M-P-G0会处于自旋状态，尝试从全局队列<br>获取G，再从其他线程绑定的P队列中偷取G，而不是销毁线程；当本线程因为G进行<br>系统调用阻塞时，线程会释放绑定的P队列，如果有空闲的线程可用就复用空闲的<br>线程，不然就创建一个新的线程来接管释放出来的P队列。<br>2、利用并行：GOMAXPROCS设置P的数量，最多有这么多个线程分布在多个cpu上<br>同时运行。<br>3、抢占：在coroutine中要等待一个协程主动让出CPU才执行下一个协程，在Go<br>中，一个goroutine最多占用CPU 10ms，防止其他goroutine被饿死。<br>​<br>go func的流程：<br>1、创建一个G，新建的G优先保存在P的本地队列中，如果满了则会保存到全局队列中。<br>2、G只能运行在M中，一个M必须持有一个P，M与P时1:1关系，M会从P的本地队列<br>弹出一个可执行状态的G来执行。<br>3、一个M调度G执行的过程是一个循环机制。<br>4、如果G阻塞，则M也会被阻塞，runtime会把这个线程M从P摘除，再创建或者<br>复用其他线程来接管P队列。<br>5、当G、M不在被阻塞，即系统调用结束，会先尝试找会之前的P队列，如果之前<br>的P队列已经被其他线程接管，那么这个G会尝试获取一个空闲的P队列执行，并放<br>入到这个P的本地队列。否则这个线程M会变成休眠状态，加入空闲线程队列，而G<br>则会被放入全局队列中。<br>​<br>M0：<br>M0是启动程序后的编号为0的主线程，这个M对应的实例会在全局变量runtime.m0中，<br>不需要在heap上分配，M0负责执行初始化操作和启动第一个G，之后M0与其他的M一样。<br>G0：<br>G0是每次启动一个M都会第一个创建的goroutine，G0仅负责调度，不指向任何可执行<br>函数，每个M都会有一个自己的G0，在调度或者系统调用时会使用G0的栈空间，全局变量<br>的G0是M0的。<br>​<br>N:1—–出现阻塞的瓶颈，无法利用多个cpu<br>1:1—–跟多线程/多进程模型无异，切换协程代价昂贵<br>M:N—–能够利用多核，过于依赖协程调度器的优化和算法<br>​<br>​<br>同步协作式调度<br>异步抢占式调度<br>​</p><p>channel底层的数据结构是什么？发送和接收元素的本质是什么？</p><p>type hchan struct {<br> qcount   uint           // *chan里元素数量<br> dataqsiz uint           // *底层循环数组的长度，就是chan的容量<br> buf      unsafe.Pointer // *指向大小为dataqsiz的数组，有缓冲的channel<br> elemsize uint16         // chan中的元素大小<br> closed   uint32         // chan是否被关闭的标志<br> elemtype *_type         // chan中元素类型<br> recvx    uint           // *当前可以接收的元素在底层数组索引(&lt;-chan)<br> sendx    uint           // *当前可以发送的元素在底层数组索引(chan&lt;-)<br> recvq    waitq          // 等待接收的协程队列(&lt;-chan)<br> sendq    waitq          // 等待发送的协程队列(chan&lt;-)<br> lock     mutex          // 互斥锁,保证每个读chan或者写chan的操作都是原子的<br>}<br>​<br>// waitq是sudog的一个双向链表，sudog实际上是对goroutine的一个封装。<br>type waitq struct {<br> first *sudog<br> last  *sudog<br>}<br>​<br>// channel的发送和接收操作本质上都是”值的拷贝”(只是拷贝它的值而已)，</p><p>channel使用应该注意哪些情况，在哪些情况下会死锁/阻塞？</p><p>1、一个无缓冲channel在一个主go程里同时进行读和写；<br>2、无缓冲channel在go程开启之前使用通道；<br>3、通道1中调用了通道2，通道2中调用了通道1；<br>4、读取空的channel；<br>5、超过channel缓存继续写入数据；<br>6、向已经关闭的channel中写入数据不会导致死锁，但会Panic异常。<br>7、close一个已经关闭的channel会Panic异常。</p><p>那些类型不能作map的为key？map的key为什么是无序的？</p><p>map的key必须可以比较，func、map、slice这三种类型不可比较，<br>只有在都是nil的情况下，才可与nil (== or !=)。因此这三种类型<br>不能作为map的key。<br>​<br>数组或者结构体能够作为key？？？？有些能，有些不能，要看字段或者元素是否可比较<br>​<br>1、map在扩容后，会发生key的搬迁，原来落在同一个bucket中的key可能分散，key的位置发生了变化。<br>2、go中遍历map时，并不是固定从0号bucket开始遍历，每次都是从一个随机值序号的bucket开始遍历，<br>并且是从这个bucket的一个随机序号的cell开始遍历。<br>3、哈希查找表用一个哈希函数将key分配到不同的bucket(数组的下标index)。不同的哈希函数实现也<br>会导致map无序。<br>​<br>“迭代map的结果是无序的”这个特性是从go1.0开始加入的。</p><p>如何解决哈希查找表存在的”碰撞”问题（hash冲突）？</p><p>hash碰撞指的是：两个不同的原始值被哈希之后的结果相同，也就是不同的key被哈希分配到了同一个bucket。<br>​<br>链表法：将一个bucket实现成一个链表，落在同一个bucket中的key都会插入这个链表。<br>​<br>开放地址法：碰撞发生后，从冲突的下标处开始往后探测，到达数组末尾时，从数组开始处探测，直到找到一个<br>空位置存储这个key，当找不到位置的情况下会触发扩容。</p><p>map是线程安全的么？</p><p>map不是线程安全的，sync.map是线程安全的。<br>​<br>在查找、赋值、遍历、删除的过程中都会检测写标志，一旦发现写标志”置位”等于1，则直接panic,<br>因为这表示有其他协程同时在进行写操作。赋值和删除函数在检测完写标志是”复位”之后，先将<br>写标志位”置位”，才会进行之后的操作。<br>​<br>思考：为什么sync.map为啥是线程安全？？</p><p>map的底层实现原理是什么？</p><p>type hmap struct {<br> count      int   // len(map)元素个数<br> flags      uint8 //写标志位<br> B          uint8 // buckets数组的长度的对数，buckets数组的长度是2^B<br> noverflow  uint16<br> hash0      uint32<br> buckets    unsafe.Pointer // 指向buckets数组<br> oldbuckets unsafe.Pointer // 扩容的时候，buckets长度会是oldbuckets的两倍<br> nevacuate  uintptr<br> extra      *mapextra<br>}<br>​<br>// 编译期间动态创建的bmap<br>type bmap struct {<br> topbits  [8]uint8<br> keys     [8]keytype<br> values   [8]valuetype<br> pad      uintptr<br> overflow uintptr<br>}<br>​<br>在go中map是数组存储的，采用的是哈希查找表，通过哈希函数将key分配到不同的bucket，<br>每个数组下标处存储的是一个bucket，每个bucket中可以存储8个kv键值对，当每个bucket<br>存储的kv对到达8个之后，会通过overflow指针指向一个新的bucket，从而形成一个链表。</p><p>map的扩容过程是怎样的？</p><p>相同容量扩容<br>2倍容量扩容<br>​<br>扩容时机:<br>1、当装载因子超过6.5时，表明很多桶都快满了，查找和插入效率都变低了，触发扩容。<br>​<br>扩容策略：元素太多，bucket数量少，则将B加1，buctet最大数量(2^B)直接变为<br>原来bucket数量的2倍，再渐进式的把key/value迁移到新的内存地址。<br>​<br>2、无法触发条件1，overflow bucket数量太多，查找、插入效率低，触发扩容。<br>(可以理解为：一座空城，房子很多，但是住户很少，都分散了，找起人来很困难)<br>​<br>扩容策略：开辟一个新的bucket空间，将老bucket中的元素移动到新bucket，使得<br>同一个bucket中的key排列更紧密，节省空间，提高bucket利用率。</p><p>map的key的定位过程是怎样的？</p><p>对key计算hash值，计算它落到那个桶时，只会用到最后B个bit位，再用哈希值的高8位<br>找到key在bucket中的位置。桶内没有key会找第一个空位放入，冲突则从前往后找到第一个空位。</p><p>iface和eface的区别是什么？值接收者和指针接收者的区别？</p><p>iface和eface都是Go中描述接口的底层结构体，区别在于iface包含方法。<br>而eface则是不包含任何方法的空接口：interface{}<br>​<br>注意：编译器会为所有接收者为T的方法生成接收者为<em>T的包装方法，但是链接器会把程序中确定不会用到的方法都裁剪掉。因此</em>T和T不能定义同名方法。<br>生成包装方法是为了接口，因为接口不能直接使用接收者为值类型的方法。<br>​<br>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用<br>者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。<br>​<br>如果类型具备”原始的本质”，如go中内置的原始类型，就定义值接收者就好。<br>如果类型具备”非原始的本质”，不能被安全的复制，这种类型总是应该被共享，则可定义为指针接收者。</p><p>context是什么？如何被取消？有什么作用？</p><p>type Context interface {<br> // 当context被取消或者到了deadline，返回一个被关闭的channel<br> Done() &lt;-chan struct{}<br> // 在channel Done关闭后，返回context取消原因<br> Err() error<br> // 返回context是否会被取消以及自动取消时间(即deadline)<br> Deadline() (deadline time.Time,ok boll)<br> // 获取key对应的value<br> Value(key interface{}) interface{}<br>}<br>​<br>type canceler interface {<br> cancel(removeFromParent bool, err error)<br> Done() &lt;-chan struct{}<br>}<br>​<br>context：goroutine的上下文，包含goroutine的运行状态、环境、现场等信息。<br>​<br>实现了canceler接口的Context，就表明是可取消的。<br>​<br>context用来解决goroutine之间退出通知、元数据传递的功能。比如并发控制和超时控制。<br>​<br>注意事项：<br>1、不要将Context塞到结构体里，直接将Context类型作为函数的第一参数，而且一般都<br>命名为ctx。<br>2、不要向函数传入一个nil的Context，如果你实在不知道传什么，标准库给你准备好了<br>一个Context：todo<br>3、不要把本应该作为函数参数的类型塞到Context中，Context存储的应该是一些共同<br>的数据。例如：登陆的session、cookie等<br>4、同一个Context可能会被传递到多个goroutine，Context是并发安全的。</p><p>slice的底层数据结构是怎样的？</p><p>type slice struct {<br> array unsafe.Pointer // 底层数组的起始位置<br> len int<br> cap int<br>}<br>​<br>slice的元素要存在一段连续的内存中，底层数据是数组，slice是对数组的封装，它描述一个数组的片段。<br>slice可以向后扩展，不可以向前扩展。<br>s[i]不可以超越len(s),向后扩展不可以超越底层数组cap(s)。<br>make会为slice分配底层数组，而new不会为slice分配底层数组，所以array其实位置会是nil，可以通过append来分配底层数组。<br>​<br>slice扩容方案计算：<br>1、预估扩容后的容量：即假设扩容后的 cap 等于扩容后元素的个数<br>if<br> oldCap * 2 &lt; cap，则newCap = cap<br>else<br> oldLen &lt; 1024,则newCap = oldCap * 2<br> oldLen &gt;= 1024,则newCap = oldCap * 1.25<br>​<br>2、预估内存大小（int一个元素占8子节，string一个元素占16子节）<br>假设元素类型是int，预估容量newCap = 5，那么预估内存 = 5 * 8 = 40 byte<br>​<br>3、匹配到合适的内存规格（内存分配规格为8、16、32、48、64、80….）<br>实际申请的内存为 48 byte， cap = 48 / 8 = 6</p><p>你了解GC么？常见的GC实现方式有哪些？</p><p>GC即垃圾回收机制：引用计数、三色标记法+混合写屏障机制</p><p>go的GC有那三个阶段？流程是什么？如果内存分配速度超过了标记清除速度怎么办？</p><p>goV1.3之前采用的是普通标记清除，流程如下：<br>1、开始STW，暂停程序业务逻辑，找出不可达的对象和可达对象；<br>2、给所有可达对象做上标记；<br>3、标记完成之后，开始清除未标记的对象；<br>4、停止STW，让程序继续运行，然后循环重复这个过程，直到程序生命周期结束。<br>​<br>goV1.5三色标记法，流程如下：<br>1、只要是新创建的对象，默认的颜色都标记为白色；<br>2、每次GC回收开始，从根节点开始遍历所有对象，把遍历到的对象从白色集合<br>放入灰色集合；<br>3、遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色<br>对象放入黑色集合；<br>4、重复3中内容，直到灰色集合中无任何对象；<br>5、回收白色集合中的所有对象。<br>​<br>犹如剥洋葱一样，一层一层的遍历着色，但同时满足以下条件会导致对象丢失：<br>条件1：一个白色对象被黑色对象引用；<br>条件2：灰色对象与白色对象之间的可达关系同时被解除。<br>​<br>强三色：强制性的不允许黑色对象引用白色对象。<br>弱三色：黑色对象可以引用白色对象，但白色对象存在其他灰色对象对它的引用，或者<br>可达它的链路上游存在灰色对象。<br>​<br>goV1.8三色+混合写屏障机制，栈不启动屏障，流程如下：<br>1、GC开始将栈上的对象全部扫描并标记为黑色(之后不再进行重复扫描，无需STW)；<br>2、GC期间，任何在栈上创建的新对象均标记为黑色；<br>3、被删除的对象和被添加的对象均标记为灰色；<br>4、回收白色集合中的所有对象。<br>​<br>总结：<br>v1.3普通标记清除法，整体过程需要STW，效率极低；<br>v1.5三色标记法+屏障，堆空间启动写屏障，栈空间不启动，全部扫描之后，需要重新扫描<br>一次栈(需要STW)，效率普通；<br>v1.8三色标记法+混合写屏障，堆空间启动，栈空间不启动屏障，整体过程几乎不需要STW,<br>效率较高。<br>​<br>如果申请内存的速度超过预期，运行时就会让申请内存的应用程序辅助完成垃圾收集的扫描阶段，<br>在标记和标记终止阶段结束之后就会进入异步的清理阶段，将不用的内存增量回收。并发标记会<br>设置一个标志，并在mallocgc调用时进行检查，当存在新的内存分配时，会暂停分配内存过快<br>的哪些goroutine，并将其转去执行一些辅助标记的工作，从而达到放缓内存分配和加速GC工作<br>的目的。</p><p>内存泄漏如何解决？</p><p>1、通过pprof工具获取内存相差较大的两个时间点heap数据。htop可以查看内存增长情况。<br>2、通过go tool pprof比较内存情况，分析多出来的内存。<br>3、分析代码、修复代码。</p><p>内存逃逸分析？</p><p>在函数中申请一个新的对象，如果分配在栈中，则函数执行结束可自动将内存回收；<br>如果分配在堆中，则函数执行结束可交给GC处理。<br>​<br>案例：<br>函数返回局部变量指针；<br>申请内存过大超过栈的存储能力。</p><p>你是如何实现单元测试的？有哪些框架？</p><p>testing、GoMock、testify</p><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><p>sql语句中group by和order by谁先执行？</p><p>select (all | distinct) 字段或者表达式 (from子句) (where子句) (group by子句) (having子句) (order by子句) (limit子句);<br>​<br>1、from子句:构成提供给select的数据源,所以一般后面写表名<br>2、where子句:where子句是对数据源中的数据进行过滤的条件设置<br>3、group by子句:对通过where子句过滤后的数据进行分组<br>4、having子句:对分组后的的数据进行过滤,作用和where类似<br>5、order by子句:对取得的数据结果以某个标准(字段)进行排序,默认是asc(正序)<br>6、limit子句:对取出来的数据进行数量的限制,从第几行开始取出来几行数据<br>7、all | distinct 用于设置select出来的数据是否消除重复行，默认是all既不消除所有的数据都出来；distinct表示会消除重复行</p><p>mysql的存储引擎有哪些？都有什么区别？</p><p>MyISAM，InnoDB<br>区别：<br>1、MySAM不支持事务、不支持外键，而innodb支持<br>2、都是b+树作为索引结构，但是实现方式不同,innoDb是聚集索引，myisam是非聚集索引。<br>3、innoDb不保存表的具体行数，count(*)需要全表扫描，而myisam用一个变量保存了整个<br>表的行数，速度更快。<br>4、innodb组小的锁粒度是行锁，myisam最小的锁粒度是表锁。myisam一个更新语句会锁住<br>整张表，导致其他查询、更新都会被阻塞，因此并发当问受限。</p><p>为什么需要B-树/B+树？</p><p>因为传统的树是在内存中进行的数据搜索，而当数据量非常大时，内存不够用，大部分数据只能存放在<br>磁盘上，只有需要的数据才加载到内存中。一般情况下内存访问的时间约为50ns,而磁盘在10ms左右，<br>大部分时间会阻塞在磁盘IO上，因此要提高性能，得减少磁盘IO次数。</p><p>mysql索引底层实现？</p><p>MyISAM引擎使用B+树作为索引结构，叶子节点的data域存放的是数据记录的地址，需要再寻址一次才能<br>得到数据，是”非聚集索引”。<br>​<br>InnoDB引擎也使用B+树作为索引结构，区别如下：<br>1、InnoDB的叶子节点data域保存了完整的数据记录，因此主键索引很高效，是”聚集索引”。<br>2、InnoDB非主键索引的叶子节点存储的是主键和其他带索引的列数据，因此查询做到覆盖索引<br>会很高效。<br>​<br>hash索引底层的数据结构是哈希表，在绝大多数需求为单条记录查询的时候，可以选择哈希索引，<br>查询性能最快；其余大部分场景，建议都选择BTree索引。</p><p>为什么MongoDB使用B-树，而mysql使用B+树？</p><p>Mg是类似json格式的数据模型，对性能要求高，属于聚合型数据库，而B-树恰好key和data域聚合<br>在一起，且最佳查询时间复杂度为O(1);<br>​<br>mysql是一种关系型数据库，B+树的特性可以增加区间访问性，而B-树并不支持；B+树的查询时间复杂<br>度始终为O(log n)，查询效率更加稳定。</p><p>B-树和B+树的区别？</p><p>1、B+树非叶子节点只存储key的副本，相当于叶子节点的索引，真实的key和data域<br>都在叶子节点存储，查询时间复杂度固定为O(log n)，而B-树节点内部每个key都带着data域，<br>查询时间复杂度不固定，与key在树中的位置有关，最好为O(1)。<br>​<br>2、B+树叶子节点带有顺序指针，两两相连大大增加区间访问性，利用磁盘预读提前将访问节点附近的数据读入内存，减<br>少了磁盘IO的次数，也可使用在范围查询，而B-树每个节点key和data在一起，则无法区间查找。<br>​<br>3、磁盘是分block的，一次磁盘IO会读取若干个block，具体和操作系统有关，磁盘IO数据大小是固定的，在一<br>次IO中，单个元素越小，量就越大。由于B+树的节点只存储key的副本，这就意味着B+树单次磁盘IO的数据大于B-树，<br>自然磁盘IO次数也更少。</p><p>覆盖索引是什么？</p><p>从索引中就能查到记录，而不需要索引之后再回表中查记录，避免了回表的产生，减少了树的搜索次数。</p><p>索引设计的原则？需要注意事项？</p><p>1、出现在where子句中的列，或者连接子句中指定的列。<br>2、基数较小的列，索引效果较差，没有必要在此列建立索引。<br>3、取值离散大的字段放在联合索引的前面，count()值越大说明字段唯一值越多，离散程度高。<br>4、尽量使用短索引，如果对长字符串列进行索引，应该指定一个前缀长度，节省索引空间。<br>5、应符合最左前缀匹配原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)<br>就停止匹配，其中(=和in)可以乱序，mysql查询优化器会优化成索引可以识别的形式。<br>​<br>注意：<br>1、不要过度索引，并非索引越多也好，索引需要空间来存储，也需要定期维护，并且索引会降低<br>写操作的性能。<br>2、非必要情况，所有列都应该指定列为NOT NULL，使用零值作为默认值。</p><p>什么是数据库事务？</p><p>事务是一个不可分割的数据操作序列，也是数据库并发控制的基本单位，其执行结果必须使数据库<br>从一种一致性状态变到另一种一致性状态。事务是逻辑上的一组操作，要么都执行，要么都不执行。</p><p>事务的四大特性(ACID)?</p><p>1、原子性：事务是最小的执行单位，包含的所有数据库操作要么全部成功，要么全部失败回滚；<br>2、一致性：执行事务前后数据都必须处于一致性状态；<br>3、隔离性：一个事务未提交的业务结果是否对于其它事务可见，对应有四种事务隔离级别。<br>4、持久性：一个事务一旦被提交了，那么对数据库中数据的改变就是永久性的，即使是在数据库<br>系统遇到故障的情况下也不会丢失提交事务的操作。</p><p>事务隔离级别有哪些？如何解决脏读和幻读？</p><p>数据库定义了四种不同的事务隔离级别，由低到高依次为：<br>Read uncommitted 读取未提交—–三者均可能<br>Read committed 读取已提交——解决了脏读，可能出现不可重复读和幻读<br>Repeatable read 可重复读——可能出现幻读，解决了脏读和不可重复读<br>Serializable 可串行化（对所涉及到的表加锁，并非行级锁）<br>​<br>脏读:读取未提交数据(A事务读到未提交的B事务数据)<br>解决：设置事务级别为Read committed<br>​<br>不可重复读:前后多次读取，数据内容不一致(原因：读取了其它事务更改的数据且提交了事务，针对update操作)<br>解决：使用行级锁，锁定该行，事务A多次读取操作完成后才释放该锁，才允许其它事务操作。<br>​<br>幻读：前后多次读取，数据总量不一致(原因：读取了其它事务新增的数据且提交了事务，针对insert和delete操作)<br>解决：使用表级锁，锁定整张表，事务A多次读取数据总量之后才释放该锁，才允许其它事务操作。<br>​<br>mysql的事务隔离级别默认为Repeatable read(可重复读，可能会出现幻读)</p><p>乐观锁和悲观锁的实现方式？</p><p>乐观锁：基于数据版本号实现(基于mvcc理论)<br>悲观锁：数据库的锁机制</p><p>innoDB存储引擎的锁的算法有那三种？</p><p>Record lock: 单个行记录上的锁<br>Gap lock: 间隙锁，锁定一个范围，不包括记录本身<br>Next-key lock: record+gap 锁定一个范围，包含记录本身<br>​<br>注意：(间隙：范围查询中，存在于范围内，但不存在的记录，这称为间隙)</p><p>mysql的mvcc实现原理是什么？</p><p>MVCC只适用mysql事务隔离级别：Read committed 和 Repeatable Read，MVCC的<br>版本是在事务提交之后才会产生。<br>​<br>多版本并发控制：Undo log实现MVCC，并发控制通过锁来实现。<br>简单来说就是在每一行记录的后面增加两个隐藏列，记录创建版本号和删除版本号，而<br>每一个事务在启动的时候，都有一个唯一的递增的版本号，通过版本号来减少锁的争用。<br>​<br>1、在插入操作时，记录的创建版本号就是事务版本号；<br>2、在更新操作时，采用的是先标记旧的那行记录为已删除，并且删除版本号是事务版本<br>号，然后插入一行新的记录；<br>3、删除操作的时候，就把事务版本号作为删除版本号；<br>4、查询时，符合删除版本号大于当前事务版本号并且创建版本号小于或者等于当前事务版本号<br>这两个条件的记录才能被事务查询出来。</p><p>bin log、redo log、undo log作用是什么？有什么区别？</p><p>bin log:<br>记录mysql服务层产生的日志，常用来进行数据恢复、数据库复制。<br>​<br>redo log:<br>记录了数据操作在物理层面的修改。mysql中大量使用缓存，缓存存在与内存中，<br>修改操作时会直接修改内存，而不是立刻修改磁盘，当内存和磁盘数据不一致时，称内存中<br>的数据为脏页。<br>​<br>为了保证数据的安全性，事务进行时会不断产生redo log，在事务提交时进行一次flush操作，<br>保存到磁盘中，redo log是按照顺序写入的，磁盘的顺序读写的速度远大于随机读写。当数据<br>库或主机失效重启时，会根据redo log进行数据的恢复，如果redo log中有事务提交，则进行<br>事务提交修改数据。这样实现了事务的原子性、一致性、持久性。<br>​<br>undo log:<br>当进行数据修改时除了记录redo log，还会记录undo log，它记录了修改的反向操作，用于<br>数据的撤回操作，可以实现事务回滚，mvcc就是根据undo log实现回溯到某个特定的版本的<br>数据的。</p><p>大表数据查询，如何优化？</p><p>1、优化sql语句+索引<br>2、增加缓存，memcached、redis<br>3、做主从复制，读写分离<br>4、拆表—垂直拆分、水平拆分</p><p>Mysql数据库cpu飙升如何排查？</p><p>1、首先top查看是否真是由于mysqld占用导致的。<br>2、show processlist，分析session情况，有没有激增，是不是有消耗资源的sql在运行。<br>3、找出消耗高的sql，explain查看执行计划。</p><p>主从复制的实现步骤？</p><p>1、主库db的操作事件被写入到 binlog<br>2、从库发起连接，连接到主库<br>3、此时主库创建一个 binlog dump thread 线程，把binlog的内容发送到从库<br>4、从库启动之后，创建一个I/O线程，读取主库传过来的binlog内容并写入到relay log<br>5、还会创建一个SQL线程，从relay log里面读取内容，从Exec_Master_Log_Pos位置<br>开始执行读取到的操作事件，将内容写入到slave的db</p><h3 id="kafka"><a href="#kafka" class="headerlink" title="kafka"></a>kafka</h3><p>kafka为什么性能高？</p><p>1、kafka本身是分布式集群，同时采用了分区技术，具有较高的并发度；<br>2、顺序写入磁盘，Kafka 的 producer 生产数据，要写入到 log 文件中，写的过程是一直追加到文件末端，为顺序写。<br>3、零拷贝技术</p><p>kafka重复消费可能的原因以及处理方式？</p><p>原因1：消费者宕机、重启等，导致消息已经消费但是没有提交offset；<br>原因2：消费者使用自动提交offset，但当还没有提交的时候，有新的消费者加入或者移除，发生了rebalance。<br>再次消费的时候，消费者会根据提交的偏移量来，于是重复消费了数据。<br>原因3：消息处理耗时，或者消费者拉取的消息量太多，处理耗时，超过了max.poll.interval.ms的配置时间，<br>导致认为当前消费者已经死掉，触发再均衡。  </p><p>解决方案：消费者实现消费幂<br>1、消费表<br>2、数据库唯一索引<br>3、缓存消费过的消息ID</p><p>触发重平衡(rebalanced)的情况？</p><p>1、有新的消费者加入消费组、或已有消费者主动离开组<br>2、消费者超过session时间未发送心跳（已有 consumer 崩溃了）<br>3、一次poll()之后的消息处理时间超过了max.poll.interval.ms的配置时间，因为一次poll()<br>处理完才会触发下次poll()（已有 consumer 崩溃了）<br>4、订阅主题数发生变更<br>5、订阅主题的分区数发生变更</p><p>kafka消息丢失的原因以及解决方式？</p><p>生产者丢失消息情况：可能因为网络问题并没有发送出去。<br>解决：可以给send方法添加回调函数,按一定次数、间隔重试。  </p><p>消费者丢失消息情况：消费者自动提交offset，拿到消息还未真正消费，就挂掉了，但是offset却被自动提交了。<br>解决：关闭自动提交offset，每次在真正消费完消息之后之后再自己手动提交offset，这样解决了消息丢失，但会带来重复消费问题。  </p><p>kafka丢失消息情况：<br>leader副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些<br>没有被 follower 副本的同步的话，就会造成消息丢失。  </p><p>解决：设置 ack = all。ack是Kafka生产者很重要的一个参数。代表则所有副本都要接收到该消息之后该消息才算真正成功被发送。</p><p>Kafka中的消息有序吗？</p><p>kafka无法保证整个topic多个分区有序，但是由于每个分区（partition）内，<br>每条消息都有一个offset，故可以保证分区内有序</p><p>topic的分区数可以增加或减少吗？为什么？</p><p>topic的分区数只能增加不能减少，因为减少掉的分区也就是被删除的分区的数据难以处理.  </p><p>注意：消费者组中的消费者个数如果超过topic的分区，那么就会有消费者消费不到数据.</p><p>kafka是怎么维护offset的？</p><p>维护offset的原因：<br>由于consumer在消费过程中可能会出现断电宕机等故障，consumer恢复后，需要从故障前的位置<br>的继续消费，所以consumer需要实时记录自己消费到了哪个offset，以便故障恢复后继续消费。  </p><p>维护offset的方式：<br>Kafka 0.9版本之前，consumer默认将offset保存在Zookeeper中，从0.9版本开始，<br>consumer默认将offset保存在Kafka一个内置的topic中，该topic为<strong>__consumer_offsets</strong>。  </p><p>关于offset的常识：<br>消费者提交消费位移时提交的是当前消费到的最新消息的offset+1而不是offset。</p><p>kafka集群消息积压问题如何处理？</p><p>从两个角度去分析：<br>1、如果是 Kafka 消费能力不足，则可以考虑增加 Topic 的分区数，并且同时提升消费<br>组的消费者数量，消费者数=分区数。（两者缺一不可）<br>2、如果是下游的数据处理不及时，提高每批次拉取的数量。如果是因为批次拉取数据过少<br>（拉取 数据/处理时间&lt;生产速度），也会使处理的数据小于生产的数据，造成数据积压。</p><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><p>redis单线程为什么效率也这么高？</p><ol><li>redis是基于内存的，内存的读写速度非常快.  </li><li>redis是单线程的，省去了很多上下文切换线程的时间.  </li><li>IO多路复用</li></ol><p>redis有那五种常用的数据结构？应用场景以及实现原理是什么？</p><p>ziplist: 压缩列表，此数据结构是为了节约内存而开发<br>intset: 整数集合，是集合键的底层实现方式之一<br>quicklist：ziplist的一个双向链表<br>skiplist：跳表  </p><ol><li>string              计数             sds(raw，embstr，int)  </li><li>hash                缓存结构数据       quicklist(hashtable，ziplist)  </li><li>list                异步消息队列       (ziplist，linkedlist)  </li><li>set(无序、成员唯一)   计算共同喜好(交集)、统计访问ip     (intset，hashtable)  </li><li>zset(有序、成员唯一)  排行榜、延迟队列        (ziplist，skiplist)</li></ol><p>redis的过期策略？</p><p>定期删除+惰性删除策略  </p><ul><li><p>定期删除策略：Redis 启用一个定时器定时监视所有的 key，判断key是否过期，过期的话就删除。<br>这种策略可以保证过期的 key 最终都会被删除，但是也存在严重的缺点：每次都遍历内存中所有的数据，<br>非常消耗 CPU 资源，并且当 key 已过期，但是定时器还处于未唤起状态，这段时间内 key 仍然可以用。  </p></li><li><p>惰性删除策略：在获取 key 时，先判断 key 是否过期，如果过期则删除。这种方式存在一个缺点：<br>如果这个 key 一直未被使用，那么它一直在内存中，其实它已经过期了，会浪费大量的空间。  </p></li><li><p>这两种策略天然的互补，结合起来之后，定时删除策略就发生了一些改变，不在是每次扫描全部的<br>key 了，而是随机抽取一部分 key 进行检查，这样就降低了对 CPU 资源的损耗，惰性删除<br>策略互补了为检查到的key，基本上满足了所有要求。但是有时候就是那么的巧，既没有被定时器抽取到，<br>又没有被使用，这些数据又如何从内存中消失？没关系，还有内存淘汰机制，当内存不够用时，内存淘汰机制就会上场。</p></li></ul><p>Redis中的批量操作Pipeline？</p><p>非pipeline：client一个请求，redis server一个响应，期间client阻塞。<br>Pipeline：redis的管道命令，允许client将多个请求依次发给服务器，过程中不需要等待请求的回复，而是在最后读取所有结果。</p><p>redis与mysql数据一致性解决方案？</p><p>延迟双删策略：<br>1、先删除缓存，然后更新数据库，但可能在更新未完成之前，有请求穿透到db取了旧数据并写入了缓存，因此需要更新完数据库之后，延迟几十毫秒，再删一次缓存。<br>2、先更新数据库，再删除缓存，再延迟删一次。<br>如果删除失败则重试，比如放入队列循环删除。</p><p>发生缓存穿透、击穿、雪崩的原因以及解决方案？</p><ul><li><p>缓存穿透<br>是指查询一个一定不存在的数据，由于缓存是不命中时被动写的，并且出于容错考虑，如果从存储层查不到数据<br>则不写入缓存，这将导致这个不存在的数据每次请求都要到存储层去查询，失去了缓存的意义。在流量大时，<br>可能DB就挂掉了，要是有人利用不存在的key频繁攻击我们的应用，这就是漏洞。(简单来说就是缓存和数据库<br>都不存在这个数据，这种情况称为穿透)<br>解决方案：<br>1、接口层增加校验，比如id&lt;=0这种一定不存在的情况直接拦截掉。<br>2、如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，<br>但它的过期时间会很短，最长不超过五分钟。<br>3、采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这<br>个bitmap拦截掉，从而避免了对底层存储系统的查询压力。  </p></li><li><p>缓存雪崩<br>缓存雪崩是指在我们设置缓存时采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发<br>到DB，DB瞬时压力过重雪崩。重启导致缓存失效，也可能出现并发到DB。<br>解决方案：<br>1、考虑用加锁(互斥锁)，锁定key之后完成db的查询以及缓存的更新之后再释放锁定key，从而避免失效时大量的并发请求落到底层存储系统上。<br>2、缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。<br>3、重启导致缓存失效，我们可以采用缓存预热，提前使用一个接口更新好缓存，再启动服务。  </p></li><li><p>缓存击穿(场景：热点数据)<br>缓存中不存在，但数据库中有的数据(一般是缓存时间到期)。缓存在某个时间点过期的时候，恰好在这个时间点对这个Key有大量的并发<br>请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。与雪崩区别是击穿指并发查同一条数据。<br>解决方案：<br>1、使用互斥锁(SETNX)<br>2、设置热点数据永远不过期，数据是需要维护的。</p></li></ul><p>redis的持久化方案RDB和AOF详解？</p><p>RDB:在指定的时间间隔内将内存中的数据集快照写入磁盘，它恢复时就是将快照文件直接读到内存里。<br>AOF:持久化记录服务器执行的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据集。AOF文件中的命令全部以 Redis 协议的格式来保存，<br>新命令会被追加到文件的末尾,Redis 还可以在后台对 AOF 文件进行重写(rewrite)，使得 AOF 文件的体积不会超出保存数据集状态所需的实际大小</p><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>浏览器访问一个网站，都经历了怎样一个流程？</p><p>1、DNS 解析:将域名解析成 IP 地址<br>2、TCP 连接：TCP 三次握手<br>3、发送 HTTP 请求<br>4、服务器处理请求并返回 HTTP 报文<br>5、浏览器解析渲染页面<br>6、断开连接：TCP 四次挥手</p><p>什么是HTTP与HTTPS有什么区别？</p><p>1、HTTP的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头<br>2、HTTP是不安全的，而 HTTPS 是安全的<br>3、HTTP标准端口是80 ，而 HTTPS 的标准端口是443<br>4、在OSI网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层<br>5、HTTP无法加密，而HTTPS 对传输的数据进行加密<br>6、HTTP无需证书，而HTTPS 需要CA机构颁发的SSL证书</p><p>什么是Http协议无状态协议?怎么解决Http协议无状态协议?</p><p>无状态协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息。<br>也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。<br>可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，<br>当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“</p><p>HTTP请求报文与响应报文格式？</p><ul><li><p>请求报文包含：<br>1、请求行：包含请求方法、URI、HTTP版本信息<br>2、请求头部字段<br>3、空行<br>4、请求内容实体  </p></li><li><p>响应报文包含：<br>1、状态行：包含HTTP版本、状态码、状态码的原因短语<br>2、响应头部字段<br>3、空行<br>4、响应内容实体</p></li></ul><p>HTTP常见的状态码有哪些？</p><p>1XX系列：指定客户端应相应的某些动作，代表请求已被接受，需要继续处理。由于 HTTP/1.0 协议中没有定义任何<br>1xx 状态码，所以除非在某些试验条件下，服务器禁止向此类客户端发送 1xx 响应。  </p><p>2XX系列：代表请求已成功被服务器接收、理解、并接受。这系列中最常见的有200、201状态码。<br>200状态码：表示请求已成功，请求所希望的响应头或数据体将随此响应返回<br>201状态码：表示请求成功并且服务器创建了新的资源，且其 URI 已经随Location 头信息返回。假如需要的资源<br>无法及时建立的话，应当返回 ‘202 Accepted’  </p><p>202状态码：服务器已接受请求，但尚未处理  </p><p>3XX系列：代表需要客户端采取进一步的操作才能完成请求，这些状态码用来重定向，后续的请求地址（重定向目标<br>）在本次响应的 Location 域中指明。这系列中最常见的有301、302状态码。<br>301状态码：被请求的资源已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动<br>将请求者转到新位置。  </p><p>302状态码：请求的资源临时从不同的URI响应请求，但请求者应继续使用原有位置来进行以后的请求  </p><p>304自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。 如果网页自请求者上次请<br>求后再也没有更改过，您应将服务器配置为返回此响应(称为 If-Modified-Since HTTP 标头)。  </p><p>4XX系列：表示请求错误。代表了客户端看起来可能发生了错误，妨碍了服务器的处理。常见有：401、404状态码。<br>401状态码：请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。<br>403状态码：服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且<br>这个请求也不应该被重复提交。  </p><p>404状态码：请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂<br>时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已<br>经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被<br>拒绝或者没有其他适合的响应可用的情况下。  </p><p>5xx系列：代表了服务器在处理请求的过程中有错误或者异常状态发生，也有可能是服务器意识到以当前的软硬<br>件资源无法完成对请求的处理。常见有500、503状态码。<br>500状态码：服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在<br>服务器的程序码出错时出现。<br>503状态码：由于临时的服务器维护或者过载，服务器当前无法处理请求。通常，这个是暂时状态，一段时间会恢复</p><p>网络的七层结构及其作用？</p><ul><li>应用层（数据）：确定进程之间通信的性质以满足用户需要以及提供网络与用户应用  </li><li>表示层（数据）：主要解决用户信息的语法表示问题，如加密解密  </li><li>会话层（数据）：提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制，如服务器验证用户登录便是由会话层完成的  </li><li>传输层（段）：实现网络不同主机上用户进程之间的数据通信，可靠与不可靠的传输，传输层的错误检测，流量控制等  </li><li>网络层（包）：提供逻辑地址（IP）、选路，数据从源端到目的端的传输  </li><li>数据链路层（帧）：将上层数据封装成帧，用MAC地址访问媒介，错误检测与修正  </li><li>物理层（比特流）：设备之间比特流的传输，物理接口，电气特性等</li></ul><p>TCP/IP协议四层?</p><p>应用层、传输层、网络层、数据链路层</p><p>TCP协议和UDP协议有什么区别？</p><p>CP和UDP协议属于传输层协议，主要区别：<br>1、TCP是面向连接的，UDP是无连接的;<br>2、TCP是可靠的，UDP是不可靠的;<br>3、TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多的通信模式;<br>4、TCP是面向字节流的，UDP是面向报文的;<br>5、TCP有拥塞控制机制;UDP没有拥塞控制，适合媒体通信;<br>6、TCP首部开销(20个字节)比UDP的首部开销(8个字节)要大;</p><p>TCP协议的三次握手和四次挥手？为什么是三次和四次？</p><ul><li><p>三次握手(我要和你建立链接，你真的要和我建立链接么，我真的要和你建立链接，成功)  </p><p>第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，<br>等待Server确认。  </p><p>第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，<br>随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。  </p><p>第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据<br>包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状<br>态，完成三次握手，随后Client与Server之间可以开始传输数据了。  </p></li><li><p>四次挥手(我要和你断开链接;好的，断吧。我也要和你断开链接;好的，断吧)  </p><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。   </p><p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1(与SYN相同，一个FIN占用一个序号)，Server进<br>入CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。   </p><p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。   </p><p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进<br>入CLOSED状态，完成四次挥手。  </p></li></ul><p><strong>三次握手</strong>：目的是为了防止已失效的链接请求报文突然又传送到了服务端，因而产生错误。  </p><p><strong>四次挥手</strong>：TCP 协议是一种面向连接的、可靠的、基于字节流的运输层通信协议。TCP 是全双工模式，这就意味着，当 A<br>向 B 发出 FIN 报文段时，只是表示 A 已经没有数据要发送了，而此时 A 还是能够接受到来自 B 发出的数据;B 向 A 发<br>出 ACK 报文段也只是告诉 A ，它自己知道 A 没有数据要发了，但 B 还是能够向 A 发送数据。</p><p>http1.0、http1.1、http2.0有什么区别？</p><p>http1.0和http1.1区别：<br>1、http1.1默认开启长连接keep-alive，在一个TCP连接(一次完整的tcp握手和挥手)上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。<br>2、http1.0客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能。HTTP1.1支持只发送header信息（不带任何body信息），<br>如果服务器认为客户端有权限请求服务器，则返回100，客户端接收到100才开始把请求body发送到服务器；如果返回401，客户端就可以不用发送请求body了节约了带宽。<br>3、http1.1的请求消息和响应消息都支持host域，且请求消息中如果没有host域会报告一个错误（400 Bad Request）。  </p><p>http1.1和http2.0区别:<br>1、http2.0在1.1的基础上增加了多路复用，做到同一个连接并发处理多个请求，而且并发请求的数量比HTTP1.1大了好几个数量级。<br>http1.1也可以多建立几个TCP连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。<br>2、http1.1不支持header数据的压缩，http2.0使用HPACK算法对header的数据进行压缩，这样数据体积小了，在网络上传输就会更快。<br>3、http2.0引入了server push，它允许服务端推送资源给浏览器，免得客户端再次创建连接发送请求到服务器端获取。(例如：客户端向服务器发送一个获取html的请求，<br>不需要再次请求去获取html所依赖的css、js，而是在第一次html请求时，服务器端主动的都推送给客户端)</p><p>ProtoBuff协议相比其它有什么好处？</p><p>pb是一种轻便高效的”结构化数据”存储格式，可以用于”结构化数据”的序列化和反序列化。<br>1、跨语言，支持大多数语言开发，代码开源，运行稳定可靠。<br>2、性能好、效率高，占据空间和运行时间相比json和xml小，二进制序列化格式，数据压缩紧凑，占据字节数小。<br>3、支持向后向前兼容，比如向后兼容：A、B两模块，B升级有”statue”属性，可设置为非必填或者缺省，这样A就被兼容了。<br>4、适合数据大、传输速率敏感的场合使用。<br>5、支持数据类型多。<br>6、数据结构化定义灵活，可嵌套定义。</p><h3 id="分布式系统、微服务架构"><a href="#分布式系统、微服务架构" class="headerlink" title="分布式系统、微服务架构"></a>分布式系统、微服务架构</h3><p>什么是分布式事务？</p><p>二阶段提交、三阶段提交</p><p>分布式锁有哪些实现方式？分别会存在什么问题，哪种实现更好？</p><p>zk(ZooKeeper)锁实现原理：<br>（1）创建一个目录mylock；<br>（2）线程A想获取锁就在mylock目录下创建临时顺序节点；<br>（3）获取mylock目录下所有的子节点，然后获取比自己小的兄弟节点，如果不存在，则说明当前线程顺序号最小，获得锁；<br>（4）线程B获取所有节点，判断自己不是最小节点，设置监听比自己次小的节点；<br>（5）线程A处理完，删除自己的节点，线程B监听到变更事件，判断自己是不是最小的节点，如果是则获得锁。  </p><p>redis事务：<br>1、事务提供了一种将多个命令打包，然后一次性有序（FIFO）执行的机制<br>2、事务执行过程不会被中断<br>3、带WATCH命令的事务会将客户端和被监视的键在数据库watched_keys字典中进行关联，当键被修改程序会将所有监视键的客<br>户端REDIS_DIRTY_CAS标识打开<br>4、在客户端提交EXEC命令时，会检查REDIS_DIRTY_CAS标识，标识打开事务将不会被执行<br>5、Redis事务具有ACID的特性（当服务器运行在AOF模式下，并且appendfsync选项值为always时才具有持久性  </p><p>redis 实现分布式锁:<br>2.6.12版本之后命令： SET key value EX 10 NX  （合并了1、2两个步骤）<br>核心思路：<br>1、使用setnx设置互斥锁<br>2、为了避免异常情况导致死锁，因此需要为锁设置过期时间<br>3、为了避免删锁混乱，导致锁永久失效，需要为每个请求分配唯一的value值，再删锁时，验证是否属于自身的锁。<br>4、为了避免在删锁的操作过程中的异常情况，如锁过期，新的请求获得锁，此时删除的是新的锁。可以再执行任务中新启一个协程每隔10s去检查主程是否还持有锁，<br>如果还持有锁，则为锁进行续期。  </p><p>基于lua脚本实现redis的乐观锁</p><p>说下微服务架构有哪些组件，这些组件是如何实现自身功能的？</p><p>微服务架构如何设计？</p><p>如何防止超卖？</p><p>1、使用 redis 的队列来实现。将要促销的商品数量以队列的方式存入 redis 中，每当用户抢到一件促销商品则从队列中删除一个数据，确保商品不会超卖  </p><p>2、乐观锁，增加版本号，查询库存和更新库存时比较版本号</p><h3 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h3><p>题目：将6，2，10，32，9，5，18，14，30，29从小到大进行排列,使用冒泡排序</p><p>package main  </p><p>import “fmt”  </p><p>func main() {<br>    // 定义数组<br>    arr := [10]int{6, 2, 10, 32, 9, 5, 18, 14, 30, 29}<br>    for i := 0; i &lt; len(arr); i++ {<br>        for j := 0; j &lt; len(arr)-i-1; j++ {<br>            if arr[j] &gt; arr[j+1] {<br>                arr[j], arr[j+1] = arr[j+1], arr[j]<br>            }<br>        }<br>    }<br>    fmt.Println(arr)<br>}</p><p>快排</p><p>选择排序</p><p>堆排</p><p>动态规划</p><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><p>关系型数据库和非关系型数据库有什么区别？</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview,go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Interview</title>
    <link href="/2022/01/04/go/Interview/interview_1ch0/"/>
    <url>/2022/01/04/go/Interview/interview_1ch0/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-Interview-Summary"><a href="#Go-Interview-Summary" class="headerlink" title="Go Interview  Summary"></a>Go Interview  Summary</h1><h2 id="Base-concept"><a href="#Base-concept" class="headerlink" title="Base concept"></a>Base concept</h2><h3 id="Make-new"><a href="#Make-new" class="headerlink" title="Make   new"></a>Make   new</h3><p>new(T) make(T, args) 是 Go 语言内建函数,用来分配内存，但适用的类型不同<br><code>new(T) 会为了 T 类型新建新的内存空间并返回内存地址，即 *T, 用于 数组，结构体</code><br><code>make(T, args) 会返回初始化T类型的值，适用于 slice，map，channel</code></p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>Go语言中闭包是引用了自由变量的函数，被引用的自由变量和函数一同存在，即使已经离开了自由变量的环境也不会被释放或者删除，在闭包中可以继续使用这个自由变量，因此，简单的说：</p><p>函数 + 引用环境 = 闭包</p><ul><li>在go中，当我们<strong>调用</strong>函数或者将<strong>函数运算的结果</strong>赋值给变量的时候，是需要<strong>加括号</strong>的，同时括号里面是参数</li><li>在go中，当我们将<strong>函数本身</strong>赋值给某个变量的时候，是不能加括号的</li></ul><h3 id="接口类型断言和type-switch"><a href="#接口类型断言和type-switch" class="headerlink" title="接口类型断言和type-switch"></a>接口类型断言和type-switch</h3><p><a href="https://www.cnblogs.com/f-ck-need-u/p/9893347.html"></a></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main <span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span> <span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span>&#125; <span class="hljs-keyword">type</span> Mouse <span class="hljs-keyword">struct</span> &#123;Name <span class="hljs-keyword">string</span>&#125; <span class="hljs-keyword">type</span> Introduce <span class="hljs-keyword">interface</span> &#123;Intro()&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span><span class="hljs-title">Intro</span><span class="hljs-params">()</span></span>&#123;fmt.Println(<span class="hljs-string">&quot;hi, i am Cat, you can call me:&quot;</span>,c.Name)&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mouse)</span><span class="hljs-title">Intro</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;hi, i am Mouse, you can call me:&quot;</span>,m.Name)&#125;<span class="hljs-comment">// 接口参数</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selfIntro</span><span class="hljs-params">(in Introduce)</span></span>  &#123;in.Intro()&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">typeJudge</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span>  &#123;<span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>)&#123;<span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>,<span class="hljs-keyword">int8</span>,<span class="hljs-keyword">int64</span>,<span class="hljs-keyword">int16</span>,<span class="hljs-keyword">int32</span>,<span class="hljs-keyword">uint</span>,<span class="hljs-keyword">uint8</span>,<span class="hljs-keyword">uint16</span>,<span class="hljs-keyword">uint32</span>,<span class="hljs-keyword">uint64</span>:fmt.Println(<span class="hljs-string">&quot;整型变量&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-keyword">float32</span>,<span class="hljs-keyword">float64</span>:fmt.Println(<span class="hljs-string">&quot;浮点型变量&quot;</span>)<span class="hljs-keyword">case</span> []<span class="hljs-keyword">byte</span>,[]<span class="hljs-keyword">rune</span>,<span class="hljs-keyword">string</span>:fmt.Println(<span class="hljs-string">&quot;字符串变量&quot;</span>)<span class="hljs-keyword">default</span>:fmt.Println(<span class="hljs-string">&quot;不清楚...&quot;</span>)&#125;&#125; <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">//-----------动态类型--------------</span>tom := Cat&#123;<span class="hljs-string">&quot;Tom&quot;</span>&#125;selfIntro(&amp;tom)jerry := Mouse&#123;<span class="hljs-string">&quot;Jerry&quot;</span>&#125;selfIntro(&amp;jerry)<span class="hljs-comment">//-----------类型断言与type-switch--------</span>typeJudge(<span class="hljs-number">1</span>)typeJudge(<span class="hljs-number">1.1</span>)typeJudge(<span class="hljs-string">&quot;1.1&quot;</span>)typeJudge([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hi&quot;</span>))typeJudge([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;)&#125;</code></pre><h3 id="实现-set"><a href="#实现-set" class="headerlink" title="实现 set"></a>实现 set</h3><h3 id="Go语言如何跳出多层循环"><a href="#Go语言如何跳出多层循环" class="headerlink" title="Go语言如何跳出多层循环"></a>Go语言如何跳出多层循环</h3><ol><li>标记, break</li><li>goto</li></ol><h3 id="Channel-应用场景"><a href="#Channel-应用场景" class="headerlink" title="Channel  应用场景"></a>Channel  应用场景</h3><blockquote><ul><li>数据交流：当作并发的 buffer 或者 queue，解决生产者 - 消费者问题。多个 goroutine 可以并发当作生产者（Producer）和消费者（Consumer）。</li><li>数据传递：一个 goroutine 将数据交给另一个 goroutine，相当于把数据的拥有权 (引用) 托付出去。</li><li>信号通知：一个 goroutine 可以将信号 (closing、closed、data ready 等) 传递给另一个或者另一组 goroutine。</li><li>任务编排：可以让一组 goroutine 按照一定的顺序并发或者串行的执行，这就是编排的功能。</li><li>锁：利用 Channel 也可以实现互斥锁的机制。</li></ul></blockquote><h3 id="知道golang的内存逃逸吗？什么情况下会发生内存逃逸？"><a href="#知道golang的内存逃逸吗？什么情况下会发生内存逃逸？" class="headerlink" title="知道golang的内存逃逸吗？什么情况下会发生内存逃逸？"></a>知道golang的<strong>内存逃逸</strong>吗？什么情况下会发生内存逃逸？</h3><p><code>golang程序变量</code>会携带有一组校验数据，用来证明它的整个生命周期是否在运行时完全可知。如果变量通过了这些校验，它就可以在<code>栈上</code>分配。否则就说它 <code>逃逸</code> 了，必须在<code>堆上分配</code>。</p><p>能引起变量逃逸到堆上的<strong>典型情况</strong>：</p><ul><li><strong>在方法内把局部变量指针返回</strong> 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。</li><li><strong>发送指针或带有指针的值到 channel 中。</strong> 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。</li><li>*<strong>在一个切片上存储指针或带指针的值。</strong> 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。</li><li><strong>slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。</strong> slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。</li><li><strong>在 interface 类型上调用方法。</strong> 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。</li></ul><h3 id="Append-实现传入切片"><a href="#Append-实现传入切片" class="headerlink" title="Append 实现传入切片"></a>Append 实现传入切片</h3><h3 id="切片扩容"><a href="#切片扩容" class="headerlink" title="切片扩容"></a>切片扩容</h3><p>append的时候发生扩容的动作</p><ul><li>append单个元素，或者append少量的多个元素，这里的少量指double之后的容量能容纳，这样就会走以下扩容流程，不足1024，双倍扩容，超过1024的，1.25倍扩容。</li><li>若是append多个元素，且double后的容量不能容纳，直接使用预估的容量。</li></ul><p><strong>以上两个分支得到新容量后，均需要根据slice的类型size，算出新的容量所需的内存情况<code>capmem</code>，然后再进行<code>capmem</code>向上取整，得到新的所需内存，除上类型size，得到真正的最终容量,作为新的slice的容量。</strong></p><h3 id="nil切片和空切片指向的地址一样吗"><a href="#nil切片和空切片指向的地址一样吗" class="headerlink" title="nil切片和空切片指向的地址一样吗"></a><strong>nil切片和空切片指向的地址一样吗</strong></h3><ul><li><strong>nil切片和空切片指向的地址不一样。nil空切片引用数组指针地址为0（无指向任何实际地址）</strong></li><li><strong>空切片的引用数组指针地址是有的，且固定为一个值</strong></li></ul><h3 id="json包里使用的时候，结构体里的变量不加tag能不能正常转成json里的字段？"><a href="#json包里使用的时候，结构体里的变量不加tag能不能正常转成json里的字段？" class="headerlink" title="json包里使用的时候，结构体里的变量不加tag能不能正常转成json里的字段？"></a><code>json</code>包里使用的时候，结构体里的变量不加<code>tag</code>能不能正常转成<code>json</code>里的字段？</h3><ul><li><p>如果变量<code>首字母小写</code>，则为<code>private</code>。无论如何<code>不能转</code>，因为取不到<code>反射信息</code>。</p></li><li><p>如果变量<code>首字母大写</code>，则为<code>public</code>。</p></li><li><ul><li><code>不加tag</code>，可以正常转为<code>json</code>里的字段，<code>json</code>内字段名跟结构体内字段<code>原名一致</code>。</li><li><code>加了tag</code>，从<code>struct</code>转<code>json</code>的时候，<code>json</code>的字段名就是<code>tag</code>里的字段名，原字段名已经没用。</li></ul></li></ul><h3 id="for循环select时，如果通道已经关闭会怎么样？如果select中的case只有一个，又会怎么样？"><a href="#for循环select时，如果通道已经关闭会怎么样？如果select中的case只有一个，又会怎么样？" class="headerlink" title="for循环select时，如果通道已经关闭会怎么样？如果select中的case只有一个，又会怎么样？"></a><code>for</code>循环<code>select</code>时，如果通道已经关闭会怎么样？如果<code>select</code>中的<code>case</code>只有一个，又会怎么样？</h3><ul><li>for循环<code>select</code>时，如果其中一个case通道已经关闭，则每次都会执行到这个case。</li><li>如果select里边只有一个case，而这个case被关闭了，则会出现死循环。</li></ul><p>把关闭后的通道至赋值为 nil ， 则 select 读取会阻塞</p><ul><li><code>select</code>中如果任意某个通道有值可读时，它就会被执行，其他被忽略。</li><li>如果没有<code>default</code>字句，<code>select</code>将有可能阻塞，直到某个通道有值可以运行，所以<code>select</code>里最好有一个<code>default</code>，否则将有一直阻塞的风险。</li></ul><h3 id="对已经关闭的的-chan-进行读写，会怎么样？为什么？"><a href="#对已经关闭的的-chan-进行读写，会怎么样？为什么？" class="headerlink" title="对已经关闭的的 chan 进行读写，会怎么样？为什么？"></a>对<strong>已经关闭</strong>的的 <code>chan</code> 进行读写，会怎么样？<strong>为什么？</strong></h3><ul><li><p>读<strong>已经关闭</strong>的 <code>chan</code> 能一直读到东西，但是读到的内容根据通道内<code>关闭前</code>是否有元素而不同。</p></li><li><ul><li>如果 <code>chan</code> 关闭前，<code>buffer</code> 内有元素<strong>还未读</strong> , 会正确读到 <code>chan</code> 内的值，且返回的第二个 bool 值（是否读成功）为 <code>true</code>。</li><li>如果 <code>chan</code> 关闭前，<code>buffer</code> 内有元素<strong>已经被读完</strong>，<code>chan</code> 内无值，接下来所有接收的值都会非阻塞直接成功，返回 <code>channel</code> 元素的<strong>零值</strong>，但是第二个 <code>bool</code> 值一直为 <code>false</code>。</li></ul></li><li><p>写<strong>已经关闭</strong>的 <code>chan</code> 会 <code>panic</code></p></li></ul><h3 id="对未初始化的的-chan-进行读写，会怎么样？为什么？"><a href="#对未初始化的的-chan-进行读写，会怎么样？为什么？" class="headerlink" title="对未初始化的的 chan 进行读写，会怎么样？为什么？"></a>对<strong>未初始化</strong>的的 <code>chan</code> 进行读写，会怎么样？<strong>为什么？</strong></h3><p>读写<strong>未初始化</strong>的 <code>chan</code> 都会<strong>阻塞</strong>。</p><h3 id="能说说uintptr和unsafe-Pointer的区别吗？"><a href="#能说说uintptr和unsafe-Pointer的区别吗？" class="headerlink" title="能说说uintptr和unsafe.Pointer的区别吗？"></a>能说说uintptr和unsafe.Pointer的区别吗？</h3><ul><li>unsafe.Pointer只是单纯的通用指针类型，用于转换不同类型指针，它不可以参与指针运算；</li><li>而uintptr是用于指针运算的，GC 不把 uintptr 当指针，也就是说 uintptr 无法持有对象， uintptr 类型的目标会被回收；</li><li>unsafe.Pointer 可以和 普通指针 进行相互转换；</li><li>unsafe.Pointer 可以和 uintptr 进行相互转换。</li></ul><h3 id="拷贝大切片一定比小切片代价大吗？"><a href="#拷贝大切片一定比小切片代价大吗？" class="headerlink" title="拷贝大切片一定比小切片代价大吗？"></a>拷贝大切片一定比小切片代价大吗？</h3><p>并不是，所有切片的大小相同；<strong>三个字段</strong>（一个 uintptr，两个int）。切片中的第一个字是指向切片底层数组的指针，这是切片的存储空间，第二个字段是切片的长度，第三个字段是容量。将一个 slice 变量分配给另一个变量只会复制三个机器字。所以 <strong>拷贝大切片跟小切片的代价应该是一样的</strong>。</p><h3 id="字符串转成byte数组，会发生内存拷贝吗？"><a href="#字符串转成byte数组，会发生内存拷贝吗？" class="headerlink" title="字符串转成byte数组，会发生内存拷贝吗？"></a>字符串转成byte数组，会发生内存拷贝吗？</h3><p>字符串转成切片，会产生拷贝。严格来说，只要是发生类型强转都会发生内存拷贝。那么问题来了。<br>频繁的内存拷贝操作听起来对性能不大友好。<strong>有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢？</strong></p><ul><li><p>想要在底层转换二者，只需要把 <code>StringHeader</code> 的地址强转成 <code>SliceHeader</code> 就行。那么go有个很强的包叫 <code>unsafe</code> 。</p></li><li><ul><li>1.<code>unsafe.Pointer(&amp;a)</code>方法可以得到变量<code>a</code>的地址。</li><li>2.<code>(*reflect.StringHeader)(unsafe.Pointer(&amp;a))</code> 可以把字符串a转成底层结构的形式。</li><li>3.<code>(*[]byte)(unsafe.Pointer(&amp;ssh))</code> 可以把ssh底层结构体转成byte的切片的指针。</li><li>4.再通过 <code>*</code>转为指针指向的实际内容。</li></ul></li></ul><h3 id="翻转含有中文、数字、英文字母的字符串"><a href="#翻转含有中文、数字、英文字母的字符串" class="headerlink" title="翻转含有中文、数字、英文字母的字符串"></a>翻转含有<code>中文、数字、英文字母</code>的字符串</h3><ul><li><code>rune</code>关键字，从golang源码中看出，它是int32的别名（-2^31 ~ 2^31-1），比起byte（-128～127），<strong>可表示更多的字符</strong>。</li><li>由于rune可表示的范围更大，所以能处理一切字符，当然也包括<strong>中文字符</strong>。在平时计算中文字符，可用rune。</li><li>因此将<code>字符串</code>转为<code>rune的切片</code>，再进行翻转，完美解决。</li></ul><h3 id="在不执行resp-Body-Close-的情况下，泄漏了吗？如果泄漏，泄漏了多少个goroutine"><a href="#在不执行resp-Body-Close-的情况下，泄漏了吗？如果泄漏，泄漏了多少个goroutine" class="headerlink" title="在不执行resp.Body.Close()的情况下，泄漏了吗？如果泄漏，泄漏了多少个goroutine?"></a><strong>在不执行<code>resp.Body.Close()</code>的情况下，泄漏了吗？如果泄漏，泄漏了多少个<code>goroutine</code>?</strong></h3><ul><li><p><code>http.Get</code> 默认使用 <code>DefaultTransport</code> 管理连接。</p></li><li><p>所以结论呼之欲出了，虽然执行了 <code>6</code> 次循环，而且每次都没有执行 <code>Body.Close()</code> ,就是因为执行了<code>ioutil.ReadAll()</code>把内容都读出来了，连接得以复用，因此只泄漏了一个<code>读goroutine</code>和一个<code>写goroutine</code>，最后加上<code>main goroutine</code>，所以答案就是<code>3个goroutine</code>。</p></li><li><p>从另外一个角度说，正常情况下我们的代码都会执行 <code>ioutil.ReadAll()</code>，但如果此时忘了 <code>resp.Body.Close()</code>，确实会导致泄漏。但如果你<strong>调用的域名一直是同一个</strong>的话，那么只会泄漏一个 <code>读goroutine</code> 和一个<code>写goroutine</code>，<strong>这就是为什么代码明明不规范但却看不到明显内存泄漏的原因</strong>。</p></li></ul><h3 id="数据库连接池orm"><a href="#数据库连接池orm" class="headerlink" title="数据库连接池orm"></a>数据库连接池orm</h3><blockquote><p>本文由 <a href="http://ksria.com/simpread/">简悦 SimpRead</a> 转码， 原文地址 <a href="https://blog.csdn.net/gcglhd/article/details/109717743">blog.csdn.net</a></p></blockquote><p>背景：</p><pre><code>    在开发过程中遇到一个瓶颈那就是，数据库的连接池设置，有两个需求第一个就是**大量用户同时并发操作数据库的时候，会出现连接超时问题**。其次就是用户**少量的时候如何实现快速的实现数据的相关操作**：针对这两个问题，我们需要进行相关的数据库的配置。</code></pre><p>首先我们采用的是 Go 语言开发，然后使用的就是 Gorm 包进行相关的数据库操作。</p><ol><li>Grom 相关的学习文档如下：</li></ol><p><a href="http://gorm.book.jasperxu.com/">http://gorm.book.jasperxu.com/</a></p><p><a href="https://gorm.io/docs/generic_interface.html">https://gorm.io/docs/generic_interface.html</a></p><ol start="2"><li>连接池的原理参考博客：</li></ol><p><a href="https://blog.csdn.net/weixin_39902875/article/details/112098338">https://blog.csdn.net/weixin_39902875/article/details/112098338</a></p><p><a href="https://www.cnblogs.com/taoshihan/p/11922953.html">https://www.cnblogs.com/taoshihan/p/11922953.html</a></p><ol start="3"><li>针对背景中遇到的问题，我们进行相关的处理：</li></ol><p>1） 针对大量用户并发操作数据库出现连接超时问题：</p><p>gorm 底层是根据 sql.DB 实现的，而 sql.DB 里面提供了相关的配置函数：</p><pre><code class="hljs yaml"><span class="hljs-attr">datasource:</span>  <span class="hljs-attr">maxConn:</span> <span class="hljs-number">200</span>  <span class="hljs-attr">maxOpen:</span> <span class="hljs-number">200</span></code></pre><p>2）针对少量用户快速实现相关数据库1操作的问题：</p><p>gorm 底层是根据 sql.DB 实现的，而 sql.DB 里面提供了相关的配置函数：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Database <span class="hljs-keyword">struct</span> &#123;MaxConn <span class="hljs-keyword">int</span>MaxOpen <span class="hljs-keyword">int</span>&#125;<span class="hljs-keyword">var</span> DatabaseConfig = <span class="hljs-built_in">new</span>(Database) <span class="hljs-comment">//设置全局的引用型指针变量</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetConfig</span><span class="hljs-params">()</span> *<span class="hljs-title">Database</span></span> &#123;viper.SetConfigFile(<span class="hljs-string">&quot;conf/settings.yml&quot;</span>)content, err := ioutil.ReadFile(<span class="hljs-string">&quot;conf/settings.yml&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;ioutil获取配置文件失败！&quot;</span>)&#125;err = viper.ReadConfig(strings.NewReader(os.ExpandEnv(<span class="hljs-keyword">string</span>(content))))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Println(<span class="hljs-string">&quot;viperhuoqu 配置文件失败！&quot;</span>)&#125;cfgDatabase := viper.Sub(<span class="hljs-string">&quot;datasource&quot;</span>)DatabaseConfig = InitDatabase(cfgDatabase)<span class="hljs-keyword">return</span> DatabaseConfig&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">InitDatabase</span><span class="hljs-params">(cfg *viper.Viper)</span> *<span class="hljs-title">Database</span></span> &#123;db := &amp;Database&#123;MaxConn: cfg.GetInt(<span class="hljs-string">&quot;maxConn&quot;</span>),MaxOpen: cfg.GetInt(<span class="hljs-string">&quot;maxOpen&quot;</span>),&#125;<span class="hljs-keyword">return</span> db&#125;</code></pre><p><strong>3）一般情况上面的两个函数是一起使用的，而且最大连接数的设置，必须要大于最大可空闲连接数。</strong></p><p>实例：我们下面以一个 Gorm 的实例进行相关的使用说明：</p><p>第一步： 我们要采用配置文件的方式进行相关的测试，配置文件名称：setings.yml。内容如下：</p><pre><code class="hljs stata"><span class="hljs-keyword">var</span> <span class="hljs-keyword">DB</span> *gorm.<span class="hljs-keyword">DB</span>func main() &#123;<span class="hljs-comment">//获得一个*grom.DB对象</span><span class="hljs-keyword">DB</span>, <span class="hljs-keyword">err</span> := gorm.<span class="hljs-keyword">Open</span>(<span class="hljs-string">&quot;mysql&quot;</span>, <span class="hljs-string">&quot;username:password@/database?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span>)<span class="hljs-keyword">if</span> <span class="hljs-keyword">err</span> != nil &#123;fmt.Println(<span class="hljs-string">&quot;Gorm 异常：&quot;</span>, <span class="hljs-keyword">err</span>)&#125;<span class="hljs-comment">//根据*grom.DB对象获得*sql.DB的通用数据库接口</span>sqlDb := <span class="hljs-keyword">DB</span>.<span class="hljs-keyword">DB</span>()defer sqlDb.<span class="hljs-keyword">Close</span>()database := GetConfig()fmt.Println(<span class="hljs-string">&quot;maxConn: &quot;</span>, database.MaxConn)fmt.Println(<span class="hljs-string">&quot;maxOpen: &quot;</span>, database.MaxOpen)sqlDb.SetMaxOpenConns(database.MaxOpen)<span class="hljs-comment">//设置最大连接数</span>    sqlDb.SetMaxIdleConns(database.MaxConn) <span class="hljs-comment">//设置最大的空闲连接数</span>data, _ := json.Marshal(sqlDb.Stats()) <span class="hljs-comment">//获得当前的SQL配置情况</span>fmt.Println(<span class="hljs-built_in">string</span>(data))&#125;</code></pre><p>第二步：相关的 viper 获取配置文件信息，具体的细节可以参考我之前的相关博客：  </p><pre><code class="hljs taggerscript">GOROOT=D:<span class="hljs-symbol">\G</span>o #gosetupGOPATH=E:<span class="hljs-symbol">\G</span>opath;E:<span class="hljs-symbol">\D</span>evelop<span class="hljs-symbol">\g</span>owork;E:<span class="hljs-symbol">\G</span>ITwork<span class="hljs-symbol">\g</span>inWork #gosetupD:<span class="hljs-symbol">\G</span>o<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\g</span>o.exe build -o C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\g</span>ree<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\T</span>emp<span class="hljs-symbol">\_</span>__8go_build_main_go.exe E:<span class="hljs-symbol">\D</span>evelop<span class="hljs-symbol">\g</span>owork<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\t</span>est<span class="hljs-symbol">\m</span>ain.go #gosetupC:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\g</span>ree<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\T</span>emp<span class="hljs-symbol">\_</span>__8go_build_main_go.exe #gosetupmaxConn:  200maxOpen:  200&#123;&quot;MaxOpenConnections&quot;:200,&quot;OpenConnections&quot;:1,&quot;InUse&quot;:0,&quot;Idle&quot;:1,&quot;WaitCount&quot;:0,&quot;WaitDuration&quot;:0,&quot;MaxIdleClosed&quot;:0,&quot;MaxIdleTimeClosed&quot;:0,&quot;MaxLifetimeClosed&quot;:0&#125; Process finished with exit code 0</code></pre><p>第三步： 主函数进行相关的测试：</p><pre><code class="hljs stata">func Test2(t *testing.T) &#123;dsn := <span class="hljs-string">&quot;root:****@tcp(127.0.0.1:3306)/Mytest?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span><span class="hljs-keyword">db</span>, _ := gorm.<span class="hljs-keyword">Open</span>(mysql.<span class="hljs-keyword">Open</span>(dsn), &amp;gorm.Config&#123;&#125;)<span class="hljs-keyword">var</span> <span class="hljs-keyword">pro</span> ProTransMapping<span class="hljs-keyword">pro</span>.ID = 1 <span class="hljs-keyword">db</span>.Debug().Where(<span class="hljs-string">&quot;id = ?&quot;</span>,<span class="hljs-keyword">pro</span>.ID).Take(&amp;<span class="hljs-keyword">pro</span>)<span class="hljs-keyword">pro</span>.Manufacturer = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">pro</span>.DevicePro = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">db</span>.<span class="hljs-keyword">Save</span>(&amp;<span class="hljs-keyword">pro</span>)&#125;</code></pre><p> 最后一步就是：测试验证：</p><pre><code class="hljs taggerscript">GOROOT=D:<span class="hljs-symbol">\G</span>o #gosetupGOPATH=E:<span class="hljs-symbol">\G</span>opath;E:<span class="hljs-symbol">\D</span>evelop<span class="hljs-symbol">\g</span>owork;E:<span class="hljs-symbol">\G</span>ITwork<span class="hljs-symbol">\g</span>inWork #gosetupD:<span class="hljs-symbol">\G</span>o<span class="hljs-symbol">\b</span>in<span class="hljs-symbol">\g</span>o.exe build -o C:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\g</span>ree<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\T</span>emp<span class="hljs-symbol">\_</span>__8go_build_main_go.exe E:<span class="hljs-symbol">\D</span>evelop<span class="hljs-symbol">\g</span>owork<span class="hljs-symbol">\s</span>rc<span class="hljs-symbol">\t</span>est<span class="hljs-symbol">\m</span>ain.go #gosetupC:<span class="hljs-symbol">\U</span>sers<span class="hljs-symbol">\g</span>ree<span class="hljs-symbol">\A</span>ppData<span class="hljs-symbol">\L</span>ocal<span class="hljs-symbol">\T</span>emp<span class="hljs-symbol">\_</span>__8go_build_main_go.exe #gosetupmaxConn:  200maxOpen:  200&#123;&quot;MaxOpenConnections&quot;:200,&quot;OpenConnections&quot;:1,&quot;InUse&quot;:0,&quot;Idle&quot;:1,&quot;WaitCount&quot;:0,&quot;WaitDuration&quot;:0,&quot;MaxIdleClosed&quot;:0,&quot;MaxIdleTimeClosed&quot;:0,&quot;MaxLifetimeClosed&quot;:0&#125; Process finished with exit code 0</code></pre><p>二.  更新空值问题：</p><p><a href="https://www.cnblogs.com/oxspirt/p/11240527.html">https://www.cnblogs.com/oxspirt/p/11240527.html</a></p><pre><code>  方法 1 ：当前遇到一个问题，那就是使用 gorm 的时候采用更新方式去更新数据，如果更新后的值为 0，“” 或者 nil，就不会更新该字段，而是只更新非空的其他字段。</code></pre><p>解决方式，采用 map 去更新要更新的数据，不需要采用 struct 结构体。</p><pre><code>  方法 2： 采用 save 的方式，先进行 take 获取源数据，然后在 save 进行保存。</code></pre><pre><code class="hljs stata">func Test2(t *testing.T) &#123;dsn := <span class="hljs-string">&quot;root:****@tcp(127.0.0.1:3306)/Mytest?charset=utf8&amp;parseTime=True&amp;loc=Local&quot;</span><span class="hljs-keyword">db</span>, _ := gorm.<span class="hljs-keyword">Open</span>(mysql.<span class="hljs-keyword">Open</span>(dsn), &amp;gorm.Config&#123;&#125;)<span class="hljs-keyword">var</span> <span class="hljs-keyword">pro</span> ProTransMapping<span class="hljs-keyword">pro</span>.ID = 1 <span class="hljs-keyword">db</span>.Debug().Where(<span class="hljs-string">&quot;id = ?&quot;</span>,<span class="hljs-keyword">pro</span>.ID).Take(&amp;<span class="hljs-keyword">pro</span>)<span class="hljs-keyword">pro</span>.Manufacturer = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">pro</span>.DevicePro = <span class="hljs-string">&quot;&quot;</span><span class="hljs-keyword">db</span>.<span class="hljs-keyword">Save</span>(&amp;<span class="hljs-keyword">pro</span>)&#125;</code></pre><p>最近在使用 go 语言的 orm 做一些数据库的操作，最后发现了一个 bug 就是 invalid connection，所以就去的了解了一下链接池和 mysql 的超时时间，下面我就用 go 的 orm+mysql 来说明（我理解语言都是相通的，原理应该都是一样的）。</p><p>在我们要对数据库进行增删改查的时候，第一步就是要去连接数据库</p><pre><code class="hljs go"><span class="hljs-comment">//conn the database</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ConnDb</span><span class="hljs-params">(dbConnString <span class="hljs-keyword">string</span>, dbName <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;maxIdle := <span class="hljs-number">50</span>maxConn := <span class="hljs-number">50</span>err := orm.RegisterDataBase(dbName, <span class="hljs-string">&quot;mysql&quot;</span>, dbConnString+<span class="hljs-string">&quot;?charset=utf8&amp;loc=Asia%2FShanghai&quot;</span>, maxIdle, maxConn) <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;util.GLogger.Errorw(<span class="hljs-string">&quot;in Connect DB&quot;</span>, <span class="hljs-string">&quot;err&quot;</span>, err)&#125;<span class="hljs-keyword">return</span> err&#125;</code></pre><p>这里面连接的就是 mysql 数据库，设置的最大连接池为 50，最大空闲连接是 50。</p><p>而这个连接池主要是做什么的呢？简单的说就是，你要去数据库里面拿数据改数据，你就需要和数据库建立起一个管道，这个就是建立一个网络连接，我们都知道 tcp 连接是比较耗时的，那么既然已经花了一定时间去建立了这个管道，那么我怎么才能随取随用，而不用丢弃呢？那么连接池就是存放这些已经建立的管道的地方，50 这个数值呢，可以简单的理解成最多放 50 个管道，注意，这个并不是越大越好，因为太大的话会比较占内存，当然了太小了会出现等待阻塞的情况。</p><p>既然连接池里面就是放这些管道的，那么空闲连接就是指这些空闲的管道，那么就很明显了，空闲连接的数值设置就不要大于连接池的大小了，因为大了连接池也不会帮你保存那么多的空闲连接管道的。</p><p>了解了这些简单的概念之后，那么每次访问数据库的时候是怎么一个工作流呢？</p><p><img src="https://img-blog.csdnimg.cn/20190917000424380.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hhbmxhaXBlbmcxMQ==,size_16,color_FFFFFF,t_70"></p><p>通过这个图我们就可以很清晰的看到整个连接访问的流程。</p><p>step1（获取可用的连接）去连接池里面寻找可用的空闲连接，如果没有空闲的连接了，那么就去判断是否连接池已满，如果没有超过，那么就去新建一个连接，如果满了，那么就等待连接的释放；当然了，如果有空闲连接的话，就直接判断这个连接是否过期，没有过期就直接用，过期了就重新去判断这个连接池是否已经满了，没有的话就去新建连接，满了就等待。</p><p>step2 （操作数据库）拿到了这个连接就去做增删改查操作。</p><p>step3 （释放连接）操作完数据库之后需要释放连接，那么释放的连接就会空闲下来，如果超过空闲连接数，就是直接关闭掉，如果没有就给等待的使用。</p><p>那么你就会注意到了，这个连接是会失效的：</p><p>mysql 数据库的 timeout，当你和数据库建立起连接的时候，数据库不能一直信任你啊，那么数据库就有了超时这一说，就是过了这个时间段我就不信任你这个连接了，你必须再次和我连接，查看数据库设置的各种超时时间的语句如下：</p><pre><code class="hljs sql"><span class="hljs-keyword">show</span> <span class="hljs-keyword">variables</span> <span class="hljs-keyword">like</span>  <span class="hljs-string">&#x27;%timeout%&#x27;</span>;</code></pre><p>其中这里面会有两个超时时间：交互式连接超时时间（interactive_timeout）和非交互式连接超时时间（wait_timeout）</p><p>交互式连接：就是你通过命令行与 mysql 连接</p><p>非交互式连接：就是在程序中与 mysql 连接</p><p>而这个非交互超时时间就是在连接池里面一直空闲的连接的空闲时间超过 wait_timeout 的设定的时候就会失效。那么这个时候当程序拿到这个空闲连接的时候去做查询的时候就会出现最开始出现的问题，invalid connection。</p><p>了解了基本原理之后，针对 invalid connection 无效连接的解决办法就很简单了：</p><ol><li><p>延长数据库的 wait_timeout 时间。</p></li><li><p>程序定时去检查这些失效的连接及时丢弃掉，注意这里程序的检查时间就需要小于 mysql 设置的 wait_timeout 的值。</p></li></ol><p>以上就是我对连接池的理解，如有错误还请大神指出，谢谢～</p><h3 id="GRPC"><a href="#GRPC" class="headerlink" title="GRPC"></a>GRPC</h3><p>1、Simple RPC<br>proto语法 :<br>简单rpc 这就是一般的rpc调用，一个请求对象对应一个返回对象<br>proto语法：</p><p>rpc simpleHello(Person) returns (Result) {}<br>1<br>客户端发起一次请求，服务端响应一个数据，即标准RPC通信。<br>这种模式，一个每一次都是发起一个独立的tcp连接，走一次三次握手和四次挥手！</p><p>2、 Server-side streaming RPC<br>服务端流式rpc 一个请求对象，服务端可以传回多个结果对象<br>proto语法 :</p><p>rpc serverStreamHello(Person) returns (stream Result) {}<br>1<br>服务端流 RPC 下，客户端发出一个请求，但不会立即得到一个响应，而是在服务端与客户端之间建立一个单向的流，服务端可以随时向流中写入多个响应消息，最后主动关闭流，而客户端需要监听这个流，不断获取响应直到流关闭</p><p>应用场景举例：<br>典型的例子是客户端向服务端发送一个股票代码，服务端就把该股票的实时数据源源不断的返回给客户端。</p><p>3、Client-side streaming RPC<br>客户端流式rpc 客户端传入多个请求对象，服务端返回一个响应结果<br>proto语法 :</p><p>rpc clientStreamHello(stream Person) returns (Result) {}<br>1<br>应用场景：<br>物联网终端向服务器报送数据。</p><p>4、 Bidirectional streaming RPC<br>双向流式rpc 结合客户端流式rpc和服务端流式rpc，可以传入多个对象，返回多个响应对象<br>proto语法 :</p><p>rpc biStreamHello(stream Person) returns (stream Result) {}<br>1<br>应用场景：聊天应用。</p><p>总结<br>流式 RPC 定义与 简单 RPC 的区别只是在请求或返回参数前增加了 stream 关键词，如下：</p><p>service HelloService {<br>  // 客户端流式 RPC<br>  rpc SayHello1 (stream  HelloRequest) returns (HelloResponse);<br>  // 服务端流式 RPC<br>  rpc SayHello2 (HelloRequest) returns (stream HelloResponse);<br>  // 双向流式 RPC<br>  rpc SayHello3 (stream  HelloRequest) returns (stream HelloResponse);}<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>grpc应用场景<br>gRPC设计为低延迟和高吞吐量通信。gRPC非常适用于效率至关重要的轻型微服务。点对点实时通信 - gRPC对双向流媒体提供出色的支持。gRPC服务可以实时推送消息而无需轮询。多语言混合开发环境 - gRPC工具支持所有流行的开发语言，使gRPC成为多语言开发环境的理想选择。</p><p>网络受限环境 - 使用Protobuf（一种轻量级消息格式）序列化gRPC消息。gRPC消息始终小于等效的JSON消息。</p><h2 id="IAM-认证-授权"><a href="#IAM-认证-授权" class="headerlink" title="IAM 认证 授权"></a>IAM 认证 授权</h2><h2 id="Gin"><a href="#Gin" class="headerlink" title="Gin"></a>Gin</h2><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><h3 id="路由树"><a href="#路由树" class="headerlink" title="路由树"></a>路由树</h3><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><p>Map 与工厂模式<br>• Map 的 value 可以是⼀一个⽅方法<br>• 与 Go 的 Dock type 接⼝口⽅方式⼀一起，可以⽅方便便的实现单⼀一⽅方法对象的⼯工⼚厂模式</p><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="三次握手-四次挥手"><a href="#三次握手-四次挥手" class="headerlink" title="三次握手 四次挥手"></a>三次握手 四次挥手</h3><h3 id="TCP-与-UDP"><a href="#TCP-与-UDP" class="headerlink" title="TCP 与 UDP"></a>TCP 与 UDP</h3><h3 id="TCP-与-HTTP"><a href="#TCP-与-HTTP" class="headerlink" title="TCP 与 HTTP"></a>TCP 与 HTTP</h3><h3 id="HTTP-1-0-1-1-2-0-3-0"><a href="#HTTP-1-0-1-1-2-0-3-0" class="headerlink" title="HTTP 1.0 1.1 2.0 3.0"></a>HTTP 1.0 1.1 2.0 3.0</h3><h3 id="Rpc和Http的区别"><a href="#Rpc和Http的区别" class="headerlink" title="Rpc和Http的区别"></a>Rpc和Http的区别</h3><p>RPC：Remote Produce Call远程过程调用。自定义数据格式，基于原生TCP通信，速度快，效率高。</p><p>Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议。也可以用来进行远程服务调用。缺点是消息封装臃肿。</p><ul><li><strong>相同点</strong>：底层通讯都是基于socket，都可以实现远程调用，都可以实现服务调用服务</li><li><strong>不同点：</strong><br><strong>RPC</strong>：框架有：dubbo、cxf、（RMI远程方法调用）Hessian<br>当使用RPC框架实现服务间调用的时候，要求服务提供方和服务消费方 都必须使用统一的RPC框架，要么都dubbo，要么都cxf<br>跨操作系统在同一编程语言内使用<br>优势：调用快、处理快<br><strong>http</strong>：框架有：httpClient<br>当使用http进行服务间调用的时候，无需关注服务提供方使用的编程语言，也无需关注服务消费方使用的编程语言，服务提供方只需要提供restful风格的接口，服务消费方，按照restful的原则，请求服务，即可<br>跨系统跨编程语言的远程调用框架<br>优势：通用性强<br><strong>总结：对比RPC和http的区别</strong><br>1 RPC要求服务提供方和服务调用方都需要使用相同的技术，要么都hessian，要么都dubbo<br>而http无需关注语言的实现，只需要遵循rest规范<br>2 RPC的开发要求较多，像Hessian框架还需要服务器提供完整的接口代码(包名.类名.方法名必须完全一致)，否则客户端无法运行<br>3 Hessian只支持POST请求<br>4 Hessian只支持JAVA语言</li></ul><h3 id="TLS-加密原理"><a href="#TLS-加密原理" class="headerlink" title="TLS 加密原理"></a>TLS 加密原理</h3><h3 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h3><ul><li>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</li><li>2××：成功，报文已经收到并被正确处理；</li><li>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</li><li>4××：客户端错误，请求报文有误，服务器无法处理；</li><li>5××：服务器错误，服务器在处理请求时内部发生了错误。</li></ul><blockquote><p>HTTPS 解决了 HTTP 里 “明文”“不安全” 的缺点，尽最大可能保证着我们的上网安全。</p></blockquote><p>服务器收到请求报文，解析后需要进行处理，具体的业务逻辑多种多样，但最后必定是拼出一个响应报文发回客户端。</p><p>响应报文由响应头加响应体数据组成，响应头又由状态行和头字段构成。</p><p>我们先来复习一下状态行的结构，有三部分：</p><p><img src="https://static001.geekbang.org/resource/image/a1/00/a1477b903cd4d5a69686683c0dbc3300.png"></p><p>开头的 Version 部分是 HTTP 协议的版本号，通常是 HTTP/1.1，用处不是很大。</p><p>后面的 Reason 部分是原因短语，是状态码的简短文字描述，例如 “OK”“Not Found” 等等，也可以自定义。但它只是为了兼容早期的文本客户端而存在，提供的信息很有限，目前的大多数客户端都会忽略它。</p><p>所以，状态行里有用的就只剩下中间的状态码（Status Code）了。它是一个十进制数字，以代码的形式表示服务器对请求的处理结果，就像我们通常编写程序时函数返回的错误码一样。</p><p>不过你要注意，它的名字是 “状态码” 而不是“错误码”。也就是说，它的含义不仅是错误，更重要的意义在于表达 HTTP 数据处理的“状态”，客户端可以依据代码适时转换处理状态，例如继续发送请求、切换协议，重定向跳转等，有那么点 TCP 状态转换的意思。</p><p>目前 RFC 标准里规定的状态码是三位数，所以取值范围就是从 000 到 999。但如果把代码简单地从 000 开始顺序编下去就显得有点太 “low”，不灵活、不利于扩展，所以状态码也被设计成有一定的格式。</p><p>RFC 标准把状态码分成了五类，用数字的第一位表示分类，而 0<del>99 不用，这样状态码的实际可用范围就大大缩小了，由 000</del>999 变成了 100~599。</p><p>这五类的具体含义是：</p><p>1××：提示信息，表示目前是协议处理的中间状态，还需要后续的操作；</p><p>2××：成功，报文已经收到并被正确处理；</p><p>3××：重定向，资源位置发生变动，需要客户端重新发送请求；</p><p>4××：客户端错误，请求报文有误，服务器无法处理；</p><p>5××：服务器错误，服务器在处理请求时内部发生了错误。</p><p>在 HTTP 协议中，正确地理解并应用这些状态码不是客户端或服务器单方的责任，而是双方共同的责任。</p><p>客户端作为请求的发起方，获取响应报文后，需要通过状态码知道请求是否被正确处理，是否要再次发送请求，如果出错了原因又是什么。这样才能进行下一步的动作，要么发送新请求，要么改正错误重发请求。</p><p>服务器端作为请求的接收方，也应该很好地运用状态码。在处理请求时，选择最恰当的状态码回复客户端，告知客户端处理的结果，指示客户端下一步应该如何行动。特别是在出错的时候，尽量不要简单地返 400、500 这样意思含糊不清的状态码。</p><p>目前 RFC 标准里总共有 41 个状态码，但状态码的定义是开放的，允许自行扩展。所以 Apache、Nginx 等 Web 服务器都定义了一些专有的状态码。如果你自己开发 Web 应用，也完全可以在不冲突的前提下定义新的代码。</p><p>在我们的实验环境里也可以对这些状态码做测试验证，访问 URI“/12-1”，用查询参数 “code=xxx” 来检查这些状态码的效果，服务器不仅会在状态行里显示状态码，还会在响应头里用自定义的 “Expect-Code” 字段输出这个代码。</p><p><code>1××</code></p><p>1×× 类状态码属于提示信息，是协议处理的中间状态，实际能够用到的时候很少。</p><p>我们偶尔能够见到的是 “101 Switching Protocols”。它的意思是客户端使用 Upgrade 头字段，要求在 HTTP 协议的基础上改成其他的协议继续通信，比如 WebSocket。而如果服务器也同意变更协议，就会发送状态码 101，但这之后的数据传输就不会再使用 HTTP 了。</p><p><code>2××</code></p><p>2×× 类状态码表示服务器收到并成功处理了客户端的请求，这也是客户端最愿意看到的状态码。</p><p>“200 OK” 是最常见的成功状态码，表示一切正常，服务器如客户端所期望的那样返回了处理结果，如果是非 HEAD 请求，通常在响应头后都会有 body 数据。</p><p>“204 No Content”是另一个很常见的成功状态码，它的含义与 “200 OK” 基本相同，但响应头后没有 body 数据。所以对于 Web 服务器来说，正确地区分 200 和 204 是很必要的。</p><p>“206 Partial Content” 是 HTTP 分块下载或断点续传的基础，在客户端发送 “范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。</p><p>状态码 206 通常还会伴随着头字段 “Content-Range”，表示响应报文里 body 数据的具体范围，供客户端确认，例如 “Content-Range: bytes 0-99/2000”，意思是此次获取的是总计 2000 个字节的前 100 个字节。</p><p><code>3××</code></p><p>3×× 类状态码表示客户端请求的资源发生了变动，客户端必须用新的 URI 重新发送请求获取资源，也就是通常所说的 “重定向”，包括著名的 301、302 跳转。</p><p>“301 Moved Permanently” 俗称 “永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。</p><p>与它类似的是 “302 Found”，曾经的描述短语是 “Moved Temporarily”，俗称 “临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。</p><p>301 和 302 都会在响应头里使用字段 Location 指明后续要跳转的 URI，最终的效果很相似，浏览器都会重定向到新的 URI。两者的根本区别在于语义，一个是 “永久”，一个是 “临时”，所以在场景、用法上差距很大。</p><p>比如，你的网站升级到了 HTTPS，原来的 HTTP 不打算用了，这就是 “永久” 的，所以要配置 301 跳转，把所有的 HTTP 流量都切换到 HTTPS。</p><p>再比如，今天夜里网站后台要系统维护，服务暂时不可用，这就属于 “临时” 的，可以配置成 302 跳转，把流量临时切换到一个静态通知页面，浏览器看到这个 302 就知道这只是暂时的情况，不会做缓存优化，第二天还会访问原来的地址。</p><p>“304 Not Modified” 是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成 “重定向已到缓存的文件”（即 “缓存重定向”）。</p><p>301、302 和 304 分别涉及了 HTTP 协议里重要的 “重定向跳转” 和“缓存控制”，在之后的课程中我还会细讲。</p><p><code>4××</code></p><p>4×× 类状态码表示客户端发送的请求报文有误，服务器无法处理，它就是真正的 “错误码” 含义了。</p><p>“400 Bad Request” 是一个通用的错误码，表示请求报文有错误，但具体是数据格式错误、缺少请求头还是 URI 超长它没有明确说，只是一个笼统的错误，客户端看到 400 只会是 “一头雾水”“不知所措”。所以，在开发 Web 应用时应当尽量避免给客户端返回 400，而是要用其他更有明确含义的状态码。</p><p>“403 Forbidden” 实际上不是客户端的请求出错，而是表示服务器禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等，如果服务器友好一点，可以在 body 里详细说明拒绝请求的原因，不过现实中通常都是直接给一个 “闭门羹”。</p><p>“404 Not Found”可能是我们最常看见也是最不愿意看到的一个状态码，它的原意是资源在本服务器上未找到，所以无法提供给客户端。但现在已经被 “用滥了”，只要服务器“不高兴” 就可以给出个 404，而我们也无从得知后面到底是真的未找到，还是有什么别的原因，某种程度上它比 403 还要令人讨厌。</p><p>4×× 里剩下的一些代码较明确地说明了错误的原因，都很好理解，开发中常用的有：</p><p>405 Method Not Allowed：不允许使用某些方法操作资源，例如不允许 POST 只能 GET；</p><p>406 Not Acceptable：资源无法满足客户端请求的条件，例如请求中文但只有英文；</p><p>408 Request Timeout：请求超时，服务器等待了过长的时间；</p><p>409 Conflict：多个请求发生了冲突，可以理解为多线程并发时的竞态；</p><p>413 Request Entity Too Large：请求报文里的 body 太大；</p><p>414 Request-URI Too Long：请求行里的 URI 太大；</p><p>429 Too Many Requests：客户端发送了太多的请求，通常是由于服务器的限连策略；</p><p>431 Request Header Fields Too Large：请求头某个字段或总体太大；</p><p><code>5xx</code></p><p>5×× 类状态码表示客户端请求报文正确，但服务器在处理时内部发生了错误，无法返回应有的响应数据，是服务器端的 “错误码”。</p><p>“500 Internal Server Error” 与 400 类似，也是一个通用的错误码，服务器究竟发生了什么错误我们是不知道的。不过对于服务器来说这应该算是好事，通常不应该把服务器内部的详细信息，例如出错的函数调用栈告诉外界。虽然不利于调试，但能够防止黑客的窥探或者分析。</p><p>“501 Not Implemented”表示客户端请求的功能还不支持，这个错误码比 500 要 “温和” 一些，和 “即将开业，敬请期待” 的意思差不多，不过具体什么时候 “开业” 就不好说了。</p><p>“502 Bad Gateway” 通常是服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误，但具体的错误原因也是不知道的。</p><p>“503 Service Unavailable” 表示服务器当前很忙，暂时无法响应服务，我们上网时有时候遇到的 “网络服务正忙，请稍后重试” 的提示信息就是状态码 503。</p><p>503 是一个 “临时” 的状态，很可能过几秒钟后服务器就不那么忙了，可以继续提供服务，所以 503 响应报文里通常还会有一个 “Retry-After” 字段，指示客户端可以在多久以后再次尝试发送请求。</p><p><strong>小结</strong></p><p>状态码是十进制的三位数，分为五类，从 100 到 599；</p><p>2×× 类状态码表示成功，常用的有 200、204、206；</p><p>3×× 类状态码表示重定向，常用的有 301、302、304；</p><p>4×× 类状态码表示客户端错误，常用的有 400、403、404；</p><p>5×× 类状态码表示服务器错误，常用的有 500、501、502、503。</p><h3 id="RPC-调用与-HTTP-调用的区别"><a href="#RPC-调用与-HTTP-调用的区别" class="headerlink" title="RPC 调用与 HTTP 调用的区别"></a>RPC 调用与 HTTP 调用的区别</h3><p><strong>a. 区别：</strong></p><ul><li>-传输协议</li></ul><p>RPC，可以基于TCP协议，也可以基于HTTP协议</p><p>HTTP，基于HTTP协议</p><ul><li>传输效率</li></ul><p>RPC，使⽤⾃定义的TCP协议，可以让请求报⽂体积更⼩，或者使⽤HTTP2协议，也可以很好的减少报⽂的体积，提⾼传输效率</p><p>HTTP，如果是基于HTTP1.1的协议，请求中会包含很多⽆⽤的内容，如果是基于HTTP2.0，那么简单的封装以下是可以作为⼀个RPC来使⽤的，这时标准RPC框架更多的是服务治理</p><ul><li>性能消耗，主要在于序列化和反序列化的耗时</li></ul><p>RPC，可以基于thrift实现⾼效的⼆进制传输</p><p>HTTP，⼤部分是通过json来实现的，字节⼤⼩和序列化耗时都⽐thrift要更消耗性能</p><ul><li>负载均衡</li></ul><p>RPC，基本都⾃带了负载均衡策略</p><p>HTTP，需要配置Nginx，HAProxy来实现</p><ul><li>服务治理（下游服务新增，重启，下线时如何不影响上游调⽤者）</li></ul><p>RPC，能做到⾃动通知，不影响上游</p><p>HTTP，需要事先通知，修改Nginx/HAProxy配置</p><p><strong>b. 总结：</strong></p><p>RPC主要⽤于公司内部的服务调⽤，性能消耗低，传输效率⾼，服务治理⽅便。HTTP主要⽤于对外的异构环境，浏览器接⼝调⽤，APP接⼝调⽤，第三⽅接⼝调⽤等。</p><h3 id="机密性，完整性，身份认证和不可否认"><a href="#机密性，完整性，身份认证和不可否认" class="headerlink" title="机密性，完整性，身份认证和不可否认"></a>机密性，完整性，身份认证和不可否认</h3><p>机密性由对称加密AES保证，完整性由SHA384摘要算法保证，身份认证和不可否认由RSA非对称加密保证</p><h3 id="加密算法有哪些"><a href="#加密算法有哪些" class="headerlink" title="加密算法有哪些"></a>加密算法有哪些</h3><ul><li>对称加密算法；</li><li>非对称加密算法；</li><li>Hash算法；</li></ul><p>加密算法的核心思想是“把一个小秘密（密钥）转化为一个大秘密（密文消息）”，守住了小秘密，也就守住了大秘密；</p><p>对称加密只使用一个密钥，运算速度快，密钥必须保密，无法做到安全的密钥交换，常用的有 AES 和 ChaCha20；</p><p>非对称加密使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢，常用的有 RSA 和 ECC；</p><p>把对称加密和非对称加密结合起来就得到了“又好又快”的混合加密，也就是 TLS 里使用的加密方式。</p><h3 id="Go-对密码加密"><a href="#Go-对密码加密" class="headerlink" title="Go 对密码加密"></a>Go 对密码加密</h3><p>密码 + 盐（一串随机数） 再Hash</p><p><strong><em>\</em>Go语言提供了一种较为安全的加密方式，使用GoLang golang.org/x/crypto/bcrypt 模块，通过该模块可以快速实现密码的存储处理。**</strong></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><h3 id="查看-CPU-占用前五的进程"><a href="#查看-CPU-占用前五的进程" class="headerlink" title="查看 CPU 占用前五的进程"></a>查看 CPU 占用前五的进程</h3><p>linux 下 取进程占用 cpu 最高的前10个进程</p><p>ps aux|head -1;ps aux|grep -v PID|sort -rn -k +3|head</p><p>linux 下 取进程占用内存(MEM)最高的前10个进程</p><p>ps aux|head -1;ps aux|grep -v PID|sort -rn -k +4|head</p><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="恢复上一次-commit"><a href="#恢复上一次-commit" class="headerlink" title="恢复上一次 commit"></a>恢复上一次 commit</h3><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="快速排序-1"><a href="#快速排序-1" class="headerlink" title="快速排序"></a>快速排序</h3><h3 id="最小二乘法"><a href="#最小二乘法" class="headerlink" title="最小二乘法"></a>最小二乘法</h3><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LeastSquares</span><span class="hljs-params">(x[]<span class="hljs-keyword">float64</span>,y[]<span class="hljs-keyword">float64</span>)</span><span class="hljs-params">(a <span class="hljs-keyword">float64</span>,b <span class="hljs-keyword">float64</span>)</span></span>&#123;    <span class="hljs-comment">// x是横坐标数据,y是纵坐标数据</span>    <span class="hljs-comment">// a是斜率，b是截距</span>    xi := <span class="hljs-keyword">float64</span>(<span class="hljs-number">0</span>)    x2 := <span class="hljs-keyword">float64</span>(<span class="hljs-number">0</span>)    yi := <span class="hljs-keyword">float64</span>(<span class="hljs-number">0</span>)    xy := <span class="hljs-keyword">float64</span>(<span class="hljs-number">0</span>)    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(x)!= <span class="hljs-built_in">len</span>(y) &#123;        beego.Debug(<span class="hljs-string">&quot;最小二乘时，两数组长度不一致!&quot;</span>)    &#125;<span class="hljs-keyword">else</span> &#123;        length := <span class="hljs-keyword">float64</span>(<span class="hljs-built_in">len</span>(x))        <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(x); i++&#123;            xi += x[i]            x2 += x[i] * x[i]            yi += y[i]            xy += x[i] * y[i]        &#125;        a = (yi * xi - xy * length) / (xi * xi - x2 * length)        b = (yi * x2 - xy * xi) / (x2 * length - xi * xi)    &#125;    <span class="hljs-keyword">return</span>&#125;</code></pre><h3 id="双蛋问题"><a href="#双蛋问题" class="headerlink" title="双蛋问题"></a>双蛋问题</h3><p>分十组，每组遍历</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview,go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows shell</title>
    <link href="/2022/01/04/tmp/windows/shell/"/>
    <url>/2022/01/04/tmp/windows/shell/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows-shell"><a href="#Windows-shell" class="headerlink" title="Windows shell"></a>Windows shell</h1><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> window 编辑shell脚本导致无法执行问题</span>set ff=unix</code></pre><h2 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h2><blockquote><p>mklink<br>Creates a symbolic link.<br>MKLINK [[/D] | [/H] | [/J]] Link Target /D Creates a directory symbolic link. Default is a file symbolic link. /H Creates a hard link instead of a symbolic link. /J Creates a Directory Junction.<br>       Link specifies the new symbolic link name.<br>        Target specifies the path (relative or absolute) that the new link refers to.</p></blockquote><pre><code class="hljs shell">mklink /J &quot;e:\test&quot; &quot;f:\test&quot; &quot;e:\test&quot; 这个文件夹事先不能存在，是要创建的目标文件夹（映射的)<span class="hljs-meta">#</span><span class="bash">[[建立d]]:develop链接目录，指向远程的目标服务器上的e盘的对应目录。</span>mklink /d d:\develop \\138.20.1.141\e$\develop<span class="hljs-meta">#</span><span class="bash">[[建立d]]:develop链接目录，指向远程的目标服务器上的e盘的对应目录。</span>mklink /d d:\recivefiles \\138.20.1.141\e$\recivefiles[[删除虚拟的链接目录，并不会删除远程文件夹真实文件，注意千万不能用del，del]]会删除远程的真实文件。 rmdir d:\recivefiles rmdir d:\develop</code></pre><ul><li>添加启动项</li></ul><ol><li>打开电脑，然后点击左下角开始选项；</li><li>接着在弹出的选项中选择允许选项；</li><li>这时候弹出运行框，我们输入shell:startup，点击确定；</li><li>这时候弹出开机<strong>启动项</strong>文件夹；</li><li>然后根据实际需要选择合适的软件，单击右键，选择复制；</li><li>回到开机<strong>启动项</strong>文件夹，单击右键，选择粘贴即可。</li></ol><p>attrib +h +s * /s /d<br>attrib -h -s * /s /d</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>win</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github</title>
    <link href="/2021/12/31/tmp/github%E5%8A%A0%E9%80%9F/"/>
    <url>/2021/12/31/tmp/github%E5%8A%A0%E9%80%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="Github-加速"><a href="#Github-加速" class="headerlink" title="Github 加速"></a>Github 加速</h1><ul><li>github.com.cnpmjs.org</li><li>hub.fastgit.org</li><li>git.sdut.me</li><li>github.wuyanzheshui.workers.dev</li><li>raw.Githubusercontent.Com</li></ul><ul><li><a href="http://toolwa.com/github">http://toolwa.com/github</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go_perf</title>
    <link href="/2021/12/29/go/Go_perf/"/>
    <url>/2021/12/29/go/Go_perf/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-perf"><a href="#Go-perf" class="headerlink" title="Go perf"></a>Go perf</h1><h2 id="1-net"><a href="#1-net" class="headerlink" title="1. net"></a>1. net</h2><h3 id="1-1-拼接-ip"><a href="#1-1-拼接-ip" class="headerlink" title="1.1 拼接 ip"></a>1.1 拼接 ip</h3><pre><code class="hljs shell">net.JoinHostPort(s.BindAddress, strconv.Itoa(s.BindPort))</code></pre><h3 id="1-2-设置-body"><a href="#1-2-设置-body" class="headerlink" title="1.2 设置 body"></a>1.2 设置 body</h3><pre><code class="hljs shell">body := bytes.NewBufferString(`&#123;&quot;nickname&quot;:&quot;admin2&quot;,&quot;email&quot;:&quot;admin2@foxmail.com&quot;,&quot;phone&quot;:&quot;1812885xxx&quot;&#125;`)</code></pre><h3 id="1-3-替换标准库"><a href="#1-3-替换标准库" class="headerlink" title="1.3 替换标准库"></a>1.3 替换标准库</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 日志库能够兼容标准库 <span class="hljs-built_in">log</span> 包，我们就可以很容易地替换掉标准库 <span class="hljs-built_in">log</span> 包</span><span class="hljs-meta">#</span><span class="bash"> logrus 就兼容标准库 <span class="hljs-built_in">log</span> 包</span>log &quot;github.com/sirupsen/logrus&quot;</code></pre><p><img src="https://tool.lu/netcard/" alt="IP签名"></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>01 Docker</title>
    <link href="/2021/12/27/cloud/K8S/K8S-M/01%20docker/"/>
    <url>/2021/12/27/cloud/K8S/K8S-M/01%20docker/</url>
    
    <content type="html"><![CDATA[<h1 id="01-Docker"><a href="#01-Docker" class="headerlink" title="01 Docker"></a>01 Docker</h1><h2 id="1-Namespace"><a href="#1-Namespace" class="headerlink" title="1. Namespace"></a>1. Namespace</h2><blockquote><p>namespace 是 linux 系统的底层概念，在内核层实现，即有一些不同类型的命名空间被部署在内核，各个 docker 容器运行在同一个 docker 主进程并且共用同一个宿主机系统内核，各 docker 容器运行在宿主机的用户空间，每个容器都要有类似于虚拟机一样的相互隔离的运行空间，但容器技术是在一个进程内是在哪运行指定服务的运行环境，并且还可以保护宿主机不受其他进程的干扰和影响，如文件系统空间、网络空间、进程空间等，目前主要通过以下技术实现容器运行空间的相互隔离。</p></blockquote><table><thead><tr><th align="center">隔离类型</th><th align="center">功能</th><th align="center">系统调用参数</th><th align="center">内核版本</th></tr></thead><tbody><tr><td align="center">MNT Namespace(mount)</td><td align="center">提供磁盘挂载点和文件系统的隔离能力</td><td align="center">CLONE_NEWNS</td><td align="center">Linux 2.4.19</td></tr><tr><td align="center">IPC Namespace(Inter-Process Communication)</td><td align="center">提供进程间通信的隔离能力</td><td align="center">CLONE_NEWIPC</td><td align="center">Linux 2.6.19</td></tr><tr><td align="center">UTS Namespace(UNIX Timesharing System)</td><td align="center">提供主机名隔离能力</td><td align="center">CLONE_NEWUTS</td><td align="center">Linux 2.6.19</td></tr><tr><td align="center">PID Namespace(Process Identification)</td><td align="center">提供进程隔离能力</td><td align="center">CLONE_NEWPID</td><td align="center">Linux 2.6.24</td></tr><tr><td align="center">Net Namespace(network)</td><td align="center">提供网络隔离能力</td><td align="center">CLONE_NEWNET</td><td align="center">Linux 2.6.29</td></tr><tr><td align="center">User Namespace(user)</td><td align="center">提供用户隔离能力</td><td align="center">CLONE_NEWUSER</td><td align="center">Linux 3.8</td></tr></tbody></table><h3 id="1-1-MNT-Namespace"><a href="#1-1-MNT-Namespace" class="headerlink" title="1.1 MNT Namespace"></a>1.1 MNT Namespace</h3><ul><li><p>每个容器都要有独立的根文件系统、独立的用户空间，以实现在容器内启动服务并且使用容器的运行环境。</p></li><li><p>即一个宿主机是 Ubuntu 的服务器，可以在里面启动一个 centos 运行环境的容器并且在容器里面启动个 Nginx 服务，此 Nginx 运行时使用的运行环境就是 centos 系统目录的运行环境，但是在容器里面是不能访问主机的资源，宿主机是使用了 <strong>chroot</strong> 技术把容器锁定到一个指定的运行目录里面并作为容器的根运行环境。</p></li></ul><h3 id="1-2-IPC-Namespace"><a href="#1-2-IPC-Namespace" class="headerlink" title="1.2 IPC Namespace"></a>1.2 IPC Namespace</h3><ul><li>容器内的进程间通信，允许容器内的不同进程的访问。</li></ul><h3 id="1-3-UTS-Namespace"><a href="#1-3-UTS-Namespace" class="headerlink" title="1.3 UTS Namespace"></a>1.3 UTS Namespace</h3><ul><li><p>UNIX Timesharing System 包含了运行内核的名称、版本、底层体系结构类型等信息</p></li><li><p>用于系统标识，其中包含了 hostname 和 域名 domainname，它使得一个容器拥有属于自己 hostname 标识，这个主机名标识独立于宿主机系统和其上的其他容器。</p></li></ul><h3 id="1-4-PID-Namespace"><a href="#1-4-PID-Namespace" class="headerlink" title="1.4 PID Namespace"></a>1.4 PID Namespace</h3><ul><li>Linux 系统中，有一个 PID 为 1 的进程（init/systemd）是其他所有进程的父进程，那么在每个容器内也要有一个父进程来管理其下属的自己成，那么多个容器的进程通过 PID Namespace 进程隔离（如 PID 编号重复、容器内的主进程生成与回收子进程等）。</li></ul><h3 id="1-5-Net-Namespace"><a href="#1-5-Net-Namespace" class="headerlink" title="1.5 Net Namespace"></a>1.5 Net Namespace</h3><ul><li>每个容器都类似于虚拟机一个样有自己的网卡、监听端口、TCP/IP 协议栈等，Docker 使用 network namespace 启动一个 vethX 接口，这样你的容器将拥有它自己的桥接 ip 地址，通常是 docker0，而docker0 实质就是 Linux 的虚拟网桥，网桥是在 OSI 七层模型的数据链路层的网络设备，通过 MAC 地址对网络进行划分，并且在不同网络直接传递数据。</li></ul><h3 id="1-6-User-Namespace"><a href="#1-6-User-Namespace" class="headerlink" title="1.6 User Namespace"></a>1.6 User Namespace</h3><ul><li><p>各个容器内可能会出现重名的用户和用户组名称，或重复的用户 UID 或 GID，那么怎么隔离各个容器内的用户空间。</p></li><li><p>User Namespace 允许在各个宿主机的各个容器空间内创建相同的用户名以及相同的用户 UID 和 GID，只是会把用户的作用范围限制在每个容器内，即 A 容器和 B 容器可以有相同的用户名称和 ID 的账户，但是此用户的有效范围仅是当前容器内，不能访问另一个容器内的文件系统，即相互隔离、互不影响、永不相见。</p></li></ul><h2 id="2-Cgroup"><a href="#2-Cgroup" class="headerlink" title="2. Cgroup"></a>2. Cgroup</h2><blockquote><p>在一个容器内，如果不对其做任何资源限制，则宿主机会允许其占用无限大的内存空间，有时候会因为代码 BUG 导致程序一直申请内存，直到把宿主机内存占尽，为了避免此类的问题集出现，宿主机有必要对容器进行资源分配限制，比如 CPU、内存等。</p><p>Linxu Cgroups，全称 Linux Control Groups，限制一个进程组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等，此外，还能够对进程进行优先级设置，以及将进程挂起和恢复等操作。</p><p>Cgroups 在内核层默认已经开启，从 centos 和 ubuntu 对比结果来看，显然内核较新的 ubuntu 支持的功能更多。</p></blockquote><h3 id="2-1-查看命令"><a href="#2-1-查看命令" class="headerlink" title="2.1 查看命令"></a>2.1 查看命令</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 具体查看 /boot 目录</span><span class="hljs-meta">#</span><span class="bash"> 具体内核版本自行 TAB 补全</span>cat /boot/config-5.4.0-51-generic |grep CGROUP | grep -v &quot;^#&quot;cat /boot/config-5.4.0-51-generic |grep CGROUP | grep -v &quot;^#&quot; |wc -l<span class="hljs-meta">#</span><span class="bash"> 查看内存限制</span>cat /boot/config-5.4.0-51-generic |grep MEM |grep CG |grep -v &quot;^#&quot;</code></pre><h3 id="2-2-具体实现"><a href="#2-2-具体实现" class="headerlink" title="2.2 具体实现"></a>2.2 具体实现</h3><ul><li>blkio: 块设备 IO  限制</li><li>cpu: 使用调度程序为 cgroup 任务提供 CPU 的访问</li><li>cpuacct: 产生 cgroup 任务的 CPU 资源报告</li><li>cpuet: 入股欧式多核心的 CPU，这个子系统会为 cgroup 任务分配单独的 CPU 和内存</li><li>devices: 允许或拒绝 cgroup 任务对设备的访问</li><li>freezer: 暂停和恢复 cgroup 任务</li><li>memory: 设置每个 cgroup 的内存限制以及产生内存资源报告</li><li>net_cls: 标记每个网络包以供 cgroup 仿版使员工</li><li>ns: 命名空间子系统</li><li>perf_event: 增加了对每个 cgroup 的监测跟踪的能力，可以监测属于某个特定的 cgroup 的所有线程以及运行在特定 CPU 上的线程</li></ul><h2 id="3-Docker-Install"><a href="#3-Docker-Install" class="headerlink" title="3. Docker Install"></a>3. Docker Install</h2><h3 id="3-1-Install-On-Centos-7"><a href="#3-1-Install-On-Centos-7" class="headerlink" title="3.1 Install On Centos 7"></a>3.1 Install On Centos 7</h3><blockquote><p>注意 ：<br>yum -y update：升级所有包同时也升级软件和系统内核；<br>yum -y upgrade：只升级所有包，不升级软件和系统内核。</p></blockquote><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看内核版本</span>uname -r<span class="hljs-meta">#</span><span class="bash"> 更新 yum 包</span>yum -y update<span class="hljs-meta">#</span><span class="bash"> 卸载旧版 docker</span>yum remove -y docker docker-common docker-selinux docker-engine<span class="hljs-meta">#</span><span class="bash"> 安装依赖包</span>yum install -y yum-utils device-mapper-persistent-data lvm2<span class="hljs-meta">#</span><span class="bash"> 添加 yum 源</span>yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repoyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span class="hljs-meta">#</span><span class="bash"> 查看docker 版本</span>yum list docker-ce --showduplicates | sort -r<span class="hljs-meta">#</span><span class="bash"> 选择 docker 版本安装</span>yum -y install docker-ce-3:20.10.9-3.el7<span class="hljs-meta">#</span><span class="bash"> 启动 Docker</span>systemctl start docker<span class="hljs-meta">#</span><span class="bash"> 开机启动 docker</span>systemctl enable docker<span class="hljs-meta">#</span><span class="bash"> 安装 docker compose</span>curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composedocker-compose -vsystemctl daemon-reloadservice docker restartservice docker status</code></pre><h3 id="3-2-Install-On-Ubuntu"><a href="#3-2-Install-On-Ubuntu" class="headerlink" title="3.2 Install On Ubuntu"></a>3.2 Install On Ubuntu</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 备份初始源</span>cp /etc/apt/sources.list /etc/apt/sources.list_backuptee /etc/apt/sources.list &lt;&lt; EOF<span class="hljs-meta">#</span><span class="bash">  阿里源</span>deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverseEOF<span class="hljs-meta">#</span><span class="bash"> 添加公钥</span>apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 40976EAF437D05B5apt-key adv --keyserver keyserver.ubuntu.com --recv-keys 3B4FE6ACC0B21F32apt-get -y update apt-get -y upgradeapt-get -y install build-essentialapt -y autoremove<span class="hljs-meta">#</span><span class="bash"> 卸载旧版</span>sudo apt-get remove docker docker-engine docker.io containerd runc<span class="hljs-meta">#</span><span class="bash"> 安装 docker 1</span>curl -fsSL https://get.docker.com | bash -s docker --mirror aliyun<span class="hljs-meta">#</span><span class="bash"> 安装 docker 2</span>curl -sSL https://get.daocloud.io/docker | sh<span class="hljs-meta">#</span><span class="bash"> 安装 docker compose</span>curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composedocker-compose -vsystemctl daemon-reloadservice docker restartservice docker status</code></pre><h3 id="3-3-Install-bash-completion"><a href="#3-3-Install-bash-completion" class="headerlink" title="3.3 Install bash-completion"></a>3.3 Install bash-completion</h3><pre><code class="hljs shell">yum install -y bash-completionapt install -y bash-completionsource /usr/share/bash-completion/bash_completionsource /usr/share/bash-completion/completions/docker</code></pre><h2 id="4-Docker-Command"><a href="#4-Docker-Command" class="headerlink" title="4. Docker Command"></a>4. Docker Command</h2><blockquote><p>官方手册</p><p><a href="https://docs.docker.com/engine/reference/run/">Docker 基础命令</a></p></blockquote><h3 id="4-0-build-脚本"><a href="#4-0-build-脚本" class="headerlink" title="4.0 build 脚本"></a>4.0 build 脚本</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/usr/bin/env bash</span>images=(    &#x27;harbor.test.com/1ch0/centos-app:7.6&#x27;    &#x27;harbor.test.com/1ch0/centos-app&#x27;)for image in $&#123;images[@]&#125;; do    docker build -t &quot;$image&quot; .    docker push &quot;$image&quot;done</code></pre><h3 id="4-1-容器信息"><a href="#4-1-容器信息" class="headerlink" title="4.1 容器信息"></a>4.1 容器信息</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">[[查看docker]]容器版本</span>docker version<span class="hljs-meta">#</span><span class="bash">[[查看docker]]容器信息</span>docker info<span class="hljs-meta">#</span><span class="bash">[[查看docker]]容器帮助</span>docker --help</code></pre><h3 id="4-2-镜像操作"><a href="#4-2-镜像操作" class="headerlink" title="4.2 镜像操作"></a>4.2 镜像操作</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 删除 tag 为 none 的镜像</span>docker images|grep none|awk &#x27;&#123;print $3&#125;&#x27;|xargs docker rmi -f<span class="hljs-meta">#</span><span class="bash">[[列出本地images]]</span>docker images<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#含中间映像层</span></span>docker images -a<span class="hljs-meta">#</span><span class="bash">[[只显示镜像ID]]</span>docker images -q<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#含中间映像层</span></span>docker images -qa   <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#显示镜像摘要信息(DIGEST列)</span></span>docker images --digests<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#显示镜像完整信息</span></span>docker images --no-trunc<span class="hljs-meta">#</span><span class="bash">[[搜索仓库MySQL]]镜像</span>docker search mysql<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># --filter=stars=600：只显示 starts&gt;=600 的镜像</span></span>docker search --filter=stars=600 mysql<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># --no-trunc 显示镜像完整 DESCRIPTION 描述</span></span>docker search --no-trunc mysql<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># --automated ：只列出 AUTOMATED=OK 的镜像</span></span>docker search  --automated mysql<span class="hljs-meta">#</span><span class="bash">[[搜索仓库MySQL]]镜像</span>docker search mysql<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># --filter=stars=600：只显示 starts&gt;=600 的镜像</span></span>docker search --filter=stars=600 mysql<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># --no-trunc 显示镜像完整 DESCRIPTION 描述</span></span>docker search --no-trunc mysql<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># --automated ：只列出 AUTOMATED=OK 的镜像</span></span>docker search  --automated mysql<span class="hljs-meta">#</span><span class="bash">[[下载Redis官方最新镜像，相当于：docker]] pull redis:latest</span>docker pull redis<span class="hljs-meta">#</span><span class="bash">[[下载仓库所有Redis]]镜像</span>docker pull -a redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#下载私人仓库镜像</span></span>docker pull bitnami/redis<span class="hljs-meta">#</span><span class="bash">[[单个镜像删除，相当于：docker]] rmi redis:latest</span>docker rmi redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#强制删除(针对基于镜像有运行的容器进程)</span></span>docker rmi -f redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#多个镜像删除，不同镜像间以空格间隔</span></span>docker rmi -f redis tomcat nginx<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#删除本地全部镜像</span></span>docker rmi -f $(docker images -q)<span class="hljs-meta">#</span><span class="bash">[[（1）编写dockerfile]]</span>cd /docker/dockerfilevim mycentos<span class="hljs-meta">#</span><span class="bash">[[（2）构建docker]]镜像</span>docker build -f /docker/dockerfile/mycentos -t mycentos:1.1</code></pre><h3 id="4-3-容器操作"><a href="#4-3-容器操作" class="headerlink" title="4.3 容器操作"></a>4.3 容器操作</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">[[新建并启动容器，参数：-i]]  以交互模式运行容器；-t  为容器重新分配一个伪输入终端；--name  为容器指定一个名称</span>docker run -i -t --name mycentos<span class="hljs-meta">#</span><span class="bash">[[后台启动容器，参数：-d]]  已守护方式启动容器</span>docker run -d mycentos<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#启动一个或多个已经被停止的容器</span></span>docker start redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#重启容器</span></span>docker restart redis[[top]]支持 ps 命令参数，格式：docker top [OPTIONS] CONTAINER [ps OPTIONS]<span class="hljs-meta">#</span><span class="bash">[[列出redis]]容器中运行进程</span>docker top redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#查看所有运行容器的进程信息</span></span>for i in  `docker ps |grep Up|awk &#x27;&#123;print $1&#125;&#x27;`;do echo \ &amp;&amp;docker top $i; done<span class="hljs-meta">#</span><span class="bash">[[查看redis]]容器日志，默认参数</span>docker logs rabbitmq<span class="hljs-meta">#</span><span class="bash">[[查看redis容器日志，参数：-f]]  跟踪日志输出；-t   显示时间戳；--tail  仅列出最新N条容器日志；</span>docker logs -f -t --tail=20 redis<span class="hljs-meta">#</span><span class="bash">[[查看容器redis从2019年05月21日后的最新10]]条日志。</span>docker logs --since=&quot;2019-05-21&quot; --tail=10 redis<span class="hljs-meta">#</span><span class="bash">[[使用run]]方式在创建时进入</span>docker run -it centos /bin/bash<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#关闭容器并退出</span></span>exit<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#仅退出容器，不关闭</span></span>快捷键：Ctrl + P + Q<span class="hljs-meta">#</span><span class="bash">[[直接进入centos]] 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=<span class="hljs-literal">false</span>  确保CTRL-D或CTRL-C不会关闭容器</span>docker attach --sig-proxy=false centos <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i  即使没有附加也保持STDIN 打开；-t  分配一个伪终端</span></span>docker exec -i -t  centos /bin/bash<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#以交互模式在容器中执行命令，结果返回到当前终端屏幕</span></span>docker exec -i -t centos ls -l /tmp<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端</span></span>docker exec -d centos  touch cache.txt <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#查看正在运行的容器</span></span>docker ps<span class="hljs-meta">#</span><span class="bash">[[查看正在运行的容器的ID]]</span>docker ps -q<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#查看正在运行+历史运行过的容器</span></span>docker ps -a<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#显示运行容器总文件大小</span></span>docker ps -s<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#显示最近创建容器</span></span>docker ps -l<span class="hljs-meta">#</span><span class="bash">[[显示最近创建的3]]个容器</span>docker ps -n 3<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#不截断输出</span></span>docker ps --no-trunc <span class="hljs-meta">#</span><span class="bash">[[获取镜像redis]]的元信息</span>docker inspect redis<span class="hljs-meta">#</span><span class="bash">[[获取正在运行的容器redis]]的 IP</span>docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#停止一个运行中的容器</span></span>docker stop redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#杀掉一个运行中的容器</span></span>docker kill redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#删除一个已停止的容器</span></span>docker rm redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#删除一个运行中的容器</span></span>docker rm -f redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#删除多个容器</span></span>docker rm -f $(docker ps -a -q)docker ps -a -q | xargs docker rm<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># -l 移除容器间的网络连接，连接名为 db</span></span>docker rm -l db <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># -v 删除容器，并删除容器挂载的数据卷</span></span>docker rm -v redis<span class="hljs-meta">#</span><span class="bash">[[基于当前redis容器创建一个新的镜像；参数：-a]] 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停</span>docker commit -a=&quot;DeepInThought&quot; -m=&quot;my redis&quot; [redis容器ID]  myredis:v1.1<span class="hljs-meta">#</span><span class="bash">[[将rabbitmq容器中的文件copy]]至本地路径</span>docker cp rabbitmq:/[container_path] [local_path]<span class="hljs-meta">#</span><span class="bash">[[将主机文件copy至rabbitmq]]容器</span>docker cp [local_path] rabbitmq:/[container_path]/<span class="hljs-meta">#</span><span class="bash">[[将主机文件copy至rabbitmq]]容器，目录重命名为[container_path]（注意与非重命名copy的区别）</span>docker cp [local_path] rabbitmq:/[container_path]</code></pre><h2 id="5-Harbor-Install"><a href="#5-Harbor-Install" class="headerlink" title="5. Harbor Install"></a><a href="https://k8scat.com/posts/harbor/install-single-instance/">5. Harbor Install</a></h2><h3 id="5-1-生成证书"><a href="#5-1-生成证书" class="headerlink" title="5.1 生成证书"></a>5.1 生成证书</h3><pre><code class="hljs shell">apt install opensslcurl -LO https://github.com/goharbor/harbor/releases/download/v2.2.2/harbor-online-installer-v2.2.2.tgztar -zxvf harbor-online-installer-v2.2.2.tgz &amp;&amp; rm -f harbor-online-installer-v2.2.2.tgzcd harbor &amp;&amp; ls -la<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 自建 CA</span></span>openssl genrsa -out ca.key 4096openssl req -x509 -new -nodes -sha512 -days 3650 \    -subj &quot;/C=CN/ST=Shenzhen/L=Shenzhen/O=example/OU=Personal/CN=k8scat.com&quot; \    -key ca.key \    -out ca.crt<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 生成域名证书</span></span>openssl genrsa -out harbor.k8scat.com.key 4096<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 生成证书签名请求文件 CSR（Certificate Signing Request）</span></span>openssl req -sha512 -new \    -subj &quot;/C=CN/ST=Shenzhen/L=Shenzhen/O=example/OU=Personal/CN=harbor.k8scat.com&quot; \    -key harbor.k8scat.com.key \    -out harbor.k8scat.com.csr<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 生成 x509 v3 扩展文件，以此来满足 SAN（Subject Alternative Name） 和 x509 v3 扩展的要求</span></span>cat &gt; v3.ext &lt;&lt;-EOFauthorityKeyIdentifier=keyid,issuerbasicConstraints=CA:FALSEkeyUsage = digitalSignature, nonRepudiation, keyEncipherment, dataEnciphermentextendedKeyUsage = serverAuthsubjectAltName = @alt_names[alt_names]DNS.1=harbor.k8scat.comEOF<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 使用 ca.crt、ca.key、harbor.k8scat.com.csr 和 v3.ext 来生成我们需要的域名证书</span></span>openssl x509 -req -sha512 -days 3650 \    -extfile v3.ext \    -CA ca.crt -CAkey ca.key -CAcreateserial \    -in harbor.k8scat.com.csr \    -out harbor.k8scat.com.crt</code></pre><h3 id="5-2-配置证书"><a href="#5-2-配置证书" class="headerlink" title="5.2 配置证书"></a>5.2 配置证书</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 配置 Harbor 和 Docker 的证书</span></span>mkdir -p /data/cert/cp harbor.k8scat.com.crt /data/cert/cp harbor.k8scat.com.key /data/cert/<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># Docker</span></span><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># 转换</span></span>openssl x509 -inform PEM -in harbor.k8scat.com.crt -out harbor.k8scat.com.certmkdir -p /etc/docker/certs.d/harbor.k8scat.com/cp harbor.k8scat.com.cert /etc/docker/certs.d/harbor.k8scat.com/cp harbor.k8scat.com.key /etc/docker/certs.d/harbor.k8scat.com/cp ca.crt /etc/docker/certs.d/harbor.k8scat.com/systemctl restart docker</code></pre><h3 id="5-3-配置-harbor-yml"><a href="#5-3-配置-harbor-yml" class="headerlink" title="5.3 配置 harbor.yml"></a>5.3 配置 harbor.yml</h3><ol><li>cp harbor.yml.tmpl harbor.yml</li><li>修改<ul><li>hostname : harbor.k8scat.com</li><li>https<ul><li>certificate: /data/cert/harbor.k8scat.com.crt</li><li>private_key: /data/cert/harbor.k8scat.com.key</li></ul></li><li>harbor_admin_password: xxx</li><li>database.password: xxx</li></ul></li><li>./install.sh</li><li>harbor 搭建成功(<a href="https://139.198.166.89/">点击访问</a>)</li></ol><h3 id="5-4-up-amp-amp-down"><a href="#5-4-up-amp-amp-down" class="headerlink" title="5.4 up &amp;&amp; down"></a>5.4 up &amp;&amp; down</h3><pre><code class="hljs shell">cd harbordocker-compose updocker-compose down</code></pre><h2 id="6-Harbor-HA"><a href="#6-Harbor-HA" class="headerlink" title="6. Harbor HA"></a><a href="https://blog.51cto.com/qsyj/3246708">6. Harbor HA</a></h2><h2 id="7-docker-打包"><a href="#7-docker-打包" class="headerlink" title="7. docker 打包"></a>7. docker 打包</h2><pre><code class="hljs markdown">打包容器为镜像： docker commit 65cbaa57fe08  alg<span class="hljs-emphasis">_324</span><span class="hljs-emphasis">镜像迁移到其他服务器：</span><span class="hljs-emphasis">docker image ls # 找到对应docker</span><span class="hljs-emphasis">docker save XXX:latest &gt; XXX.tar # 保存docker镜像为tar文件</span><span class="hljs-emphasis">scp /etc/share/test.js root@123.123.123.123:/opt/soft/test.js  # scp传输，将本机镜像传输到其他服务器</span><span class="hljs-emphasis">docker load <span class="xml"><span class="hljs-tag">&lt; <span class="hljs-attr">XXX.tar</span>  # 解压镜像</span></span></span><span class="hljs-emphasis"><span class="xml">服务器之间传输文件－scp命令</span></span><span class="hljs-emphasis"><span class="xml">在工作中遇到一个需求，需要在两台服务器之间传输文件，用到了scp命令，用着还挺方便。</span></span><span class="hljs-emphasis"></span><span class="hljs-emphasis"><span class="xml">scp是secure copy的简写，用于在Linux下进行远程拷贝文件的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是加密的。</span></span><span class="hljs-emphasis"></span><span class="hljs-emphasis"><span class="xml">使用方式：</span></span><span class="hljs-emphasis"></span><span class="hljs-emphasis"><span class="xml">scp [参数] [原路径] [目标路径]</span></span><span class="hljs-emphasis"></span><span class="hljs-emphasis"><span class="xml">常用可选参数：</span></span><span class="hljs-emphasis"></span><span class="hljs-emphasis"><span class="xml">-B 使用批处理模式（传输过程中不询问传输口令或短语）</span></span><span class="hljs-emphasis"><span class="xml">-C 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</span></span><span class="hljs-emphasis"><span class="xml">-p 保留原文件的修改时间，访问时间和访问权限。</span></span><span class="hljs-emphasis"><span class="xml">-r 递归复制整个目录。</span></span><span class="hljs-emphasis"><span class="xml">-P port 注意是大写的P, port是指定数据传输用到的端口号</span></span><span class="hljs-emphasis"><span class="xml">路径规则：</span></span><span class="hljs-emphasis"></span><span class="hljs-emphasis"><span class="xml">user@IP:dirname</span></span><span class="hljs-emphasis"><span class="xml">user:登录用户名</span></span><span class="hljs-emphasis"><span class="xml">IP:登录服务器地址</span></span><span class="hljs-emphasis"><span class="xml">dirname:文件路径</span></span><span class="hljs-emphasis"><span class="xml">例如： root@123.123.123.123:/etc/share/test.js 表示123.123.123.123服务器上，root用户/etc/share/下的test.js文件</span></span><span class="hljs-emphasis"></span><span class="hljs-emphasis"><span class="xml">注意：</span></span><span class="hljs-emphasis"></span><span class="hljs-emphasis"><span class="xml">执行scp命令之后，会要求输入user的登录密码，（如果两台机器之前已部署ssh身份验证，则不需要）；</span></span><span class="hljs-emphasis"><span class="xml">如果是从服务器获取文件，则目标路径直接填写本地存放路径即可。</span></span><span class="hljs-emphasis"><span class="xml">如果是上传文件到服务器，则原路径填写本地文件路径即可。</span></span><span class="hljs-emphasis"><span class="xml">从远程服务器复制文件到本机目录</span></span><span class="hljs-emphasis"><span class="xml">$scp root@123.123.123.123:/opt/soft/test.js /etc/share/</span></span><span class="hljs-emphasis"><span class="xml">表示：复制123.123.123.123机器上/opt/soft/目录下test.js文件到本机/etc/share/下。</span></span><span class="hljs-emphasis"></span><span class="hljs-emphasis"><span class="xml">传输本机文件到远程机器指定目录</span></span><span class="hljs-emphasis"><span class="xml">$scp /etc/share/test.js root@123.123.123.123:/opt/soft/test.js</span></span><span class="hljs-emphasis"><span class="xml">表示：复制本机器/etc/share/目录下test.js文件到远程123.123.123.123机器上的/opt/soft/目录下。</span></span></code></pre><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://k8scat.com/posts/harbor/install-single-instance">https://k8scat.com/posts/harbor/install-single-instance</a></li><li><a href="https://blog.51cto.com/qsyj/3246708">https://blog.51cto.com/qsyj/3246708</a></li><li><a href="https://mp.weixin.qq.com/s/yXJxTR_sPdEMt56cf7JPhQ">https://mp.weixin.qq.com/s/yXJxTR_sPdEMt56cf7JPhQ</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nacos-sdk-go v2.0.0-Beta.1 源码结构</title>
    <link href="/2021/12/24/go/finished/Nacos-sdk-go%20v2.0.0-Beta.1/"/>
    <url>/2021/12/24/go/finished/Nacos-sdk-go%20v2.0.0-Beta.1/</url>
    
    <content type="html"><![CDATA[<h1 id="Nacos-sdk-go-v2-0-0-Beta-1-源码结构"><a href="#Nacos-sdk-go-v2-0-0-Beta-1-源码结构" class="headerlink" title="Nacos-sdk-go v2.0.0-Beta.1 源码结构"></a>Nacos-sdk-go v2.0.0-Beta.1 源码结构</h1><p><img src="https://raw.githubusercontent.com/1ch0/Figure-bed/main/img/Nacos-sdk-gov2.0.0-Beta.1.png" alt="Nacos-sdk-go v2.0.0-Beta.1 源码思维导图"></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go,nacos</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python</title>
    <link href="/2021/12/14/python/Python/"/>
    <url>/2021/12/14/python/Python/</url>
    
    <content type="html"><![CDATA[<h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>不可变：int、float、str、tuple、bool</p><p>可变：list、set、dict</p><p>可迭代：str、list、dict、tuple、set</p><h4 id="Str-字符串"><a href="#Str-字符串" class="headerlink" title="Str 字符串"></a>Str 字符串</h4><pre><code class="hljs python"><span class="hljs-built_in">len</span>(s)  <span class="hljs-comment"># 统计字符串长度</span><span class="hljs-built_in">ord</span>(s)  <span class="hljs-comment"># 字符 =》ASCII</span>cha(s)  <span class="hljs-comment"># ASCII =》字符</span><span class="hljs-string">&#x27; &#x27;</span>.join(s)  <span class="hljs-comment"># 拼接字符串；</span>[::<span class="hljs-number">-1</span>]  <span class="hljs-comment"># 反转字符串</span>[a: b]  <span class="hljs-comment"># 按下标a~b切割</span>.split()  <span class="hljs-comment"># 切割字符串(默认空字符,会保存成列表)</span>.splitlines()  <span class="hljs-comment"># 按行切割</span>.strip()  <span class="hljs-comment"># 去除两侧字符(默认空字符)</span>.lstrip()  <span class="hljs-comment"># 去除左边的特定字符</span>.rstrip()  <span class="hljs-comment"># 去除右边的特定字符</span>.zfill(n)  <span class="hljs-comment"># 返回指定 n长度字符串，不足的前面补0</span>.count(i)  <span class="hljs-comment"># 计算 i 在字符串s中出现的次数</span>.find(i)  <span class="hljs-comment"># 查找字符串，并返回 i 第一次出现的下标；rfind()  # 反向查找字符串</span>.index(i)  <span class="hljs-comment"># 查询元素返回 i 第一次出现的下标(若不在列表中则会报错，可以指定开始、结束范围)</span>.replace(old, new, <span class="hljs-built_in">max</span>)  <span class="hljs-comment"># 把old替换成new(新字符串)，max指定最多替换次数</span>.upper()  <span class="hljs-comment"># 所有小写转大写；lower()  # 所有大写转小写；</span>.swapcase()  <span class="hljs-comment"># 大小写互转；capitalize()  # 字符串首字母转大写；title()  # 每个单词首字母大写；</span>.isupper()  <span class="hljs-comment"># 判断是否全是大写；islower()  # 判断是否全是小写；</span>.isalpha()  <span class="hljs-comment"># 判断是否只是字母</span>.isdigit()  <span class="hljs-comment"># 判断是否只是数字</span>.isdecimal()  <span class="hljs-comment"># 判断是否只包含十进制字符</span>.startswith()  <span class="hljs-comment"># 判断是否以特定字符开头；endswith()  # 判断是否以特定字符结尾</span>.isalnum()  <span class="hljs-comment"># 判断是否只是字母或数字</span><span class="hljs-built_in">isinstance</span>(s, <span class="hljs-built_in">type</span>)  <span class="hljs-comment"># 判断是否为指定类型</span>.rjust(<span class="hljs-number">3</span>, <span class="hljs-string">&#x27;0&#x27;</span>)  <span class="hljs-comment"># 右对齐，用0填充至3长度</span></code></pre><pre><code class="hljs python"><span class="hljs-string">b&#x27;&#x27;</span>  <span class="hljs-comment"># 表示bytes类型</span><span class="hljs-string">u&#x27;&#x27;</span>  <span class="hljs-comment"># 表示unicode字符串</span><span class="hljs-string">r&#x27;&#x27;</span>  <span class="hljs-comment"># 非转义字符</span><span class="hljs-string">f&#x27;&#x27;</span>  <span class="hljs-comment"># 格式化操作</span>s1 = <span class="hljs-string">&#x27;good man&#x27;</span><span class="hljs-string">f&#x27;LP is a <span class="hljs-subst">&#123;s1&#125;</span>.&#x27;</span>  <span class="hljs-comment"># LP is a good man.</span></code></pre><h4 id="List-列表"><a href="#List-列表" class="headerlink" title="List 列表"></a>List 列表</h4><pre><code class="hljs python">.<span class="hljs-built_in">len</span>()  <span class="hljs-comment"># 统计列表长度</span><span class="hljs-string">&#x27; &#x27;</span>.join(lt)  <span class="hljs-comment"># 将列表拼接成字符串(按&#x27; &#x27;拼接)</span>lt.append(a)  <span class="hljs-comment"># 追加元素a到末尾</span>lt.extend(lt2)  <span class="hljs-comment"># 将可迭代对象a的元素展开追加到列表末尾</span><span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lt)  <span class="hljs-comment"># 遍历列表(可以同时获取元素及下标)，可设置起始位置</span>.insert(i, a)  <span class="hljs-comment"># 指定i下标位置插入元素a</span>.index()  <span class="hljs-comment"># 查询元素返回第一次出现的下标(若不在列表中则会报错，可以指定开始、结束范围)</span>.remove(v)  <span class="hljs-comment"># 删除指定值的元素(只删第一个)</span>.pop(i)  <span class="hljs-comment"># 弹出指定下标的元素(默认最后一个)</span>.count()  <span class="hljs-comment"># 统计元素出现的次数</span>.clear()  <span class="hljs-comment"># 清空列表</span>.copy()  <span class="hljs-comment"># 拷贝一个列表</span>[::<span class="hljs-number">-1</span>]  <span class="hljs-comment"># 逆序</span>.reverse()  <span class="hljs-comment"># 逆序</span>.sort()  <span class="hljs-comment"># 原对象升序排序  # sort(reverse=True)  # 降序排序；</span><span class="hljs-built_in">sorted</span>(lt)  <span class="hljs-comment"># 排序，返回新对象，可以用于多种可迭代对象</span></code></pre><h5 id="Collections-计数器与队列"><a href="#Collections-计数器与队列" class="headerlink" title="Collections(计数器与队列)"></a>Collections(计数器与队列)</h5><p><strong>Counter</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counterc = Counter(lt)<span class="hljs-built_in">dict</span>(c)  <span class="hljs-comment"># 获取元素及出现次数(字典形式显示)</span>c.most_common(n)  <span class="hljs-comment"># 获取出现次数最多的元素及次数，指定获取前n个</span></code></pre><p><strong>deque</strong></p><pre><code class="hljs python">d = deque(lt)  <span class="hljs-comment"># 注：列表函数同样用</span>d.append(a)  <span class="hljs-comment"># 从右侧添加元素a</span>d.appendleft(a) <span class="hljs-comment"># 从左侧添加元素a</span>d.remove(a)  <span class="hljs-comment"># 删除元素a</span>d.pop()  <span class="hljs-comment"># 从右侧弹出元素(不能指定下标)</span>d.popleft()  <span class="hljs-comment"># 从左侧弹出元素</span>d.extend(lt2)  <span class="hljs-comment"># 从右侧扩充序列</span>d.extendleft(lt2)  <span class="hljs-comment"># 从左侧扩充序列</span>d.rotate(n)  <span class="hljs-comment"># 循环移动，n正右移n次，n负左移n次</span></code></pre><h5 id="Itertools-排列组合"><a href="#Itertools-排列组合" class="headerlink" title="Itertools(排列组合)"></a>Itertools(排列组合)</h5><pre><code class="hljs python">it = itertools.permutations(lt, n)  <span class="hljs-comment"># 从可迭代对象lt中取出n个元素，所有的可能就是排列(有序)，会重复</span>it = itertools.combinations(lt, n)  <span class="hljs-comment"># 组合，按lt中顺序排列，且不重复</span>it = itertools.product(lt, lt2, ltn)  <span class="hljs-comment"># 笛卡尔成绩，多个序列中的组合</span>it = itertools.product(lt, repeat=n)  <span class="hljs-comment"># 相等于n个lt，功能同上</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> it:    print(i)</code></pre><h4 id="Tuple-元组"><a href="#Tuple-元组" class="headerlink" title="Tuple 元组"></a>Tuple 元组</h4><pre><code class="hljs python"><span class="hljs-built_in">len</span>(t)  <span class="hljs-comment"># 统计长度</span>index()  <span class="hljs-comment"># 获取指定元素的下标</span>count()  <span class="hljs-comment"># 统计指定元素出现的次数</span><span class="hljs-built_in">max</span>(t)  <span class="hljs-comment"># 最大值</span><span class="hljs-built_in">min</span>(t)  <span class="hljs-comment"># 最小值</span></code></pre><h4 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h4><pre><code class="hljs python"><span class="hljs-built_in">len</span>(s)  <span class="hljs-comment"># 计算长度</span>add()  <span class="hljs-comment"># 添加元素</span>remove()  <span class="hljs-comment"># 删除元素(不存在会报错)</span>discard()  <span class="hljs-comment"># 删除元素(不存在不会报错)</span>pop()  <span class="hljs-comment"># 随机删除并返回</span>clear()  <span class="hljs-comment"># 清空元素</span>s1 | s2  <span class="hljs-comment"># 并集(所有元素)</span>s1 &amp; s2  <span class="hljs-comment"># 交集(相同元素)</span>s1 ^ s2  <span class="hljs-comment"># 对称差集(不同元素)</span>s1 - s2  <span class="hljs-comment"># 差集(s1有s2没有元素)</span>s1 &lt;= s2  <span class="hljs-comment"># s1是否是s2的子集</span>s1 &gt;= s2  <span class="hljs-comment"># s1是否是s2的父集</span>s1.union(s2)  <span class="hljs-comment"># 并集</span>s1.intersection(s2)  <span class="hljs-comment"># 交集</span>s1.intersection_update(s2)  <span class="hljs-comment"># 交集(会覆盖原来的集合)</span>s1.isdisjoint(s2)  <span class="hljs-comment"># 是否 没有 交集</span>s1.issubset(s2)  <span class="hljs-comment"># s1是否是s2的子集</span>s1.issuperset(s2)  <span class="hljs-comment"># s1是否是s2的父集(超集)</span></code></pre><h4 id="Dict-字典操作"><a href="#Dict-字典操作" class="headerlink" title="Dict 字典操作"></a>Dict 字典操作</h4><pre><code class="hljs python">d[n]  <span class="hljs-comment"># 获取n的值</span>.get(n)  <span class="hljs-comment"># 获取n键的值，没有返回None，可指定默认值, 对原字典无修改</span>.setdefault()  <span class="hljs-comment">#  无值时使用默认值，并将默认值写入原字典</span>.keys()  <span class="hljs-comment"># 遍历字典，获取键</span>.values()  <span class="hljs-comment"># 遍历字典，获取值</span>.items()  <span class="hljs-comment"># 遍历字典，同时获取键和值</span>.update()  <span class="hljs-comment"># 更新字典(存在覆盖，不存在添加)</span>.pop(n)  <span class="hljs-comment"># 删除 键n 并返回</span><span class="hljs-keyword">del</span> d[n] <span class="hljs-comment"># 删除 键n</span>.clear()  <span class="hljs-comment"># 清空元素</span>a.update(b)  <span class="hljs-comment"># 将字典b 合并到 字典a</span>c = <span class="hljs-built_in">dict</span>(a, **b)  <span class="hljs-comment"># 将字典a,b合并，返回新字典</span></code></pre><p><code>__和_</code>区别</p><pre><code class="hljs python">_单前置下划线  <span class="hljs-comment"># 表示属性和方法的私有化</span>__双前置下划线  <span class="hljs-comment"># 避免和子类属性命名冲突，不能直接被调用</span>xx__双后置下划线  <span class="hljs-comment"># 避免与python关键字冲突</span>__xx__双前后下划线  <span class="hljs-comment"># 表示魔法属性/魔法方法</span></code></pre><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__method</span>(<span class="hljs-params">self</span>):</span>        print(<span class="hljs-string">&quot;I&#x27;m a method in A&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">method</span>(<span class="hljs-params">self</span>):</span>        self.__method()<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">A</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__method</span>(<span class="hljs-params">self</span>):</span>        print(<span class="hljs-string">&quot;I&#x27;m a method in B&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">str__</span>(<span class="hljs-params">self</span>):</span>        print(<span class="hljs-string">&quot;I&#x27;m a method in B__&quot;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    a = A()    a.method()  <span class="hljs-comment"># I&#x27;m a method in A</span>    b = B()    b.method()  <span class="hljs-comment"># I&#x27;m a method in A</span>    b.str__()  <span class="hljs-comment"># I&#x27;m a method in B__</span></code></pre><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><h4 id="For"><a href="#For" class="headerlink" title="For"></a>For</h4><pre><code class="hljs python"><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)<span class="hljs-keyword">pass</span><span class="hljs-keyword">for</span> i, v <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(lt):    <span class="hljs-keyword">pass</span></code></pre><h4 id="While"><a href="#While" class="headerlink" title="While"></a>While</h4><pre><code class="hljs python"><span class="hljs-keyword">while</span> <span class="hljs-number">1</span>:  <span class="hljs-comment"># 死循环</span>    <span class="hljs-keyword">pass</span>i = <span class="hljs-number">0</span><span class="hljs-keyword">while</span> i &lt; <span class="hljs-built_in">len</span>(lt):  <span class="hljs-comment"># 循环列表时，每次循环会检查列表长度</span>        <span class="hljs-keyword">if</span> i == <span class="hljs-number">3</span>:        <span class="hljs-keyword">continue</span>  <span class="hljs-comment"># 跳出本循环，开始下次循环</span>        <span class="hljs-keyword">break</span>  <span class="hljs-comment"># 终止while循环</span>    <span class="hljs-keyword">pass</span></code></pre><h3 id="迭代器生成器"><a href="#迭代器生成器" class="headerlink" title="迭代器生成器"></a>迭代器生成器</h3><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><ul><li>可以被 next()函数调用不断返回下个值，叫迭代器</li><li>iter()：创建迭代器。字符串，列表，元组 都可以用 创建迭代器</li><li>next()  <code>__next__()</code>：输出迭代器下一个元素，且元素只能用一次，迭代完继续取值会报错 StopIteration</li></ul><pre><code class="hljs python">arr = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]ite = <span class="hljs-built_in">iter</span>(arr)  <span class="hljs-comment"># 转为迭代器</span>print(ite)  <span class="hljs-comment"># &lt;list_iterator object at 0x0000023C07E0A780&gt;</span>print(ite.__next__())  <span class="hljs-comment"># 0</span>print(<span class="hljs-built_in">next</span>(ite))  <span class="hljs-comment"># 1</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ite:    print(i)  <span class="hljs-comment"># 2, 3, 4</span></code></pre><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><ul><li>小括号的列表生成式是生成器</li><li>使用 yield 关键字的函数也叫生成器，生成器也是一个迭代器</li></ul><pre><code class="hljs python">gen = (i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>))print(gen)  <span class="hljs-comment"># &lt;generator object &lt;genexpr&gt; at 0x0000025F87C6B8E0&gt;</span>print(gen.__next__())  <span class="hljs-comment"># 0</span>print(<span class="hljs-built_in">next</span>(gen))  <span class="hljs-comment"># 1</span><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> gen:    print(i)  <span class="hljs-comment"># 2, 3, 4</span></code></pre><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><ul><li>一种算法，在函数内调用它本身，一直反复，且必须有结束条件</li><li>优点：代码简单，容易理解</li></ul><h3 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h3><p><strong>直接赋值</strong></p><ul><li>对象的引用， </li></ul><p><strong>浅拷贝</strong></p><ul><li>只拷贝父对象，但子对象只会增加一个引用。也可以用 copy()</li></ul><p><strong>深拷贝</strong></p><ul><li>父对象和子对象都拷贝</li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> copyarr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]arr1 = arrarr2 = copy.copy(arr)  <span class="hljs-comment"># 浅拷贝</span>arr3 = copy.deepcopy(arr)  <span class="hljs-comment"># 深拷贝</span>print(arr <span class="hljs-keyword">is</span> arr)  <span class="hljs-comment"># 判断是否是同一个对象的多个引用</span></code></pre><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>面向过程：步骤化。一步一步实现步骤</p><p>面向对象：行为化。按功能或特点划分封装成类</p><ul><li>特点：封装、继承、多态</li><li>优点：灵活性、重用性好</li><li>缺点：因为调用要先实例化，所以性能比面向过程差一些</li></ul><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="内置系统函数"><a href="#内置系统函数" class="headerlink" title="内置系统函数"></a>内置系统函数</h4><pre><code class="hljs python">print()  <span class="hljs-comment"># 打印</span><span class="hljs-built_in">input</span>()  <span class="hljs-comment"># 输入</span><span class="hljs-built_in">type</span>()  <span class="hljs-comment"># 获取类型</span><span class="hljs-built_in">len</span>()  <span class="hljs-comment"># 统计元素个数</span><span class="hljs-built_in">range</span>()  <span class="hljs-comment"># 自动生成序列</span><span class="hljs-built_in">enumerate</span>()  <span class="hljs-comment"># 枚举可迭代对象，同时列出数据和数据下标</span><span class="hljs-built_in">ord</span>()  <span class="hljs-comment"># 字符转ASCII</span><span class="hljs-built_in">chr</span>()  <span class="hljs-comment"># ASCII转字符</span><span class="hljs-built_in">int</span>()  <span class="hljs-comment"># 转为十进制，去除小数点后位数</span><span class="hljs-built_in">bin</span>()  <span class="hljs-comment"># 十转二进制</span><span class="hljs-built_in">oct</span>()  <span class="hljs-comment"># 十转八进制</span><span class="hljs-built_in">hex</span>()  <span class="hljs-comment"># 十转十六进制</span><span class="hljs-built_in">abs</span>()  <span class="hljs-comment"># 求绝对值</span><span class="hljs-built_in">max</span>()  <span class="hljs-comment"># 最大值</span><span class="hljs-built_in">min</span>()  <span class="hljs-comment"># 最小值</span><span class="hljs-built_in">sum</span>()  <span class="hljs-comment"># 求和</span><span class="hljs-built_in">pow</span>()  <span class="hljs-comment"># 求幂</span><span class="hljs-built_in">round</span>()  <span class="hljs-comment"># 四舍五入</span><span class="hljs-built_in">round</span>(<span class="hljs-number">3.12356</span>, n)  <span class="hljs-comment"># 小数后保留n位</span></code></pre><h4 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h4><pre><code class="hljs python">os.system(<span class="hljs-string">&#x27;cls&#x27;</span>)  <span class="hljs-comment"># 清屏操作</span>os.system(<span class="hljs-string">&#x27;calc&#x27;</span>)  <span class="hljs-comment"># 计算器</span>print(os.environ[<span class="hljs-string">&#x27;path&#x27;</span>])  <span class="hljs-comment"># 获取环境变量</span><span class="hljs-keyword">if</span> ** <span class="hljs-keyword">else</span> **  <span class="hljs-comment"># 灵活使用</span><span class="hljs-keyword">yield</span> x  <span class="hljs-comment"># 函数会返回yield后的内容，然后会停止在这里，用于生成器</span><span class="hljs-built_in">iter</span>()  <span class="hljs-comment"># 可将可迭代对象转换为迭代器</span>gliobal n  <span class="hljs-comment"># 声明n是全局变量(可以是多个)</span><span class="hljs-keyword">nonlocal</span> n  <span class="hljs-comment"># 声明n是外层的局部变量</span><span class="hljs-built_in">isinstance</span>(a, <span class="hljs-built_in">type</span>)  <span class="hljs-comment"># 判断对象a是否是type类型的</span></code></pre><h5 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h5><ul><li>将多个可迭代对象里边对应的元素打包成元组，返回其对象，只能使用一次。</li><li>若长度不一样，输出其对象最小长度</li></ul><pre><code class="hljs python">a = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>]c = [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]s1 = <span class="hljs-built_in">zip</span>(a, b)print(s1)  <span class="hljs-comment"># &lt;zip object at 0x000001F712A32EC8&gt;</span>s2 = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">zip</span>(a, b, c))print(s2)  <span class="hljs-comment"># [(&#x27;a&#x27;, 1, &#x27;A&#x27;), (&#x27;b&#x27;, 2, &#x27;B&#x27;), (&#x27;c&#x27;, 3, &#x27;C&#x27;)]</span>s3 = <span class="hljs-built_in">dict</span>(<span class="hljs-built_in">zip</span>(a, b))print(s3)  <span class="hljs-comment"># &#123;&#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span>a2, a3 = <span class="hljs-built_in">zip</span>(*<span class="hljs-built_in">zip</span>(a, b))print(a2, a3)  <span class="hljs-comment"># (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;) (1, 2, 3)</span></code></pre><h5 id="Lambda-匿名函数"><a href="#Lambda-匿名函数" class="headerlink" title="Lambda(匿名函数)"></a>Lambda(匿名函数)</h5><ul><li>匿名函数，也是一个表达式，可以赋值给变量</li><li>有独立的命名空间，访问不到外部变量</li><li>让代码更简洁</li></ul><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> 参数: 表达式<span class="hljs-keyword">lambda</span> x, y: x + y<span class="hljs-keyword">lambda</span> d: d[<span class="hljs-string">&#x27;age&#x27;</span>]</code></pre><h5 id="递归-1"><a href="#递归-1" class="headerlink" title="递归"></a>递归</h5><pre><code class="hljs python"><span class="hljs-keyword">return</span> 表达式：递归</code></pre><h5 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h5><p>@ 函数名：装饰器(不改变原来函数)</p><h5 id="Retry-函数重试"><a href="#Retry-函数重试" class="headerlink" title="Retry 函数重试"></a>Retry 函数重试</h5><ul><li>函数执行错误重试机制</li></ul><pre><code class="hljs axapta">pip install <span class="hljs-keyword">retry</span></code></pre><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">retry</span>(<span class="hljs-params">exceptions=Exception, tries=<span class="hljs-number">-1</span>, delay=<span class="hljs-number">0</span>, max_delay=<span class="hljs-literal">None</span>, backoff=<span class="hljs-number">1</span>, jitter=<span class="hljs-number">0</span>, logger=logging_logger</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;Return a retry decorator.</span><span class="hljs-string">    ：param exceptions：捕获异常或异常元组。 默认：Exception。</span><span class="hljs-string">    ：param tries：Exception最大尝试次数。 默认值：-1（无限）。</span><span class="hljs-string">    ：param delay：尝试之间的初始延迟。 默认值：0。</span><span class="hljs-string">    ：param max_delay：延迟的最大值。 默认值：无（无限制）。</span><span class="hljs-string">    ：param backoff：乘法器应用于尝试之间的延迟。 默认值：1（无退避）。</span><span class="hljs-string">    ：param jitter：额外的秒数添加到尝试之间的延迟。 默认值：0。</span><span class="hljs-string">               如果数字固定，则随机如果范围元组（最小值，最大值）</span><span class="hljs-string">    ：param logger：logger.warning（fmt，error，delay）将在失败尝试中调用。</span><span class="hljs-string">                    默认值：retry.logging_logger。 如果无，则记录被禁用。</span><span class="hljs-string">    &quot;&quot;&quot;</span></code></pre><pre><code class="hljs python"><span class="hljs-keyword">from</span> retry <span class="hljs-keyword">import</span> retry<span class="hljs-meta">@retry(tries=3)  # 重试2次，共执行3次</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>():</span>...</code></pre><h4 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h4><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><ul><li>根据指定函数对序列做出映射(函数，序列)</li></ul><pre><code class="hljs python"><span class="hljs-comment"># 每个元素+1</span>nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">n</span>):</span>    <span class="hljs-keyword">return</span> n + <span class="hljs-number">1</span>res = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(add, nums))print(res)  <span class="hljs-comment"># [2, 3, 4]</span><span class="hljs-comment"># 一行写法</span>res = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x+<span class="hljs-number">1</span>, nums))print(res)  <span class="hljs-comment"># [2, 3, 4]</span></code></pre><h5 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h5><ul><li>过滤序列，过滤掉不符合条件的元素，返回由符合条件元素组成的新列表(函数，可迭代对象)</li></ul><pre><code class="hljs python"><span class="hljs-comment"># 保留奇数</span>nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">n</span>):</span>    <span class="hljs-keyword">return</span> n % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>res = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(func, nums))print(res)  <span class="hljs-comment"># [1, 3, 5]</span><span class="hljs-comment"># 一行写法</span>res = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>, nums))print(res)  <span class="hljs-comment"># [1, 3, 5]</span></code></pre><h5 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a>Reduce</h5><ul><li>对参数序列中的元素进行累积(函数， 序列)</li></ul><pre><code class="hljs python"><span class="hljs-comment">## 实现1—100之和</span><span class="hljs-keyword">from</span> functools impor reduce<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>):</span>    <span class="hljs-keyword">return</span> a + bnums = [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>)]res = reduce(add, nums)print(res)  <span class="hljs-comment"># 5050</span><span class="hljs-comment"># 一行写法</span>res = reduce(<span class="hljs-keyword">lambda</span> x, y: x + y, [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">101</span>)])print(res)</code></pre><h4 id="模块函数-需要引入"><a href="#模块函数-需要引入" class="headerlink" title="模块函数(需要引入)"></a>模块函数(需要引入)</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> xx  <span class="hljs-comment"># 引入xx包</span><span class="hljs-keyword">from</span> xx <span class="hljs-keyword">import</span> yy  <span class="hljs-comment"># 只引入xx包里的yy类(可引多个类)</span><span class="hljs-keyword">from</span> xx <span class="hljs-keyword">import</span> yy <span class="hljs-keyword">as</span> zz  <span class="hljs-comment"># 引入模块中的指定内容，并且起别名</span><span class="hljs-keyword">from</span> xx <span class="hljs-keyword">import</span> *  <span class="hljs-comment"># 模糊导入，导入该模块中`__all__`列表指定的内容</span></code></pre><p>isinstance(a, type)：判断对象a是否是type类型的</p><h5 id="Inspect"><a href="#Inspect" class="headerlink" title="Inspect:"></a>Inspect:</h5><h6 id="Isfunction"><a href="#Isfunction" class="headerlink" title="Isfunction"></a>Isfunction</h6><pre><code class="hljs python"><span class="hljs-keyword">from</span> inspect <span class="hljs-keyword">import</span> isfunctionisfunction(n)  <span class="hljs-comment"># 判断标识符n是否是函数</span></code></pre><h5 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h5><h6 id="Iterator-Iterable"><a href="#Iterator-Iterable" class="headerlink" title="Iterator,Iterable"></a>Iterator,Iterable</h6><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Iterator, Iterableisinsratance(lt, Iterator)  <span class="hljs-comment"># 判断lt是否是迭代器</span>isinsratance(lt, Iterable)  <span class="hljs-comment"># 判断lt是否是可迭代对象</span></code></pre><h4 id="函数注解"><a href="#函数注解" class="headerlink" title="函数注解"></a>函数注解</h4><ul><li>只是声明，运行代码不会强校验 </li></ul><pre><code class="hljs python"><span class="hljs-comment"># a: int声明参数a类型为int</span><span class="hljs-comment"># -&gt; int声明返回类型为int</span><span class="hljs-comment"># -&gt; List[int]声明返回类型为数字列表</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span></span>) -&gt; int:</span>    <span class="hljs-keyword">return</span> a + <span class="hljs-number">1</span>print(add(<span class="hljs-number">1</span>))  <span class="hljs-comment"># 2</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">demo</span>(<span class="hljs-params">a: <span class="hljs-built_in">int</span>, b: <span class="hljs-built_in">int</span></span>) -&gt; List[int]:</span>    <span class="hljs-keyword">return</span> [a, b]print(demo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))  <span class="hljs-comment"># [1, 2]</span></code></pre><p>函数性能器</p><pre><code class="hljs python"><span class="hljs-keyword">import</span> cProfile<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">n</span>):</span><span class="hljs-keyword">pass</span>cProfile.run(<span class="hljs-string">&#x27;func(n)&#x27;</span>)</code></pre><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名:</span>  <span class="hljs-comment"># 类的定义</span>self.  <span class="hljs-comment"># 表示当前对象，就是调用该方法的对象</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">A</span>)  # <span class="hljs-title">B</span>继承<span class="hljs-title">A</span></span><span class="hljs-class"><span class="hljs-title">class</span> <span class="hljs-title">C</span>(<span class="hljs-params">A, B</span>)  # <span class="hljs-title">C</span>同时继承<span class="hljs-title">A</span>和<span class="hljs-title">B</span></span><span class="hljs-class"></span><span class="hljs-class"><span class="hljs-title">__</span>  # 前面加俩下划线定义私有方法</span><span class="hljs-class">@<span class="hljs-title">staticmethod</span>  # 静态方法</span><span class="hljs-class">@<span class="hljs-title">classmethod</span>  # 类方法，创建对外的简易接口</span><span class="hljs-class">@<span class="hljs-title">property</span>  # 专门保护特有的属性</span><span class="hljs-class"></span><span class="hljs-class">@<span class="hljs-title">abstractmethod</span>  # 定义抽象方法，规定接口</span><span class="hljs-class"><span class="hljs-title">repr</span>(<span class="hljs-params">d</span>)  # 返回对象的字符串显示</span><span class="hljs-class"><span class="hljs-title">eval</span>(<span class="hljs-params">r</span>)  # 执行有效的<span class="hljs-title">python</span>代码字符串</span></code></pre><h4 id="魔法属性"><a href="#魔法属性" class="headerlink" title="魔法属性"></a>魔法属性</h4><pre><code class="hljs python">__doc__  <span class="hljs-comment"># 类的描述信息</span>__module__  <span class="hljs-comment"># 操作对象属于哪个模块</span>__class__  <span class="hljs-comment"># 操作对象属于哪个类</span></code></pre><h4 id="魔法方法"><a href="#魔法方法" class="headerlink" title="魔法方法"></a>魔法方法</h4><pre><code class="hljs python">__str__()  <span class="hljs-comment"># 打印对象时会触发，str方法转换时会触发，打印对象时会打印该方法的返回值</span>__new__(cls)  <span class="hljs-comment"># 创建实例</span>__init__()  <span class="hljs-comment"># 构造方法/实例方法，初始化实例</span>__del__()  <span class="hljs-comment"># 析构方法，当对象释放时会触发</span>__next__()  <span class="hljs-comment"># 定义迭代器</span>__setattr__()  <span class="hljs-comment"># 添加或设置属性时会自动触发</span>__getattr__()  <span class="hljs-comment"># 获取指定的属性时会自动触发</span>__delattr__()  <span class="hljs-comment"># 销毁对象的指定属性时会自动触发</span>__setitem__()  <span class="hljs-comment"># 把对象当作字典，添加或设置属性时会自动触发</span>__getitem__()  <span class="hljs-comment"># 把对象当作字典，根据键获取值时自动触发</span>__delitem__()  <span class="hljs-comment"># 把对象当作字典，删除指定属性时自动触发</span>__call__()  <span class="hljs-comment"># 把对象当作函数调用，该方法会自动触发</span>__repr__()  <span class="hljs-comment"># 返回对象的字符串表示形式，使用repr函数处理时会自动触发</span></code></pre><h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><ul><li>首个参数self，实例方法不能被直接调用</li></ul><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p><strong>@staticmethod</strong></p><ul><li>修饰过的函数不需要实例化，可直接调用</li></ul><h4 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h4><p><strong>@classmethod</strong></p><ul><li>修饰过的函数不需要实例化，可直接调用。但第一个参数需要是自身类的cls参数</li></ul><h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><p>@property</p><ul><li>创建只读属性，新式类中返回属性值</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span>:</span>    a = <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        self.b = <span class="hljs-number">2</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aa</span>(<span class="hljs-params">self</span>):</span>        print(<span class="hljs-string">&#x27;aa&#x27;</span>, self.a, self.b)<span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">bb</span>(<span class="hljs-params">cls</span>):</span>        print(<span class="hljs-string">&#x27;bb&#x27;</span>, cls.a, cls().b)<span class="hljs-meta">    @staticmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cc</span>():</span>        print(<span class="hljs-string">&#x27;cc&#x27;</span>, Demo.a, Demo().b)<span class="hljs-meta">    @property</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">dd</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> self.aDemo().aa()  <span class="hljs-comment"># aa 1 2</span>Demo.bb()  <span class="hljs-comment"># bb 1 2</span>Demo.cc()  <span class="hljs-comment"># cc 1 2</span>res = Demo().ddprint(res)  <span class="hljs-comment"># dd 1</span></code></pre><h4 id="Super"><a href="#Super" class="headerlink" title="Super()"></a>Super()</h4><ul><li>解决多继承问题的方法，广度优先顺序执行</li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go</span>(<span class="hljs-params">self</span>):</span>        print(<span class="hljs-string">&quot;go A go!&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop</span>(<span class="hljs-params">self</span>):</span>        print(<span class="hljs-string">&quot;stop A stop!&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pause</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;Not Implemented&quot;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span>(<span class="hljs-params">A</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">super</span>(B, self).go()        print(<span class="hljs-string">&quot;go B go!&quot;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">C</span>(<span class="hljs-params">A</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">super</span>(C, self).go()        print(<span class="hljs-string">&quot;go C go!&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">super</span>(C, self).stop()        print(<span class="hljs-string">&quot;stop C stop!&quot;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">D</span>(<span class="hljs-params">B, C</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">go</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">super</span>(D, self).go()        print(<span class="hljs-string">&quot;go D go!&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">stop</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-built_in">super</span>(D, self).stop()        print(<span class="hljs-string">&quot;stop D stop!&quot;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">pause</span>(<span class="hljs-params">self</span>):</span>        print(<span class="hljs-string">&quot;wait D wait!&quot;</span>)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">E</span>(<span class="hljs-params">B, C</span>):</span>    <span class="hljs-keyword">pass</span>a = A()b = B()c = C()d = D()e = E()<span class="hljs-comment"># 说明下列代码的输出结果</span><span class="hljs-comment"># a.go()  # go A go!</span><span class="hljs-comment"># b.go()  # go A go! \n go B go!</span><span class="hljs-comment"># c.go()  # go A go! \n go C go!</span><span class="hljs-comment"># d.go()  # go A go! \n go C go! \n go B go! \n go D go!</span><span class="hljs-comment"># e.go()  # go A go! \n go C go! \n go B go!</span><span class="hljs-comment"># a.stop()  # stop A stop!</span><span class="hljs-comment"># b.stop()  # stop A stop!</span><span class="hljs-comment"># c.stop()  # stop A stop! \n  # stop C stop!</span><span class="hljs-comment"># d.stop()  # stop A go! \n stop C go! \n stop D go!</span><span class="hljs-comment"># e.stop()  # go A go! \n go C go!</span><span class="hljs-comment"># a.pause()  # Exception: Not Implemented</span><span class="hljs-comment"># b.pause()  # Exception: Not Implemented</span><span class="hljs-comment"># c.pause()  # Exception: Not Implemented</span><span class="hljs-comment"># d.pause()  # wait D wait!</span><span class="hljs-comment"># e.pause()  # Exception: Not Implemented</span></code></pre><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul><li>引用了外部变量的内部函数</li><li>原理：在外函数中定义一个内函数，内函数里用了外函数的变量，并且外函数的返回值是内函数的引用，这就是一个闭包</li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer</span>(<span class="hljs-params">a</span>):</span>    b = <span class="hljs-number">2</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>():</span>        print(a + b)    <span class="hljs-keyword">return</span> innerdemo = outer(<span class="hljs-number">3</span>)demo()  <span class="hljs-comment"># 5</span></code></pre><h3 id="装饰器-1"><a href="#装饰器-1" class="headerlink" title="装饰器"></a>装饰器</h3><ul><li>作用：给其他函数增加额外功能。多装饰器从下往上执行</li><li>原理：通过闭包实现</li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timeit</span>(<span class="hljs-params">func</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>():</span>        start_time = time.time()        func()        end_time = time.time()        print(<span class="hljs-string">f&#x27;运行时间: <span class="hljs-subst">&#123;end_time - start_time&#125;</span>&#x27;</span>)    <span class="hljs-keyword">return</span> inner<span class="hljs-meta">@timeit</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span>    print(<span class="hljs-string">&#x27;func执行&#x27;</span>)    time.sleep(<span class="hljs-number">2</span>)func()  <span class="hljs-comment"># 运行时间: 2.0038506984710693</span></code></pre><h4 id="带参数装饰器"><a href="#带参数装饰器" class="headerlink" title="带参数装饰器"></a>带参数装饰器</h4><pre><code class="hljs python"><span class="hljs-comment"># 函数写法</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">timeit</span>(<span class="hljs-params">name=<span class="hljs-string">&#x27;&#x27;</span></span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">outer</span>(<span class="hljs-params">func</span>):</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>():</span>            start_time = time.time()            func()            end_time = time.time()            print(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;name&#125;</span>运行时间: <span class="hljs-subst">&#123;end_time - start_time&#125;</span>&#x27;</span>)        <span class="hljs-keyword">return</span> inner    <span class="hljs-keyword">return</span> outer<span class="hljs-meta">@timeit(&#x27;func函数&#x27;)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span>    print(<span class="hljs-string">&#x27;func执行&#x27;</span>)    time.sleep(<span class="hljs-number">2</span>)func()  <span class="hljs-comment"># func函数运行时间: 2.0038506984710693</span><span class="hljs-comment"># 类写法</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">timeit</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, name=<span class="hljs-string">&#x27;&#x27;</span></span>):</span>        self.name = name    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, func</span>):</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">inner</span>(<span class="hljs-params">*args, **kwargs</span>):</span>            start_time = time.time()            func()            end_time = time.time()            print(<span class="hljs-string">f&#x27;<span class="hljs-subst">&#123;self.name&#125;</span>运行时间: <span class="hljs-subst">&#123;end_time - start_time&#125;</span>&#x27;</span>)        <span class="hljs-keyword">return</span> inner<span class="hljs-meta">@timeit(&#x27;func函数&#x27;)</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>():</span>    print(<span class="hljs-string">&#x27;func执行&#x27;</span>)    time.sleep(<span class="hljs-number">2</span>)func()  <span class="hljs-comment"># func函数运行时间: 2.0138235092163086</span></code></pre><h3 id="单例"><a href="#单例" class="headerlink" title="单例"></a>单例</h3><ul><li>保证类里边只有一个实例</li><li>实现方式：<code>__new__</code>、模块导入、用装饰器、使用类</li></ul><p><code>__new__</code></p><ul><li>先判断是不是存在实例，存在返回，不存在则创建。</li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    _instance_lock = threading.Lock()    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-comment"># 先判断是不是存在实例，存在返回，不存在则创建。</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, <span class="hljs-string">&#x27;_instance&#x27;</span>):            <span class="hljs-keyword">with</span> Singleton._instance_lock:                <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(cls, <span class="hljs-string">&#x27;_instance&#x27;</span>):                    Singleton._instance = <span class="hljs-built_in">object</span>.__new__(cls)        <span class="hljs-keyword">return</span> Singleton._instanceobj1 = Singleton()obj2 = Singleton()print(obj1, obj2)</code></pre><p><strong>模块导入</strong></p><ul><li>python模块就是单例模式，首次导入会建pyc文件，其他会直接导入这个文件</li></ul><pre><code class="hljs python"><span class="hljs-comment"># mysingleton.py</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>:</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">foo</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">pass</span>    singleton = Singleton()<span class="hljs-comment"># 导入</span><span class="hljs-keyword">from</span> mysingleton <span class="hljs-keyword">import</span> Singleton</code></pre><p><strong>装饰器</strong></p><ul><li>装饰器外层定义字典用来存类的实例，之后每次先判断是不是存在实例，存在返回，不存在则创建。</li></ul><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">singleton</span>(<span class="hljs-params">cls</span>):</span>    _instance = &#123;&#125;    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_singleton</span>(<span class="hljs-params">*args, **kwargs</span>):</span>        <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _instance:            _instance[cls] = cls(*args, **kwargs)        <span class="hljs-keyword">return</span> _instance[cls]    <span class="hljs-keyword">return</span> _singleton<span class="hljs-meta">@singleton</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span>:</span>    a = <span class="hljs-number">1</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, x=<span class="hljs-number">0</span></span>):</span>        self.x = xa1 = A(<span class="hljs-number">2</span>)</code></pre><p><strong>使用类</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">pass</span><span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">instance</span>(<span class="hljs-params">cls, *args, **kwargs</span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(Singleton, <span class="hljs-string">&quot;_instance&quot;</span>):            Singleton._instance = Singleton(*args, **kwargs)        <span class="hljs-keyword">return</span> Singleton._instance</code></pre><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> picklepickle.dumps()  <span class="hljs-comment"># 序列化，会将对象转换为bytes</span>pickle.loads()  <span class="hljs-comment"># 反序列化，从bytes中解析出对象</span></code></pre><h3 id="Json"><a href="#Json" class="headerlink" title="Json"></a>Json</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> jsonjson.dumps()  <span class="hljs-comment"># 将字典转换为JSON字符串</span>json.loads()  <span class="hljs-comment"># 将JSON字符串转换为字典</span></code></pre><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> urllib.parse <span class="hljs-keyword">import</span> urlencodeurlencode(d)  <span class="hljs-comment"># 将字典进行URL编码</span></code></pre><h3 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h3><pre><code class="hljs python">datetime  <span class="hljs-comment"># 为日期和时间处理同时提供了简单和复杂的方法</span>zlib  <span class="hljs-comment"># 直接支持通用的数据打包和压缩格式：zlib，gzip，bz2，zipfile，以及 tarfile</span>random  <span class="hljs-comment"># 提供了生成随机数的工具</span>math  <span class="hljs-comment"># 为浮点运算提供了对底层C函数库的访问</span>sys  <span class="hljs-comment"># 工具脚本经常调用命令行参数。这些命令行参数以链表形式存储于 sys 模块的 argv 变量</span>glob  <span class="hljs-comment"># 提供了一个函数用于从目录通配符搜索中生成文件列表</span>os  <span class="hljs-comment"># 提供了不少与操作系统相关联的函数</span>urllib  <span class="hljs-comment"># 获取网页源码</span></code></pre><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<span class="hljs-comment"># 正常执行</span><span class="hljs-keyword">except</span> &lt;异常名&gt;:<span class="hljs-comment"># 异常执行</span><span class="hljs-keyword">except</span> &lt;异常名&gt;, 附加数据:<span class="hljs-comment"># 异常执行</span><span class="hljs-keyword">else</span>:    <span class="hljs-comment"># 没有异常时会执行</span><span class="hljs-keyword">finally</span>:<span class="hljs-comment"># 都执行</span>    <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&#x27;手动抛出的异常&#x27;</span>)</code></pre><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><pre><code class="hljs python"><span class="hljs-keyword">import</span> logginglogging.basicConfig(level=logging.DEBUG,                    <span class="hljs-built_in">format</span>=<span class="hljs-string">&#x27;%(asctime)s - %(filename)s[line:%(lineno)d] - %(levelname)s: %(message)s&#x27;</span>)logging.info(<span class="hljs-string">&#x27;xxx&#x27;</span>)<span class="hljs-comment"># DEBUG：用于调试目的的低级系统信息</span><span class="hljs-comment"># INFO：一般系统信息</span><span class="hljs-comment"># WARNING：描述已发生的小问题的信息。</span><span class="hljs-comment"># ERROR：描述已发生的主要问题的信息。</span><span class="hljs-comment"># CRITICAL：描述已发生的严重问题的信息。</span></code></pre><h3 id="数学模块"><a href="#数学模块" class="headerlink" title="数学模块"></a>数学模块</h3><h5 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h5><pre><code class="hljs python"><span class="hljs-keyword">import</span> mathmath.ceil(<span class="hljs-number">3.1</span>)  <span class="hljs-comment"># 向上进一</span>math.floor(<span class="hljs-number">3.9</span>)  <span class="hljs-comment"># 向下进一</span>math.sqrt(x)  <span class="hljs-comment"># 返回数字x的平方根</span>math.radians(<span class="hljs-number">360</span>)  <span class="hljs-comment"># 度转换为弧度</span>math.degrees(math.pi)  <span class="hljs-comment"># 弧度转换为度</span></code></pre><h5 id="Sys"><a href="#Sys" class="headerlink" title="Sys"></a>Sys</h5><pre><code class="hljs python"><span class="hljs-keyword">import</span> syssys.argv  <span class="hljs-comment"># 是一个列表，保存所有的命令行参数</span></code></pre><h5 id="Random-随机数"><a href="#Random-随机数" class="headerlink" title="Random 随机数"></a>Random 随机数</h5><pre><code class="hljs python"><span class="hljs-keyword">import</span> randomrandom.randint(a, b)  <span class="hljs-comment"># 生成指定a~b范围随机整数</span>random.random()  <span class="hljs-comment"># 生成0~1的随机小数</span>random.uniform(a,b)  <span class="hljs-comment"># 生成a~b的随机小数</span>random.randrange(a, b, n)  <span class="hljs-comment"># 生成a~b范围随机整数，可指定步幅n</span>random.choice(lt)  <span class="hljs-comment"># 从容器对象或字符串随机返回一个元素</span>random.sample(lt, <span class="hljs-number">3</span>)  <span class="hljs-comment"># 从容器对象返回指定个数元素的列表</span>random.choices(lt)  <span class="hljs-comment"># 从容器对象返回一个元素的列表，samlp函数个数为1的情况</span>random.shuffle(lt)  <span class="hljs-comment"># 将列表随机打乱</span></code></pre><h5 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h5><p><code>__add__、__radd__、__iadd__</code>：加法</p><p><code>__sub__、__rsub__、__isub__</code>：减法</p><p><code>__mul__、__rmul__、__imul__</code>：乘法</p><p><code>__truediv__、__rtruediv__、__itruediv__</code>：除法</p><p><code>__mod__、__rmod__、__imod__</code>：求余</p><h5 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h5><p><code>__gt__、__lt__、__eq__</code>：大于、小于、等于</p><p><code>__ge__、__le__、__ne__</code>：大于等于、小于等于、不等于</p><h3 id="时间模块"><a href="#时间模块" class="headerlink" title="时间模块"></a>时间模块</h3><h4 id="Time"><a href="#Time" class="headerlink" title="Time"></a>Time</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> timet = time.time()  <span class="hljs-comment"># 获取时间戳，1499825149.257892，(从1970-01-01 00:00:00到此刻的秒数)</span><span class="hljs-built_in">round</span>(time.time())  <span class="hljs-comment"># 秒级时间戳，10位</span><span class="hljs-built_in">round</span>(time.time() * <span class="hljs-number">1000</span>)  <span class="hljs-comment"># 毫秒级时间戳，13位</span><span class="hljs-built_in">round</span>(time.time() * <span class="hljs-number">1000000</span>)  <span class="hljs-comment"># 微秒级时间戳，16位</span>time.sleep(t)  <span class="hljs-comment"># 睡眠指定t的秒数(可以是小数)</span>time.localtime(t)  <span class="hljs-comment"># 将时间戳转换为时间日期对象(time.struct_time)，(默认当前时间戳)，包含时区</span>time.gmtime(t)  <span class="hljs-comment"># 将时间戳转换为 time.struct_time 对象，不带时区</span>time.mktime(t)  <span class="hljs-comment"># 根据年月日等信息创建时间戳</span>time.timezone(t)  <span class="hljs-comment"># 7+0时区与当前系统时区相差的秒数</span>%Y  <span class="hljs-comment"># 年(4位)</span>%y  <span class="hljs-comment"># 年(2位)</span>%m  <span class="hljs-comment"># 月</span>%d  <span class="hljs-comment"># 日</span>%D  <span class="hljs-comment"># 月/日/年</span>% H  <span class="hljs-comment"># 时</span>%M  <span class="hljs-comment"># 分</span>%S  <span class="hljs-comment"># 秒</span>%w  <span class="hljs-comment"># 星期</span>%W  <span class="hljs-comment"># 本周是今年的第几周</span>t = time.struct_timetime.strftime(<span class="hljs-string">&#x27;%D&#x27;</span>, t)  <span class="hljs-comment"># 格式化显示，对 time.struct_time 对象进行</span></code></pre><h4 id="Calendar"><a href="#Calendar" class="headerlink" title="Calendar"></a>Calendar</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> calendarcalendar(y，w=<span class="hljs-number">2</span>, l=<span class="hljs-number">1</span>, c=<span class="hljs-number">6</span>, m=<span class="hljs-number">3</span>)  <span class="hljs-comment"># 返回y年的日历，后边是默认格式</span>calendar.month(y, m)  <span class="hljs-comment"># 返回y年m月的日历</span>calendar.isleap(y)  <span class="hljs-comment"># 判断y年是否是 闰年</span>calendar.leapdays(x, y)  <span class="hljs-comment"># 两个x和y年份之间的闰年数量，区间：[起始， 结束]</span></code></pre><h4 id="Datetime"><a href="#Datetime" class="headerlink" title="Datetime"></a>Datetime</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<span class="hljs-keyword">import</span> datetime<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datedatetime.datetime.now()  <span class="hljs-comment"># 当前时间2022-01-07 10:44:00.357475</span>date(y, m, d)  <span class="hljs-comment"># 创建对象(年-月-日)</span>date.today()  <span class="hljs-comment"># 创建对象(今天的年月日)</span>date.fromtimestamp(time.time())  <span class="hljs-comment"># 用时间戳创建对象(今天的年月日)</span>d1 = date.today()  <span class="hljs-comment"># d1是对象</span>d1.isocalendar()  <span class="hljs-comment"># 日历显示，(年, 第几周, 星期几)</span>d1.isoweekday()  <span class="hljs-comment"># 获取星期，标准格式1~7</span>d1.weekday()  <span class="hljs-comment"># 获取星期，格式0~6</span>d1.year, d1.month, d1.day  <span class="hljs-comment"># 提取单独的年月日</span>d1.timetuple()  <span class="hljs-comment"># 转换为time.struct_time对象</span>d1.isoformat()  <span class="hljs-comment"># 标准格式显示(y-m-d)</span>d1.strftime(<span class="hljs-string">&#x27;%Y-%m-%d %H:%M:%S&#x27;</span>)  <span class="hljs-comment"># 格式化显示</span>datetime.timestamp(d1)  <span class="hljs-comment"># 转成时间戳</span></code></pre><h4 id="Timedelta"><a href="#Timedelta" class="headerlink" title="Timedelta"></a>Timedelta</h4><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> timedelta, datetimetd = timedelta(seconds=<span class="hljs-number">3600</span>)  <span class="hljs-comment"># 时间差</span>td.days  <span class="hljs-comment"># 提取天数</span>td.seconds  <span class="hljs-comment"># 提取秒数(天以外的秒数)</span>td.total_seconds()  <span class="hljs-comment"># 总共的秒数</span></code></pre><h3 id="文件操作："><a href="#文件操作：" class="headerlink" title="文件操作："></a>文件操作：</h3><h4 id="文件管理："><a href="#文件管理：" class="headerlink" title="文件管理："></a>文件管理：</h4><pre><code class="hljs python"><span class="hljs-built_in">open</span>(file, mode)  <span class="hljs-comment"># 打开文件, mode打开模式</span>close(file)  <span class="hljs-comment"># 关闭文件</span><span class="hljs-keyword">with</span>  <span class="hljs-comment"># 操作文件后，保证文件关闭</span>    r  <span class="hljs-comment"># 只读(不存在报错)；w  # 只写(不存在创建，存在清空)；a  # 追加(不存在创建，存在不清空)</span>    r+  <span class="hljs-comment"># r强化版(可以读写)；w+  # w强化版(可以读写)；a+  # a强化版(可以读写)</span>readbble(file)  <span class="hljs-comment"># 判断文件是否可读</span>writable(file)  <span class="hljs-comment"># 判断文件是否可写</span>read(size)  <span class="hljs-comment"># 读取指定size长度内容，默认读全部</span>readline()  <span class="hljs-comment"># 读取整行内容，包括&#x27;\n&#x27;字符</span>write()  <span class="hljs-comment"># 写操作</span>tell(file)  <span class="hljs-comment"># 获取文件操作位置</span>remove(file)  <span class="hljs-comment"># 删除文件</span></code></pre><h5 id="Shutil"><a href="#Shutil" class="headerlink" title="Shutil"></a>Shutil</h5><pre><code class="hljs python"><span class="hljs-keyword">import</span> shutilshutil.copy(old,new)  <span class="hljs-comment"># 拷贝文件(old只能是文件，new可以是文件可以是目录)</span>shutil.copyfile(old,new)  <span class="hljs-comment"># 拷贝文件，只能是文件</span>shutil.copytree(old,new)  <span class="hljs-comment"># 拷贝目录，只能时目录，且new不能存在</span>os.rmdir(<span class="hljs-string">&#x27;test&#x27;</span>)  <span class="hljs-comment"># 删除空目录</span>shutil.rmtree()  <span class="hljs-comment"># 递归删除目录(空目录，有内容都可以删)</span>os.rename(old,new)  <span class="hljs-comment"># 重命名目录(文件)</span>shutil.move(old,new)  <span class="hljs-comment"># 移动目录(文件)</span></code></pre><h5 id="Bytes"><a href="#Bytes" class="headerlink" title="Bytes"></a>Bytes</h5><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">encode</span><span class="hljs-params">(<span class="hljs-string">&#x27;utf-8&#x27;</span>)</span></span>：编码<span class="hljs-function"><span class="hljs-title">decode</span><span class="hljs-params">(<span class="hljs-string">&#x27;utf-8&#x27;</span>)</span></span>：解码</code></pre><h4 id="目录管理"><a href="#目录管理" class="headerlink" title="目录管理"></a>目录管理</h4><h5 id="Os-模块"><a href="#Os-模块" class="headerlink" title="Os 模块"></a>Os 模块</h5><pre><code class="hljs python"><span class="hljs-keyword">import</span> osos.name  <span class="hljs-comment"># 判断正在使用的平台 (windows 返回 &#x27;nt&#x27;; Linux 返回&#x27;posix&#x27;)</span>os.system(cls)  <span class="hljs-comment"># 清屏</span>os.system(calc)  <span class="hljs-comment"># 调出计算器</span>os.environ[path]  <span class="hljs-comment"># 获取环境变量</span>os.getenv(pathxx)  <span class="hljs-comment"># 从环境中取字符串,获取环境变量的值</span>os.getpid()  <span class="hljs-comment"># 获取当前进程id号</span>os.getpid()  <span class="hljs-comment"># 获取当前进程的父进程id号</span>os.getcwd()  <span class="hljs-comment"># 查看当前目录</span>os.mkdir(path)  <span class="hljs-comment"># 新建目录</span>os.makedirs(a/b/c)  <span class="hljs-comment"># 创建多级目录(可创建中间目录)</span>os.rmdir(path)  <span class="hljs-comment"># 删除空目录</span>os.removedirs(path)  <span class="hljs-comment"># 删除多层目录</span>os.remove(file)  <span class="hljs-comment"># 删除文件</span>os.rename(test, test2)  <span class="hljs-comment"># 重命名文件(目录)</span>os.stat(file)  <span class="hljs-comment"># 查看文件信息</span>os.listdir(path)  <span class="hljs-comment"># 遍历目录，返回指定路径下的文件和文件夹列表</span>os.getcwd()  <span class="hljs-comment"># 查看当前工作目录</span>os.listdir(os.getcwd())  <span class="hljs-comment"># 查看指定文件内容</span>os.walk(path)  <span class="hljs-comment"># 生成目录树下的所有文件名</span>os.chdir()  <span class="hljs-comment"># 改变目录</span></code></pre><h5 id="Os-path模块"><a href="#Os-path模块" class="headerlink" title="Os.path模块"></a>Os.path模块</h5><p>import os</p><pre><code class="hljs python"><span class="hljs-comment"># import os</span>os.path.join(path, file)  <span class="hljs-comment"># 目录拼接</span>os.path.dirname(path)  <span class="hljs-comment"># 去掉文件名，返回目录路径</span>os.path.basename(path)  <span class="hljs-comment"># 去掉目录路径，返回文件名</span>os.path.split(path)  <span class="hljs-comment"># 切割路径和文件名；dir, file = os.path.split(path)</span>os.path.splitext(path)  <span class="hljs-comment"># 切割路径和后缀</span>os.path.exists(file)  <span class="hljs-comment"># 判断文件(目录)是否存在</span>os.path.isdir(path)  <span class="hljs-comment"># 是否是目录</span>os.path.isfile(path)  <span class="hljs-comment"># 是否是文件</span>os.path.isabs(path)  <span class="hljs-comment"># 是否是绝对路径</span>os.path.abspath(path)  <span class="hljs-comment"># 转换为绝对路径</span>os.path.getsize(file)  <span class="hljs-comment"># 获取文件大小(只适用于文件，不适用目录)</span></code></pre><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h4 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h4><pre><code class="hljs python"><span class="hljs-keyword">import</span> res = <span class="hljs-string">&quot;www.findlp com&quot;</span>p = <span class="hljs-string">&quot;.([a-z]+) &quot;</span>re.<span class="hljs-built_in">compile</span>(p)  <span class="hljs-comment"># 创建正则表达式对象，可以让创建正则对象和内容匹配分开操作</span>re.match(p, s)  <span class="hljs-comment"># 从开头进行匹配，找到返回对象结果，没有返回None</span>re.search(p, s)  <span class="hljs-comment"># 从任意位置匹配，作用同 match</span>re.findall(p, s)  <span class="hljs-comment"># 全部匹配，返回所有匹配到的结果列表，没有则返回空列表，添加 () 后，结果只显示 () 匹配的内容</span>.span()  <span class="hljs-comment"># 返回匹配内容的位置</span>.group()  <span class="hljs-comment"># 返回匹配内容、</span>.groups()  <span class="hljs-comment"># 返回所有组的信息，正则需要()</span>.groupdict()  <span class="hljs-comment"># 返回分组的字典，键是组的名字，值是组的内容</span></code></pre><h4 id="正则语法"><a href="#正则语法" class="headerlink" title="正则语法"></a>正则语法</h4><h6 id="单个字符"><a href="#单个字符" class="headerlink" title="单个字符"></a>单个字符</h6><p>[abc]：abc的任意一个字符</p><p>[0-9]：任意数字字符</p><p>[a-zA-Z]：任意字母</p><p>[^0-9]：非数字字符</p><p>. ：除’\n’以外的任意字符</p><h6 id="单个字符-1"><a href="#单个字符-1" class="headerlink" title="单个字符"></a>单个字符</h6><p>‘\d’：匹配数字字符，等价[0-9]</p><p>‘\D’：匹配非数字字符</p><p>‘\w’：匹配字(数字、字母、下划线、汉字)</p><p>‘\W’：匹配非字(&lt; &gt;|、)</p><p>‘\s’：匹配空白字符(\n, \r, \t、空格)</p><p>‘\S’：匹配非空白字符</p><p>‘\b’：匹配词边界(开头、结尾、空格、标点)</p><p>‘\B’：匹配非词边界</p><h6 id="次数限定"><a href="#次数限定" class="headerlink" title="次数限定"></a>次数限定</h6><p>*：匹配0次或任意次</p><p>+：匹配最少一次</p><p>?：匹配零次或一次，非贪婪匹配</p><p>?: ：非匹配获取，匹配冒号后的内容，但不获取匹配结果，不进行存储供以后使用</p><p>{m}：指定m次</p><p>{m,n}：指定m~n次</p><p>{m,}：最少m次</p><p>{,m}最多m次</p><h6 id="边界限定"><a href="#边界限定" class="headerlink" title="边界限定"></a>边界限定</h6><p>^：以指定内容开头</p><p>$：以指定内容结尾</p><h6 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h6><div></div>：固定匹配<[a-z]+></[a-z]+>：动态匹配：匹配多次嵌套的标签<p>&lt;[a-z]+)&gt;&lt;/(\1)&gt;：无名分组：\1、\2分别表示前面的第一组、第二组匹配的内容</p><p>(?P<one>[a-z]+)  ；?P=one：给标签起名；相对应</p><h6 id="匹配模式"><a href="#匹配模式" class="headerlink" title="匹配模式"></a>匹配模式</h6><p>re.I ：表示忽略大小写</p><p>re.M ：多行处理(默认会把字符串当作一行处理)</p><p>re.S ：单行处理，是.可以匹配任意(忽略\n)</p><h6 id="字符替换"><a href="#字符替换" class="headerlink" title="字符替换"></a>字符替换</h6><p>re.sub(“old_str”, “new_str”, text, 2) ：最多替换2次，默认全部</p><h3 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image, ImageDraw, ImageFontimg = Image.<span class="hljs-built_in">open</span>(fp, mode=<span class="hljs-string">&quot;r&quot;</span>)  <span class="hljs-comment"># 打开图片(图片名.要带后缀)</span>img.save()  <span class="hljs-comment"># 保存图片(指定文件名.要带后缀)</span>img.show()  <span class="hljs-comment"># 查看图片</span>Image.new(mode, size, color=<span class="hljs-number">0</span>)  <span class="hljs-comment"># 新建图片(&#x27;RGB&#x27;, 尺寸, 颜色)</span>img.thumbnail(size)  <span class="hljs-comment"># 修改尺寸，在原图修改</span>img.resize(size)  <span class="hljs-comment"># 修改尺寸，生成新的图片</span>draw = ImageDraw.Draw(img)  <span class="hljs-comment"># 创建画笔</span>font = ImageFont.truetype(font, size=<span class="hljs-number">10</span>)  <span class="hljs-comment"># 创建字体</span>draw.point(xy, fill)  <span class="hljs-comment"># 画点，一个像素(位置，颜色)</span>draw.line(xy, fill, width=<span class="hljs-number">0</span>)  <span class="hljs-comment"># 画线(位置*n，颜色，宽度)</span>draw.text(xy, text, fill, font)  <span class="hljs-comment"># 画字(位置，字，颜色，字体)</span></code></pre><h3 id="进程线程协程"><a href="#进程线程协程" class="headerlink" title="进程线程协程"></a>进程线程协程</h3><h4 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h4><p>multiprocessing</p><ul><li>进程是最小的资源管理单元，独立运行，一个程序就是一个进程<ul><li>优点：利用cpu多核</li><li>缺点：占用资源多；启动数目有限</li><li>适用：CPU密集型计算</li></ul></li></ul><h4 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h4><p>threading</p><ul><li>线程是最小的执行单元</li><li>一个程序至少一个主线程，可以开多个线程，线程之间数据共享</li><li>资源分配给进程，cpu分配给线程，真正在cpu上运行的是线程<ul><li>优点：比进程更轻量；占用资源少</li><li>缺点：<ul><li>相比进程：多线程只能并发，因为GIL的存在不能利用cpu多核</li><li>相比协程：启动数目有限；占用内存资源；有线程切换开销</li></ul></li><li>适用：IO密集型计算；同时运行的任务数目要求不多</li></ul></li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<span class="hljs-keyword">import</span> time<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span>(<span class="hljs-params">n</span>):</span>    print(<span class="hljs-string">&quot;task:&quot;</span>, n)    <span class="hljs-keyword">while</span> n &gt;= <span class="hljs-number">0</span>:        time.sleep(<span class="hljs-number">1</span>)        print(n, <span class="hljs-string">&quot;s&quot;</span>)        n -= <span class="hljs-number">1</span><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    t1 = threading.Thread(target=main, args=(<span class="hljs-number">3</span>,))    t2 = threading.Thread(target=main, args=(<span class="hljs-number">4</span>,))    t1.start()    t2.start()</code></pre><p><strong>多线程+queue队列</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> threading<span class="hljs-keyword">from</span> queue <span class="hljs-keyword">import</span> Queue<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">parse</span>(<span class="hljs-params">input_queue: Queue, output_queue: Queue</span>):</span>    <span class="hljs-keyword">while</span> output_queue.qsize() &lt; <span class="hljs-number">1000</span>:        num = input_queue.get()        output_queue.put(num + <span class="hljs-number">1</span>)        print(<span class="hljs-string">f&#x27;输出成功, 目前 <span class="hljs-subst">&#123;output_queue.qsize()&#125;</span>&#x27;</span>)<span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:    print(<span class="hljs-string">&#x27;start&#x27;</span>)    base_url = <span class="hljs-string">&#x27;https://www.cnbolgs.com/#p&#x27;</span>    input_queue = Queue()    output_queue = Queue()    thread_list = []    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10000</span>):        input_queue.put(<span class="hljs-number">1</span>)    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):        t = threading.Thread(target=parse, args=(input_queue, output_queue))        t.start()        thread_list.append(t)    <span class="hljs-keyword">for</span> t <span class="hljs-keyword">in</span> thread_list:        t.join()    print(<span class="hljs-string">&#x27;end&#x27;</span>)</code></pre><h4 id="多协程"><a href="#多协程" class="headerlink" title="多协程"></a>多协程</h4><p>asyncio</p><ul><li>一个线程可有多个协程<ul><li>优点：内存开销最少；启动数量最多</li><li>缺点：支持的库有限（aiohttp vs requests）；代码实现复杂</li><li>适用：IO密集型计算；需要超多任务运行；代码复杂度能接受</li></ul></li></ul><pre><code class="hljs plain"></code></pre><h2 id="虚拟环境"><a href="#虚拟环境" class="headerlink" title="虚拟环境"></a>虚拟环境</h2><h4 id="安装工具"><a href="#安装工具" class="headerlink" title="安装工具"></a>安装工具</h4><pre><code class="hljs sh">pip install virtualenvwrapper  <span class="hljs-comment"># linux</span>pip install virtualenvwrapper-win  <span class="hljs-comment"># windows cmd</span>pip install virtualenvwrapper-powershell <span class="hljs-comment"># windows powershell</span></code></pre><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><pre><code class="hljs sh"><span class="hljs-comment"># 查看虚拟环境列表</span>workonlsvirtualenv<span class="hljs-comment"># 创建虚拟环境</span>mkvirtualenv -p python3 env-name<span class="hljs-comment"># 删除虚拟环境</span>rmvirtualenv env-name<span class="hljs-comment"># 激活虚拟环境</span>workon env-name<span class="hljs-comment"># 推出虚拟环境</span>deactivate</code></pre><h4 id="Powershell"><a href="#Powershell" class="headerlink" title="Powershell"></a>Powershell</h4><p><strong>powershell 无法使用 workon 切换虚拟环境</strong></p><ul><li>临时解决</li></ul><pre><code class="hljs sh">&amp; cmd /k workon &lt;envname&gt;</code></pre><ul><li>永久配置</li></ul><p>在 C:\Users\xxx\Documents\WindowsPowerShell 下新建 Microsoft.PowerShell_profile.ps1文件</p><p>添加以下内容</p><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">workon</span>(<span class="hljs-params">$environment</span>) </span>&#123;  &amp; cmd /k workon.bat $environment&#125;</code></pre><h2 id="Anaconda"><a href="#Anaconda" class="headerlink" title="Anaconda"></a>Anaconda</h2><pre><code class="hljs sh"><span class="hljs-comment"># 查看版本</span>conda -V<span class="hljs-comment"># 列出所有虚拟环境</span>conda-env listconda info -e<span class="hljs-comment"># 更新conda</span>conda update<span class="hljs-comment"># 初始化conda与shell的交互</span>conda init</code></pre><h4 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h4><pre><code class="hljs sh"><span class="hljs-comment"># 列出已安装包</span>conda list</code></pre><h5 id="安装包"><a href="#安装包" class="headerlink" title="安装包"></a>安装包</h5><pre><code class="hljs sh">conda install package_name<span class="hljs-comment"># 指定环境安装包</span>conda install -n env_name package_name</code></pre><h5 id="删除包"><a href="#删除包" class="headerlink" title="删除包"></a>删除包</h5><pre><code class="hljs sh">conda remove package_name<span class="hljs-comment"># 指定环境删除包</span>conda remove -n env_name package_name</code></pre><h4 id="虚拟环境-1"><a href="#虚拟环境-1" class="headerlink" title="虚拟环境"></a>虚拟环境</h4><h5 id="新建环境"><a href="#新建环境" class="headerlink" title="新建环境"></a>新建环境</h5><ul><li>默认创建在conda目录下的envs文件目录下</li></ul><pre><code class="hljs sh">conda create -n env_name python=3.6.2<span class="hljs-comment"># 新建环境，同时安装需要的包</span>conda create -n env_name numpy matplotlib python=3.6.2<span class="hljs-comment"># 安装打包的环境</span>conda env_name create -f environment.yml</code></pre><h5 id="激活环境"><a href="#激活环境" class="headerlink" title="激活环境"></a>激活环境</h5><pre><code class="hljs sh"><span class="hljs-comment"># Linux</span><span class="hljs-built_in">source</span> activate env_name<span class="hljs-comment"># Windows</span>activate env_name</code></pre><h5 id="退出环境"><a href="#退出环境" class="headerlink" title="退出环境"></a>退出环境</h5><pre><code class="hljs sh"><span class="hljs-comment"># Linux</span>sourve deactivate<span class="hljs-comment"># Windows</span>deactivate</code></pre><h5 id="删除环境"><a href="#删除环境" class="headerlink" title="删除环境"></a>删除环境</h5><pre><code class="hljs sh">conda remove -n env_name --all</code></pre><h5 id="复制环境"><a href="#复制环境" class="headerlink" title="复制环境"></a>复制环境</h5><pre><code class="hljs sh">conda cteate -n new_env_name --<span class="hljs-built_in">clone</span> old_env_name</code></pre><h5 id="环境迁移"><a href="#环境迁移" class="headerlink" title="环境迁移"></a>环境迁移</h5><pre><code class="hljs sh"><span class="hljs-comment"># 打包环境</span>conda env_name <span class="hljs-built_in">export</span> &gt; environment.yml<span class="hljs-comment"># 安装打包的环境</span>conda env_name create -f environment.yml</code></pre><h5 id="更新python版本"><a href="#更新python版本" class="headerlink" title="更新python版本"></a>更新python版本</h5><ul><li>需要在指定环境下运行命令</li></ul><pre><code class="hljs sh"><span class="hljs-comment"># 更新最新版本</span>conda update python<span class="hljs-comment"># 升级指定版本</span>conda install python==3.6.9</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python</title>
    <link href="/2021/12/14/python/Django/"/>
    <url>/2021/12/14/python/Django/</url>
    
    <content type="html"><![CDATA[<h2 id="项目创建"><a href="#项目创建" class="headerlink" title="项目创建"></a>项目创建</h2><pre><code class="hljs bash"><span class="hljs-comment"># 创建名为 django01的项目</span>django-admin startproject django01 <span class="hljs-comment"># 进入项目目录</span><span class="hljs-built_in">cd</span> django01 <span class="hljs-comment"># 创建名为 app01的app</span>django-admin startapp app01 <span class="hljs-comment"># 启动django项目，默认127.0.0.1:8000</span>python manage.py runserver <span class="hljs-comment"># 指定端口启动</span>python manage.py runserver 8002  <span class="hljs-comment"># 创建超级管理员</span>python manage.py createsuperuser</code></pre><h2 id="Setting-py"><a href="#Setting-py" class="headerlink" title="Setting.py"></a>Setting.py</h2><p><strong>文档：</strong></p><p><a href="https://docs.djangoproject.com/zh-hans/3.2/ref/settings/">https://docs.djangoproject.com/zh-hans/3.2/ref/settings/</a></p><h3 id="服务主机"><a href="#服务主机" class="headerlink" title="服务主机"></a>服务主机</h3><pre><code class="hljs python"><span class="hljs-comment"># 安全措施，允许哪些地址访问</span>DEBUG = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 生产环境要禁用</span>ALLOWED_HOSTS = []  <span class="hljs-comment"># 默认。DEBUG=True时，根据[&#x27;.localhost&#x27;, &#x27;127.0.0.1&#x27;, &#x27;[::1]&#x27;]验证</span>ALLOWED_HOSTS = [<span class="hljs-string">&#x27;*&#x27;</span>]  <span class="hljs-comment"># 允许所有</span>ALLOWED_HOSTS = [<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-string">&#x27;192.168.1.10&#x27;</span>]  <span class="hljs-comment"># 允许指定ip访问</span></code></pre><h3 id="注册app"><a href="#注册app" class="headerlink" title="注册app"></a>注册app</h3><pre><code class="hljs python">INSTALLED_APPS = [    ...    <span class="hljs-string">&#x27;apps.app01.App01Config&#x27;</span>,  <span class="hljs-comment"># 新加</span>    <span class="hljs-string">&#x27;apps.user.UserConfig&#x27;</span>  <span class="hljs-comment"># 新加</span>]</code></pre><h3 id="Mysql数据库"><a href="#Mysql数据库" class="headerlink" title="Mysql数据库"></a>Mysql数据库</h3><pre><code class="hljs python">DATABASES = &#123;    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;        <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.mysql&#x27;</span>,        <span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;db_name&#x27;</span>,        <span class="hljs-string">&#x27;USER&#x27;</span>: <span class="hljs-string">&#x27;root&#x27;</span>,        <span class="hljs-string">&#x27;PASSWORD&#x27;</span>: <span class="hljs-string">&#x27;123456&#x27;</span>,        <span class="hljs-string">&#x27;HOST&#x27;</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,        <span class="hljs-string">&#x27;PORT&#x27;</span>: <span class="hljs-number">3306</span>    &#125;,    ...&#125;</code></pre><h5 id="Pymysql"><a href="#Pymysql" class="headerlink" title="Pymysql"></a>Pymysql</h5><ul><li>推荐使用mysqlclient</li></ul><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> pymysql</code></pre><p>settings.py 同级<code>__init__</code>.py </p><pre><code class="hljs elm"><span class="hljs-keyword">import</span> pymysql<span class="hljs-title">pymysql</span>.install_as_MySQLdb()</code></pre><h5 id="Mysqlcilent"><a href="#Mysqlcilent" class="headerlink" title="Mysqlcilent"></a>Mysqlcilent</h5><pre><code class="hljs bash">pip install mysqlclient</code></pre><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> django-redis</code></pre><p>settings.py</p><pre><code class="hljs python">CACHES = &#123;    <span class="hljs-comment"># 默认</span>    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;        <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;django.core.cache.backends.locmem.LocMemCache&#x27;</span>,        <span class="hljs-string">&#x27;LOCATION&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,        <span class="hljs-string">&#x27;TIMEOUT&#x27;</span>: <span class="hljs-number">300</span>,  <span class="hljs-comment"># 缓存超时时间，单位秒。None：永久不过期</span>        <span class="hljs-string">&#x27;OPTIONS&#x27;</span>: &#123;            <span class="hljs-string">&#x27;MAX_ENTRIES&#x27;</span>: <span class="hljs-number">300</span>,  <span class="hljs-comment"># 允许缓存最大条目</span>            <span class="hljs-string">&#x27;CULL_FREQUENCY&#x27;</span>: <span class="hljs-number">3</span>, <span class="hljs-comment"># 缓存条目最大时，删除条目的比例。1：全部；2：1/2；3：1/3</span>                    &#125;,    &#125;,    <span class="hljs-comment"># 附加缓存</span>    <span class="hljs-string">&#x27;session&#x27;</span>: &#123;        <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;django_redis.cache.RedisCache&#x27;</span>,  <span class="hljs-comment"># 缓存redis</span>        <span class="hljs-string">&#x27;LOCATION&#x27;</span>: <span class="hljs-string">&#x27;redis://127.0.0.1:6379/1&#x27;</span>,        <span class="hljs-string">&#x27;OPTIONS&#x27;</span>: &#123;            <span class="hljs-string">&#x27;CLIENT_CLASS&#x27;</span>: <span class="hljs-string">&#x27;django_redis.client.DefaultClient&#x27;</span>,            <span class="hljs-comment"># &#x27;PASSWORD&#x27;: &#x27;&#x27;</span>        &#125;    &#125;,    <span class="hljs-comment"># 购物车</span>    <span class="hljs-string">&#x27;cart&#x27;</span>: &#123;        <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;django_redis.cache.RedisCache&#x27;</span>,  <span class="hljs-comment"># 缓存redis</span>        <span class="hljs-string">&#x27;LOCATION&#x27;</span>: <span class="hljs-string">&#x27;redis://127.0.0.1:6379/2&#x27;</span>,        <span class="hljs-string">&#x27;OPTIONS&#x27;</span>: &#123;            <span class="hljs-string">&#x27;CLIENT_CLASS&#x27;</span>: <span class="hljs-string">&#x27;django_redis.client.DefaultClient&#x27;</span>,            <span class="hljs-comment"># &#x27;PASSWORD&#x27;: &#x27;&#x27;</span>        &#125;    &#125;,&#125;</code></pre><p>views.py</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django_redis <span class="hljs-keyword">import</span> get_redis_connection conn = get_redis_connection(<span class="hljs-string">&#x27;cart&#x27;</span>)print(conn.hgetall(<span class="hljs-string">&#x27;xxx&#x27;</span>))</code></pre><h3 id="HTML模板目录"><a href="#HTML模板目录" class="headerlink" title="HTML模板目录"></a>HTML模板目录</h3><pre><code class="hljs python">TEMPLATES = [    &#123;        <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;django.template.backends.django.DjangoTemplates&#x27;</span>,        <span class="hljs-string">&#x27;DIRS&#x27;</span>: [os.path.join(BASE_DIR, <span class="hljs-string">&#x27;templates&#x27;</span>)]   <span class="hljs-comment"># 指定html文件所在的位置目录templates</span>        ,        <span class="hljs-string">&#x27;APP_DIRS&#x27;</span>: <span class="hljs-literal">True</span>,        <span class="hljs-string">&#x27;OPTIONS&#x27;</span>: &#123;            <span class="hljs-string">&#x27;context_processors&#x27;</span>: [                <span class="hljs-string">&#x27;django.template.context_processors.debug&#x27;</span>,                <span class="hljs-string">&#x27;django.template.context_processors.request&#x27;</span>,                <span class="hljs-string">&#x27;django.contrib.auth.context_processors.auth&#x27;</span>,                <span class="hljs-string">&#x27;django.contrib.messages.context_processors.messages&#x27;</span>,            ],        &#125;,    &#125;,]</code></pre><h3 id="语言时区"><a href="#语言时区" class="headerlink" title="语言时区"></a>语言时区</h3><pre><code class="hljs python">LANGUAGE_CODE = <span class="hljs-string">&#x27;zh-hans&#x27;</span>  <span class="hljs-comment"># 中文显示</span>TIME_ZONE = <span class="hljs-string">&#x27;Asia/Shanghai&#x27;</span>  <span class="hljs-comment"># 设置时区</span>USE_I18N = <span class="hljs-literal">True</span>  <span class="hljs-comment"># 国际化</span>USE_L10N = <span class="hljs-literal">True</span>  <span class="hljs-comment"># admin后台显示时间格式化为 &#x27;2020-09-12 12:00:00&#x27;</span>USE_TZ = <span class="hljs-literal">False</span>  <span class="hljs-comment"># ORM查询返回，是否自动转换为UTC时间</span></code></pre><h3 id="静态文件"><a href="#静态文件" class="headerlink" title="静态文件"></a>静态文件</h3><pre><code class="hljs python"><span class="hljs-comment"># 静态文件夹的别名</span>STATIC_URL = <span class="hljs-string">&#x27;/static/&#x27;</span><span class="hljs-comment"># 所有静态文件（css/js/图片）都放在我下面你配置的文件夹中</span>STATICFILES_DIRS = [    os.path.join(BASE_DIR, <span class="hljs-string">&quot;static&quot;</span>),]</code></pre><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><pre><code class="hljs python"><span class="hljs-comment"># 数据库Session（默认）</span>SESSION_ENGINE = <span class="hljs-string">&#x27;django.contrib.sessions.backends.db&#x27;</span>   <span class="hljs-comment"># 存储数据库</span><span class="hljs-comment"># 缓存Session</span>SESSION_ENGINE = <span class="hljs-string">&#x27;django.contrib.sessions.backends.cache&#x27;</span>  <span class="hljs-comment"># 指定缓存存储</span>SESSION_CACHE_ALIAS = <span class="hljs-string">&#x27;default&#x27;</span>                            <span class="hljs-comment"># 使用的缓存别名（默认内存缓存，也可以是memcache），此处别名依赖缓存的设置</span> <span class="hljs-comment"># 文件Session</span>SESSION_ENGINE = <span class="hljs-string">&#x27;django.contrib.sessions.backends.file&#x27;</span>    <span class="hljs-comment"># 存储文件</span>SESSION_FILE_PATH = <span class="hljs-literal">None</span>                                    <span class="hljs-comment"># 缓存文件路径，如果为None，则使用tempfile模块获取一个临时地址tempfile.gettempdir() </span> <span class="hljs-comment"># 缓存+数据库</span>SESSION_ENGINE = <span class="hljs-string">&#x27;django.contrib.sessions.backends.cached_db&#x27;</span>        <span class="hljs-comment"># 引擎</span> <span class="hljs-comment"># 加密Cookie Session</span>SESSION_ENGINE = <span class="hljs-string">&#x27;django.contrib.sessions.backends.signed_cookies&#x27;</span>   <span class="hljs-comment"># 引擎</span> <span class="hljs-comment"># 其他公用设置项：</span>SESSION_COOKIE_NAME ＝ <span class="hljs-string">&quot;sessionid&quot;</span>            <span class="hljs-comment"># Session的cookie保存在浏览器上时的key，即：sessionid＝随机字符串（默认）</span>SESSION_COOKIE_PATH ＝ <span class="hljs-string">&quot;/&quot;</span>                    <span class="hljs-comment"># Session的cookie保存的路径。默认 /</span>SESSION_COOKIE_DOMAIN = <span class="hljs-literal">None</span>                  <span class="hljs-comment"># Session的cookie保存的域名。默认 None</span>SESSION_COOKIE_SECURE = <span class="hljs-literal">False</span>                 <span class="hljs-comment"># 是否Https传输cookie。默认 False</span>SESSION_COOKIE_HTTPONLY = <span class="hljs-literal">True</span>                <span class="hljs-comment"># 是否Session的cookie只支持http传输。默认 True</span>SESSION_COOKIE_AGE = <span class="hljs-number">1209600</span>                  <span class="hljs-comment"># session的cookie失效日期，单位秒，默认2周</span>SESSION_EXPIRE_AT_BROWSER_CLOSE = <span class="hljs-literal">False</span>       <span class="hljs-comment"># 是否关闭浏览器使得Session过期。默认</span>SESSION_SAVE_EVERY_REQUEST = <span class="hljs-literal">False</span>            <span class="hljs-comment"># 是否每次请求都保存Session，默认修改之后才保存。默认</span></code></pre><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><pre><code class="hljs python">LOGGING = &#123;    <span class="hljs-string">&#x27;version&#x27;</span>: <span class="hljs-number">1</span>,    <span class="hljs-string">&#x27;disable_existing_loggers&#x27;</span>: <span class="hljs-literal">False</span>,    <span class="hljs-string">&#x27;formatters&#x27;</span>: &#123;        <span class="hljs-string">&#x27;verbose&#x27;</span>: &#123;            <span class="hljs-string">&#x27;format&#x27;</span>: <span class="hljs-string">&#x27;&#123;levelname&#125; &#123;asctime&#125; &#123;module&#125; &#123;message&#125; &#x27;</span>,            <span class="hljs-string">&#x27;style&#x27;</span>: <span class="hljs-string">&#x27;&#123;&#x27;</span>,        &#125;,        <span class="hljs-string">&#x27;simple&#x27;</span>: &#123;            <span class="hljs-string">&#x27;format&#x27;</span>: <span class="hljs-string">&#x27;&#123;levelname&#125; &#123;message&#125;&#x27;</span>,            <span class="hljs-string">&#x27;style&#x27;</span>: <span class="hljs-string">&#x27;&#123;&#x27;</span>,        &#125;,    &#125;,    <span class="hljs-string">&#x27;handlers&#x27;</span>: &#123;        <span class="hljs-string">&#x27;sql&#x27;</span>: &#123;            <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;DEBUG&#x27;</span>,            <span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;logging.FileHandler&#x27;</span>,            <span class="hljs-string">&#x27;filename&#x27;</span>: os.path.join(BASE_DIR, <span class="hljs-string">&quot;logs/sql.log&quot;</span>),            <span class="hljs-string">&#x27;formatter&#x27;</span>: <span class="hljs-string">&#x27;verbose&#x27;</span>        &#125;,        <span class="hljs-string">&#x27;error&#x27;</span>: &#123;            <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;INFO&#x27;</span>,            <span class="hljs-string">&#x27;class&#x27;</span>: <span class="hljs-string">&#x27;logging.FileHandler&#x27;</span>,            <span class="hljs-string">&#x27;filename&#x27;</span>: os.path.join(BASE_DIR, <span class="hljs-string">&quot;logs/error.log&quot;</span>),            <span class="hljs-string">&#x27;formatter&#x27;</span>: <span class="hljs-string">&#x27;verbose&#x27;</span>        &#125;,    &#125;,    <span class="hljs-string">&#x27;loggers&#x27;</span>: &#123;        <span class="hljs-string">&#x27;django&#x27;</span>: &#123;            <span class="hljs-string">&#x27;handlers&#x27;</span>: [<span class="hljs-string">&#x27;error&#x27;</span>],            <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;DEBUG&#x27;</span>,            <span class="hljs-string">&#x27;propagate&#x27;</span>: <span class="hljs-literal">True</span>,        &#125;,        <span class="hljs-string">&#x27;error&#x27;</span>: &#123;            <span class="hljs-string">&#x27;handlers&#x27;</span>: [<span class="hljs-string">&#x27;error&#x27;</span>],            <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;DEBUG&#x27;</span>,            <span class="hljs-string">&#x27;propagate&#x27;</span>: <span class="hljs-literal">True</span>,        &#125;,        <span class="hljs-string">&#x27;django.db.backends&#x27;</span>: &#123;            <span class="hljs-string">&#x27;handlers&#x27;</span>: [<span class="hljs-string">&#x27;sql&#x27;</span>],            <span class="hljs-string">&#x27;level&#x27;</span>: <span class="hljs-string">&#x27;DEBUG&#x27;</span>,            <span class="hljs-string">&#x27;propagate&#x27;</span>: <span class="hljs-literal">True</span>,        &#125;,    &#125;,&#125;</code></pre><h2 id="Simpleui-后台"><a href="#Simpleui-后台" class="headerlink" title="Simpleui 后台"></a>Simpleui 后台</h2><p>官网教程：<a href="https://simpleui.72wo.com/docs/simpleui/doc.html">https://simpleui.72wo.com/docs/simpleui/doc.html</a></p><pre><code class="hljs sh">pip install django-simpleui</code></pre><p>settings.py 加入</p><pre><code class="hljs python">INSTALLED_APPS = [    <span class="hljs-string">&#x27;simpleui&#x27;</span>,    ...]</code></pre><h2 id="环境打包"><a href="#环境打包" class="headerlink" title="环境打包"></a>环境打包</h2><pre><code class="hljs bash"><span class="hljs-comment"># 打包环境</span>pip freeze &gt; requirements.txt<span class="hljs-comment"># 下载环境</span>pip install -r requirements.txt</code></pre><h2 id="Model-模型"><a href="#Model-模型" class="headerlink" title="Model 模型"></a>Model 模型</h2><ul><li>文档：<a href="https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/">https://docs.djangoproject.com/zh-hans/3.2/ref/models/fields/</a></li></ul><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span>(<span class="hljs-params">models.Model</span>):</span>    GENDERS = (        (<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;男&#x27;</span>),        (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;女&#x27;</span>)    )    name = models.CharField(max_length=<span class="hljs-number">20</span>, verbose_name=<span class="hljs-string">&#x27;名字&#x27;</span>, db_column=<span class="hljs-string">&#x27;name&#x27;</span>)    gender = models.IntegerField(default=<span class="hljs-number">0</span>, choices=GENDERS, verbose_name=<span class="hljs-string">&#x27;性别&#x27;</span>)    created = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;创建时间&#x27;</span>)    updated = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;更新时间&#x27;</span>)    deleted = models.IntegerField(default=<span class="hljs-number">0</span>, verbose_name=<span class="hljs-string">&#x27;逻辑删除&#x27;</span>)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        <span class="hljs-comment"># managed = False</span>        db_table = <span class="hljs-string">&#x27;author&#x27;</span>        app_label = <span class="hljs-string">&#x27;demo&#x27;</span>    <span class="hljs-comment"># 逻辑删除</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, using=<span class="hljs-literal">None</span>, keep_parents=<span class="hljs-literal">False</span></span>):</span>        self.deleted = <span class="hljs-number">1</span>        self.save()                <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params">models.Model</span>):</span>    name = models.CharField(max_length=<span class="hljs-number">30</span>, default=<span class="hljs-string">&#x27;&#x27;</span>, verbose_name=<span class="hljs-string">&#x27;书名&#x27;</span>)    author = models.ForeignKey(Author, on_delete=models.CASCADE, db_constraint=<span class="hljs-literal">False</span>, related_name=<span class="hljs-string">&#x27;作者&#x27;</span>)  <span class="hljs-comment"># db_constraint=False：逻辑外键。数据库不使用外键，仅django内部使用</span>    price = models.IntegerField(default=<span class="hljs-number">0</span>, verbose_name=<span class="hljs-string">&#x27;价格&#x27;</span>)    seq = models.IntegerField(default=<span class="hljs-number">0</span>, verbose_name=<span class="hljs-string">&#x27;顺序&#x27;</span>)    created = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;创建时间&#x27;</span>)    updated = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;更新时间&#x27;</span>)    deleted = models.IntegerField(default=<span class="hljs-number">0</span>, verbose_name=<span class="hljs-string">&#x27;逻辑删除&#x27;</span>)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        <span class="hljs-comment"># managed = False</span>        db_table = <span class="hljs-string">&#x27;book&#x27;</span>        app_label = <span class="hljs-string">&#x27;demo&#x27;</span></code></pre><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>    <span class="hljs-comment"># 索引</span>    indexes = [        models.Index(fields=[<span class="hljs-string">&#x27;project&#x27;</span>]),    ]            <span class="hljs-comment"># 联合索引</span>    index_together = [[<span class="hljs-string">&quot;pub_date&quot;</span>, <span class="hljs-string">&quot;deadline&quot;</span>]]<span class="hljs-comment"># index_together = [&quot;pub_date&quot;, &quot;deadline&quot;]  # 单字段可以一个列表 </span>    <span class="hljs-comment"># 联合唯一索引</span>    unique_together = [[<span class="hljs-string">&#x27;driver&#x27;</span>, <span class="hljs-string">&#x27;restaurant&#x27;</span>]]      <span class="hljs-comment"># unique_together = [&#x27;driver&#x27;, &#x27;restaurant&#x27;]</span></code></pre><h4 id="DateTimeField"><a href="#DateTimeField" class="headerlink" title="DateTimeField"></a>DateTimeField</h4><p>精度默认为 6，修改为0 需要将相对配置 datetime(6) 改为 datetime</p><pre><code class="hljs python"><span class="hljs-comment">## settings.py</span><span class="hljs-keyword">from</span> django.db.backends.mysql.base <span class="hljs-keyword">import</span> DatabaseWrapperDatabaseWrapper.data_types[<span class="hljs-string">&#x27;DateTimeField&#x27;</span>] = <span class="hljs-string">&#x27;datetime&#x27;</span></code></pre><h4 id="模型逆向生成"><a href="#模型逆向生成" class="headerlink" title="模型逆向生成"></a>模型逆向生成</h4><pre><code class="hljs python">python manage.py inspectdb &gt; apps/models.py<span class="hljs-comment"># 指定表生成</span>python manage.py inspectdb tb &gt; apps/models.py</code></pre><h4 id="清理migrations"><a href="#清理migrations" class="headerlink" title="清理migrations"></a>清理migrations</h4><pre><code class="hljs python">python manage.py makemigrations<span class="hljs-comment"># 确保 migration文件和数据库同步</span>python manage.py showmigrations<span class="hljs-comment"># 看文件是否都迁移成功。[X]表示迁移成功</span>python manage.py migrate --fake app名 zero  <span class="hljs-comment"># 清除迁移历史记录</span>python manage.py makemigrations  <span class="hljs-comment"># 再次生成迁移文件</span>python manage.py migrate --fake-initial  <span class="hljs-comment"># 执行迁移，但不会真的执行</span></code></pre><h2 id="多数据库"><a href="#多数据库" class="headerlink" title="多数据库"></a>多数据库</h2><p><strong>settings.py</strong></p><pre><code class="hljs python">DATABASES = &#123;    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;        <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.mysql&#x27;</span>,        <span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,        <span class="hljs-string">&#x27;USER&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,        <span class="hljs-string">&#x27;PASSWORD&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,        <span class="hljs-string">&#x27;HOST&#x27;</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,        <span class="hljs-string">&#x27;PORT&#x27;</span>: <span class="hljs-number">3306</span>    &#125;,    <span class="hljs-string">&#x27;db02&#x27;</span>: &#123;        <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;django.db.backends.mysql&#x27;</span>,        <span class="hljs-string">&#x27;NAME&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,        <span class="hljs-string">&#x27;USER&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,        <span class="hljs-string">&#x27;PASSWORD&#x27;</span>: <span class="hljs-string">&#x27;&#x27;</span>,        <span class="hljs-string">&#x27;HOST&#x27;</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,        <span class="hljs-string">&#x27;PORT&#x27;</span>: <span class="hljs-number">3306</span>    &#125;&#125;<span class="hljs-comment"># 数据库路由文件地址</span>DATABASE_ROUTERS = [<span class="hljs-string">&#x27;fresh.database_router.DatabaseAppsRouter&#x27;</span>]<span class="hljs-comment"># 配置app对应的路由表</span>DATABASE_APPS_MAPPING = &#123;    <span class="hljs-string">&#x27;app01&#x27;</span>: <span class="hljs-string">&#x27;default&#x27;</span>,    <span class="hljs-string">&#x27;app02&#x27;</span>: <span class="hljs-string">&#x27;db02&#x27;</span>,    <span class="hljs-string">&#x27;app03&#x27;</span>: <span class="hljs-string">&#x27;db02&#x27;</span>,&#125;</code></pre><p><strong>创建数据库路由规则</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settingsDATABASE_MAPPING = settings.DATABASE_APPS_MAPPING<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseAppsRouter</span>:</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    A router to control all database operations on models for different</span><span class="hljs-string">    databases.</span><span class="hljs-string">    In case an app is not set in settings.DATABASE_APPS_MAPPING, the router</span><span class="hljs-string">    will fallback to the `default` database.</span><span class="hljs-string">    Settings example:</span><span class="hljs-string">    DATABASE_APPS_MAPPING = &#123;&#x27;app1&#x27;: &#x27;db1&#x27;, &#x27;app2&#x27;: &#x27;db2&#x27;&#125;</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">db_for_read</span>(<span class="hljs-params">self, model, **hints</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;&quot;Point all read operations to the specific database.&quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> model._meta.app_label <span class="hljs-keyword">in</span> DATABASE_MAPPING:            <span class="hljs-keyword">return</span> DATABASE_MAPPING[model._meta.app_label]        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">db_for_write</span>(<span class="hljs-params">self, model, **hints</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;Point all write operations to the specific database.&quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> model._meta.app_label <span class="hljs-keyword">in</span> DATABASE_MAPPING:            <span class="hljs-keyword">return</span> DATABASE_MAPPING[model._meta.app_label]        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allow_relation</span>(<span class="hljs-params">self, obj1, obj2, **hints</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;Allow any relation between apps that use the same database.&quot;&quot;&quot;</span>        db_obj1 = DATABASE_MAPPING.get(obj1._meta.app_label)        db_obj2 = DATABASE_MAPPING.get(obj2._meta.app_label)        <span class="hljs-keyword">if</span> db_obj1 <span class="hljs-keyword">and</span> db_obj2:            <span class="hljs-keyword">if</span> db_obj1 == db_obj2:                <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>            <span class="hljs-keyword">else</span>:                <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allow_syncdb</span>(<span class="hljs-params">self, db, model</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;Make sure that apps only appear in the related database.&quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> db <span class="hljs-keyword">in</span> DATABASE_MAPPING.values():            <span class="hljs-keyword">return</span> DATABASE_MAPPING.get(model._meta.app_label) == db        <span class="hljs-keyword">elif</span> model._meta.app_label <span class="hljs-keyword">in</span> DATABASE_MAPPING:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allow_migrate</span>(<span class="hljs-params">self, db, app_label, model=<span class="hljs-literal">None</span>, **hints</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">        Make sure the auth app only appears in the &#x27;auth_db&#x27;</span><span class="hljs-string">        database.</span><span class="hljs-string">        &quot;&quot;&quot;</span>        <span class="hljs-keyword">if</span> db <span class="hljs-keyword">in</span> DATABASE_MAPPING.values():            <span class="hljs-keyword">return</span> DATABASE_MAPPING.get(app_label) == db        <span class="hljs-keyword">elif</span> app_label <span class="hljs-keyword">in</span> DATABASE_MAPPING:            <span class="hljs-keyword">return</span> <span class="hljs-literal">False</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre><p><strong>创建model</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span>(<span class="hljs-params">models.Model</span>):</span>    name = models.CharField(max_length=<span class="hljs-number">20</span>)    created = models.DateTimeField()    updated = models.DateTimeField()    deleted = models.IntegerField()    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        db_table = <span class="hljs-string">&#x27;author&#x27;</span>        app_label = <span class="hljs-string">&#x27;demo&#x27;</span></code></pre><p><strong>生成数据表</strong></p><pre><code class="hljs python">python manage.py makemigrationspython manage.py migrate --database=db02</code></pre><h2 id="跨域解决"><a href="#跨域解决" class="headerlink" title="跨域解决"></a>跨域解决</h2><h4 id="方案一：禁用跨域校验（开发模式可以用）"><a href="#方案一：禁用跨域校验（开发模式可以用）" class="headerlink" title="方案一：禁用跨域校验（开发模式可以用）"></a>方案一：禁用跨域校验（开发模式可以用）</h4><pre><code class="hljs python">MIDDLEWARE = [    <span class="hljs-comment"># &#x27;django.middleware.csrf.CsrfViewMiddleware&#x27;,  # 注释这行，会允许所有跨域请求</span>]</code></pre><h4 id="方案二：cors扩展（推荐）"><a href="#方案二：cors扩展（推荐）" class="headerlink" title="方案二：cors扩展（推荐）"></a>方案二：cors扩展（推荐）</h4><pre><code class="hljs sh">pip install django-cors-headers</code></pre><p><strong>setting.py</strong></p><pre><code class="hljs python"><span class="hljs-comment"># 配置应用</span>INSTALLED_APPS = [    ...    <span class="hljs-string">&#x27;corsheaders&#x27;</span>,    ...]<span class="hljs-comment"># 中间层设置</span>MIDDLEWARE = [    <span class="hljs-string">&#x27;corsheaders.middleware.CorsMiddleware&#x27;</span>,  <span class="hljs-comment"># 注意顺序放首位</span>    ...]CORS_ALLOW_CREDENTIALS = <span class="hljs-literal">True</span> <span class="hljs-comment"># 允许携带cookie</span><span class="hljs-comment"># CORS_ORIGIN_ALLOW_ALL = True # 允许所有主机跨域</span><span class="hljs-comment"># 允许跨域白名单</span>CORS_ORIGIN_WHITELIST = (    <span class="hljs-string">&#x27;127.0.0.1:8080&#x27;</span>,    ...)<span class="hljs-comment"># 允许跨域请求方法</span>CORS_ALLOW_METHODS = (    <span class="hljs-string">&#x27;GET&#x27;</span>,    <span class="hljs-string">&#x27;POST&#x27;</span>,    <span class="hljs-string">&#x27;PUT&#x27;</span>,    <span class="hljs-string">&#x27;PATCH&#x27;</span>,    <span class="hljs-string">&#x27;DELETE&#x27;</span>,    <span class="hljs-string">&#x27;OPTIONS&#x27;</span>,    <span class="hljs-string">&#x27;VIEW&#x27;</span>,)<span class="hljs-comment"># 允许跨域请求头</span>CORS_ALLOW_HEADERS = (    <span class="hljs-string">&#x27;XMLHttpRequest&#x27;</span>,    <span class="hljs-string">&#x27;X_FILENAME&#x27;</span>,    <span class="hljs-string">&#x27;accept-encoding&#x27;</span>,    <span class="hljs-string">&#x27;authorization&#x27;</span>,    <span class="hljs-string">&#x27;content-type&#x27;</span>,    <span class="hljs-string">&#x27;dnt&#x27;</span>,    <span class="hljs-string">&#x27;origin&#x27;</span>,    <span class="hljs-string">&#x27;user-agent&#x27;</span>,    <span class="hljs-string">&#x27;x-csrftoken&#x27;</span>,    <span class="hljs-string">&#x27;x-requested-with&#x27;</span>,    <span class="hljs-string">&#x27;Pragma&#x27;</span>,)</code></pre><h2 id="Session-会话"><a href="#Session-会话" class="headerlink" title="Session 会话"></a>Session 会话</h2><p><strong>全局配置</strong></p><pre><code class="hljs python"><span class="hljs-comment"># setting.py</span><span class="hljs-comment"># 缓存session</span>CACHES = &#123;    ...    <span class="hljs-string">&#x27;session&#x27;</span>: &#123;        <span class="hljs-string">&#x27;BACKEND&#x27;</span>: <span class="hljs-string">&#x27;django_redis.cache.RedisCache&#x27;</span>,        <span class="hljs-string">&#x27;LOCATION&#x27;</span>: <span class="hljs-string">&#x27;redis://127.0.0.1:6379/1&#x27;</span>,        <span class="hljs-string">&#x27;OPTIONS&#x27;</span>: &#123;            <span class="hljs-string">&#x27;CLIENT_CLASS&#x27;</span>: <span class="hljs-string">&#x27;django_redis.client.DefaultClient&#x27;</span>,            <span class="hljs-comment"># &#x27;PASSWORD&#x27;: &#x27;&#x27;</span>        &#125;    &#125;&#125;<span class="hljs-comment"># Session配置</span>SESSION_ENGINE = <span class="hljs-string">&#x27;django.contrib.sessions.backends.cache&#x27;</span>  <span class="hljs-comment"># 指定redis存储</span>SESSION_CACHE_ALIAS = <span class="hljs-string">&#x27;session&#x27;</span>  <span class="hljs-comment"># 使用的缓存别名</span>SESSION_COOKIE_AGE = <span class="hljs-number">30</span>  <span class="hljs-comment"># 过期时间，单位秒。默认2周</span>REST_FRAMEWORK = &#123;    <span class="hljs-comment"># 自定义认证</span>    <span class="hljs-string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: (        <span class="hljs-string">&#x27;utils.custom_authentication.CustomJWTAuth&#x27;</span>,    ),&#125;</code></pre><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><pre><code class="hljs python">request.session.session_key  <span class="hljs-comment"># 获取sessionid</span>request.session.exists(<span class="hljs-string">&#x27;sessionid&#x27;</span>)  <span class="hljs-comment"># 判断获取sessionid是否存在</span>request.session[<span class="hljs-string">&#x27;key&#x27;</span>] = <span class="hljs-string">&#x27;value&#x27;</span>  <span class="hljs-comment"># 设置session</span>request.session.setdefault(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>)  <span class="hljs-comment"># 不存在则设置</span>request.session.get(<span class="hljs-string">&#x27;key&#x27;</span>)  <span class="hljs-comment"># 获取session，默认None</span><span class="hljs-keyword">del</span> request.session[<span class="hljs-string">&#x27;key&#x27;</span>]  <span class="hljs-comment"># 删除session指定键值对</span>request.session.delete()  <span class="hljs-comment"># 删除当前会话数据和数据库数据</span>request.session.clear()  <span class="hljs-comment"># 清除session，删除存储session值</span>request.session.flush()  <span class="hljs-comment"># 清除session，删除当前会话cookie和存储session（常用）</span>request.session.keys()  <span class="hljs-comment"># 获取所有键</span>request.session.values()  <span class="hljs-comment"># 获取所有值</span>request.session.items()  <span class="hljs-comment"># 获取所有键值对</span>request.session.iterkeys()  <span class="hljs-comment"># </span>request.session.itervalues()  <span class="hljs-comment">#</span>request.session.iteritems()  <span class="hljs-comment"># </span>request.session.clear_expired()  <span class="hljs-comment"># 删除所有失效日期小于当前日期的session</span>request.session.set_expiry(value)  <span class="hljs-comment"># 设置session、cookie有效期</span><span class="hljs-comment"># 整数：指定秒后过期；</span>    <span class="hljs-comment"># datatime或timedelta：指定时间过期；</span>        <span class="hljs-comment"># 0：用户关闭浏览器时过期</span></code></pre><h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><pre><code class="hljs python"></code></pre><h2 id="Transaction-事务"><a href="#Transaction-事务" class="headerlink" title="Transaction 事务"></a>Transaction 事务</h2><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> transaction<span class="hljs-comment"># 装饰器用法</span><span class="hljs-meta">@transaction.atomic</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">request</span>):</span>    <span class="hljs-comment"># 函数下所有代码会在一个事务中执行</span>    <span class="hljs-keyword">pass</span><span class="hljs-comment"># with用法，更灵活</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">func</span>(<span class="hljs-params">request</span>):</span>    <span class="hljs-comment"># 这部分代码不在事务中，会被 Django 自动提交</span>    <span class="hljs-keyword">pass</span>    <span class="hljs-keyword">with</span> transaction.atomic():        <span class="hljs-comment"># 这部分代码会在事务中执行</span>        s1 = transaction.savepoint()  <span class="hljs-comment"># 设置保存点，可设置多个</span>        transaction.savepoint_rollback(s1)  <span class="hljs-comment"># 事务回滚至指定保存点</span>        transaction.savepoint_commit(s1)  <span class="hljs-comment"># 提交事务</span>        <span class="hljs-keyword">pass</span></code></pre><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><h3 id="查询条件"><a href="#查询条件" class="headerlink" title="查询条件"></a>查询条件</h3><pre><code class="hljs sh"><span class="hljs-comment"># 使用方式，字段__条件</span>exact  <span class="hljs-comment"># 精准 =</span>iexact  <span class="hljs-comment"># 精准 =，忽略大小写</span>contains  <span class="hljs-comment"># 包含</span>icontains  <span class="hljs-comment"># 包含，忽略大小写</span><span class="hljs-keyword">in</span>  <span class="hljs-comment"># 在容器中</span>gt  <span class="hljs-comment"># 大于 &gt;</span>gte  <span class="hljs-comment"># 大于等于 &gt;=</span>lt  <span class="hljs-comment"># 小于 &lt;</span>lte  <span class="hljs-comment"># 小于等于 &lt;=</span>startswith  <span class="hljs-comment"># 字段以给定值开始</span>istartswith  <span class="hljs-comment"># 字段以给定值开始，忽略大小写</span>endswith  <span class="hljs-comment"># 字段以给定值结束</span>iendswith  <span class="hljs-comment"># 字段以给定值结束，忽略大小写</span>range  <span class="hljs-comment"># 用于指定容器范围，并查询容器范围的数据</span>date  <span class="hljs-comment"># 针对某些date或者datetime类型的字段，根据date部分进行过滤(年月日)</span>time  <span class="hljs-comment"># 根据时间来进行查询：比较日期时间(datetime)字段的时间部分</span>year  <span class="hljs-comment"># 根据年份进行查询</span>isnull  <span class="hljs-comment"># 对应SQL语句中的IS NULL和IS NOT NULL，可接受参数为True和False</span>regex  <span class="hljs-comment"># 根据指定的正则表达式来查询</span>iregex  <span class="hljs-comment"># 根据指定的正则表达式来查询，忽略大小写</span></code></pre><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db.models <span class="hljs-keyword">import</span> F<span class="hljs-comment"># name字段为null的，排最前面</span>.order_by(F(<span class="hljs-string">&#x27;name&#x27;</span>).asc(nulls_first=<span class="hljs-literal">True</span>), <span class="hljs-string">&#x27;create_time&#x27;</span>)<span class="hljs-comment"># name字段为null的，排最后边</span>.order_by(F(<span class="hljs-string">&#x27;name&#x27;</span>).asc(nulls_last=<span class="hljs-literal">True</span>), <span class="hljs-string">&#x27;create_time&#x27;</span>)</code></pre><pre><code class="hljs python"><span class="hljs-comment"># 查不到返回404</span>get_object_or_404()</code></pre><h2 id="DRF-框架"><a href="#DRF-框架" class="headerlink" title="DRF 框架"></a>DRF 框架</h2><h3 id="安装DRF"><a href="#安装DRF" class="headerlink" title="安装DRF"></a>安装DRF</h3><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> djangorestframework  <span class="hljs-comment"># drf框架</span>pip <span class="hljs-keyword">install</span> django-filter <span class="hljs-comment"># 过滤器</span></code></pre><p><strong>setting.py 配置</strong></p><pre><code class="hljs PYTHON">INSTALLED_APPS = [...    <span class="hljs-string">&#x27;rest_framework&#x27;</span>,    <span class="hljs-string">&#x27;django_filters&#x27;</span>,        <span class="hljs-string">&#x27;apps.book&#x27;</span>,    ...]...REST_FRAMEWORK = &#123;    <span class="hljs-comment"># 返回时间格式</span>    <span class="hljs-string">&#x27;DATETIME_FORMAT&#x27;</span>: <span class="hljs-string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>,    <span class="hljs-comment"># 自定义异常响应格式</span>    <span class="hljs-string">&#x27;EXCEPTION_HANDLER&#x27;</span>: <span class="hljs-string">&#x27;utils.custom_exception.custom_exception_handler&#x27;</span>,    <span class="hljs-comment"># # 认证</span>    <span class="hljs-comment"># &#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;: (</span>    <span class="hljs-comment">#     &#x27;rest_framework.authentication.BasicAuthentication&#x27;,</span>    <span class="hljs-comment">#     &#x27;rest_framework.authentication.SessionAuthentication&#x27;,</span>    <span class="hljs-comment"># ),</span>    <span class="hljs-comment"># # 权限</span>    <span class="hljs-comment"># &#x27;DEFAULT_PERMISSION_CLASSES&#x27;: (</span>    <span class="hljs-comment">#     &#x27;rest_framework.permissions.IsAuthenticated&#x27;,</span>    <span class="hljs-comment"># ),</span>    <span class="hljs-comment"># 限流</span>    <span class="hljs-string">&#x27;DEFAULT_THROTTLE_CLASSES&#x27;</span>: (        <span class="hljs-string">&#x27;rest_framework.throttling.AnonRateThrottle&#x27;</span>,  <span class="hljs-comment"># 游客</span>        <span class="hljs-string">&#x27;rest_framework.throttling.UserRateThrottle&#x27;</span>  <span class="hljs-comment"># 用户</span>    ),    <span class="hljs-string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>: &#123;        <span class="hljs-string">&#x27;anon&#x27;</span>: <span class="hljs-string">&#x27;100/day&#x27;</span>,        <span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;10/second&#x27;</span>    &#125;,    <span class="hljs-comment"># 过滤</span>    <span class="hljs-string">&#x27;DEFAULT_FILTER_BACKENDS&#x27;</span>: (<span class="hljs-string">&#x27;django_filters.rest_framework.DjangoFilterBackend&#x27;</span>,)&#125;</code></pre><h3 id="DRF的基本使用"><a href="#DRF的基本使用" class="headerlink" title="DRF的基本使用"></a>DRF的基本使用</h3><p><strong>models.py</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span>(<span class="hljs-params">models.Model</span>):</span>    GENDERS = (        (<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;男&#x27;</span>),        (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;女&#x27;</span>)    )    name = models.CharField(max_length=<span class="hljs-number">20</span>, verbose_name=<span class="hljs-string">&#x27;名字&#x27;</span>)    gender = models.IntegerField(default=<span class="hljs-number">0</span>, choices=GENDERS, verbose_name=<span class="hljs-string">&#x27;性别&#x27;</span>)    created = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;创建时间&#x27;</span>)    updated = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;更新时间&#x27;</span>)    deleted = models.IntegerField(default=<span class="hljs-number">0</span>, verbose_name=<span class="hljs-string">&#x27;逻辑删除&#x27;</span>)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        <span class="hljs-comment"># managed = False</span>        db_table = <span class="hljs-string">&#x27;author&#x27;</span>    <span class="hljs-comment"># 逻辑删除</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">delete</span>(<span class="hljs-params">self, using=<span class="hljs-literal">None</span>, keep_parents=<span class="hljs-literal">False</span></span>):</span>        self.deleted = <span class="hljs-number">1</span>        self.save()<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params">models.Model</span>):</span>    name = models.CharField(max_length=<span class="hljs-number">30</span>, default=<span class="hljs-string">&#x27;&#x27;</span>, verbose_name=<span class="hljs-string">&#x27;书名&#x27;</span>)    author = models.ForeignKey(Author, on_delete=models.CASCADE, db_constraint=<span class="hljs-literal">False</span>,                               related_name=<span class="hljs-string">&#x27;作者&#x27;</span>)  <span class="hljs-comment"># db_constraint=False：数据库不使用外键，仅django内部使用</span>    price = models.IntegerField(default=<span class="hljs-number">0</span>, verbose_name=<span class="hljs-string">&#x27;价格&#x27;</span>)    seq = models.IntegerField(default=<span class="hljs-number">0</span>, verbose_name=<span class="hljs-string">&#x27;顺序&#x27;</span>)    created = models.DateTimeField(auto_now_add=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;创建时间&#x27;</span>)    updated = models.DateTimeField(auto_now=<span class="hljs-literal">True</span>, verbose_name=<span class="hljs-string">&#x27;更新时间&#x27;</span>)    deleted = models.IntegerField(default=<span class="hljs-number">0</span>, verbose_name=<span class="hljs-string">&#x27;逻辑删除&#x27;</span>)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        <span class="hljs-comment"># managed = False</span>        db_table = <span class="hljs-string">&#x27;book&#x27;</span></code></pre><p><strong>urls.py</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.urls <span class="hljs-keyword">import</span> path<span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> routers<span class="hljs-keyword">from</span> apps.book.views <span class="hljs-keyword">import</span> BookViewurlpatterns = [    <span class="hljs-comment"># path(&#x27;books&#x27;, BookView.as_view(&#123;&#x27;get&#x27;: &#x27;list&#x27;&#125;)),</span>]<span class="hljs-comment"># trailing_slash为False，url不自动添加尾斜杠</span>router = routers.SimpleRouter(trailing_slash=<span class="hljs-literal">False</span>)router.register(<span class="hljs-string">r&#x27;author&#x27;</span>, AuthorView, basename=<span class="hljs-string">&#x27;author&#x27;</span>)router.register(<span class="hljs-string">r&#x27;book&#x27;</span>, BookView2, basename=<span class="hljs-string">&#x27;book&#x27;</span>)urlpatterns += router.urls</code></pre><p><strong>serializer.py</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> serializers<span class="hljs-keyword">from</span> apps.demo.models <span class="hljs-keyword">import</span> Book, Author<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorSerializer</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    gender = serializers.CharField(source=<span class="hljs-string">&#x27;get_gender_display&#x27;</span>, read_only=<span class="hljs-literal">True</span>, required=<span class="hljs-literal">False</span>)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Author        fields = <span class="hljs-string">&#x27;__all__&#x27;</span>  <span class="hljs-comment"># 返回字段，__all__ 代表所有</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookSerializer</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    read_only：只在查询时有效</span><span class="hljs-string">    write_only：只在写入时有效</span><span class="hljs-string">    &quot;&quot;&quot;</span>    author = serializers.CharField(label=<span class="hljs-string">&#x27;作者&#x27;</span>, source=<span class="hljs-string">&#x27;author_id.name&#x27;</span>, read_only=<span class="hljs-literal">True</span>)    <span class="hljs-comment"># author_id = serializers.PrimaryKeyRelatedField(label=&#x27;作者&#x27;, read_only=True)</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Book        fields = <span class="hljs-string">&#x27;__all__&#x27;</span>  <span class="hljs-comment"># 返回字段，__all__ 代表所有</span></code></pre><p><strong>views.py</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorView</span>(<span class="hljs-params">ModelViewSet</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    新增：POST /author</span><span class="hljs-string">    删除：DELETE /author/1</span><span class="hljs-string">    修改：PATCH /author/1</span><span class="hljs-string">    作者列表查询：GET /author</span><span class="hljs-string">    作者图书查询：GET /author/&#123;pk&#125;/book</span><span class="hljs-string">    &quot;&quot;&quot;</span>    queryset = Author.objects.<span class="hljs-built_in">filter</span>(deleted=<span class="hljs-number">0</span>)    serializer_class = AuthorSerializer<span class="hljs-meta">    @action(methods=[&#x27;get&#x27;], detail=True, serializer_class=BookSerializer)</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">book</span>(<span class="hljs-params">self, request, pk=<span class="hljs-literal">None</span>, *args, **kwargs</span>):</span>        self.queryset = Book.objects.<span class="hljs-built_in">filter</span>(deleted=<span class="hljs-number">0</span>, author=pk)        <span class="hljs-keyword">return</span> self.<span class="hljs-built_in">list</span>(self, request, *args, **kwargs)<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookView</span>(<span class="hljs-params">APIView</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    新增：POST /book</span><span class="hljs-string">    &quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):</span>        <span class="hljs-comment"># 创建或更新</span>        name = request.data.pop(<span class="hljs-string">&#x27;name&#x27;</span>)        res, created = Book.objects.update_or_create(defaults=request.data, name=name)        ser = BookSerializer(res)        <span class="hljs-keyword">return</span> Response(ser.data)</code></pre><h3 id="Serializer-py-序列化器"><a href="#Serializer-py-序列化器" class="headerlink" title="Serializer.py 序列化器"></a>Serializer.py 序列化器</h3><p><strong>序列化：</strong>对查询结果处理</p><p><strong>反序列化：</strong>对接收参数处理</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> serializers<span class="hljs-keyword">from</span> apps.book.models <span class="hljs-keyword">import</span> Book<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookSerializer</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    read_only：只在查询时有效</span><span class="hljs-string">    write_only：只在写入时有效</span><span class="hljs-string">    &quot;&quot;&quot;</span>    name = serializers.CharField(max_length=<span class="hljs-number">30</span>)    author = serializers.CharField(max_length=<span class="hljs-number">30</span>)    price = serializers.IntegerField(required=<span class="hljs-literal">False</span>)    seq = serializers.IntegerField(required=<span class="hljs-literal">False</span>)    author = serializers.CharField(read_only=<span class="hljs-literal">True</span>, source=<span class="hljs-string">&#x27;author.name&#x27;</span>)  <span class="hljs-comment"># 序列化外键字段</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Book        fields = <span class="hljs-string">&#x27;__all__&#x27;</span>  <span class="hljs-comment"># 返回字段，__all__ 代表所有</span>        exclude = (<span class="hljs-string">&#x27;seq&#x27;</span>,)  <span class="hljs-comment"># 除了seq 字段，其他都序列化</span>        <span class="hljs-comment"># 指定字段说明</span>        extra_kwargs = &#123;            <span class="hljs-string">&#x27;name&#x27;</span>: &#123;<span class="hljs-string">&#x27;write_only&#x27;</span>: <span class="hljs-literal">True</span>&#125;,            <span class="hljs-string">&#x27;author&#x27;</span>: &#123;<span class="hljs-string">&#x27;write_only&#x27;</span>: <span class="hljs-literal">True</span>&#125;,            <span class="hljs-string">&#x27;price&#x27;</span>: &#123;<span class="hljs-string">&#x27;write_only&#x27;</span>: <span class="hljs-literal">True</span>&#125;        &#125;            <span class="hljs-comment"># 改变序列输出行为</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">to_representation</span>(<span class="hljs-params">self, instance</span>):</span>        ret = <span class="hljs-built_in">super</span>().to_representation(instance)        <span class="hljs-comment"># json字符串 =&gt; 字典</span>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;field&#x27;</span> <span class="hljs-keyword">in</span> ret:            <span class="hljs-keyword">try</span>:                ret[<span class="hljs-string">&#x27;field&#x27;</span>] = json.loads(ret[<span class="hljs-string">&#x27;field&#x27;</span>])            <span class="hljs-keyword">except</span> ValueError:                <span class="hljs-keyword">pass</span>        <span class="hljs-keyword">return</span> ret</code></pre><p><strong>view.py</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookView</span>(<span class="hljs-params">APIView</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):</span>        <span class="hljs-comment"># 创建或更新</span>        name = request.data.pop(<span class="hljs-string">&#x27;name&#x27;</span>)        res, created = Book.objects.update_or_create(defaults=request.data, name=name)        ser = BookSerializer(res)        <span class="hljs-keyword">return</span> Response(ser.data)      BookSerializer(res, many)</code></pre><h4 id="嵌套序列化"><a href="#嵌套序列化" class="headerlink" title="嵌套序列化"></a>嵌套序列化</h4><pre><code class="hljs python"><span class="hljs-comment">## models.py</span><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Author</span>(<span class="hljs-params">models.Model</span>):</span>    name = models.CharField(max_length=<span class="hljs-number">20</span>)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        <span class="hljs-comment"># managed = False</span>        db_table = <span class="hljs-string">&#x27;author&#x27;</span>        app_label = <span class="hljs-string">&#x27;demo&#x27;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span>(<span class="hljs-params">models.Model</span>):</span>    name = models.CharField(max_length=<span class="hljs-number">30</span>)    author = models.ForeignKey(Author, on_delete=models.CASCADE, related_name=<span class="hljs-string">&#x27;books&#x27;</span>, db_constraint=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># db_constraint=False：数据库不使用外键，仅django内部使用</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        <span class="hljs-comment"># managed = False</span>        db_table = <span class="hljs-string">&#x27;book&#x27;</span>        app_label = <span class="hljs-string">&#x27;demo&#x27;</span></code></pre><h5 id="常规嵌套"><a href="#常规嵌套" class="headerlink" title="常规嵌套"></a>常规嵌套</h5><pre><code class="hljs python"><span class="hljs-comment"># 书籍嵌套作者</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorSerializer</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Author        fields = <span class="hljs-string">&#x27;__all__&#x27;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookSerializer</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    author = AuthorSerializer(read_only=<span class="hljs-literal">True</span>, source=<span class="hljs-string">&#x27;author&#x27;</span>)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Book        fields = <span class="hljs-string">&#x27;__all__&#x27;</span><span class="hljs-comment"># 作者嵌套书籍</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookSerializer</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Book        fields = <span class="hljs-string">&#x27;__all__&#x27;</span>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AuthorSerializer</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    books = AuthorSerializer(read_only=<span class="hljs-literal">True</span>, source=<span class="hljs-string">&#x27;books&#x27;</span>， many=<span class="hljs-literal">True</span>)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Author        fields = <span class="hljs-string">&#x27;__all__&#x27;</span></code></pre><h5 id="从下往上查"><a href="#从下往上查" class="headerlink" title="从下往上查"></a>从下往上查</h5><pre><code class="hljs python"><span class="hljs-comment">## serializer.py</span><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> serializers<span class="hljs-comment"># 底层往上查</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookSerializer</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Book        fields = <span class="hljs-string">&#x27;__all__&#x27;</span>        depth = <span class="hljs-number">2</span>  <span class="hljs-comment"># 递归深度</span></code></pre><h5 id="从上往下查"><a href="#从上往下查" class="headerlink" title="从上往下查"></a>从上往下查</h5><pre><code class="hljs python"><span class="hljs-comment">## serializer.py</span><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> serializers        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookSerializer</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    <span class="hljs-comment"># 多对一序列化。author_id：外键字段名</span>    author = serializers.CharField(label=<span class="hljs-string">&#x27;作者&#x27;</span>, source=<span class="hljs-string">&#x27;author_id.name&#x27;</span>, read_only=<span class="hljs-literal">True</span>)    <span class="hljs-comment">#image_list = ProductImageSerializer(source=&#x27;product_info&#x27;, read_only=True, many=True)</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Book        fields = <span class="hljs-string">&#x27;__all__&#x27;</span></code></pre><h5 id="多级嵌套"><a href="#多级嵌套" class="headerlink" title="多级嵌套"></a>多级嵌套</h5><pre><code class="hljs python"><span class="hljs-comment">## models.py</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Area</span>(<span class="hljs-params">models.Model</span>):</span>    p_id = models.ForeignKey(<span class="hljs-string">&#x27;self&#x27;</span>, db_column=<span class="hljs-string">&#x27;p_id&#x27;</span>, db_constraint=<span class="hljs-literal">False</span>, on_delete=models.SET_DEFAULT, default=<span class="hljs-number">0</span>, verbose_name=<span class="hljs-string">&#x27;地区&#x27;</span>, related_name=<span class="hljs-string">&#x27;children&#x27;</span>)    name = models.CharField(max_length=<span class="hljs-number">50</span>, verbose_name=<span class="hljs-string">&#x27;地区名&#x27;</span>)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        db_table = <span class="hljs-string">&#x27;area&#x27;</span>        <span class="hljs-comment">## serializer.py</span><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> serializers<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AreaSerializer3</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Area        fields = <span class="hljs-string">&#x27;__all__&#x27;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AreaSerializer2</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    children = AreaSerializer3(many=<span class="hljs-literal">True</span>, read_only=<span class="hljs-literal">True</span>)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Area        fields = <span class="hljs-string">&#x27;__all__&#x27;</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AreaSerializer</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    children = AreaSerializer2(many=<span class="hljs-literal">True</span>, read_only=<span class="hljs-literal">True</span>)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Area        fields = <span class="hljs-string">&#x27;__all__&#x27;</span>        <span class="hljs-comment">## views.py</span><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> mixins<span class="hljs-keyword">from</span> rest_framework.viewsets <span class="hljs-keyword">import</span> GenericViewSet<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AreaView</span>(<span class="hljs-params">GenericViewSet, mixins.ListModelMixin</span>):</span>    queryset = Area.objects.<span class="hljs-built_in">filter</span>(pid=<span class="hljs-number">0</span>)    serializer_class = AreaSerializer</code></pre><h5 id="递归嵌套"><a href="#递归嵌套" class="headerlink" title="递归嵌套"></a>递归嵌套</h5><pre><code class="hljs python"><span class="hljs-comment">## models.py</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Area</span>(<span class="hljs-params">models.Model</span>):</span>    p_id = models.ForeignKey(<span class="hljs-string">&#x27;self&#x27;</span>, null=<span class="hljs-literal">True</span>, db_column=<span class="hljs-string">&#x27;p_id&#x27;</span>, db_constraint=<span class="hljs-literal">False</span>, on_delete=models.CASCADE, verbose_name=<span class="hljs-string">&#x27;地区&#x27;</span>)    name = models.CharField(max_length=<span class="hljs-number">50</span>, verbose_name=<span class="hljs-string">&#x27;地区名&#x27;</span>)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        db_table = <span class="hljs-string">&#x27;area&#x27;</span>        <span class="hljs-comment">## serializer.py</span><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> serializers<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AreaSerializer</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    children = serializers.SerializerMethodField()    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Area        fields = <span class="hljs-string">&#x27;__all__&#x27;</span>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_children</span>(<span class="hljs-params">self, obj</span>)</span>        res = Area.objects.filter(p_id=obj.id)        <span class="hljs-keyword">return</span> AreaSerializer(res, many=<span class="hljs-literal">True</span>).data    <span class="hljs-comment">## views.py</span><span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> mixins<span class="hljs-keyword">from</span> rest_framework.viewsets <span class="hljs-keyword">import</span> GenericViewSet<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AreaView</span>(<span class="hljs-params">GenericViewSet, mixins.ListModelMixin</span>):</span>    queryset = Area.objects.<span class="hljs-built_in">filter</span>(pid=<span class="hljs-literal">None</span>)    serializer_class = AreaSerializer</code></pre><h4 id="ChoiceDield"><a href="#ChoiceDield" class="headerlink" title="ChoiceDield"></a>ChoiceDield</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span>(<span class="hljs-params">models.Model</span>):</span>    GENDERS = (        (<span class="hljs-number">0</span>, <span class="hljs-string">&#x27;男&#x27;</span>),        (<span class="hljs-number">1</span>, <span class="hljs-string">&#x27;女&#x27;</span>),    )    gender = models.IntegerField(default=<span class="hljs-number">0</span>, choices=GENDERS)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserSerializer</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    <span class="hljs-comment"># 使用 get_&lt;字段名&gt;_display的方法</span>    gender = serializers.CharField(source=<span class="hljs-string">&#x27;get_gender_display&#x27;</span>, required=<span class="hljs-literal">False</span>)        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = User        fields = <span class="hljs-string">&#x27;__all__&#x27;</span></code></pre><h4 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h4><pre><code class="hljs python"><span class="hljs-comment">## views.py</span><span class="hljs-comment"># 传参</span>self.kwargs[<span class="hljs-string">&#x27;user_id&#x27;</span>] = <span class="hljs-number">123</span><span class="hljs-comment">## serializer.py</span><span class="hljs-comment"># 取参</span>self.context.get(<span class="hljs-string">&#x27;view&#x27;</span>).kwargs</code></pre><h4 id="序列化器调用"><a href="#序列化器调用" class="headerlink" title="序列化器调用"></a>序列化器调用</h4><pre><code class="hljs python"><span class="hljs-comment"># 创建</span>ser = BookSerializer(data)<span class="hljs-keyword">if</span> ser.is_valid():    ser.save()    <span class="hljs-comment"># 更新</span>instance = Book.objects.<span class="hljs-built_in">filter</span>(<span class="hljs-built_in">id</span>=<span class="hljs-number">1</span>).first()ser = BookSerializer(instance, data)<span class="hljs-comment"># ser = BookSerializer(instance=instance, data=data, partial=True)  # 部分更新</span><span class="hljs-keyword">if</span> ser.is_valid():    ser.save()</code></pre><h4 id="重写方法"><a href="#重写方法" class="headerlink" title="重写方法"></a>重写方法</h4><pre><code class="hljs python"><span class="hljs-comment">##views.py</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderView</span>(<span class="hljs-params">GenericAPIView, mixins.CreateModelMixin</span>):</span>    authentication_classes = [FreshSessionAuth]    queryset = OrderMaster.objects.<span class="hljs-built_in">filter</span>(deleted=<span class="hljs-number">0</span>)    serializer_class = OrderMasterSerializer    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):</span>        self.kwargs[<span class="hljs-string">&#x27;user_id&#x27;</span>] = <span class="hljs-number">123</span>        <span class="hljs-keyword">return</span> self.create(request, *args, **kwargs)<span class="hljs-comment">##serializer.py</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderMasterSerializer</span>(<span class="hljs-params">serializers.ModelSerializer</span>):</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = OrderMaster        fields = <span class="hljs-string">&#x27;__all__&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create</span>(<span class="hljs-params">self, validated_data</span>):</span>        user_id = self.context.get(<span class="hljs-string">&#x27;view&#x27;</span>).kwargs.get(<span class="hljs-string">&#x27;user_id&#x27;</span>)        validated_data[<span class="hljs-string">&#x27;user_id&#x27;</span>] = user_id        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().create(validated_data)        <span class="hljs-comment"># return OrderMaster.objects.create(**validated_data)</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">update</span>(<span class="hljs-params">self, instance, validated_data</span>):</span>        <span class="hljs-keyword">if</span> validated_data.get(<span class="hljs-string">&#x27;pay_state&#x27;</span>) == <span class="hljs-number">1</span>:            validated_data[<span class="hljs-string">&#x27;order_state&#x27;</span>] = <span class="hljs-number">1</span>                    <span class="hljs-built_in">super</span>().update(instance, validated_data)        <span class="hljs-keyword">return</span> instance</code></pre><h3 id="Filters-py-过滤器"><a href="#Filters-py-过滤器" class="headerlink" title="Filters.py 过滤器"></a>Filters.py 过滤器</h3><pre><code class="hljs python"><span class="hljs-comment">## filters.py</span><span class="hljs-keyword">from</span> django_filters <span class="hljs-keyword">import</span> filters<span class="hljs-keyword">from</span> django_filters.rest_framework <span class="hljs-keyword">import</span> FilterSet<span class="hljs-keyword">from</span> apps.book.models <span class="hljs-keyword">import</span> Book<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookFilter</span>(<span class="hljs-params">FilterSet</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">    field_name：指定字段，默认同名</span><span class="hljs-string">    lookup_expr：匹配方式，orm同款</span><span class="hljs-string">    &quot;&quot;&quot;</span>    name = filters.CharFilter(field_name=<span class="hljs-string">&#x27;name&#x27;</span>, lookup_expr=<span class="hljs-string">&#x27;icontains&#x27;</span>)    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Book        fields = [<span class="hljs-string">&#x27;is_delete&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>]  <span class="hljs-comment"># 过滤条件, 精准匹配</span>        <span class="hljs-comment"># or</span>        fields = &#123;            <span class="hljs-string">&#x27;is_delete&#x27;</span>: [<span class="hljs-string">&#x27;exact&#x27;</span>, <span class="hljs-string">&#x27;contains&#x27;</span>],            <span class="hljs-string">&#x27;name&#x27;</span>: [<span class="hljs-string">&#x27;exact&#x27;</span>, <span class="hljs-string">&#x27;contains&#x27;</span>],        &#125;</code></pre><h3 id="Pages-py-分页器"><a href="#Pages-py-分页器" class="headerlink" title="Pages.py 分页器"></a>Pages.py 分页器</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.pagination <span class="hljs-keyword">import</span> PageNumberPagination<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LargePagination</span>(<span class="hljs-params">PageNumberPagination</span>):</span>    page_size = <span class="hljs-number">100</span>  <span class="hljs-comment"># 每页显示数量</span>    page_size_query_param = <span class="hljs-string">&#x27;page_size&#x27;</span>  <span class="hljs-comment"># 分页控件的查询参数的名称</span>    max_page_size = <span class="hljs-number">10000</span>  <span class="hljs-comment"># 允许的最大页面大小。该属性仅在 page_size_query_param 也被设置时有效</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StandardPagination</span>(<span class="hljs-params">PageNumberPagination</span>):</span>    page_size = <span class="hljs-number">10</span>    page_size_query_param = <span class="hljs-string">&#x27;page_size&#x27;</span>    max_page_size = <span class="hljs-number">1000</span></code></pre><h3 id="APIView类视图"><a href="#APIView类视图" class="headerlink" title="APIView类视图"></a>APIView类视图</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.views <span class="hljs-keyword">import</span> APIView<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookView</span>(<span class="hljs-params">APIView</span>):</span>    renderer_classes = []  <span class="hljs-comment"># 自定义过滤器</span>    authentication_classes = []  <span class="hljs-comment"># 自定义认证</span>    throttle_classes = []  <span class="hljs-comment"># 自定义限流</span>    permission_classes = []  <span class="hljs-comment"># 自定义权限</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get</span>(<span class="hljs-params">self, request</span>):</span>        <span class="hljs-keyword">pass</span>            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">self, request</span>):</span>        <span class="hljs-keyword">pass</span></code></pre><h3 id="ModelViewSet-视图集"><a href="#ModelViewSet-视图集" class="headerlink" title="ModelViewSet 视图集"></a>ModelViewSet 视图集</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> django_filters.rest_framework <span class="hljs-keyword">import</span> DjangoFilterBackend<span class="hljs-keyword">from</span> rest_framework.authentication <span class="hljs-keyword">import</span> SessionAuthentication, BasicAuthentication<span class="hljs-keyword">from</span> rest_framework.filters <span class="hljs-keyword">import</span> SearchFilter, OrderingFilter<span class="hljs-keyword">from</span> rest_framework.pagination <span class="hljs-keyword">import</span> PageNumberPagination<span class="hljs-keyword">from</span> rest_framework.permissions <span class="hljs-keyword">import</span> IsAuthenticated<span class="hljs-keyword">from</span> rest_framework.viewsets <span class="hljs-keyword">import</span> ModelViewSet<span class="hljs-keyword">from</span> apps.book.models <span class="hljs-keyword">import</span> Book<span class="hljs-keyword">from</span> apps.book.filters <span class="hljs-keyword">import</span> BookFilter<span class="hljs-keyword">from</span> apps.book.pages <span class="hljs-keyword">import</span> LargeSetPagination<span class="hljs-keyword">from</span> apps.book.serializers <span class="hljs-keyword">import</span> BookSerializer<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookView</span>(<span class="hljs-params">ModelViewSet</span>):</span>    <span class="hljs-comment"># renderer_classes = []  # 自定义过滤器</span>    <span class="hljs-comment"># authentication_classes = []  # 自定义认证</span>    <span class="hljs-comment"># throttle_classes = []  # 自定义限流</span>    <span class="hljs-comment"># permission_classes = []  # 自定义权限</span>    <span class="hljs-comment"># http_method_names = [&#x27;get&#x27;, &#x27;post&#x27;,] # 允许请求方式</span>    queryset = Book.objects.<span class="hljs-built_in">all</span>()    serializer_class = BookSerializer    <span class="hljs-comment"># pagination_class = LargeSetPagination  # 自定义分页器</span>    filter_backends = [DjangoFilterBackend, SearchFilter, OrderingFilter]    <span class="hljs-comment"># 过滤方案一 filter_class 自定义高级过滤规则</span>    <span class="hljs-comment"># filter_class = BookFilter  # 与filter_fields相斥，需配置DjangoFilterBackend</span>    <span class="hljs-comment"># 过滤方案二 filter_fields 精准查询</span>    <span class="hljs-comment"># filter_backends = [DjangoFilterBackend]  # 全局配置过滤器后 无需配置此项</span>    filter_fields = [<span class="hljs-string">&#x27;name&#x27;</span>]  <span class="hljs-comment"># url中关键字结合列表内字段各自精准匹配</span>    <span class="hljs-comment"># 过滤 模糊查询</span>    <span class="hljs-comment"># filter_backends = [SearchFilter]  # 设置过滤后端</span>    search_fields = [<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;Author__name&#x27;</span>]  <span class="hljs-comment"># url中的关键字为search，列表内所有字段内做模糊匹配。匹配外键字段是需写：外键名__外键字段</span>    <span class="hljs-comment"># # 排序</span>    <span class="hljs-comment"># filter_backends = [OrderingFilter]  # 设置排序后端</span>    ordering_fields = [<span class="hljs-string">&#x27;seq&#x27;</span>, <span class="hljs-string">&#x27;id&#x27;</span>]  <span class="hljs-comment"># 可排序字段，倒序需在url参数后字段前面加 -</span>    ordering = [<span class="hljs-string">&#x27;seq&#x27;</span>]  <span class="hljs-comment"># 默认排序</span>    <span class="hljs-comment"># 分页</span>    <span class="hljs-comment"># pagination_class = None  # 关闭分页。全局配置后进行关闭</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">retrieve</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):</span>        print(<span class="hljs-string">&#x27;retrieve&#x27;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().retrieve(request, *args, **kwargs)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">list</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):</span>        print(<span class="hljs-string">&#x27;list&#x27;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().<span class="hljs-built_in">list</span>(request, *args, **kwargs)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().create(request, *args, **kwargs)</code></pre><p>请求示例：</p><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/book?search=王子http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/book?name=小王子&amp;is_delete=<span class="hljs-number">0</span>http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>/book?ordering=seq,-id</code></pre><h3 id="批量创建"><a href="#批量创建" class="headerlink" title="批量创建"></a>批量创建</h3><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookView</span>(<span class="hljs-params">ModelViewSet</span>):</span>    queryset = Book.objects.<span class="hljs-built_in">all</span>()    serializer_class = BookSerializer    http_method_names = [<span class="hljs-string">&#x27;post&#x27;</span>,]        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_serializer</span>(<span class="hljs-params">self, *args, **kwargs</span>):</span>        <span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;data&#x27;</span> <span class="hljs-keyword">in</span> kwargs:            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(kwargs[<span class="hljs-string">&#x27;data&#x27;</span>], <span class="hljs-built_in">list</span>):                kwargs[<span class="hljs-string">&#x27;many&#x27;</span>] = <span class="hljs-literal">True</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().get_serializer(*args, **kwargs)</code></pre><h3 id="自定义路由"><a href="#自定义路由" class="headerlink" title="自定义路由"></a>自定义路由</h3><p><strong>urls.py</strong></p><pre><code class="hljs python">urlpatterns = [    <span class="hljs-comment"># 额外行为，单独定义路由。或使用 @action注册配合路由器自动生成</span>    <span class="hljs-comment"># path(&#x27;books/latest&#x27;, BookView.as_view(&#123;&#x27;get&#x27;: &#x27;latest&#x27;&#125;)),</span>]router = routers.SimpleRouter(trailing_slash=<span class="hljs-literal">False</span>)router.register(<span class="hljs-string">r&#x27;books&#x27;</span>, BookView)urlpatterns += router.urls</code></pre><p><strong>views.py</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.decorators <span class="hljs-keyword">import</span> action<span class="hljs-keyword">from</span> rest_framework.viewsets <span class="hljs-keyword">import</span> ModelViewSet<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookView</span>(<span class="hljs-params">ModelViewSet</span>):</span>    queryset = Book.objects.<span class="hljs-built_in">filter</span>(is_delete=<span class="hljs-number">0</span>)    serializer_class = BookSerializer    <span class="hljs-meta">    @action(methods=[&#x27;get&#x27;], detail=False)  # 使路由器自动生成该路由。detail=False表示不需要pk</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">latest</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):</span>        book = Book.objects.latest(<span class="hljs-string">&#x27;id&#x27;</span>)        ser = self.get_serializer(book)        <span class="hljs-keyword">return</span> Response(ser.data)        <span class="hljs-meta">    @action(methods=[&#x27;get&#x27;], detail=True)  # 使路由器自动生成该路由。detail=True表示需要pk，路由为 books/&#123;pk&#125;/lastst</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">latest</span>(<span class="hljs-params">self, request, *args, **kwargs</span>):</span>        pk = kwargs[<span class="hljs-string">&#x27;pk&#x27;</span>]        book = Book.objects.latest(<span class="hljs-string">&#x27;id&#x27;</span>)        ser = self.get_serializer(book)        <span class="hljs-keyword">return</span> Response(ser.data)</code></pre><h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p><strong>全局配置</strong></p><pre><code class="hljs python"><span class="hljs-comment">## settings.py</span>REST_FRAMEWORK = &#123;    <span class="hljs-string">&#x27;DEFAULT_VERSIONING_CLASS&#x27;</span>: <span class="hljs-string">&#x27;rest_framework.versioning.NamespaceVersioning&#x27;</span>,    <span class="hljs-string">&#x27;DEFAULT_VERSION&#x27;</span>: <span class="hljs-string">&#x27;v1&#x27;</span>,  <span class="hljs-comment"># 默认版本(从request对象里取不到，显示的默认值)</span>    <span class="hljs-string">&#x27;ALLOWED_VERSIONS&#x27;</span>: [<span class="hljs-string">&#x27;v1&#x27;</span>, <span class="hljs-string">&#x27;v2&#x27;</span>],  <span class="hljs-comment"># 允许的版本，与接口文档冲突</span>    <span class="hljs-string">&#x27;VERSION_PARAM&#x27;</span>: <span class="hljs-string">&#x27;version&#x27;</span>  <span class="hljs-comment"># URL中获取值的key</span>&#125;<span class="hljs-comment">## urls.py</span>path(<span class="hljs-string">r&#x27;v1/api/&#x27;</span>, include((<span class="hljs-string">&#x27;apps.urls&#x27;</span>, <span class="hljs-string">&quot;apps&quot;</span>), namespace=<span class="hljs-string">&quot;v1&quot;</span>)),path(<span class="hljs-string">r&#x27;v2/api/&#x27;</span>, include((<span class="hljs-string">&#x27;apps.urls&#x27;</span>, <span class="hljs-string">&quot;apps&quot;</span>), namespace=<span class="hljs-string">&quot;v2&quot;</span>)),</code></pre><h3 id="自定义异常类响应码"><a href="#自定义异常类响应码" class="headerlink" title="自定义异常类响应码"></a>自定义异常类响应码</h3><p><strong>custom_exceptions.py</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.utils.translation <span class="hljs-keyword">import</span> gettext_lazy <span class="hljs-keyword">as</span> _<span class="hljs-keyword">from</span> rest_framework.exceptions <span class="hljs-keyword">import</span> APIException<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HaveExisted</span>(<span class="hljs-params">APIException</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;资源已存在&quot;&quot;&quot;</span>    status_code = <span class="hljs-number">409</span>    default_detail = _(<span class="hljs-string">&#x27;Have Existed.&#x27;</span>)    default_code = <span class="hljs-string">&#x27;have_existed&#x27;</span></code></pre><h3 id="自定义异常格式"><a href="#自定义异常格式" class="headerlink" title="自定义异常格式"></a>自定义异常格式</h3><p><strong>全局配置</strong></p><pre><code class="hljs python"><span class="hljs-comment">## settings.py</span>REST_FRAMEWORK = &#123;    <span class="hljs-comment"># 自定义异常格式</span>    <span class="hljs-string">&#x27;EXCEPTION_HANDLER&#x27;</span>: <span class="hljs-string">&#x27;utils.custom_exception.custom_exception_handler&#x27;</span>,&#125;</code></pre><p><strong>custom_response_exception.py</strong></p><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">自定义异常响应格式：&#123;&#x27;code&#x27;:0,&#x27;message&#x27;:&#x27;成功&#x27;,&#x27;data&#x27;:[]&#125;</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">from</span> rest_framework.response <span class="hljs-keyword">import</span> Response<span class="hljs-keyword">from</span> rest_framework.views <span class="hljs-keyword">import</span> exception_handler<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">custom_exception_handler</span>(<span class="hljs-params">exc, context</span>):</span>    response = exception_handler(exc, context)    res = &#123;&#125;    <span class="hljs-keyword">if</span> response <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:        res = &#123;            <span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">9999</span>,            <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;服务器未知错误&#x27;</span>        &#125;        <span class="hljs-keyword">return</span> response    <span class="hljs-keyword">else</span>:        data = []        <span class="hljs-comment"># print(&#x27;exception&#x27;, response.status_code, response.data)</span>        res[<span class="hljs-string">&#x27;code&#x27;</span>] = response.status_code        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(response.data, <span class="hljs-built_in">dict</span>):            data = <span class="hljs-built_in">dict</span>(response.data)        <span class="hljs-keyword">if</span> response.status_code &gt;= <span class="hljs-number">500</span>:            res[<span class="hljs-string">&#x27;message&#x27;</span>] = <span class="hljs-string">&#x27;服务器错误&#x27;</span>        <span class="hljs-keyword">elif</span> response.status_code == <span class="hljs-number">404</span>:            res[<span class="hljs-string">&#x27;message&#x27;</span>] = <span class="hljs-string">&#x27;未找到&#x27;</span>        <span class="hljs-keyword">elif</span> response.status_code == <span class="hljs-number">400</span>:            res[<span class="hljs-string">&#x27;message&#x27;</span>] = <span class="hljs-string">&#x27;参数错误&#x27;</span>        <span class="hljs-keyword">elif</span> response.status_code == <span class="hljs-number">401</span>:            res[<span class="hljs-string">&#x27;message&#x27;</span>] = <span class="hljs-string">&#x27;未认证&#x27;</span>        <span class="hljs-keyword">elif</span> response.status_code == <span class="hljs-number">403</span>:            res[<span class="hljs-string">&#x27;message&#x27;</span>] = <span class="hljs-string">&#x27;权限不允许&#x27;</span>        <span class="hljs-keyword">elif</span> response.status_code == <span class="hljs-number">405</span>:            res[<span class="hljs-string">&#x27;message&#x27;</span>] = <span class="hljs-string">&#x27;方法不允许&#x27;</span>        <span class="hljs-keyword">elif</span> response.status_code == <span class="hljs-number">409</span>:            res[<span class="hljs-string">&#x27;message&#x27;</span>] = <span class="hljs-string">&#x27;资源已存在&#x27;</span>        <span class="hljs-keyword">else</span>:            res[<span class="hljs-string">&#x27;message&#x27;</span>] = <span class="hljs-string">&#x27;未知错误&#x27;</span>        res[<span class="hljs-string">&#x27;data&#x27;</span>] = data    <span class="hljs-keyword">return</span> Response(res)</code></pre><h3 id="自定义响应格式"><a href="#自定义响应格式" class="headerlink" title="自定义响应格式"></a>自定义响应格式</h3><p><strong>全局配置</strong></p><pre><code class="hljs python"><span class="hljs-comment"># setting.py</span>REST_FRAMEWORK = &#123;    <span class="hljs-comment"># 自定义响应格式</span>    <span class="hljs-string">&#x27;DEFAULT_RENDERER_CLASSES&#x27;</span>: [        <span class="hljs-string">&#x27;utils.custom_response.CustomRenderer&#x27;</span>    ],&#125;</code></pre><p><strong>custom_response.py</strong></p><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">自定义返回处理格式：&#123;&#x27;code&#x27;:0,&#x27;message&#x27;:&#x27;成功&#x27;,&#x27;data&#x27;:[]&#125;</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-keyword">from</span> rest_framework.renderers <span class="hljs-keyword">import</span> JSONRenderer<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomRenderer</span>(<span class="hljs-params">JSONRenderer</span>):</span>    <span class="hljs-comment"># 重构render方法</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">render</span>(<span class="hljs-params">self, data, accepted_media_type=<span class="hljs-literal">None</span>, renderer_context=<span class="hljs-literal">None</span></span>):</span>        print(<span class="hljs-string">&#x27;renderer&#x27;</span>, data)        ret = &#123;&#125;        <span class="hljs-keyword">if</span> renderer_context:            <span class="hljs-comment"># 如果返回的data为字典</span>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">dict</span>) <span class="hljs-keyword">and</span> data.get(<span class="hljs-string">&#x27;code&#x27;</span>) <span class="hljs-keyword">and</span> data.get(<span class="hljs-string">&#x27;message&#x27;</span>):                <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">                若响应信息中已有code、message，则pass返回</span><span class="hljs-string">                &#x27;&#x27;&#x27;</span>                ret = data            <span class="hljs-keyword">elif</span> <span class="hljs-built_in">isinstance</span>(data, <span class="hljs-built_in">dict</span>) <span class="hljs-keyword">and</span> data.get(<span class="hljs-string">&#x27;count&#x27;</span>) <span class="hljs-keyword">and</span> data.get(<span class="hljs-string">&#x27;results&#x27;</span>):                <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">                若响应信息中已有count、results，则为分页列表消息，对其格式化</span><span class="hljs-string">                &#x27;&#x27;&#x27;</span>                <span class="hljs-comment"># ret[&#x27;code&#x27;] = data.pop(&#x27;code&#x27;, renderer_context[&quot;response&quot;].status_code)</span>                ret[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">0</span>                ret[<span class="hljs-string">&#x27;message&#x27;</span>] = data.pop(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-string">&#x27;成功&#x27;</span>)                ret[<span class="hljs-string">&#x27;count&#x27;</span>] = data[<span class="hljs-string">&#x27;count&#x27;</span>]                ret[<span class="hljs-string">&#x27;next&#x27;</span>] = data[<span class="hljs-string">&#x27;next&#x27;</span>]                ret[<span class="hljs-string">&#x27;previous&#x27;</span>] = data[<span class="hljs-string">&#x27;previous&#x27;</span>]                ret[<span class="hljs-string">&#x27;data&#x27;</span>] = data[<span class="hljs-string">&#x27;results&#x27;</span>]            <span class="hljs-keyword">else</span>:                <span class="hljs-string">&#x27;&#x27;&#x27;</span><span class="hljs-string">                若响应信息不是字典，则直接格式化返回</span><span class="hljs-string">                &#x27;&#x27;&#x27;</span>                <span class="hljs-comment"># ret[&#x27;code&#x27;] = renderer_context[&quot;response&quot;].status_code</span>                ret[<span class="hljs-string">&#x27;code&#x27;</span>] = <span class="hljs-number">0</span>                ret[<span class="hljs-string">&#x27;message&#x27;</span>] = <span class="hljs-string">&#x27;成功&#x27;</span>                ret[<span class="hljs-string">&#x27;data&#x27;</span>] = data            renderer_context[<span class="hljs-string">&quot;response&quot;</span>][<span class="hljs-string">&#x27;status_code&#x27;</span>] = <span class="hljs-number">200</span>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().render(ret, accepted_media_type, renderer_context)        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().render(data, accepted_media_type, renderer_context)</code></pre><h3 id="自定义认证"><a href="#自定义认证" class="headerlink" title="自定义认证"></a>自定义认证</h3><h4 id="Session-1"><a href="#Session-1" class="headerlink" title="Session"></a>Session</h4><p><strong>全局配置</strong></p><pre><code class="hljs python"><span class="hljs-comment"># setting.py</span>REST_FRAMEWORK = &#123;    <span class="hljs-comment"># 自定义认证</span>    <span class="hljs-string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: (        <span class="hljs-string">&#x27;utils.custom_authentication.CustomSessionAuth&#x27;</span>,    ),&#125;</code></pre><p><strong>局部使用</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookView</span>(<span class="hljs-params">APIView</span>):</span>    authentication_classes = [CustomSessionAuth]</code></pre><p><strong>保存session</strong></p><pre><code class="hljs python">request.session[<span class="hljs-string">&#x27;id&#x27;</span>] = <span class="hljs-number">123</span>request.session[<span class="hljs-string">&#x27;username&#x27;</span>] = <span class="hljs-string">&#x27;abc&#x27;</span></code></pre><p><strong>验证</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomSessionAuth</span>(<span class="hljs-params">BaseAuthentication</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">authenticate</span>(<span class="hljs-params">self, request</span>):</span>        print(<span class="hljs-string">&#x27;session&#x27;</span>, request.session)        session_key = request.session.session_key        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> session_key:            <span class="hljs-keyword">raise</span> AuthenticationFailed(<span class="hljs-string">&#x27;未认证&#x27;</span>)        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> request.session.get(<span class="hljs-string">&#x27;id&#x27;</span>):            <span class="hljs-keyword">raise</span> AuthenticationFailed(<span class="hljs-string">&#x27;认证失败&#x27;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre><h4 id="JWT-Token"><a href="#JWT-Token" class="headerlink" title="JWT Token"></a>JWT Token</h4><p><strong>全局配置</strong></p><pre><code class="hljs python"><span class="hljs-comment"># setting.py</span>REST_FRAMEWORK = &#123;    <span class="hljs-comment"># 自定义认证</span>    <span class="hljs-string">&#x27;DEFAULT_AUTHENTICATION_CLASSES&#x27;</span>: (        <span class="hljs-string">&#x27;utils.custom_authentication.CustomJWTAuth&#x27;</span>,    ),&#125;</code></pre><p><strong>局部使用</strong></p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookView</span>(<span class="hljs-params">APIView</span>):</span>    authentication_classes = [CustomJWTAuth]</code></pre><p><strong>生成 jwt token</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> datetime<span class="hljs-keyword">import</span> jwt<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_token</span>(<span class="hljs-params">payload</span>):</span>    print(<span class="hljs-built_in">type</span>(payload))    t = datetime.datetime.now()    key = <span class="hljs-string">&#x27;lp&#x27;</span>    payload[<span class="hljs-string">&#x27;exp&#x27;</span>] = datetime.datetime.utcnow() + datetime.timedelta(seconds=<span class="hljs-number">600</span>)    token = jwt.encode(payload=payload,                       key=key,                       algorithm=<span class="hljs-string">&#x27;HS256&#x27;</span>)    <span class="hljs-comment"># print(&#x27;create_token &#x27;, token)</span>    <span class="hljs-keyword">return</span> token</code></pre><p><strong>custom_authentication.py</strong></p><pre><code class="hljs python"><span class="hljs-keyword">import</span> jwt<span class="hljs-keyword">from</span> jwt <span class="hljs-keyword">import</span> exceptions<span class="hljs-keyword">from</span> rest_framework.authentication <span class="hljs-keyword">import</span> BaseAuthentication<span class="hljs-keyword">from</span> rest_framework.exceptions <span class="hljs-keyword">import</span> AuthenticationFailed<span class="hljs-keyword">from</span> apps.user.models <span class="hljs-keyword">import</span> UserWechat<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomJWTAuth</span>(<span class="hljs-params">BaseAuthentication</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">authenticate</span>(<span class="hljs-params">self, request</span>):</span>        token = request.META.get(<span class="hljs-string">&#x27;HTTP_Authorization&#x27;</span>.upper())        key = <span class="hljs-string">&#x27;lp&#x27;</span>        payload = <span class="hljs-literal">None</span>        <span class="hljs-keyword">if</span> token <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:            <span class="hljs-keyword">raise</span> AuthenticationFailed(<span class="hljs-string">&#x27;未认证&#x27;</span>)        <span class="hljs-keyword">try</span>:            payload = jwt.decode(token, key, algorithms=[<span class="hljs-string">&#x27;HS256&#x27;</span>])            <span class="hljs-comment"># print(&#x27;validate_token &#x27;, type(payload), payload)</span>        <span class="hljs-keyword">except</span> exceptions.ExpiredSignatureError:            <span class="hljs-keyword">raise</span> AuthenticationFailed(<span class="hljs-string">&#x27;签名已失效&#x27;</span>)        <span class="hljs-keyword">except</span> jwt.DecodeError:            <span class="hljs-keyword">raise</span> AuthenticationFailed(<span class="hljs-string">&#x27;认证失败&#x27;</span>)        <span class="hljs-keyword">except</span> jwt.InvalidTokenError:            <span class="hljs-keyword">raise</span> AuthenticationFailed(<span class="hljs-string">&#x27;签名非法&#x27;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre><h3 id="自定义权限"><a href="#自定义权限" class="headerlink" title="自定义权限"></a>自定义权限</h3><p><strong>全局配置</strong></p><pre><code class="hljs python"><span class="hljs-string">&#x27;DEFAULT_PERMISSION_CLASSES&#x27;</span>: (<span class="hljs-string">&#x27;utils.custom_permission.CustomPermission&#x27;</span>,),</code></pre><p><strong>custom_permission.py</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.permissions <span class="hljs-keyword">import</span> BasePermission<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomPermission</span>(<span class="hljs-params">BasePermission</span>):</span>    message = <span class="hljs-string">&#x27;没有权限&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">has_permission</span>(<span class="hljs-params">self, request, view</span>):</span>        print(request.user)        print(view)        <span class="hljs-keyword">if</span> <span class="hljs-number">1</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span>        <span class="hljs-keyword">else</span>:            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span></code></pre><h3 id="自定义限流"><a href="#自定义限流" class="headerlink" title="自定义限流"></a>自定义限流</h3><p><strong>全局配置</strong></p><pre><code class="hljs python"><span class="hljs-comment"># 限流</span><span class="hljs-string">&#x27;DEFAULT_THROTTLE_CLASSES&#x27;</span>: (    <span class="hljs-string">&#x27;utils.custom_throttle.CustomAnonRateThrottle&#x27;</span>,  <span class="hljs-comment"># 自定义游客</span>    <span class="hljs-string">&#x27;utils.custom_throttle.CustomUserRateThrottle&#x27;</span>,  <span class="hljs-comment"># 自定义用户</span>),<span class="hljs-string">&#x27;DEFAULT_THROTTLE_RATES&#x27;</span>: &#123;    <span class="hljs-string">&#x27;anon&#x27;</span>: <span class="hljs-string">&#x27;2/day&#x27;</span>,    <span class="hljs-string">&#x27;user&#x27;</span>: <span class="hljs-string">&#x27;4/day&#x27;</span>&#125;,</code></pre><p><strong>custom_throttle.py</strong></p><pre><code class="hljs python"><span class="hljs-keyword">from</span> rest_framework.throttling <span class="hljs-keyword">import</span> SimpleRateThrottle<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomAnonRateThrottle</span>(<span class="hljs-params">SimpleRateThrottle</span>):</span>    scope = <span class="hljs-string">&#x27;anon&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cache_key</span>(<span class="hljs-params">self, request, view</span>):</span>        <span class="hljs-comment"># print(&#x27;限流Anon&#x27;, str(request.user), type(request.user))</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>(request.user) != <span class="hljs-string">&#x27;AnonymousUser&#x27;</span>:  <span class="hljs-comment"># 若不是匿名用户</span>            <span class="hljs-keyword">return</span> <span class="hljs-literal">None</span>  <span class="hljs-comment"># Only throttle unauthenticated requests.</span>        <span class="hljs-keyword">return</span> self.cache_format % &#123;            <span class="hljs-string">&#x27;scope&#x27;</span>: self.scope,            <span class="hljs-string">&#x27;ident&#x27;</span>: self.get_ident(request)        &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomUserRateThrottle</span>(<span class="hljs-params">SimpleRateThrottle</span>):</span>    scope = <span class="hljs-string">&#x27;user&#x27;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_cache_key</span>(<span class="hljs-params">self, request, view</span>):</span>        <span class="hljs-comment"># print(&#x27;限流User&#x27;, request.user)</span>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">str</span>(request.user) != <span class="hljs-string">&#x27;AnonymousUser&#x27;</span>:  <span class="hljs-comment"># 若不是匿名用户</span>            ident = request.user.<span class="hljs-built_in">id</span>        <span class="hljs-keyword">else</span>:            ident = self.get_ident(request)        <span class="hljs-keyword">return</span> self.cache_format % &#123;            <span class="hljs-string">&#x27;scope&#x27;</span>: self.scope,            <span class="hljs-string">&#x27;ident&#x27;</span>: ident        &#125;</code></pre><h2 id="DRF-状态码"><a href="#DRF-状态码" class="headerlink" title="DRF 状态码"></a>DRF 状态码</h2><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-string">Descriptive HTTP status codes, for code readability.</span><span class="hljs-string"></span><span class="hljs-string">See RFC 2616 - https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html</span><span class="hljs-string">And RFC 6585 - https://tools.ietf.org/html/rfc6585</span><span class="hljs-string">And RFC 4918 - https://tools.ietf.org/html/rfc4918</span><span class="hljs-string">&quot;&quot;&quot;</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_informational</span>(<span class="hljs-params">code</span>):</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">100</span> &lt;= code &lt;= <span class="hljs-number">199</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_success</span>(<span class="hljs-params">code</span>):</span>  <span class="hljs-comment"># 成功</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">200</span> &lt;= code &lt;= <span class="hljs-number">299</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_redirect</span>(<span class="hljs-params">code</span>):</span>  <span class="hljs-comment"># 重定向</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">300</span> &lt;= code &lt;= <span class="hljs-number">399</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_client_error</span>(<span class="hljs-params">code</span>):</span>  <span class="hljs-comment"># 请求错误</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">400</span> &lt;= code &lt;= <span class="hljs-number">499</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_server_error</span>(<span class="hljs-params">code</span>):</span>  <span class="hljs-comment"># 服务器错误</span>    <span class="hljs-keyword">return</span> <span class="hljs-number">500</span> &lt;= code &lt;= <span class="hljs-number">599</span>HTTP_100_CONTINUE = <span class="hljs-number">100</span>  <span class="hljs-comment"># 继续</span>HTTP_101_SWITCHING_PROTOCOLS = <span class="hljs-number">101</span>  <span class="hljs-comment"># 切换协议</span>HTTP_200_OK = <span class="hljs-number">200</span>  <span class="hljs-comment"># 正常</span>HTTP_201_CREATED = <span class="hljs-number">201</span>  <span class="hljs-comment"># 已创建</span>HTTP_202_ACCEPTED = <span class="hljs-number">202</span>  <span class="hljs-comment"># 已接受</span>HTTP_203_NON_AUTHORITATIVE_INFORMATION = <span class="hljs-number">203</span>  <span class="hljs-comment"># 非授权信息</span>HTTP_204_NO_CONTENT = <span class="hljs-number">204</span>  <span class="hljs-comment"># 无内容</span>HTTP_205_RESET_CONTENT = <span class="hljs-number">205</span>  <span class="hljs-comment"># 重置内容</span>HTTP_206_PARTIAL_CONTENT = <span class="hljs-number">206</span>  <span class="hljs-comment"># 部分内容</span>HTTP_207_MULTI_STATUS = <span class="hljs-number">207</span>  <span class="hljs-comment"># 多状态</span>HTTP_208_ALREADY_REPORTED = <span class="hljs-number">208</span>  <span class="hljs-comment"># 已报告</span>HTTP_226_IM_USED = <span class="hljs-number">226</span>  <span class="hljs-comment"># 正在使用</span>HTTP_300_MULTIPLE_CHOICES = <span class="hljs-number">300</span>  <span class="hljs-comment"># 多选择</span>HTTP_301_MOVED_PERMANENTLY = <span class="hljs-number">301</span>  <span class="hljs-comment"># 永久重定向</span>HTTP_302_FOUND = <span class="hljs-number">302</span>  <span class="hljs-comment"># 临时重定向</span>HTTP_303_SEE_OTHER = <span class="hljs-number">303</span>  <span class="hljs-comment"># 分配新地址</span>HTTP_304_NOT_MODIFIED = <span class="hljs-number">304</span>  <span class="hljs-comment"># </span>HTTP_305_USE_PROXY = <span class="hljs-number">305</span>  <span class="hljs-comment"># </span>HTTP_306_RESERVED = <span class="hljs-number">306</span>  <span class="hljs-comment"># </span>HTTP_307_TEMPORARY_REDIRECT = <span class="hljs-number">307</span>  <span class="hljs-comment"># 临时重定向2</span>HTTP_308_PERMANENT_REDIRECT = <span class="hljs-number">308</span>  <span class="hljs-comment"># </span>HTTP_400_BAD_REQUEST = <span class="hljs-number">400</span>  <span class="hljs-comment"># 语法错误</span>HTTP_401_UNAUTHORIZED = <span class="hljs-number">401</span>  <span class="hljs-comment"># 未认证</span>HTTP_402_PAYMENT_REQUIRED = <span class="hljs-number">402</span>  <span class="hljs-comment"># </span>HTTP_403_FORBIDDEN = <span class="hljs-number">403</span>  <span class="hljs-comment"># 无权限</span>HTTP_404_NOT_FOUND = <span class="hljs-number">404</span>  <span class="hljs-comment"># 未找到</span>HTTP_405_METHOD_NOT_ALLOWED = <span class="hljs-number">405</span>  <span class="hljs-comment"># 方法不允许</span>HTTP_406_NOT_ACCEPTABLE = <span class="hljs-number">406</span>  <span class="hljs-comment"># </span>HTTP_407_PROXY_AUTHENTICATION_REQUIRED = <span class="hljs-number">407</span>  <span class="hljs-comment"># </span>HTTP_408_REQUEST_TIMEOUT = <span class="hljs-number">408</span>  <span class="hljs-comment"># </span>HTTP_409_CONFLICT = <span class="hljs-number">409</span>  <span class="hljs-comment"># </span>HTTP_410_GONE = <span class="hljs-number">410</span>  <span class="hljs-comment"># </span>HTTP_411_LENGTH_REQUIRED = <span class="hljs-number">411</span>  <span class="hljs-comment"># </span>HTTP_412_PRECONDITION_FAILED = <span class="hljs-number">412</span>  <span class="hljs-comment"># </span>HTTP_413_REQUEST_ENTITY_TOO_LARGE = <span class="hljs-number">413</span>  <span class="hljs-comment"># </span>HTTP_414_REQUEST_URI_TOO_LONG = <span class="hljs-number">414</span>  <span class="hljs-comment"># </span>HTTP_415_UNSUPPORTED_MEDIA_TYPE = <span class="hljs-number">415</span>  <span class="hljs-comment"># </span>HTTP_416_REQUESTED_RANGE_NOT_SATISFIABLE = <span class="hljs-number">416</span>  <span class="hljs-comment"># </span>HTTP_417_EXPECTATION_FAILED = <span class="hljs-number">417</span>  <span class="hljs-comment"># </span>HTTP_418_IM_A_TEAPOT = <span class="hljs-number">418</span>  <span class="hljs-comment"># </span>HTTP_422_UNPROCESSABLE_ENTITY = <span class="hljs-number">422</span>  <span class="hljs-comment"># </span>HTTP_423_LOCKED = <span class="hljs-number">423</span>  <span class="hljs-comment"># </span>HTTP_424_FAILED_DEPENDENCY = <span class="hljs-number">424</span>  <span class="hljs-comment"># </span>HTTP_426_UPGRADE_REQUIRED = <span class="hljs-number">426</span>  <span class="hljs-comment"># </span>HTTP_428_PRECONDITION_REQUIRED = <span class="hljs-number">428</span>  <span class="hljs-comment"># </span>HTTP_429_TOO_MANY_REQUESTS = <span class="hljs-number">429</span>  <span class="hljs-comment">#   # </span>HTTP_431_REQUEST_HEADER_FIELDS_TOO_LARGE = <span class="hljs-number">431</span>  <span class="hljs-comment"># </span>HTTP_451_UNAVAILABLE_FOR_LEGAL_REASONS = <span class="hljs-number">451</span>  <span class="hljs-comment"># </span>HTTP_500_INTERNAL_SERVER_ERROR = <span class="hljs-number">500</span>  <span class="hljs-comment"># 服务器错误</span>HTTP_501_NOT_IMPLEMENTED = <span class="hljs-number">501</span>  <span class="hljs-comment"># </span>HTTP_502_BAD_GATEWAY = <span class="hljs-number">502</span>  <span class="hljs-comment"># </span>HTTP_503_SERVICE_UNAVAILABLE = <span class="hljs-number">503</span>  <span class="hljs-comment"># </span>HTTP_504_GATEWAY_TIMEOUT = <span class="hljs-number">504</span>  <span class="hljs-comment"># </span>HTTP_505_HTTP_VERSION_NOT_SUPPORTED = <span class="hljs-number">505</span>  <span class="hljs-comment"># </span>HTTP_506_VARIANT_ALSO_NEGOTIATES = <span class="hljs-number">506</span>  <span class="hljs-comment"># </span>HTTP_507_INSUFFICIENT_STORAGE = <span class="hljs-number">507</span>  <span class="hljs-comment"># </span>HTTP_508_LOOP_DETECTED = <span class="hljs-number">508</span>  <span class="hljs-comment"># </span>HTTP_509_BANDWIDTH_LIMIT_EXCEEDED = <span class="hljs-number">509</span>  <span class="hljs-comment"># </span>HTTP_510_NOT_EXTENDED = <span class="hljs-number">510</span>  <span class="hljs-comment"># </span>HTTP_511_NETWORK_AUTHENTICATION_REQUIRED = <span class="hljs-number">511</span>  <span class="hljs-comment"># </span></code></pre><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><ul><li>需要安装 elasticsearch2.4.1并启动</li><li>windows：<a href="https://www.cnblogs.com/hualess/p/11540477.html">https://www.cnblogs.com/hualess/p/11540477.html</a></li><li>中文分词：elasticsearch-ik</li></ul><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre><code class="hljs sh"><span class="hljs-comment"># 注意版本需相对应</span>pip install drf-haystack==1.8.10pip install elasticsearch==2.4.1</code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre><code class="hljs python"><span class="hljs-comment">## settings.py</span>INSTALLED_APPS = [...<span class="hljs-string">&#x27;rest_framework&#x27;</span><span class="hljs-string">&#x27;haystack&#x27;</span>, ]<span class="hljs-comment"># Haystack</span>HAYSTACK_CONNECTIONS = &#123;    <span class="hljs-string">&#x27;default&#x27;</span>: &#123;        <span class="hljs-string">&#x27;ENGINE&#x27;</span>: <span class="hljs-string">&#x27;haystack.backends.elasticsearch_backend.ElasticsearchSearchEngine&#x27;</span>,        <span class="hljs-string">&#x27;URL&#x27;</span>: <span class="hljs-string">&#x27;http://127.0.0.1:9200/&#x27;</span>,  <span class="hljs-comment"># 此处为elasticsearch运行的服务器ip地址，端口号固定为9200</span>        <span class="hljs-string">&#x27;INDEX_NAME&#x27;</span>: <span class="hljs-string">&#x27;fresh&#x27;</span>,  <span class="hljs-comment"># 指定elasticsearch建立的索引库的名称</span>    &#125;,&#125;<span class="hljs-comment"># 当添加、修改、删除数据时，自动生成索引</span>HAYSTACK_SIGNAL_PROCESSOR = <span class="hljs-string">&#x27;haystack.signals.RealtimeSignalProcessor&#x27;</span><span class="hljs-comment"># 指定搜索结果每页的条数</span><span class="hljs-comment"># HAYSTACK_SEARCH_RESULTS_PER_PAGE = 1</span></code></pre><h4 id="创建索引类"><a href="#创建索引类" class="headerlink" title="创建索引类"></a>创建索引类</h4><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.db <span class="hljs-keyword">import</span> models <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Es</span>(<span class="hljs-params">models.Model</span>):</span>     name=models.CharField(max_length=<span class="hljs-number">32</span>)    desc=models.CharField(max_length=<span class="hljs-number">32</span>)</code></pre><h4 id="同目录app下创建search-indexes-py"><a href="#同目录app下创建search-indexes-py" class="headerlink" title="同目录app下创建search_indexes.py"></a>同目录app下创建search_indexes.py</h4><pre><code class="hljs python"><span class="hljs-keyword">from</span> haystack <span class="hljs-keyword">import</span> indexes<span class="hljs-keyword">from</span> apps.product.models <span class="hljs-keyword">import</span> ProductInfo<span class="hljs-comment"># 索引模型类的名称必须是 模型类名称 + Index</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductInfoIndex</span>(<span class="hljs-params">indexes.SearchIndex, indexes.Indexable</span>):</span>    <span class="hljs-comment"># text表示被查询的字段，用户搜索的是这些字段的值，具体被索引的字段写在另一个文件里</span>    text = indexes.CharField(document=<span class="hljs-literal">True</span>, use_template=<span class="hljs-literal">True</span>)        <span class="hljs-comment"># 保存在索引库中的字段</span>    <span class="hljs-built_in">id</span> = indexes.IntegerField(model_attr=<span class="hljs-string">&#x27;id&#x27;</span>)    name = indexes.CharField(model_attr=<span class="hljs-string">&#x27;name&#x27;</span>)        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_model</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-keyword">return</span> ProductInfo    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">index_queryset</span>(<span class="hljs-params">self, using=<span class="hljs-literal">None</span></span>):</span>        <span class="hljs-keyword">return</span> self.get_model().objects.<span class="hljs-built_in">all</span>()</code></pre><h4 id="创建模板文件"><a href="#创建模板文件" class="headerlink" title="创建模板文件"></a>创建模板文件</h4><ul><li>创建 templates/search/indexes/app/es_text.txt</li><li>名字要对应</li></ul><pre><code class="hljs handlebars"><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">object.name</span> &#125;&#125;</span><span class="xml"> </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">object.desc</span> &#125;&#125;</span></code></pre><h4 id="手动更新索引"><a href="#手动更新索引" class="headerlink" title="手动更新索引"></a>手动更新索引</h4><ul><li>数据库有多少条数据，全部会被同步到es中</li></ul><pre><code class="hljs sh"><span class="hljs-comment"># 首次重建</span>python manage.py rebuild_index<span class="hljs-comment"># 更新</span>python manage.py update_index</code></pre><h4 id="创建haystack序列化器"><a href="#创建haystack序列化器" class="headerlink" title="创建haystack序列化器"></a>创建haystack序列化器</h4><pre><code class="hljs python"><span class="hljs-keyword">from</span> drf_haystack.serializers <span class="hljs-keyword">import</span> HaystackSerializer <span class="hljs-keyword">from</span> rest_framework.serializers <span class="hljs-keyword">import</span> ModelSerializer <span class="hljs-keyword">from</span> app <span class="hljs-keyword">import</span> models <span class="hljs-keyword">from</span> app.search_indexes <span class="hljs-keyword">import</span> EsIndex <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsSerializer</span>(<span class="hljs-params">ModelSerializer</span>):</span>     <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>         model=models.Es         fields=<span class="hljs-string">&#x27;__all__&#x27;</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsIndexSerializer</span>(<span class="hljs-params">HaystackSerializer</span>):</span>      <span class="hljs-built_in">object</span> = EsSerializer(read_only=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 只读,不可以进行反序列化</span>     <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>         index_classes = [EsIndex]  <span class="hljs-comment"># 索引类的名称</span>        fields = (<span class="hljs-string">&#x27;text&#x27;</span>, <span class="hljs-string">&#x27;object&#x27;</span>)  <span class="hljs-comment"># text：由索引类返回，固定名称；object：由序列化类返回</span></code></pre><h4 id="类试图调用"><a href="#类试图调用" class="headerlink" title="类试图调用"></a>类试图调用</h4><pre><code class="hljs angelscript"><span class="hljs-keyword">from</span> drf_haystack.viewsets <span class="hljs-keyword">import</span> HaystackViewSet <span class="hljs-keyword">from</span> app.models <span class="hljs-keyword">import</span> Book <span class="hljs-keyword">from</span> app.serializers <span class="hljs-keyword">import</span> EsIndexSerializer <span class="hljs-keyword">class</span> <span class="hljs-symbol">EsSearchView</span>(<span class="hljs-symbol">HaystackViewSet</span>):     <span class="hljs-symbol">index_models</span> = [<span class="hljs-symbol">Es</span>]     <span class="hljs-symbol">serializer_class</span> = <span class="hljs-symbol">EsIndexSerializer</span></code></pre><h4 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h4><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.conf.urls <span class="hljs-keyword">import</span> url <span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin <span class="hljs-keyword">from</span> rest_framework <span class="hljs-keyword">import</span> routers <span class="hljs-keyword">from</span> app.views <span class="hljs-keyword">import</span> EsSearchView     router = routers.DefaultRouter()     router.register(<span class="hljs-string">&quot;book/search&quot;</span>, EsSearchView, base_name=<span class="hljs-string">&quot;book-search&quot;</span>)     urlpatterns = [ url(<span class="hljs-string">r&#x27;^admin/&#x27;</span>, admin.site.urls), ]     urlpatterns += router.urls</code></pre><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8000</span>/?text=测试</code></pre><h2 id="Celery"><a href="#Celery" class="headerlink" title="Celery"></a>Celery</h2><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> django-celery</code></pre><ul><li>proj/celery.py</li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-keyword">from</span> celery <span class="hljs-keyword">import</span> Celery<span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> datetime, timedelta<span class="hljs-comment"># 设置默认的Django设置模块</span>os.environ.setdefault(<span class="hljs-string">&#x27;DJANGO_SETTINGS_MODULE&#x27;</span>, <span class="hljs-string">&#x27;alarmManagerBackend.settings&#x27;</span>)app = Celery(<span class="hljs-string">&#x27;alarmManagerBackend&#x27;</span>)<span class="hljs-comment"># 在这里使用字符串意味着worker不需要序列化</span><span class="hljs-comment"># 子进程的配置对象</span><span class="hljs-comment"># - namespace表示所有芹菜相关的配置键，应该有一个“CELERY_”前缀。</span>app.config_from_object(<span class="hljs-string">&#x27;django.conf:settings&#x27;</span>, namespace=<span class="hljs-string">&#x27;CELERY&#x27;</span>)<span class="hljs-comment"># 从所有注册的Django应用中加载任务模块。</span>app.autodiscover_tasks()<span class="hljs-comment"># 定时任务</span>app.conf.beat_schedule = &#123;    <span class="hljs-string">&#x27;skywalking_self_recover&#x27;</span>: &#123;        <span class="hljs-string">&#x27;task&#x27;</span>: <span class="hljs-string">&#x27;skywalking.tasks.skywalking_self_recover&#x27;</span>,        <span class="hljs-comment"># &#x27;schedule&#x27;: timedelta(minutes=2)</span>        <span class="hljs-string">&#x27;schedule&#x27;</span>: <span class="hljs-number">3</span>    &#125;,&#125;</code></pre><p>apps/xxx/tasks.py</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> celery <span class="hljs-keyword">import</span> shared_task<span class="hljs-meta">@shared_task</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">task_demo</span>():</span>    print(<span class="hljs-number">2</span>)    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span></code></pre><h4 id="启动命令"><a href="#启动命令" class="headerlink" title="启动命令"></a>启动命令</h4><pre><code class="hljs sh"><span class="hljs-comment">## windows</span>celery -A proj worker -l INFO --pool=solo -P eventletcelery -A proj beat -l info--logfile=E:\GCloud\alarmmanagerbackend\logs\celery.logcelery -A alarmManagerBackend beat -l info --<span class="hljs-comment"># linux启动，不要用root用户</span>celery multi start -A proj worker -l info --logfile=celery.log --pidfile=celery.pidcelery multi restart -A proj worker -l info --logfile=celery.log --pidfile=celery.pidcelery multi stop -A proj worker -l info --logfile=celery.log --pidfile=celery.pid<span class="hljs-comment"># celery进程全杀</span>ps auxww | grep <span class="hljs-string">&#x27;celery&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="hljs-built_in">kill</span> -9</code></pre><h3 id="发邮件"><a href="#发邮件" class="headerlink" title="发邮件"></a>发邮件</h3><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><pre><code class="hljs python"><span class="hljs-comment">## settings.py</span><span class="hljs-comment"># 配置邮件服务器</span><span class="hljs-comment"># EMAIL_BACKEND = &#x27;django.core.mail.backends.smtp.EmailBackend&#x27;</span>EMAIL_HOST = <span class="hljs-string">&#x27;smtp.163.com&#x27;</span>  <span class="hljs-comment"># 如果是 qq 改成 smtp.qq.com</span>EMAIL_PORT = <span class="hljs-number">465</span>  <span class="hljs-comment"># 发邮件端口</span>EMAIL_HOST_USER = <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-comment"># 邮箱</span>EMAIL_HOST_PASSWORD = <span class="hljs-string">&#x27;&#x27;</span>  <span class="hljs-comment"># 密码授权码</span>EMAIL_FROM = EMAIL_HOST_USER  <span class="hljs-comment"># 发件人抬头</span><span class="hljs-comment"># EMAIL_USE_TLS = False  # 是否使用安全协议传输</span>EMAIL_USE_SSL = <span class="hljs-literal">True</span></code></pre><p><strong>安装celery</strong></p><pre><code class="hljs cmake">pip <span class="hljs-keyword">install</span> celery</code></pre><p>项目下创建目录 celert_tasks</p><h4 id="创建celery异步任务"><a href="#创建celery异步任务" class="headerlink" title="创建celery异步任务"></a>创建celery异步任务</h4><ul><li>celery_tasks/main.py</li></ul><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<span class="hljs-keyword">from</span> celery <span class="hljs-keyword">import</span> Celery<span class="hljs-comment"># 把celery和django进行组合，必须让celery能识别和加载django的配置文件以及django的类库</span>os.environ.setdefault(<span class="hljs-string">&quot;DJANGO_SETTINGS_MODULE&quot;</span>, <span class="hljs-string">&quot;fresh.settings&quot;</span>)<span class="hljs-comment"># 对django框架初始化</span><span class="hljs-keyword">import</span> djangodjango.setup()<span class="hljs-comment"># 创建Celery实例 生产者</span>app = Celery(<span class="hljs-string">&#x27;fresh&#x27;</span>)<span class="hljs-comment"># 加载配置</span>app.config_from_object(<span class="hljs-string">&#x27;celery_tasks.config&#x27;</span>)<span class="hljs-comment"># 注册任务，多任务写多个</span>app.autodiscover_tasks([<span class="hljs-string">&#x27;celery_tasks.email&#x27;</span>])</code></pre><p>celery_tasks/config.py</p><pre><code class="hljs python"><span class="hljs-comment"># Celery配置文件</span><span class="hljs-comment"># 指定中间人、消息队列、任务队列、容器，使用redis</span>broker_url = <span class="hljs-string">&#x27;redis://127.0.0.1/3&#x27;</span><span class="hljs-comment"># 结果队列的链接地址</span>celery_result_backend = <span class="hljs-string">&#x27;redis://127.0.0.1:6379/14&#x27;</span></code></pre><p>celery_tasks/email/tasks.py</p><pre><code class="hljs python"><span class="hljs-keyword">from</span> celery <span class="hljs-keyword">import</span> Task<span class="hljs-keyword">from</span> django.core.mail <span class="hljs-keyword">import</span> send_mail<span class="hljs-keyword">from</span> django.conf <span class="hljs-keyword">import</span> settings<span class="hljs-keyword">from</span> celery_tasks.main <span class="hljs-keyword">import</span> celery_app<span class="hljs-comment"># 监听整个任务的钩子，有时任务会失败</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mytask</span>(<span class="hljs-params">Task</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_success</span>(<span class="hljs-params">self, retval, task_id, args, kwargs</span>):</span>        print(<span class="hljs-string">&#x27;task success！&#x27;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(Mytask, self).on_success(retval, task_id, args, kwargs)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_failure</span>(<span class="hljs-params">self, exc, task_id, args, kwargs, einfo</span>):</span>        print(<span class="hljs-string">&#x27;task failed&#x27;</span>)        <span class="hljs-comment"># 可以记录到程序中或者任务队列中,让celery尝试重新执行</span>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(Mytask, self).on_failure(exc, task_id, args, kwargs, einfo)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">after_return</span>(<span class="hljs-params">self, status, retval, task_id, args, kwargs, einfo</span>):</span>        print(<span class="hljs-string">&#x27;this is after return&#x27;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(Mytask, self).after_return(status, retval, task_id, args, kwargs, einfo)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">on_retry</span>(<span class="hljs-params">self, exc, task_id, args, kwargs, einfo</span>):</span>        print(<span class="hljs-string">&#x27;this is retry&#x27;</span>)        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>(Mytask, self).on_retry(exc, task_id, args, kwargs, einfo)<span class="hljs-meta">@celery_app.task(name=&#x27;send_verify_email&#x27;, base=Mytask)  # name：起别名；base：为监听类</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">send_verify_email</span>(<span class="hljs-params">to_email, verify_url</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;定义发送邮件的任务&quot;&quot;&quot;</span>    <span class="hljs-comment"># send_mail(&#x27;标题&#x27;,&#x27;普通邮件的正文&#x27;,&#x27;发件人&#x27;,&#x27;收件人列表&#x27;,&#x27;富文本邮件正文&#x27;)</span>    project_name = <span class="hljs-string">&#x27;test&#x27;</span>    subject = project_name + <span class="hljs-string">&#x27;邮箱验证&#x27;</span>    <span class="hljs-comment"># message = &#x27;普通文本&#x27;</span>    <span class="hljs-comment"># html_message是发送带html样式信息</span>    html_message = <span class="hljs-string">&#x27;&lt;p&gt;尊敬的用户您好！&lt;/p&gt;&#x27;</span> \                   <span class="hljs-string">&#x27;&lt;p&gt;感谢您使用%s。&lt;/p&gt;&#x27;</span> \                   <span class="hljs-string">&#x27;&lt;p&gt;您的邮箱为：%s 。请点击此链接激活您的邮箱：&lt;/p&gt;&#x27;</span> \                   <span class="hljs-string">&#x27;&lt;p&gt;&lt;a href=&quot;%s&quot;&gt;%s&lt;a&gt;&lt;/p&gt;&#x27;</span> % (project_name, to_email, verify_url, verify_url)    send_mail(subject, <span class="hljs-string">&#x27;&#x27;</span>, settings.EMAIL_FROM, [to_email], html_message=html_message)</code></pre><h4 id="视图调用"><a href="#视图调用" class="headerlink" title="视图调用"></a>视图调用</h4><pre><code class="hljs python"><span class="hljs-keyword">from</span> celery_tasks.email.tasks <span class="hljs-keyword">import</span> send_verify_email<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmailView</span>(<span class="hljs-params">APIView</span>):</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">post</span>(<span class="hljs-params">self, request</span>):</span>        logger = logging.getLogger(<span class="hljs-string">&#x27;django&#x27;</span>)        send_verify_email.delay(email, verify_url)        <span class="hljs-keyword">return</span> JsonResponse(&#123;<span class="hljs-string">&#x27;code&#x27;</span>: <span class="hljs-number">0</span>, <span class="hljs-string">&#x27;message&#x27;</span>: <span class="hljs-string">&#x27;成功&#x27;</span>&#125;)</code></pre><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><pre><code class="hljs sh"><span class="hljs-comment"># windows测试启动</span>celery -A alarmManagerBackend worker -l INFO --pool=solocelery -A alarmManagerBackend beat -l infocelery -A alarmManagerBackend worker -l INFO --pool=solo --logfile=E:\GCloud\API\alarmmanagerbackend\logs\celery.logcelery -A alarmManagerBackend beat -l info --logfile=E:\GCloud\API\alarmmanagerbackend\logs\celery.logcelery -A alarmManagerBackend worker --pool=solo -l info -P eventletcelery -A alarmManagerBackend beat -l info -P eventlet<span class="hljs-comment"># linux启动，不要用root用户</span>celery multi start -A celery_tasks.main worker -l info --logfile=celery.log --pidfile=celery.pidcelery multi restart -A celery_tasks.main worker -l info --logfile=celery.log --pidfile=celery.pidcelery multi stop -A celery_tasks.main worker -l info --logfile=celery.log --pidfile=celery.pid<span class="hljs-comment"># celery进程全杀</span>ps auxww | grep <span class="hljs-string">&#x27;celery&#x27;</span> | awk <span class="hljs-string">&#x27;&#123;print $2&#125;&#x27;</span> | xargs <span class="hljs-built_in">kill</span> -9</code></pre><h2 id="数据库读写分离"><a href="#数据库读写分离" class="headerlink" title="数据库读写分离"></a>数据库读写分离</h2><p>新建 db_router.py</p><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MasterSlaveDBRouter</span>(<span class="hljs-params"><span class="hljs-built_in">object</span></span>):</span>    <span class="hljs-string">&quot;&quot;&quot;数据库主从读写分离路由&quot;&quot;&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">db_for_read</span>(<span class="hljs-params">self, model, **hints</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;读数据库&quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;slave&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">db_for_write</span>(<span class="hljs-params">self, model, **hints</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;写数据库&quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;default&quot;</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">allow_relation</span>(<span class="hljs-params">self, obj1, obj2, **hints</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;是否运行关联操作&quot;&quot;&quot;</span>        <span class="hljs-keyword">return</span> <span class="hljs-literal">True</span></code></pre><p>配置 setting.py</p><pre><code class="hljs python">DATABASE_ROUTERS = [<span class="hljs-string">&quot;app.db_router.MasterSlaveDBRouter&quot;</span>]</code></pre><h2 id="生成接口文档"><a href="#生成接口文档" class="headerlink" title="生成接口文档"></a>生成接口文档</h2><ul><li>环境说明<ul><li>python &gt;= 3.6.2</li><li>Jinja2 &lt;= 3.0.0</li></ul></li></ul><pre><code class="hljs sh">pip install coreapipip install djangorestframework</code></pre><p><strong>配置</strong></p><pre><code class="hljs python"><span class="hljs-comment">## setting.py</span>INSTALLED_APPS = [    ...    <span class="hljs-string">&#x27;rest_framework&#x27;</span>]REST_FRAMEWORK = &#123;    ...<span class="hljs-string">&#x27;DEFAULT_SCHEMA_CLASS&#x27;</span>: <span class="hljs-string">&#x27;rest_framework.schemas.AutoSchema&#x27;</span>,&#125;</code></pre><h5 id="路由-1"><a href="#路由-1" class="headerlink" title="路由"></a>路由</h5><pre><code class="hljs python">urlpatterns = [    path(<span class="hljs-string">&#x27;docs/&#x27;</span>, include_docs_urls(title=<span class="hljs-string">&#x27;接口文档&#x27;</span>)),]</code></pre><h5 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h5><pre><code class="hljs awk">http:<span class="hljs-regexp">//</span><span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8000</span>/docs</code></pre><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.test <span class="hljs-keyword">import</span> TestCase<span class="hljs-comment"># 需要测试的函数</span><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span>(<span class="hljs-params">a, b</span>):</span>    <span class="hljs-keyword">return</span> a + b<span class="hljs-comment"># 普通测试</span>d = add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)<span class="hljs-keyword">assert</span> d == <span class="hljs-number">4</span>  <span class="hljs-comment"># 验证结果是否相等</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookTestCase</span>(<span class="hljs-params">TestCase</span>):</span>    <span class="hljs-string">&quot;&quot;&quot;框架测试&quot;&quot;&quot;</span>    <span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setUpClass</span>(<span class="hljs-params">cls</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;所有测试用例之前调用&quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tearDownClass</span>(<span class="hljs-params">cls</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;所有测试用例之后调用&quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setUp</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span>        <span class="hljs-string">&quot;&quot;&quot;前置准备，每个测试方法之前调用&quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tearDown</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span>        <span class="hljs-string">&quot;&quot;&quot;后置处理，每个测试方法之后调用&quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_1</span>(<span class="hljs-params">self</span>):</span> <span class="hljs-comment"># 测试函数必须以 test 开头</span>        <span class="hljs-string">&quot;&quot;&quot;测试功能&quot;&quot;&quot;</span>        c = add(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>)        self.assertEqual(c, <span class="hljs-number">1</span>)  <span class="hljs-comment"># 验证结果是否相等</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_2</span>(<span class="hljs-params">self</span>):</span>        c = add(<span class="hljs-number">-1</span>, - <span class="hljs-number">3</span>)        self.assertEqual(c, <span class="hljs-number">-4</span>)    <span class="hljs-comment"># python manage.py test</span><span class="hljs-comment"># python manage.py test 模块名</span><span class="hljs-comment"># python manage.py test 模块名.tests.类名</span><span class="hljs-comment"># python manage.py test 模块名.tests.类名.函数名</span></code></pre><h4 id="模型测试"><a href="#模型测试" class="headerlink" title="模型测试"></a>模型测试</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserTestCase</span>(<span class="hljs-params">TestCase</span>):</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setUp</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span>        <span class="hljs-comment"># UserWechat.objects.create(openid=&#x27;aaa&#x27;)</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_user_create</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;测试用户创建&quot;&quot;&quot;</span>        User.objects.create(username=<span class="hljs-string">&#x27;aaa&#x27;</span>, gender=<span class="hljs-string">&#x27;a&#x27;</span>)        res = User.objects.get(username=<span class="hljs-string">&#x27;aaa&#x27;</span>)        self.assertEqual(res.username, <span class="hljs-string">&#x27;aaa&#x27;</span>)    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tearDown</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-keyword">None</span>:</span>        <span class="hljs-keyword">pass</span></code></pre><h4 id="接口测试"><a href="#接口测试" class="headerlink" title="接口测试"></a>接口测试</h4><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAPITestCase</span>(<span class="hljs-params">TestCase</span>):</span>        <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_hello</span>(<span class="hljs-params">self</span>):</span>        res = self.client.get(<span class="hljs-string">&#x27;/hello&#x27;</span>)        self.assertEqual(res.status_code, <span class="hljs-number">200</span>)        self.assertEqual(res.json().get(<span class="hljs-string">&#x27;code&#x27;</span>), <span class="hljs-number">0</span>)            <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_login</span>(<span class="hljs-params">self</span>):</span>        data = &#123;            <span class="hljs-string">&quot;openid&quot;</span>: <span class="hljs-string">&quot;acx&quot;</span>,            <span class="hljs-string">&quot;nickname&quot;</span>: <span class="hljs-string">&quot;LP&quot;</span>,            <span class="hljs-string">&quot;gender&quot;</span>: <span class="hljs-number">0</span>        &#125;        res = self.client.post(<span class="hljs-string">&#x27;/login&#x27;</span>, data=data, content_type=<span class="hljs-string">&#x27;application/json&#x27;</span>)        self.assertEqual(res.status_code, <span class="hljs-number">200</span>)</code></pre><h5 id="Session-2"><a href="#Session-2" class="headerlink" title="Session"></a>Session</h5><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<span class="hljs-keyword">from</span> django.test <span class="hljs-keyword">import</span> TestCase<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserAPITestCase</span>(<span class="hljs-params">TestCase</span>):</span><span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">setUpClass</span>(<span class="hljs-params">cls</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;所有测试用例之前调用&quot;&quot;&quot;</span>        data = &#123;            <span class="hljs-string">&quot;openid&quot;</span>: <span class="hljs-string">&quot;aaaa&quot;</span>,            <span class="hljs-string">&quot;nickname&quot;</span>: <span class="hljs-string">&quot;LP&quot;</span>,            <span class="hljs-string">&quot;gender&quot;</span>: <span class="hljs-number">0</span>        &#125;        cls.s = requests        res = cls.s.post(<span class="hljs-string">&#x27;http://127.0.0.1:8000/fresh/api/user/login&#x27;</span>, json=data)        print(<span class="hljs-string">&#x27;登录结果&#x27;</span>, res.json())        <span class="hljs-keyword">pass</span><span class="hljs-meta">    @classmethod</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tearDownClass</span>(<span class="hljs-params">cls</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;所有测试用例之后调用&quot;&quot;&quot;</span>        <span class="hljs-keyword">pass</span>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test_logout</span>(<span class="hljs-params">self</span>):</span>        <span class="hljs-string">&quot;&quot;&quot;需要session校验&quot;&quot;&quot;</span>        res = self.s.delete(<span class="hljs-string">&#x27;http://127.0.0.1:8000/fresh/api/user/logout&#x27;</span>)        self.assertEqual(res.status_code, <span class="hljs-number">200</span>)</code></pre><h2 id="XAdmin"><a href="#XAdmin" class="headerlink" title="XAdmin"></a>XAdmin</h2><h2 id="Admin-simpleui"><a href="#Admin-simpleui" class="headerlink" title="Admin-simpleui"></a>Admin-simpleui</h2><p><a href="https://simpleui.72wo.com/docs/simpleui/">https://simpleui.72wo.com/docs/simpleui/</a></p><h2 id="Admin"><a href="#Admin" class="headerlink" title="Admin"></a>Admin</h2><h3 id="修改admin标题"><a href="#修改admin标题" class="headerlink" title="修改admin标题"></a>修改admin标题</h3><pre><code class="hljs python"><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> adminadmin.site.site_title = <span class="hljs-string">&#x27;管理后台&#x27;</span>admin.site.site_header = <span class="hljs-string">&quot;xx管理后台&quot;</span></code></pre><h3 id="导入导出"><a href="#导入导出" class="headerlink" title="导入导出"></a>导入导出</h3><pre><code class="hljs sh">pip install django-import-export</code></pre><pre><code class="hljs python"><span class="hljs-comment">## settings.py</span>INSTALLED_APPS = [...    <span class="hljs-string">&#x27;import_export&#x27;</span>,    ...]<span class="hljs-comment">## admin.py</span><span class="hljs-keyword">from</span> django.contrib <span class="hljs-keyword">import</span> admin<span class="hljs-keyword">from</span> import_export <span class="hljs-keyword">import</span> resources<span class="hljs-keyword">from</span> import_export.admin <span class="hljs-keyword">import</span> ImportExportActionModelAdmin<span class="hljs-keyword">from</span> .models <span class="hljs-keyword">import</span> Book<span class="hljs-comment"># 创建进出口资源</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookResource</span>(<span class="hljs-params">resources.ModelResource</span>):</span>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Meta</span>:</span>        model = Book        fields = (<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;price&#x27;</span>)  <span class="hljs-comment"># 导出字段</span>        <span class="hljs-comment"># exclude = (&#x27;imported&#x27;, )  # 导出排除字段</span>        <span class="hljs-meta">@admin.register(Book)</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BookAdmin</span>(<span class="hljs-params">ImportExportActionModelAdmin</span>):</span>    resource_class = BookResource    list_display = (<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;price&#x27;</span>, <span class="hljs-string">&#x27;create_time&#x27;</span>)</code></pre><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><p>环境</p><pre><code class="hljs angelscript">nginx1<span class="hljs-number">.20</span><span class="hljs-number">.0</span>mysql5<span class="hljs-number">.7</span>redis5<span class="hljs-number">.0</span><span class="hljs-number">.3</span>django3<span class="hljs-number">.2</span><span class="hljs-number">.0</span></code></pre><p>创建python虚拟环境</p><pre><code class="hljs sh">conda create -n fresh python==2.6.2<span class="hljs-comment"># 安装pip环境</span>pip install -r requirements.txt<span class="hljs-comment"># 安装uwsgi</span>pip install uwsgi</code></pre><ul><li>pip mysqlclient报错</li></ul><pre><code class="hljs cmake">yum <span class="hljs-keyword">install</span> mysql-devel</code></pre><ul><li>pip uwsgi报错</li><li>参考：<a href="https://anaconda.org/conda-forge/uwsgi">乌斯吉 * Anaconda.org</a></li></ul><pre><code class="hljs awk">conda install -c conda-forge<span class="hljs-regexp">/label/g</span>cc7 uwsgi</code></pre><h4 id="项目目录下创建-uwsgi-ini-文件"><a href="#项目目录下创建-uwsgi-ini-文件" class="headerlink" title="项目目录下创建 uwsgi.ini 文件"></a>项目目录下创建 uwsgi.ini 文件</h4><pre><code class="hljs ini"><span class="hljs-section">[uwsgi]</span><span class="hljs-comment"># 项目目录</span><span class="hljs-attr">chdir</span>=/root/project/fresh<span class="hljs-comment"># 设置日志存储</span><span class="hljs-attr">daemonize</span>=/root/project/fresh/uwsgi.log<span class="hljs-comment"># 你项目使用的虚拟环境的根目录 绝对地址</span><span class="hljs-attr">virtualenv</span> = /root/miniconda3/envs/fresh<span class="hljs-comment"># 指定socket，真实端口</span><span class="hljs-attr">socket</span>=:<span class="hljs-number">8001</span><span class="hljs-comment"># 指定pid文件</span><span class="hljs-attr">pidfile</span>=/root/project/fresh/uwsgi.pid<span class="hljs-comment"># 指定项目的wsgi模块</span><span class="hljs-attr">module</span>=fresh.wsgi<span class="hljs-comment"># 启用主进程</span><span class="hljs-attr">master</span>=<span class="hljs-literal">true</span><span class="hljs-comment"># 进程个数</span><span class="hljs-attr">workers</span>=<span class="hljs-number">3</span><span class="hljs-comment"># 在每个worker而不是master中加载应用</span><span class="hljs-attr">lazy-apps</span>=<span class="hljs-literal">true</span><span class="hljs-comment"># 每个进程最大的请求数</span><span class="hljs-attr">max-request</span> = <span class="hljs-number">1000</span><span class="hljs-comment"># 启动uwsgi的用户名和用户组</span><span class="hljs-attr">uid</span>=root<span class="hljs-attr">gid</span>=root<span class="hljs-comment"># 自动移除unix Socket和pid文件当服务停止的时候</span><span class="hljs-attr">vacuum</span>=<span class="hljs-literal">true</span><span class="hljs-comment"># 启用线程</span><span class="hljs-attr">enable-threads</span>=<span class="hljs-literal">true</span><span class="hljs-comment"># 设置自中断时间</span><span class="hljs-attr">harakiri</span>=<span class="hljs-number">30</span><span class="hljs-comment"># 设置缓冲</span><span class="hljs-attr">post-buffering</span>=<span class="hljs-number">4096</span><span class="hljs-comment">#设置在平滑的重启（直到接收到的请求处理完才重启）一个工作子进程中，等待这个工作结束的最长秒数。这个配置会使在平滑地重启工作子进程中，如果工作进程结束时间超过了8秒就会被强行结束（忽略之前已经接收到的请求而直接结束）</span><span class="hljs-attr">reload-mercy</span> = <span class="hljs-number">8</span></code></pre><h4 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h4><pre><code class="hljs sh">upstream fresh &#123;    server 127.0.0.1:8001;&#125;server &#123;    listen 80;    server_name www.smilelp.top;    location = /ok &#123;        default_type application/json;        <span class="hljs-built_in">return</span> 200 <span class="hljs-string">&#x27;&#123;&quot;msg&quot;:&quot;www.smilelp.top&quot;&#125;&#x27;</span>;    &#125;    location / &#123;        include uwsgi_params;        uwsgi_pass fresh;        uwsgi_read_timeout 15;    &#125;    location /static &#123;        <span class="hljs-built_in">alias</span> /root/project/fresh/static;    &#125;&#125;</code></pre><p>uwsgi启动 django项目</p><pre><code class="hljs sh"><span class="hljs-comment"># 启动</span>uwsgi --ini uwsgi.ini<span class="hljs-comment"># 关闭</span>uwsgi --stop uwsgi.pid<span class="hljs-comment"># 重载nginx</span>systemcal reload nginx</code></pre><h3 id="Docker部署"><a href="#Docker部署" class="headerlink" title="Docker部署"></a>Docker部署</h3><ul><li>docker+nginx+uwsgi+django+python+mysql+redis</li></ul><p><a href="https://blog.csdn.net/aafeiyang/article/details/100152373/">https://blog.csdn.net/aafeiyang/article/details/100152373/</a></p><p>Dokerfile</p><pre><code class="hljs awk">FROM ubuntu:<span class="hljs-number">16.04</span>FROM python:<span class="hljs-number">3.6</span>ENV http_proxy=http:<span class="hljs-regexp">//</span>xxx.xxx.xxx.xxx:<span class="hljs-number">3128</span>ENV https_proxy=http:<span class="hljs-regexp">//</span>xxx.xxx.xxx.xxx:<span class="hljs-number">3128</span> RUN apt-get -y update &amp;&amp; \    apt-get -y upgrade &amp;&amp; \    apt-get install -y \    vim \git \python3-dev \python3-setuptools \python3-pip \nginx \supervisor \        nodejs \        npm \        default-libmysqlclient-dev &amp;&amp; \        pip3 install --upgrade -i https:<span class="hljs-regexp">//</span>pypi.doubanio.com<span class="hljs-regexp">/simple/</span> pip setuptools &amp;&amp; \  rm -rf <span class="hljs-regexp">/var/</span>lib<span class="hljs-regexp">/apt/</span>lists/* RUN pip3 install -i https:<span class="hljs-regexp">//</span>pypi.doubanio.com<span class="hljs-regexp">/simple/</span> uwsgi COPY requirements.txt <span class="hljs-regexp">/data/</span>Project/RUN pip3 install -i https:<span class="hljs-regexp">//</span>pypi.doubanio.com<span class="hljs-regexp">/simple/</span> -r <span class="hljs-regexp">/data/</span>Project/requirements.txt COPY .<span class="hljs-regexp">/build/</span>nginx<span class="hljs-regexp">/nginx.conf /</span>etc<span class="hljs-regexp">/nginx/</span>nginx.confRUN echo <span class="hljs-string">&quot;daemon off;&quot;</span> &gt;&gt; <span class="hljs-regexp">/etc/</span>nginx/nginx.confCOPY .<span class="hljs-regexp">/build/</span>nginx<span class="hljs-regexp">/conf.d  /</span>etc<span class="hljs-regexp">/nginx/</span>conf.d ENV PYTHONIOENCODING=utf-<span class="hljs-number">8</span> EXPOSE <span class="hljs-number">9990</span> <span class="hljs-number">9999</span></code></pre><p><strong>通过docker-compose.yml 将容器运行起来</strong></p><pre><code class="hljs yml"><span class="hljs-attr">nginx:</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">nginx</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-shenzhen.aliyuncs.com/beni/nginx:latest</span>    <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-number">80</span><span class="hljs-string">:80</span>    <span class="hljs-attr">volumes:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">C:/data/django/nginx:/etc/nginx/conf.d</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">C:/data/django/www:/data/django/www</span>    <span class="hljs-attr">links:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">django:django</span> <span class="hljs-attr">django:</span>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">django</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">registry.cn-shenzhen.aliyuncs.com/beni/django:latest</span>    <span class="hljs-attr">volumes:</span>        <span class="hljs-bullet">-</span> <span class="hljs-string">C:/data/django/www:/data/django/www</span>    <span class="hljs-attr">command:</span> <span class="hljs-string">uwsgi</span> <span class="hljs-string">--ini</span> <span class="hljs-string">/data/django/www/mblog/uwsgi.ini</span></code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python,Django</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes Install</title>
    <link href="/2021/10/25/cloud/install/Kubernetes%20Install/"/>
    <url>/2021/10/25/cloud/install/Kubernetes%20Install/</url>
    
    <content type="html"><![CDATA[<h2 id="update-2022-01-06-Thursday-09-46-47"><a href="#update-2022-01-06-Thursday-09-46-47" class="headerlink" title="update: 2022-01-06-Thursday 09:46:47"></a>update: 2022-01-06-Thursday 09:46:47</h2><h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h2><p>kubernetes-intstall-on-centos7.sh</p><ul><li>升级内核</li></ul><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 升级内核</span><span class="hljs-meta">#</span><span class="bash"> 安装新内核</span>wget https://elrepo.org/linux/kernel/el7/x86_64/RPMS/kernel-lt-5.4.114-1.el7.elrepo.x86_64.rpmwget https://elrepo.org/linux/kernel/el7/x86_64/RPMS/kernel-lt-devel-5.4.114-1.el7.elrepo.x86_64.rpmyum -y install  kernel-lt-5.4.114-1.el7.elrepo.x86_64.rpm kernel-lt-devel-5.4.114-1.el7.elrepo.x86_64.rpm<span class="hljs-meta">#</span><span class="bash"> 调整默认内核启动</span>grub2-set-default &quot;CentOS Linux (5.4.114-1.el7.elrepo.x86_64) 7 (Core)&quot;<span class="hljs-meta">#</span><span class="bash"> 检查是否修改正确并重启系统</span>grub2-editenv listreboot</code></pre><hr><p>后续步骤整合</p><pre><code class="hljs shell">[[开启IPVS]] 支持cat &lt;&lt;EOF&gt; /etc/sysconfig/modules/ipvs.modules<span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>ipvs_modules=&quot;ip_vs ip_vs_lc ip_vs_wlc ip_vs_rr ip_vs_wrr ip_vs_lblc ip_vs_lblcr ip_vs_dh ip_vs_sh ip_vs_fo ip_vs_nq ip_vs_sed ip_vs_ftp nf_conntrack&quot;for kernel_module in $&#123;ipvs_modules&#125;; do  /sbin/modinfo -F filename $&#123;kernel_module&#125; &gt; /dev/null 2&gt;&amp;1  if [ $? -eq 0 ]; then    /sbin/modprobe $&#123;kernel_module&#125;  fidoneEOFchmod 755 /etc/sysconfig/modules/ipvs.modules sh /etc/sysconfig/modules/ipvs.modules lsmod | grep ip_vs<span class="hljs-meta">#</span><span class="bash"> 关闭防火墙、selinux</span>systemctl stop firewalld &amp;&amp; systemctl disable firewalldsetenforce 0sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config<span class="hljs-meta">#</span><span class="bash"> 关闭系统的交换分区</span>swapoff -acp /etc/fstab  /etc/fstab.bakcat /etc/fstab.bak | grep -v swap &gt; /etc/fstab<span class="hljs-meta">#</span><span class="bash"> 修改 iptables 设置</span>cat &lt;&lt;EOF&gt;&gt;/etc/sysctl.confvm.swappiness = 0net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1net.bridge.bridge-nf-call-ip6tables = 1EOFsysctl -pcat &lt;&lt;EOF&gt;&gt; /etc/hosts127.0.0.1   localhost192.168.0.10  k8smaster192.168.0.11  k8snode1192.168.0.12  k8snode2192.168.0.13  k8snode3192.168.0.21  k8snode4192.168.0.22  k8snode5EOF<span class="hljs-meta">#</span><span class="bash"> 指定阿里云 yum 源</span>cat &lt;&lt;EOF &gt; /etc/yum.repos.d/k8s.repo [k8s]name=k8senabled=1gpgcheck=0baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/EOF<span class="hljs-meta">#</span><span class="bash"> 查询可安装版本，指定版本进行安装</span>yum list kubeletyum list kubectlyum list kubeadm<span class="hljs-meta">#</span><span class="bash"> 安装 kubeadm、kubelet、kubectl </span>yum install -y kubelet-1.21.0-0 kubeadm-1.21.0-0 kubectl-1.21.0-0<span class="hljs-meta">#</span><span class="bash"> 将 kubectl 设置为开机启动</span>systemctl daemon-reload &amp;&amp; systemctl enable kubeletkubeadm config print init-defaultskubeadm config images listkubeadm config images list --kubernetes-version=v1.21.0 --image-repository swr.myhuaweicloud.com/iiveycat &gt; /etc/docker/daemon.json &lt;&lt;EOF&#123;  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: &#123;    &quot;max-size&quot;: &quot;100m&quot;  &#125;,  &quot;storage-driver&quot;: &quot;overlay2&quot;,  &quot;storage-opts&quot;: [    &quot;overlay2.override_kernel_check=true&quot;  ]&#125;EOFsystemctl restart dockerecho &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bashrc</code></pre><hr><ul><li>开启 IPVS 支持</li></ul><pre><code class="hljs shell">[[开启IPVS]] 支持cat &lt;&lt;EOF&gt; /etc/sysconfig/modules/ipvs.modules<span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>ipvs_modules=&quot;ip_vs ip_vs_lc ip_vs_wlc ip_vs_rr ip_vs_wrr ip_vs_lblc ip_vs_lblcr ip_vs_dh ip_vs_sh ip_vs_fo ip_vs_nq ip_vs_sed ip_vs_ftp nf_conntrack&quot;for kernel_module in $&#123;ipvs_modules&#125;; do  /sbin/modinfo -F filename $&#123;kernel_module&#125; &gt; /dev/null 2&gt;&amp;1  if [ $? -eq 0 ]; then    /sbin/modprobe $&#123;kernel_module&#125;  fidoneEOFchmod 755 /etc/sysconfig/modules/ipvs.modules sh /etc/sysconfig/modules/ipvs.modules lsmod | grep ip_vs</code></pre><ul><li>关闭防火墙、selinux</li></ul><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 关闭防火墙、selinux</span>systemctl stop firewalld &amp;&amp; systemctl disable firewalldsetenforce 0sed -i &quot;s/SELINUX=enforcing/SELINUX=disabled/g&quot; /etc/selinux/config<span class="hljs-meta">#</span><span class="bash"> 关闭系统的交换分区</span>swapoff -acp /etc/fstab  /etc/fstab.bakcat /etc/fstab.bak | grep -v swap &gt; /etc/fstab修改 iptables 设置cat &lt;&lt;EOF&gt;&gt;/etc/sysctl.confvm.swappiness = 0net.bridge.bridge-nf-call-iptables = 1net.ipv4.ip_forward = 1net.bridge.bridge-nf-call-ip6tables = 1EOFsysctl -p</code></pre><ul><li>时区 </li></ul><pre><code class="hljs shell">yum install -y ntpsystemctl enable ntpdsystemctl start ntpdtimedatectl set-timezone Asia/Shanghaitimedatectl set-ntp yesntpq -p</code></pre><ul><li>主机名本地解析配置</li></ul><pre><code class="hljs shell">cat &lt;&lt;EOF&gt; /etc/hosts127.0.0.1   localhost192.168.0.10  k8smaster192.168.0.11  k8snode1192.168.0.12  k8snode2192.168.0.13  k8snode3192.168.0.21  k8snode4192.168.0.22  k8snode5EOFhostnamectl set-hostname</code></pre><ul><li>安装 kubeadm、kubelet、kubectl 工具</li></ul><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 指定阿里云 yum 源</span>cat &lt;&lt;EOF &gt; /etc/yum.repos.d/k8s.repo [k8s]name=k8senabled=1gpgcheck=0baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/EOF<span class="hljs-meta">#</span><span class="bash"> 查询可安装版本，指定版本进行安装</span>yum list kubeletyum list kubectlyum list kubeadm<span class="hljs-meta">#</span><span class="bash"> 安装 kubeadm、kubelet、kubectl </span>yum install -y kubelet-1.21.0-0 kubeadm-1.21.0-0 kubectl-1.21.0-0<span class="hljs-meta">#</span><span class="bash"> 将 kubectl 设置为开机启动</span>systemctl daemon-reload &amp;&amp; systemctl enable kubelet</code></pre><ul><li>初始化 k8s 集群</li></ul><pre><code class="hljs shell">[root@vm210 ~]# kubeadm init   --image-repository registry.aliyuncs.com/google_containers   --kubernetes-version v1.21.0   --apiserver-advertise-address=192.168.0.130[init] Using Kubernetes version: v1.22.0[preflight] Running pre-flight checkserror execution phase preflight: [preflight] Some fatal errors occurred:[ERROR NumCPU]: the number of available CPUs 1 is less than the required 2[preflight] If you know what you are doing, you can make a check non-fatal with `--ignore-preflight-errors=...`To see the stack trace of this error execute with --v=5 or higher[root@vm210 ~]# kubelet --cgroupDriverE0821 18:06:43.647211    8799 server.go:158] &quot;Failed to parse kubelet flag&quot; err=&quot;unknown flag: --cgroupDriver&quot;[root@vm210 ~]# systemctl status kubelet● kubelet.service - kubelet: The Kubernetes Node Agent   Loaded: loaded (/usr/lib/systemd/system/kubelet.service; enabled; vendor preset: disabled)  Drop-In: /usr/lib/systemd/system/kubelet.service.d           └─10-kubeadm.conf   Active: activating (auto-restart) (Result: exit-code) since 六 2021-08-21 18:19:45 CST; 5s ago     Docs: https://kubernetes.io/docs/  Process: 8186 ExecStart=/usr/bin/kubelet $KUBELET_KUBECONFIG_ARGS $KUBELET_CONFIG_ARGS $KUBELET_KUBEADM_ARGS $KUBELET_EXTRA_ARGS (code=exited, status=1/FAILURE) Main PID: 8186 (code=exited, status=1/FAILURE)8月 21 18:19:45 vm210 systemd[1]: kubelet.service: main process exited, code=exited, status=1/FAILURE8月 21 18:19:45 vm210 systemd[1]: Unit kubelet.service entered failed state.8月 21 18:19:45 vm210 systemd[1]: kubelet.service failed.[root@vm210 ~][[vim]] /etc/docker/daemon.json&#123;  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;]&#125;[root@vm210 ~][[systemctl]] daemon-reload[root@vm210 ~][[systemctl]] restart docker// unable to configure the Docker daemon with file /etc/docker/daemon.json// choose to install docker-ce will solve this problem.[root@vm210 ~][[systemctl]] restart kubelet// run kuebeadm againERROR: Cannot connect to the Docker daemon at unix:///var/run/docker.sock. Is the docker daemon running?errors pretty printing info, error: exit status 1[ERROR Service-Docker]: docker service is not active, please run &#x27;systemctl start docker.service&#x27;[root@vm210 ~][[systemctl]] start docker.serviceerror execution phase preflight: [preflight] Some fatal errors occurred:[ERROR ImagePull]: failed to pull image registry.aliyuncs.com/google_containers/coredns:v1.8.4: output: Error response from daemon: manifest for registry.aliyuncs.com/google_containers/coredns:v1.8.4 not found: manifest unknown: manifest unknown[root@vm210 ~]# docker pull coredns/corednsUsing default tag: latestlatest: Pulling from coredns/corednsc6568d217a00: Pull completebc38a22c706b: Pull completeDigest: sha256:6e5a02c21641597998b4be7cb5eb1e7b02c0d8d23cce4dd09f4682d463798890Status: Downloaded newer image for coredns/coredns:latestdocker.io/coredns/coredns:latest[root@vm210 ~]# docker imagesREPOSITORY                                                        TAG       IMAGE ID       CREATED        SIZEregistry.aliyuncs.com/google_containers/kube-apiserver            v1.22.0   838d692cbe28   2 weeks ago    128MBregistry.aliyuncs.com/google_containers/kube-controller-manager   v1.22.0   5344f96781f4   2 weeks ago    122MBregistry.aliyuncs.com/google_containers/kube-proxy                v1.22.0   bbad1636b30d   2 weeks ago    104MBregistry.aliyuncs.com/google_containers/kube-scheduler            v1.22.0   3db3d153007f   2 weeks ago    52.7MBregistry.aliyuncs.com/google_containers/etcd                      3.5.0-0   004811815584   2 months ago   295MBcoredns/coredns                                                   latest    8d147537fb7d   2 months ago   47.6MBregistry.aliyuncs.com/google_containers/pause                     3.5       ed210e3e4a5b   5 months ago   683kB[root@vm210 ~]# docker tag coredns/coredns:latest registry.aliyuncs.com/google_containers/coredns:v1.8.4[root@vm210 ~]# docker rmi coredns/coredns:latest// success infomationYour Kubernetes control-plane has initialized successfully!To start using your cluster, you need to run the following as a regular user:  mkdir -p $HOME/.kube  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config  sudo chown $(id -u):$(id -g) $HOME/.kube/configAlternatively, if you are the root user, you can run:  export KUBECONFIG=/etc/kubernetes/admin.confYou should now deploy a pod network to the cluster.Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:  https://kubernetes.io/docs/concepts/cluster-administration/addons/Then you can join any number of worker nodes by running the following on each as root:kubeadm join 192.168.56.130:6443 --token i36hnn.8trjybo0msel27y6 \--discovery-token-ca-cert-hash sha256:4667ecb1cbe7692b8bef1d3fac79be22a8cf3d2086f8fd5538e00fb2b08b9ee3</code></pre><pre><code class="hljs shell">kubeadm config print init-defaultskubeadm config images listkubeadm config images list --kubernetes-version=v1.21.0 --image-repository swr.myhuaweicloud.com/iiveycat &gt; /etc/docker/daemon.json &lt;&lt;EOF&#123;  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],  &quot;log-driver&quot;: &quot;json-file&quot;,  &quot;log-opts&quot;: &#123;    &quot;max-size&quot;: &quot;100m&quot;  &#125;,  &quot;storage-driver&quot;: &quot;overlay2&quot;,  &quot;storage-opts&quot;: [    &quot;overlay2.override_kernel_check=true&quot;  ]&#125;EOFsystemctl  restart dockerecho &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bashrckubeadm config print init-defaults &gt; kubeadm.yamlkubeadm init --config=kubeadm.yamlkubeadm versionkubeadm init --kubernetes-version=v1.21.0 --image-repository registry.aliyuncs.com/google_containers --apiserver-advertise-address 192.168.0.102 --pod-network-cidr=10.244.0.0/16</code></pre><ul><li>master 节点</li></ul><pre><code class="hljs shell">mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config</code></pre><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubeadm.k8s.io/v1beta2</span><span class="hljs-attr">bootstrapTokens:</span><span class="hljs-bullet">-</span> <span class="hljs-attr">groups:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">system:bootstrappers:kubeadm:default-node-token</span>  <span class="hljs-attr">token:</span> <span class="hljs-string">abcdef.0123456789abcdef</span>  <span class="hljs-attr">ttl:</span> <span class="hljs-string">24h0m0s</span>  <span class="hljs-attr">usages:</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">signing</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">authentication</span><span class="hljs-attr">kind:</span> <span class="hljs-string">InitConfiguration</span><span class="hljs-attr">localAPIEndpoint:</span>  <span class="hljs-attr">advertiseAddress:</span> <span class="hljs-number">1.2</span><span class="hljs-number">.3</span><span class="hljs-number">.4</span>  <span class="hljs-attr">bindPort:</span> <span class="hljs-number">6443</span><span class="hljs-attr">nodeRegistration:</span>  <span class="hljs-attr">criSocket:</span> <span class="hljs-string">/var/run/dockershim.sock</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">node</span>  <span class="hljs-attr">taints:</span> <span class="hljs-literal">null</span><span class="hljs-meta">---</span><span class="hljs-attr">apiServer:</span>  <span class="hljs-attr">timeoutForControlPlane:</span> <span class="hljs-string">4m0s</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">kubeadm.k8s.io/v1beta2</span><span class="hljs-attr">certificatesDir:</span> <span class="hljs-string">/etc/kubernetes/pki</span><span class="hljs-attr">clusterName:</span> <span class="hljs-string">kubernetes</span><span class="hljs-attr">controllerManager:</span> &#123;&#125;<span class="hljs-attr">dns:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">CoreDNS</span><span class="hljs-attr">etcd:</span>  <span class="hljs-attr">local:</span>    <span class="hljs-attr">dataDir:</span> <span class="hljs-string">/var/lib/etcd</span><span class="hljs-attr">imageRepository:</span> <span class="hljs-string">registry.aliyuncs.com/google_containers</span><span class="hljs-attr">kind:</span> <span class="hljs-string">ClusterConfiguration</span><span class="hljs-attr">kubernetesVersion:</span> <span class="hljs-number">1.21</span><span class="hljs-number">.0</span><span class="hljs-attr">networking:</span>  <span class="hljs-attr">dnsDomain:</span> <span class="hljs-string">cluster.local</span>  <span class="hljs-attr">serviceSubnet:</span> <span class="hljs-number">10.96</span><span class="hljs-number">.0</span><span class="hljs-number">.0</span><span class="hljs-string">/12</span><span class="hljs-attr">scheduler:</span> &#123;&#125;</code></pre><pre><code class="hljs shell">kubeadm init --image-repository registry.aliyuncs.com/google_containers  \    --kubernetes-version v1.21.0  \    --apiserver-advertise-address=192.168.0.10 \    --pod-network-cidr=10.100.0.0/16</code></pre><ul><li>添加集群节点</li></ul><pre><code class="hljs shell">kubeadm join 172.16.213.221:6443 --token bnefy8.d79yn6ylxlk7k8hr     --discovery-token-ca-cert-hash sha256:eaa17f4b308e9406891f85f664c0d2c97a49bd9e963f64c9453b7042509e106c kubectl get node</code></pre><p>生成 token </p><pre><code class="hljs shell">kubeadm token create --ttl 0 --print-join-command</code></pre><blockquote><p> 查看日志</p><p>journalctl -f -u kubelet.service</p></blockquote><hr><ul><li><p>安装网络插件</p><ul><li><p>Flannel</p><pre><code class="hljs shell">export POD_SUBNET=10.100.0.0/16kubectl apply -f https://kuboard.cn/install-script/v1.21.x/calico-operator.yamlwget https://kuboard.cn/install-script/flannel/flannel-v0.14.0.yamlsed -i &quot;s#10.244.0.0/16#$&#123;POD_SUBNET&#125;#&quot; flannel-v0.14.0.yamlkubectl apply -f ./flannel-v0.14.0.yaml</code></pre></li><li><p>Calico</p><ul><li><pre><code class="shell">wget https://docs.projectcalico.org/manifests/tigera-operator.yamlwget https://docs.projectcalico.org/manifests/custom-resources.yamlvim custom-resources.yaml  cidr: 192.168.0.0/16  =&gt; cidr: 10.100.0.0/16kubectl create -f tigera-operator.yamlkubectl create -f custom-resources.yamlwatch kubectl get pods -n calico-systemwatch kubectl get nodes<pre><code class="hljs">  - 方法一  ```shell  wget https://docs.projectcalico.org/manifests/calico.yaml  kubectl apply -f calico.yaml  kubectl  get node  kubectl get pods -n kube-system  watch kubectl get pods -n calico-system</code></pre></code></pre></li><li><p>方法二</p></li></ul></li></ul></li></ul><pre><code><pre><code class="hljs shell">export POD_SUBNET=10.100.0.0/16kubectl apply -f https://kuboard.cn/install-script/v1.21.x/calico-operator.yamlwget https://kuboard.cn/install-script/v1.21.x/calico-custom-resources.yamlsed -i &quot;s#192.168.0.0/16#$&#123;POD_SUBNET&#125;#&quot; calico-custom-resources.yamlkubectl apply -f calico-custom-resources.yaml</code></pre></code></pre><ul><li><p>安装 kubernetes-dashboard</p><p>可从<a href="https://github.com/kubernetes/dashboard/releases/tag/v2.2.0">https://github.com/kubernetes/dashboard/releases/tag/v2.2.0</a> 下载最新的dashboard/资源文件，然后进行安装。</p><p>下载下来的文件名为recommended.yaml，默认情况下此文件中的几个镜像地址，国内无法访问，需要修改</p></li></ul><pre><code class="hljs shell">kubectl apply -f  recommended.yaml<span class="hljs-meta">#</span><span class="bash"> 查看 Kubernetes-dashboard 随机的访问端口</span>kubectl  get svc -n kubernetes-dashboard</code></pre><p>此时，可以通过集群任意一个节点的ip加上32081端口访问kubernetes-dashboard 。</p><p>访问dashboard需要认证，因此还需要创建一个认证机制，执行如下命令，创建一个ServiceAccount用户dashboard-admin：</p><pre><code class="hljs shell">kubectl create serviceaccount dashboard-admin -n kube-systemserviceaccount/dashboard-admin created</code></pre><p>然后将dashboard-admin用户与角色绑定:</p><pre><code class="hljs shell"> kubectl create clusterrolebinding dashboard-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-adminclusterrolebinding.rbac.authorization.k8s.io/dashboard-admin created</code></pre><p>最后，查看Token令牌，执行如下组合命令：</p><p>[root@master k8s]# kubectl describe secrets -n kube-system $(kubectl -n kube-system get secret | awk ‘/dashboard-admin/{print $1}’)<br>1.</p><p>此命令输出中，token就是令牌，复制出来保存。有了令牌后，就可以在dashboard选择令牌登录了。</p><p><a href="https://blog.51cto.com/ixdba/2857919">https://blog.51cto.com/ixdba/2857919</a></p><pre><code class="hljs javascript">注意 yum -y update：升级所有包同时也升级软件和系统内核； yum -y upgrade：只升级所有包，不升级软件和系统内核</code></pre><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code class="hljs shell"></code></pre>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Software Engineering</title>
    <link href="/2021/10/21/tmp/Software%20Engineer/Software%20Engineer/"/>
    <url>/2021/10/21/tmp/Software%20Engineer/Software%20Engineer/</url>
    
    <content type="html"><![CDATA[<h1 id="Software-Engineering"><a href="#Software-Engineering" class="headerlink" title="Software Engineering"></a>Software Engineering</h1><h2 id="WHAT"><a href="#WHAT" class="headerlink" title="WHAT?"></a>WHAT?</h2><ul><li><p>问题：<strong>软件产品质量低劣、软件维护工作量大、成本不断上升、进度不可控、程序人员无限度地增加。</strong></p></li><li><p><strong>软件工程，它是为研究和克服软件危机而生</strong></p></li></ul><blockquote><p>为了经济地获得在真实机器上可靠工作的软件而制定和使用的合理工程原则。<br>（Software engineering is the establishment and use of sound engineering principles in order to obtain economically software that is reliable and works efficiently on real machines.）</p></blockquote><ul><li>1993 年，电气电子工程师学会（IEEE）给出了一个更加综合的定义：</li></ul><blockquote><p>将系统化的、规范的、可度量的方法用于软件的开发、运行和维护的过程，即将工程化应用于软件开发中。<br>（Software Engineering: (1) The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software; that is, the application of engineering to software. (2) The study of approaches as in (1).）</p></blockquote><ul><li><strong>用工程化方法去规范软件开发，让项目可以按时完成、成本可控、质量有保证</strong></li><li>瀑布模型</li><li>敏捷开发</li></ul><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><ul><li><strong>软件工程 =  过程 + 方法 + 工具</strong></li><li><strong>软件工程的核心，就是围绕软件项目开发，对开发过程的组织，对方法的运用，对工具的使用。</strong></li></ul><h2 id="工程思维"><a href="#工程思维" class="headerlink" title="工程思维"></a>工程思维</h2><blockquote><p>软件工程是一门用工程化方法解决软件项目问题的学科，其本质也是一门工程学科，这门课的知识在学完后，不仅可以应用在软件项目中，还可以应用于日常生活中遇到的一些问题，Everything is a project。</p></blockquote><ul><li><strong>分析、设计、实施、测试、完成</strong></li></ul><h3 id="工程方法"><a href="#工程方法" class="headerlink" title="工程方法"></a>工程方法</h3><blockquote><p><strong>有目的、有计划、有步骤地解决问题的方法就是工程方法</strong></p></blockquote><ul><li><strong>想法：</strong>想法阶段通常是想要解决问题。最开始问题通常是模糊的，所以需要清晰地定义好问题，研究其可行性，检查是否有可行的解决方案。</li><li><strong>概念：</strong>概念阶段就是用图纸、草图、模型等方式，提出一些概念性的解决方案。这些方案可能有多个，最终会确定一个解决方案。</li><li><strong>计划：</strong>计划阶段是关于如何实施的计划，通常会包含人员、任务、任务持续时间、任务的依赖关系，以及完成项目所需要的预算。</li><li><strong>设计：</strong>设计阶段就是要针对产品需求，将解决方案进一步细化，设计整体架构和划分功能模块，作为分工合作和开发实施的一个依据和参考。</li><li><strong>开发：</strong>开发阶段就是根据设计方案，将解决方案构建实施。开发阶段通常是一个迭代的过程，这个阶段通常会有构建、测试、调试和重新设计的迭代。</li><li><strong>发布：</strong>将最终结果包括文档发布。</li></ul><h2 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h2><blockquote><p><strong>瀑布模型算是现代软件工程的起源，软件工程的发展，很大部分都是构建于瀑布模型的基础之上的。</strong></p></blockquote><h3 id="（Code-And-Fix）模型开发中的问题"><a href="#（Code-And-Fix）模型开发中的问题" class="headerlink" title="（Code And Fix）模型开发中的问题"></a>（Code And Fix）模型开发中的问题</h3><ul><li>整个开发过程不可控，想基于这种开发模式做项目计划太难；</li><li>项目的人数多了后，无法有效分工协作；</li><li>项目开始的时候对需求几乎没有进行有效分析，对需求的理解容易出现偏差，后期导致很多返工；</li><li>项目编码完成后，没有有效测试，运行时 Bug 非常多。</li></ul><h3 id="六个阶段"><a href="#六个阶段" class="headerlink" title="六个阶段"></a>六个阶段</h3><h4 id="一、问题的定义及规划"><a href="#一、问题的定义及规划" class="headerlink" title="一、问题的定义及规划"></a>一、问题的定义及规划</h4><p>这个阶段是需求方和开发方共同确定软件开发目标，同时还要做可行性研究，以确定项目可行。这个阶段会产生需求文档和可行性研究报告。</p><h4 id="二、需求分析"><a href="#二、需求分析" class="headerlink" title="二、需求分析"></a>二、需求分析</h4><p>对需求方提出的所有需求，进行详细的分析。这个阶段一般需要和客户反复确认，以保证能充分理解客户需求。最终会形成需求分析文档。</p><h4 id="三、软件设计"><a href="#三、软件设计" class="headerlink" title="三、软件设计"></a>三、软件设计</h4><p>根据需求分析的结果，对整个软件系统进行抽象和设计，如系统框架设计，数据库设计等等。最后会形成架构设计文档。</p><h4 id="四、程序编码"><a href="#四、程序编码" class="headerlink" title="四、程序编码"></a>四、程序编码</h4><p>将架构设计和界面设计的结果转换成计算机能运行的程序代码。</p><h4 id="五、软件测试"><a href="#五、软件测试" class="headerlink" title="五、软件测试"></a>五、软件测试</h4><p>在编码完成后，对可运行的结果对照需求分析文档进行严密的测试。如果测试发现问题，需要修复。最终测试完成后，形成测试报告。</p><h4 id="六、运行维护"><a href="#六、运行维护" class="headerlink" title="六、运行维护"></a>六、运行维护</h4><p>在软件开发完成，正式运行投入使用。后续需要继续维护，修复错误和增加功能。交付时需要提供使用说明文档。</p><h3 id="最大的问题就是不能及时响应需求变更，越到后期变更代价越大"><a href="#最大的问题就是不能及时响应需求变更，越到后期变更代价越大" class="headerlink" title="最大的问题就是不能及时响应需求变更，越到后期变更代价越大"></a><strong>最大的问题就是不能及时响应需求变更，越到后期变更代价越大</strong></h3><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>简单易行</li><li>可以按照阶段检查，能及时发现问题</li><li>前一个阶段完成后，可以重点关注下一个阶段</li><li>很好的分工协作</li><li>对质量有保障</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>难以相应需求的变更，当需求发生改变时，越到后期代价越大</li><li>工作量分布不均衡</li><li>前期进度受阻，会一直压缩后续阶段时间，导致延期或影响质量</li><li>一直到最后阶段才能看到结果</li></ul><h3 id="解决的重要问题"><a href="#解决的重要问题" class="headerlink" title="解决的重要问题"></a>解决的重要问题</h3><ul><li><strong>让软件开发过程有序可控</strong></li><li><strong>让分工协作变成可能</strong></li><li><strong>质量有保障</strong></li></ul><h2 id="其他开发模型"><a href="#其他开发模型" class="headerlink" title="其他开发模型"></a>其他开发模型</h2><hr><p>快速开发快速改</p><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><ul><li><strong>解决客户的需求不明确和需求多变的问题。</strong></li><li>抛弃策略，附加策略</li><li>Axure、墨刀</li></ul><hr><p>大瀑布拆小瀑布</p><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><ul><li><strong>按模块分批次交付</strong></li><li><strong>需求比较清楚，能模块化的软件系统，并且可以按模块分批次交付。</strong></li></ul><h3 id="迭代模型"><a href="#迭代模型" class="headerlink" title="迭代模型"></a>迭代模型</h3><ul><li><strong>每次迭代都有一个可用的版本</strong></li><li><strong>迭代结束时要完成一个可以运行的交付版本。</strong></li><li><strong>迭代模型最难的部分，在于规划每次迭代的内容和要达到的目标</strong></li></ul><p><strong>增量模型是按照功能模块来拆分；而迭代模型则是按照时间来拆分，看单位时间内能完成多少功能。</strong></p><hr><h3 id="过程模型"><a href="#过程模型" class="headerlink" title="过程模型"></a>过程模型</h3><p>基于具体问题</p><h2 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h2><p>“Scrum + 极限编程 + 看板” 的最佳实践，Scrum 主要用来管理项目过程，极限编程重点在工程实践，而看板将工作流可视化。</p><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><p>来源于一个个小的用户故事，用户故事通常是写在卡片上的一句话，在 Sprint 的开发中，再去确认需求的细节。</p><h3 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h3><p>每个 Sprint 只做一部分需求，所以是一种渐进式的架构设计，当前 Sprint 只做适合当前需求的架构设计。</p><p>这种渐进式的架构设计，迭代次数一多，就会出现架构满足不了需求的现象，产生不少冗余代码，通常我们叫它技术债务，需要定期对系统架构进行重构。</p><h3 id="项目质量"><a href="#项目质量" class="headerlink" title="项目质量"></a>项目质量</h3><p>在敏捷开发的 Sprint 中，并没有专门的测试阶段，这就依赖于开发功能的同时，要编写单元测试和集成测试代码，用自动化的方式辅助完成测试。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>在敏捷开发中，这种持续构建、持续发布的概念叫持续集成，因为整个过程都是全自动化的，每次完成一个任务，提交代码后都可以触发一次构建部署操作，脚本会拿最新的代码做一次全新的构建，然后运行所有的单元测试和集成测试代码，测试通过后部署到测试环境。</p><p>在应用上，也确实需要一些满足一些条件才能用好，例如：</p><ul><li>团队要小，人数超过一定规模就要分拆；</li><li>团队成员之间要紧密协作，客户也要自始至终深度配合；</li><li>领导们得支持。敏捷需要扁平化的组织结构，更少的控制，更多的发挥项目组成员的主动性；</li><li>写代码时要有一定比例的自动化测试代码，要花时间搭建好源码管理和持续集成环境。</li></ul><h2 id="敏捷方法（上）"><a href="#敏捷方法（上）" class="headerlink" title="敏捷方法（上）"></a>敏捷方法（上）</h2><blockquote><p>这些墙很有趣。刚入狱的时候，你痛恨周围的高墙；慢慢地，你习惯了生活在其中；最终你会发现自己不得不依靠它而生存。这就叫体制化。——《肖申克的救赎》</p></blockquote><p>“To Do（待选取）”、“In Progress（进行中）”、“Done（完成）”</p><p> Ticket</p><h3 id="基于-Git-和-CI-的开发流程"><a href="#基于-Git-和-CI-的开发流程" class="headerlink" title="基于 Git 和 CI 的开发流程"></a>基于 Git 和 CI 的开发流程</h3><p>Git 本来只是源代码管理工具，但是其强大的分支管理和灵活的权限控制，结合一定的开发流程，却可以帮助你很好的控制代码质量。</p><p>每次要往 master 添加内容，不是直接提交代码到 master，而是先基于当前稳定的 master，克隆一个 branch（分支）出来，基于 branch 去开发，开发完成后提交一个 PR（Pull Request，合并请求）</p><p>如果你不了解 CI 是什么，可以把它想象成一个机器人，每次你提交一个 PR（严格来说是 Commit，这里略作简化）到源代码服务器，这个机器人马上就知道了。</p><p>然后它创建一个干净的运行环境，把你提交的代码下载下来，再下载安装所有依赖项，然后运行你的所有测试代码，运行完后，把测试结果报告给你。测试结果直观的反馈在 PR 上，绿色表示通过，红色表示不通过。</p><p>应用敏捷开发方法的基本开发流程：</p><ul><li>把要开发的 Ticket 从“To Do”栏移动到“In Progress”栏；</li><li>从主干（master）创建一个分支（branch），基于分支去开发功能或修复 Bug；</li><li>编写实现代码和测试代码（单元测试和集成测试），是不是测试驱动不重要，看个人偏好或团队要求；</li><li>持续提交代码更新到分支，直到完成；</li><li>创建 PR（Pull Request，合并请求），邀请其他人帮忙 Review 代码，根据 Review 的结果，可能还需要更新几次；</li><li>CI 在每一次提交代码到代码库后都会自动运行，运行后主要做这些工作：<br>– 检查代码格式是不是符合规范；<br>– 运行单元测试代码；<br>– 运行集成测试。</li><li>最终这些检查都完成后，CI 会把执行结果显示在 PR 上。通常绿色表示通过，红色表示失败；</li><li>PR 能合并需要满足两个条件：CI 变绿 + 代码 Review 通过；</li><li>PR 合并后，CI 会自动构建 Docker Image，将 Image 部署到开发环境；</li><li>将相应的 Ticket 从看板上的“In Progress”栏移动到“Done”栏。</li></ul><h3 id="部署-1"><a href="#部署-1" class="headerlink" title="部署"></a>部署</h3><p>部署也都实现了自动化，但是流程上还是有一些控制。</p><ul><li>首先，部署的不再是程序代码，而是 Docker 的 Image，每次代码合并后 CI 都会自动生成新的 Image，测试也是基于 Image 测试。</li><li>部署生产环境之前，先在内部的测试环境充分测试。</li><li>部署生产环境前，需要审批确认，有 Ticket 跟踪。</li><li>部署时，先部署一部分，监测正常后再全量部署。</li><li>整个过程都有监控报警，出现问题及时回滚。</li></ul><h3 id="站立会议"><a href="#站立会议" class="headerlink" title="站立会议"></a>站立会议</h3><p><strong>1. 成员轮流发言</strong></p><p><strong>2. 检查最新的 Ticket</strong></p><p><strong>3. 停车场问题</strong></p><h2 id="敏捷开发（下）"><a href="#敏捷开发（下）" class="headerlink" title="敏捷开发（下）"></a>敏捷开发（下）</h2><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><ul><li>产品经理：写需求设计文档，将需求整理成 Ticket，随时和项目成员沟通确认需求；</li><li>开发人员：每天从看板上按照优先级从高到低领取 Ticket，完成日常开发任务；</li><li>测试人员：测试已经部署到测试环境的程序，如果发现 Bug，提交 Ticket；</li><li>项目经理：保障日常工作流程正常执行，让团队成员可以专注工作，提供必要的帮助，解决问题。</li></ul><h3 id="如何完成需求和修复-Bug"><a href="#如何完成需求和修复-Bug" class="headerlink" title="如何完成需求和修复 Bug"></a><strong>如何完成需求和修复 Bug</strong></h3><p>这个小组的日常工作，也是围绕 Ticket 来开展的。所有的需求、Bug、任务都作为 Ticket 提交到项目的 Backlog，每个 Sprint 的任务都以看板的形式展现出来。</p><p>每个人手头事情忙完后，就可以去看板上的“To Do”栏，按照优先级从高到低选取新的 Ticket。选取后移动到“In Progress”栏。</p><h3 id="每周一部署生产环境"><a href="#每周一部署生产环境" class="headerlink" title="每周一部署生产环境"></a>每周一部署生产环境</h3><p>部署放在上半周，这样后面遇到问题还有足够的时间去应对</p><p>部署完成后，需要对线上监控的图表进行观察，如果有问题需要及时甄别，必要的话对部署进行回滚操作。<strong>但轻易不会打补丁马上重新上线，因为仓促之间的修复可能会导致更大的问题。</strong></p><p>即使这一周的部署回滚了，下周再一起部署也不会有太大影响。</p><ul><li><p><strong>每周二开迭代回顾会议，总结上个 Sprint</strong></p><p>**迭代回顾会议 (Sprint Retrospective)**会议，目的是回顾一下在迭代中，团队有哪些做的好的地方，有哪些做的不好的地方。</p></li><li><p><strong>每周四迭代规划会，计划下周工作</strong></p><p><strong>迭代规划会（Sprint Planning Meeting）</strong>。这个会议是要大家一起讨论下一个 Sprint 的内容，产品经理和项目经理会商量好 Ticket 的优先级，会议上，大家一起按优先级高到低从 Backlog 中选出下个 Sprint 的内容。</p><p>团队每个成员都要对候选的下个 Sprint Backlog 中的 Ticket 从 1-5 分进行打分，1 分表示容易 1 天以内可以完成的工作量，2 分表示 2 天内可以完成的工作，5 分表示非常复杂，需要 5 天以上的工作量。</p><p>打分时，要大家一起亮分，而不是挨个表态，不然结果很容易被前面亮分的人影响。</p></li></ul><h3 id="评估每条-Ticket-工作量的大概流程"><a href="#评估每条-Ticket-工作量的大概流程" class="headerlink" title="评估每条 Ticket 工作量的大概流程"></a><strong>评估每条 Ticket 工作量的大概流程</strong></h3><ol><li>会议组织者阅读一条 Ticket，可能是用户故事，可能是 Bug，可能是优化任务。同时会询问大家对内容有没有疑问。</li><li>大家一起讨论这个 Ticket，确保充分理解这个 Ticket。</li><li>每个团队成员在心中对 Ticket 进行工作量估算。</li><li>会议组织者确认大家是否都已经确定估算结果，确认后，开始倒数：“3，2，1”，大家一起伸出一只手，亮出代表分数的手指头。</li><li>如果估算结果存在分歧，出分最高的和最低的各自说明理由，讨论后达成一致。</li></ol><p>估算扑克，因为亮分时用扑克牌亮分而得名，但并非一定要用扑克牌。</p><p><strong>用这种方式评估工作量有几点很明显的好处：</strong></p><ol><li><strong>大家积极参与，详细了解需求。</strong>相比以前，可能只有当某个功能模块分配到自己头上的时候，才会去详细了解那部分需求，而其他开发人员可能都不了解这部分需求。</li><li><strong>工作量是由实际参与开发的成员作出评估，往往更准确也更容易被接受。</strong>以前项目经理代为估算的模式，很容易不准确，或者让开发人员抵触。</li><li><strong>促进成员的交流和经验分享。</strong>我们知道一般经验浅的新手估算工作量都会偏乐观，而经验丰富的老手则会更准确，通过这种方式，新手可以向老手学习到很多工作量估算甚至技术实现的经验。</li></ol><p>在经过几个 Sprint 的磨合后，一般一个团队在每个 Sprint 的产出是比较稳定的。比如说这样一个 7 人的小团队，一个 Sprint 预计可以完成 20-30 分的 Ticket。</p><h3 id="每周五分支切割"><a href="#每周五分支切割" class="headerlink" title="每周五分支切割"></a>每周五分支切割</h3><p>周五标志着一周的工作要结束了，所以下班之前（4 点左右），要做 branch cut（分支切割），也就是要把当前主干上的代码，克隆到一个分支（branch）上。</p><p>经过一周的开发，master （主干）已经合并了不少新的 PR（Pull Request，合并请求），但是如果你直接把 master 的代码部署到生产环境，肯定还是不放心，毕竟自动化测试还是不能完全代替专业测试人员的测试。</p><p>所以我们需要把 master 上的代码部署到测试环境进行测试，并且对测试出来的 Bug 进行修复，直到稳定下来为止。由于 master 还需要一直合并新的功能，所以最好的方式就是每次 Sprint 结束，从 master 创建一个分支版本出来，然后基于这个分支部署和修复 Bug。</p><p>所以需要基于主干做一个 branch cut，创建一个预部署的分支，将预部署分支的代码部署到测试环境，这样下周测试人员就可以测试新的版本。测试验收通过后，预部署分支的代码会部署到生产环境。</p><h3 id="每周轮值"><a href="#每周轮值" class="headerlink" title="每周轮值"></a>每周轮值</h3><p>小组里面除了日常开发工作以外，其实还有不少琐碎的事情，比如每周部署生产环境，每天部署测试环境，每周的 branch cut（分支切割），回答其他小组的问题，主持每日会议（不一定需要项目经理），这些事情如果都是一个人做难免会有些枯燥。</p><p>在敏捷开发中，鼓励发挥每个成员的主动性，所以每周轮值是一个不错的方式，可以让每个人都有机会去体验一下，帮助团队完成这些事情，更有集体荣誉感和责任感。</p><h2 id="软件质量与时间成本范围"><a href="#软件质量与时间成本范围" class="headerlink" title="软件质量与时间成本范围"></a>软件质量与时间成本范围</h2><h3 id="软件项目管理金三角"><a href="#软件项目管理金三角" class="headerlink" title="软件项目管理金三角"></a>软件项目管理金三角</h3><ul><li><p>软件质量（产品的质量，客户的满意度）</p></li><li><p>范围（需要实现多少功能）</p></li><li><p>时间（多久可以完成）</p></li><li><p>成本（花多少钱）</p></li></ul><p><strong>软件工程的目标就是要构建和维护高质量的软件</strong></p><p><strong>调整范围</strong>、<strong>增加成本</strong></p><p>增加需求，也就是范围这条边要增加，那就必然对成本和时间这两条边造成影响，要么延期，要么增加成本。</p><p>面对这种临时加需求的情况，我们也不需要直接说不能加，而是清楚的让产品经理认识到这样做的后果：进度延期，需要更多的成本。如果这个功能真的太重要，可以接受延期，也不是不可以接受，那就重新制定新的项目计划好了。</p><p><strong>瀑布模型的范围是固定的，其他两条边时间和成本是变量。</strong></p><p><strong>在敏捷开发中，时间和成本两条边是固定，就只有范围这条边是变量。</strong></p><h3 id="MVP-模式"><a href="#MVP-模式" class="headerlink" title="MVP 模式"></a><strong>MVP 模式</strong></h3><p>MVP（minimum viable product，最小化的可行性产品）模式，是一种快速推出产品的模式：一开始只推出最核心的功能，满足用户最核心的需求，然后在用户的使用过程中收集反馈，进一步升级迭代。</p><h2 id="可行性研究"><a href="#可行性研究" class="headerlink" title="可行性研究"></a>可行性研究</h2><p><strong>如果发现方案不具备可行性，也应及时调整方案或停止项目以止损。</strong></p><ul><li><strong>经济可行性。</strong>从成本和收益角度分析，看投入产出比。不仅要分析短期利益，还要分析长期利益，看是不是值得做。</li><li><strong>技术可行性。</strong>软件项目最终是需要人通过技术来实现的，所以要分析技术上是不是可行，如果有技术上解决不了的问题又能否规避。</li><li><strong>社会可行性。</strong>社会可行性涉及法律、道德、社会影响等社会因素。比如，触犯国家法律的事情肯定不能做；产品如若不符合道德标准，可能带来较大的社会负面影响，那么也要慎重考虑。</li></ul><p>技术可行不可行，关键还是在人。就算技术成熟，如果短时间内找不到人来做，也是有很大风险的。同时也要评估可能存在的技术风险，像本例中的设备兼容问题，如果不兼容设备很多，那技术就不可行了。</p><p>社会可行性。</p><ul><li>道德可行性是没有问题的，不会有任何不良道德行为。</li><li>社会影响方面，也没有负面影响。</li><li>法律可行性上，项目本身不违反国家法律法规。</li></ul><p>可行性研究是项目启动前很关键的一步，可能最早帮你发现风险，甚至避免损失，千万要重视起来。就如我前面所说的：</p><blockquote><p>哪怕你做的可行性研究不能改变决策，最后项目结束的时候，和当初做的可行性研究做一下对比，也都是非常宝贵的项目经验积累。</p></blockquote><p><strong>如果可行性研究并不能给你一个很明确的结果，也可以考虑小范围试点，先实现一个最小化可行产品，等验证了可行性，再逐步加大投入</strong></p><h2 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h2><p><strong>因为管理，最重要的一点就是大局观，要能从整个项目的角度，从整个团队的角度去思考，去确定方向，去发现问题，对问题及时解决及时调整。</strong></p><h4 id="管好软件项目中的人"><a href="#管好软件项目中的人" class="headerlink" title="管好软件项目中的人"></a>管好软件项目中的人</h4><p><strong>1. 管理好客户的预期</strong></p><ul><li>质量达标：交付产品是高质量的，满足客户需要的。</li><li>完整交付：按照约定的功能范围交付最终产品。</li><li>按时交付：项目按照客户认可的进度完成。</li><li>预算之内：在预算内完成项目</li></ul><p><strong>2. 用流程和规范让项目成员一起紧密协作</strong></p><p><strong>好的项目管理，不需要直接去管人，而是管理好流程规范；项目成员不需要按照项目经理的指令做事，而是遵循流程规范。</strong></p><h4 id="管好软件项目中的事"><a href="#管好软件项目中的事" class="headerlink" title="管好软件项目中的事"></a>管好软件项目中的事</h4><p><strong>1. 选择适合项目的开发模式</strong></p><p><strong>2. 制定好项目计划</strong></p><p><strong>3. 对计划进行跟踪和控制，同时做好风险管理</strong></p><ul><li><p><strong>团队的成功，才是你的成功</strong></p></li><li><p><strong>形成自己的管理风格</strong></p></li><li><p><strong>坚持就是胜利</strong></p></li></ul><p>从转变思维方式开始，从技术思维到管理思维，从关注细节到关注整体。然后去改变习惯，控制自己想写代码的冲动，多去从其他角度想办法。</p><p>要管理好一个项目，关键是要管理好项目中的人和事。对客户要管理好期望，对项目成员则通过合理的流程规范更好的一起协作；对于项目中事的管理就是对软件开发过程的管理，选择好开发模型很重要，然后就是制定好计划，按照计划推进，过程中不断的调整，并且管理好项目中的风险。</p><h2 id="项目计划"><a href="#项目计划" class="headerlink" title="项目计划"></a>项目计划</h2><p>制定项目计划，通常有三个基本步骤：</p><ul><li>第一步：任务分解；</li><li>第二步：估算时间；</li><li>第三步：排任务路径。</li></ul><p><strong>要双方一起沟通，消除偏差。</strong>特别要注意的是，开发人员预估工作量通常会很乐观，所以最后时间会偏紧，这种情况一样要去沟通消除偏差。估算的主要目的是尽可能得到准确的时间。</p><p><strong>提问可以帮助双方搞清楚真实的情况是什么样的，而且也不会招致反感。</strong></p><p><strong>排路径就是要根据任务之间的关系，资源的占用情况，排出合适的顺序。</strong></p><h4 id="设置里程碑"><a href="#设置里程碑" class="headerlink" title="设置里程碑"></a>设置里程碑</h4><h4 id="计划需要跟踪和调整"><a href="#计划需要跟踪和调整" class="headerlink" title="计划需要跟踪和调整"></a>计划需要跟踪和调整</h4><p>项目计划是保障软件项目成功非常重要的手段，制定计划的过程，可以让你对项目有全面的了解，跟踪计划让你知道项目进展情况，出现问题也可以及时调整。</p><p>将任务分解、估算时间、排路径，三步就可以制定出一个项目计划，制定计划不要追求完美，制定好一个初步计划后，就可以先按照计划推进起来，进行过程中还可以继续调整细化。设置里程碑可以有效的保证项目的按时交付。</p><h2 id="流程和规范"><a href="#流程和规范" class="headerlink" title="流程和规范"></a>流程和规范</h2><h3 id="提升团队效率"><a href="#提升团队效率" class="headerlink" title="提升团队效率"></a>提升团队效率</h3><p><strong>从个体来看，因为流程规范的存在，确实可能存在效率降低的情况，但从团队的角度来看，好的流程规范反而是提升效率的。</strong></p><p>以代码审查的规范为例，对于技术高的程序员来说，代码审查可能会耽误一点时间，但对整个团队来讲：</p><ul><li>即使是水平高的程序员，也可能会被发现有错误，代码审查可以降低出错的概率，保障质量；</li><li>对于水平低的程序员，可以通过代码审查学习和成长，代码被高水平程序员审查后，可以有效提高质量。</li></ul><h3 id="将好的实践标准化流程化，让大家可以共享经验"><a href="#将好的实践标准化流程化，让大家可以共享经验" class="headerlink" title="将好的实践标准化流程化，让大家可以共享经验"></a>将好的实践标准化流程化，让大家可以共享经验</h3><h3 id="借助流程规范，让项目管理从人治到“法治”"><a href="#借助流程规范，让项目管理从人治到“法治”" class="headerlink" title="借助流程规范，让项目管理从人治到“法治”"></a>借助流程规范，让项目管理从人治到“法治”</h3><p><strong>好的项目管理，不需要直接管人管事，而是管理好计划和流程规范；项目成员不需要按照项目经理的指令做事，而是遵循计划和流程规范。</strong></p><p><strong>流程规范，看起来是约束，实际上你用的好的话，不仅可以提高团队效率，还可以将好的实践标准化流程化，让大家可以共享经验，还可以有效的管理项目。</strong></p><h2 id="如何制定好流程规范？"><a href="#如何制定好流程规范？" class="headerlink" title="如何制定好流程规范？"></a>如何制定好流程规范？</h2><p><strong>第一步：明确要解决的问题</strong></p><p>在流程上规范起来，例如：数据库操作之前先备份数据库，事先写好 SQL 语句，需要有人审查，测试环境先测试通过，最后再生产环境执行，那么就可以避免以后再出现不小心删除数据表的事情发生。</p><p><strong>第二步：提出解决方案</strong></p><p>在提出解决方案，制定开发流程时，可以参考借鉴软件工程中，大家公认的好的实践。比如说：</p><ul><li><strong>敏捷开发的流程：</strong>虽然你的项目不一定采用敏捷开发的方式，但是敏捷开发中一些好的流程是可以借鉴的，例如参考我之前文章提到的像看板、站立会议、持续集成，这些好的工作流程，都可以借鉴。</li><li><strong>代码规范：</strong>其实很多公司都公开了他们的代码规范，可以直接基于这些规范制定团队的规范。例如说前端的有 Airbnb 的代码规范 <a href="http://github.com/airbnb/javascript">Airbnb JavaScript Style Guide</a>，Java 的有 <a href="http://google.github.io/styleguide/javaguide.html">Google Java Style Guide</a> ，.Net 的有<a href="http://docs.microsoft.com/en-us/dotnet/standard/index">.NET Guide</a>，等等。</li><li><strong>源代码管理流程：</strong>现在的源代码主流是 git，而基于 Git 的代码管理已经有很多成熟的流程规范可以参考。例如阮一峰老师写过的《 <a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html">Git 使用规范流程</a> 》、《<a href="http://www.ruanyifeng.com/blog/2015/12/git-workflow.html">Git 工作流程</a>》和《<a href="http://www.ruanyifeng.com/blog/2012/07/git.html">Git 分支管理策略</a>》，或者 Github 官方出品的《<a href="http://guides.github.com/introduction/flow/index.html">Understanding the GitHub flow</a>》，Gitlab 官方推荐的《<a href="http://docs.gitlab.com/ee/workflow/gitlab_flow.html">Introduction to GitLab Flow</a>》。</li><li><strong>部署流程：</strong>十年前，每日定时构建还是很时髦的部署流程，而现在，主流的部署流程已经变成了持续部署，每次代码合并到主分支都可以触发一次自动部署，这样一有问题，就能马上知道发生在哪个环节。</li></ul><p><strong>第三步：达成共识，推广执行</strong></p><p><strong>第四步： 持续优化，不断改进</strong></p><h3 id="将流程规范工具化"><a href="#将流程规范工具化" class="headerlink" title="将流程规范工具化"></a>将流程规范工具化</h3><p><strong>应该尽可能借助技术手段来推动甚至替代流程规范。</strong></p><blockquote><p>“软件工程”和“质量工程”需要依靠架构技术，而不是依靠 CMM 和 QA 管理流程。一切工程问题，首先要思考能否通过技术解决，当前技术无法解决的问题，暂时由管理手段代劳，同时不停止寻找技术手段。</p></blockquote><p>流程和规范，就像红绿灯一样，不是一种约束，而是牺牲一点个体利益，提高团队效率；流程和规范将好的实践标准化流程化，让大家可以共享经验；流程和规范，让项目管理从人治变成“法治”。</p><p>要制定好项目规范，先明确要解决的问题，然后提出解决方案，看是否可以通过流程规范来解决，有了方案后需要团队成员一起达成一致，最后再推广执行。在执行过程中需要持续的优化，不断改进。</p><h2 id="白天开会，加班写代码的节奏怎么破"><a href="#白天开会，加班写代码的节奏怎么破" class="headerlink" title="白天开会，加班写代码的节奏怎么破"></a>白天开会，加班写代码的节奏怎么破</h2><h3 id="开会是有价值的"><a href="#开会是有价值的" class="headerlink" title="开会是有价值的"></a>开会是有价值的</h3><ul><li><strong>项目目标：</strong>这项目是要干什么的，达到一个什么目标；</li><li><strong>项目里程碑：</strong>项目的开始结束时间，项目的阶段划分，以及各个阶段的时间点；</li><li><strong>角色分工：</strong>项目成员的分工和角色是什么，每个人知道自己的任务是什么，知道遇到问题该找谁；</li><li><strong>流程规范：</strong>项目开发的主要流程是什么，基于瀑布还是敏捷。</li></ul><h3 id="开会是有成本的"><a href="#开会是有成本的" class="headerlink" title="开会是有成本的"></a>开会是有成本的</h3><p><strong>开会其实是有成本的，而且还不低。</strong></p><p><strong>因为有的会议，就不是为了创造价值。</strong></p><h3 id="如何提高开会效率"><a href="#如何提高开会效率" class="headerlink" title="如何提高开会效率"></a>如何提高开会效率</h3><p><strong>减少开会的成本，增加开会创造的价值</strong></p><p><strong>意识到开会是有成本的，如果开会创造的价值不能大于其成本，就是浪费。</strong></p><p><strong>1. 砍掉一些没价值的会议</strong></p><p><strong>2. 减少参与会议的人</strong></p><p><strong>3. 缩短开会时间</strong></p><p><strong>4. 提升会议所创造的价值</strong></p><h2 id="项目管理工具"><a href="#项目管理工具" class="headerlink" title="项目管理工具"></a>项目管理工具</h2><p><strong>一个任务，只有 0% 和 100% 两种状态是准确的，中间状态都是不靠谱的。</strong></p><blockquote><p>一切管理问题，都应思考能否通过工具或技术解决，如果当前工具或技术无法解决，暂时由流程规范代替，同时不停止寻找工具和技术。</p></blockquote><h4 id="项目计划工具"><a href="#项目计划工具" class="headerlink" title="项目计划工具"></a>项目计划工具</h4><p> MS Project </p><p>采用 Scrum 的方式来进行项目管理</p><h4 id="基于-Ticket-的任务跟踪系统"><a href="#基于-Ticket-的任务跟踪系统" class="headerlink" title="基于 Ticket 的任务跟踪系统"></a>基于 Ticket 的任务跟踪系统</h4><p>一个 Ticket，应该包含：</p><ul><li>标题：摘要性的描述 Ticket 内容；</li><li>类型：属于什么类型的 Ticket：Bug、需求、任务；</li><li>内容：Ticket 的详细内容，例如，如果是 Bug 的话，除了要写清楚 Bug 内容，还需要重现步骤。如果是需求的话，要有需求的描述，可能还需要额外的文档链接辅助说明；</li><li>创建人：谁创建的这条 Ticket；</li><li>优先级：这个 Ticket 的优先级高还是低；</li><li>状态：Ticket 的状态，例如：未开始、处理中、已解决、重新打开、关闭等；</li><li>指派给谁：这个 Ticket 被指派给谁了，谁来负责；</li><li>历史记录：整个 Ticket 改变的历史信息，用以跟踪；</li></ul><h4 id="基于看板的可视化任务管理"><a href="#基于看板的可视化任务管理" class="headerlink" title="基于看板的可视化任务管理"></a>基于看板的可视化任务管理</h4><ul><li>从“待选取”栏选择一个 Ticket，拖动到“开发中”栏，表示这个 Ticket 已经选取，开始开发了。</li><li>手头上的 Ticket 开发完成后，就可以将 Ticket 拖动到下一栏——“测试”栏。</li><li>测试人员看到新加入“测试”栏就可以从测试栏选取 Ticket 进行测试。</li><li>如果测试没通过，Ticket 就会被拖动到“待选取”栏。</li><li>如果测试通过，Ticket 就会被拖动到下一栏——“待部署”栏。</li><li>部署完成后，所有“待部署”栏的 Ticket 就会被拖动到“完成”栏。</li></ul><h3 id="项目管理软件"><a href="#项目管理软件" class="headerlink" title="项目管理软件"></a>项目管理软件</h3><p>如果单纯是项目计划工具，功能最好、最全的应该是微软的<a href="http://products.office.com/zh-CN/project/">MS Project</a>，但遗憾的是只能运行在 Window 上，不支持 Mac 平台。如果要在 Mac 上使用项目计划工具，可选的有<a href="http://www.omnigroup.com/omniplan">OmniPlan</a>和<a href="http://www.projectwizards.net/en">Merlin Project</a>。</p><p>基于 Ticket 的任务跟踪系统，最有名的应该是<a href="http://www.atlassian.com/">Atlassian</a>公司出品的<a href="http://www.atlassian.com/software/jira">Jira</a>软件，功能全面，体验很好。Jira 主要是在海外比较流行，因为访问速度和使用习惯等原因，国内用户要相对少一些。</p><p>同类产品也很多，微软的<a href="http://visualstudio.microsoft.com/zh-hans/tfs/?rr=https://shimo.im/docs/5A0wCnmLwn0nCjE9">Azure DevOps</a> （以前叫 TFS, Team Foundation Server），和微软系的产品如 Visual Studio、Azure 可以很好的整合。</p><p>代码托管平台<a href="http://github.com/account/unverified-email">GitHub</a>本身也集成了一套 Issue 跟踪管理系统，虽然没有 Jira 那么强大，但是对于普通项目来说，足够用了。尤其是对于开源项目，完全可以基于 GitHub 的 Issue 进行日常的项目管理。</p><p>国内同类的软件有：</p><ul><li><a href="http://www.zentao.net/">禅道</a>：为数不多提供开源版本可以自己搭建的；</li><li><a href="http://worktile.com/">Worktile</a>：集成了即时消息软件；</li><li><a href="http://www.tapd.cn/">TAPD</a>：腾讯出品，可以和腾讯的服务很好整合，例如企业微信和腾讯云；</li><li><a href="http://cn.aliyun.com/product/yunxiao">云效</a>：阿里巴巴出品，可以和阿里的服务很好整合，例如阿里云和钉钉；</li><li><a href="http://developer.huawei.com/ict/cn/devcloud">DevCloud</a>：华为出品，和华为云有很好的整合。</li></ul><p><strong>如何选择适合的工具</strong></p><p>从功能上来说，基本上，上面提到的每一款产品都能满足日常项目管理的基本需求，建议从项目特色、团队成员和价格服务等因素综合考虑。</p><p>例如说你的项目完全是微软技术栈，就可以考虑使用 TFS；如果你深度使用阿里云和钉钉，那么就可以考虑阿里的云效；如果你想自己搭建，那么就可以考虑 Jira 或者禅道。</p><p>这些产品都有免费版本，可以先试用，你可以仔细对比后，根据自身的情况再最终决定。</p><h2 id="风险管理：不能盲目乐观，凡事都应该有B计划"><a href="#风险管理：不能盲目乐观，凡事都应该有B计划" class="headerlink" title="风险管理：不能盲目乐观，凡事都应该有B计划"></a>风险管理：不能盲目乐观，凡事都应该有B计划</h2><ul><li>估算一个模块工作量，程序员总是会给出一个乐观的进度，而最终实现这个模块的时候，却发现总是有些其他的事情发生影响了进度；</li><li>一个关键的程序员，突然离职了，导致项目进度停滞。其实早前就有一些迹象，而项目经理没引起重视；</li><li>技术负责人很激进的采用了一个最近很流行的新技术，结果做的过程中，发现这个技术还不太成熟，很多坑没法填，导致项目最终失败；</li><li>服务器突然挂了，才发现硬盘坏了而数据没有备份，造成巨大的损失。</li></ul><p><strong>风险 = 损失 x 发生概率。</strong></p><p><strong>对软件项目风险的管理，才是体现项目管理水平的地方。</strong></p><ul><li>被动应对：风险已经发生，造成了问题才被动应对；</li><li>有备无患：事先制定好风险发生后的补救方案，但没有任何防范措施；</li><li>防患未然：对可能的风险做出防范，并把风险防范作为项目任务的一部分。</li></ul><h4 id="培养风险意识"><a href="#培养风险意识" class="headerlink" title="培养风险意识"></a>培养风险意识</h4><p><strong>项目中的任务，不能盲目乐观，都思考一下它最坏的结果是什么，如果最坏的结果不能接受，就说明要有个 B 计划，考虑风险管理了。</strong></p><h4 id="如何对风险进行管理？"><a href="#如何对风险进行管理？" class="headerlink" title="如何对风险进行管理？"></a>如何对风险进行管理？</h4><p><strong>第一步：风险识别，识别可能的风险</strong></p><p><strong>第二步：风险量化，对风险进行评估量化</strong></p><p><strong>第三步：应对计划，对风险制定应对策略</strong></p><ul><li><p><strong>回避风险——更改导致风险的方案</strong></p></li><li><p><strong>转移风险——将损失转嫁出去</strong></p></li><li><p><strong>缓解风险——降低风险发生概率或减少可能造成的损失</strong></p></li><li><p><strong>接受风险——明知山有虎偏向虎山行</strong></p></li></ul><p><strong>第四步：风险监控，对风险进行监控预警</strong></p><p>软件项目风险管理包括风险识别、风险量化、应对计划和风险监控四个过程。</p><h2 id="项目文档"><a href="#项目文档" class="headerlink" title="项目文档"></a>项目文档</h2><p><strong>短期高估文档的重要性，而长期低估文档的重要性。</strong></p><h3 id="WHY"><a href="#WHY" class="headerlink" title="WHY"></a>WHY</h3><ul><li><p><strong>帮助写文档的人理清楚思路</strong></p><p>先写文档，就会抛开代码细节，去站在全局思考。</p><p>真正的障碍是没想清楚，在心中只有一些未成型的混乱的想法和概念，必须要努力把这些模糊的想法确定化和具体化，才能写出来。</p><p>换个角度来说，如果你连文档都写不出来，那又怎么能指望代码写得好呢？</p></li><li><p><strong>便于未来的维护和交接</strong></p></li><li><p><strong>团队更好的协作沟通</strong></p></li></ul><h3 id="如何写好文档？"><a href="#如何写好文档？" class="headerlink" title="如何写好文档？"></a>如何写好文档？</h3><p><strong>1. 从模仿开始</strong></p><p>​    <strong>模仿就是最好的写文档方式</strong></p><p><strong>2. 从小文档开始</strong></p><p><strong>3. 从粗到细，迭代更新</strong></p><p>​    <strong>写得越细则无用功越多，最后，你甚至会因为不想改文档而抵触不同的意见。</strong></p><p><strong>4. 一些基本的画图的技巧</strong></p><ul><li><p>线框图</p><p>线框图是最常用也最实用的一种图形，用简单的方框代替功能、模块、服务等，再用箭头表示关系或者数据流向，非常简单直接。</p></li><li><p>流程图</p><p>流程图是软件项目文档中一种常用图形，可以方便的表示各种不同条件下的逻辑路径。<strong>要画好流程图不难，重点是要理清楚逻辑关系，各个关键节点在不同条件下的走向。</strong></p></li><li><p>时序图</p><p>时序图也是软件项目所特有的一种图形，可以表示不同对象之间发送消息的时间顺序，尤其在涉及网络通信的文档中特别常用。</p><p>画好时序图，关键是要列清楚所有涉及的对象或者服务，以及消息发送的先后顺序。</p><p>例：注销登录过程的时序图。</p></li><li><p>各种格式截图</p><p>截图也是个非常简单直接的方式，把软件的 UI、交互设计的效果、数据趋势图、数据统计图等直接截图，必要的话配上一些箭头、文字，也可以很好的说明清楚问题。尤其是产品设计文档，经常用到。</p></li></ul><h3 id="需求分析-1"><a href="#需求分析-1" class="headerlink" title="需求分析"></a>需求分析</h3><p><strong>第一步：挖掘真实需求</strong></p><ol><li>目标用户：用户不同，诉求也不一样；</li><li>使用场景：使用场景不一样，解决方案也会有所不同；</li><li>想要解决的问题：用户背后想要解决的问题是什么。</li></ol><p><strong>第二步：提出解决方案</strong></p><p><strong>第三步：筛选和验证方案</strong></p><p>整个过程是迭代进行的，如下所示：</p><ul><li>收集需求：对用户需求进行收集整理；<ul><li>头脑风暴：就是大家一起开会头脑风暴讨论；</li><li>用户调研：通过调查问卷或者访谈，通过问用户一些问题收集反馈；</li><li>竞品分析：通过分析其他同类产品的功能获得需求；</li><li>快速原型：通过原型来收集反馈，收集确认需求。</li></ul></li><li>分析需求：对需求进行分析，挖掘用户真实需求；<ul><li>表层需求：用户对解决问题的期望，例如马车更快；</li><li>深层需求：用户的深层次动机，诉求产生的原因，例如乘客对出行速度的要求；</li><li>底层需求：人性本能的需求，例如对安全感对舒适的追求。</li><li>要分析好用户需求背后的真实需求，就是要结合“目标用户”和“使用场景”，按照上面三个层次去思考。</li></ul></li><li>需求评估：筛选过滤掉不可行的需求；<ul><li>可行性：技术能否实现；</li><li>成本：人力成本、时间成本；</li><li>商业风险和收益：有没有商业上的风险，收益是否合理；</li><li>紧急性与重要性：是不是用户迫切的需求。</li></ul></li><li>需求设计：针对用户需求提出解决方案，设计成产品方案；<ul><li>在需求设计的时候，可以用草图、原型设计工具、界面设计工具进行设计。</li></ul></li><li>验证需求：验证方案是否可行。<ul><li>对需求的验证方式其实是贯穿整个软件项目生命周期的，在需求分析阶段，会反复验证确认设计好的需求是否满足用户的真实需求，例如各种设计评审。</li><li>在产品开发完成后，也需要有需求的验收，以确保开发出来的软件产品是客户想要的，满足客户需求的。</li><li>现在很多互联网产品，还有一种基于数据的验证需求方式，也就是 A/B 测试。</li></ul></li></ul><h2 id="原型设计"><a href="#原型设计" class="headerlink" title="原型设计"></a>原型设计</h2><p><strong>注意，这里的快速原型模型，是开发软件项目的一种模式，还不是工具。</strong></p><p>第一个阶段就是纯静态 HTML 页面</p><p>第二个阶段就是模拟一个后台服务，没有数据库，数据直接保存内存中</p><p>第三个阶段就是完成最终的后台服务，接入真正的数据库或者其他后台服务，完成整个网站的开发</p><p><strong>第一阶段确认界面布局和内容，第二阶段确认交互，第三阶段实现。</strong></p><p><strong>整个过程单靠产品经理是无法完成的，必须要有开发人员配合才能完成。</strong></p><ul><li>低保真原型设计</li></ul><p>用线框图来代替第一阶段</p><ul><li><p>中等保真原型设计</p><p>Axure   墨刀</p></li><li><p>高保真原型设计</p></li></ul><h4 id="第一步：分析"><a href="#第一步：分析" class="headerlink" title="第一步：分析"></a>第一步：分析</h4><h4 id="第二步：设计"><a href="#第二步：设计" class="headerlink" title="第二步：设计"></a>第二步：设计</h4><p><strong>画产品的信息结构图</strong></p><p><strong>画产品使用流程图</strong></p><p><strong>需要用流程图把这些界面之间跳转的逻辑梳理清楚</strong></p><h4 id="第三步：实施"><a href="#第三步：实施" class="headerlink" title="第三步：实施"></a>第三步：实施</h4><p><strong>要优先考虑满足产品需求，然后是让界面好看好用。</strong></p><h4 id="第四步：验证"><a href="#第四步：验证" class="headerlink" title="第四步：验证"></a>第四步：验证</h4><h3 id="合适的原型设计工具"><a href="#合适的原型设计工具" class="headerlink" title="合适的原型设计工具"></a>合适的原型设计工具</h3><p><strong>Axure RP</strong>：<a href="http://www.axure.com/">Axure RP</a> 曾一度是原型设计工具的代名词，历史悠久功能强大，可以制作网站、桌面软件、移动 App 的原型。 缺点是专业度较高，价格高。</p><p><strong>墨刀</strong>：<a href="http://modao.cc/">墨刀</a> 是一款优秀的国产原型设计工具，可以制作网站、桌面软件、移动 App 的原型。上手相对容易，价钱也较 Axure 便宜很多。</p><p><strong>Adobe XD</strong>：<a href="http://www.adobe.com/cn/products/xd.html">Adobe XD</a> 是 Adebe 出的一款设计兼原型设计工具，可以制作出高保真原型，对于设计师尤其容易上手。</p><p><strong>ProtoPie</strong>：<a href="http://www.protopie.io/">ProtoPie </a>是一款高保真原型设计工具，不需要编程基础，可以做出逼真强大的交互效果。</p><p><strong>Framer X</strong>：<a href="http://www.framer.com/">Framer X</a>是一款高保真的原型设计工具，功能很强大，但是需要一定的编程基础，尤其适合程序员使用。</p><p>要做好原型设计，可以结合工程方法，分成四个阶段：分析、设计、实施和验证。</p><ul><li>分析阶段，搞清楚用户的需求，原型设计的目标；</li><li>设计阶段，划分好产品的信息架构，设计好产品操作的流程；</li><li>实施阶段，按照设计的结果，对每个界面制作原型，并做好界面之间的链接；</li><li>验证阶段，和项目成员、客户进行确认，收集意见反馈，根据反馈进行修改。</li></ul><h2 id="产品意识"><a href="#产品意识" class="headerlink" title="产品意识"></a>产品意识</h2><h3 id="程序员的价值"><a href="#程序员的价值" class="headerlink" title="程序员的价值"></a>程序员的价值</h3><p><strong>第一，你的价值体现在你所做的产品之上。</strong></p><p><strong>第二，你的价值体现在团队中的稀缺性。</strong></p><ul><li>有的程序员能搞定别人搞不定的技术难题；</li><li>有的程序员擅长培训新人；</li><li>有的程序员擅长和业务部门沟通；</li><li>有的程序员能高质量地完成功能模块；</li><li>有的程序员能按照需求设计好的架构，可以让团队高效率低成本地完成需求。</li></ul><h3 id="什么是产品意识"><a href="#什么是产品意识" class="headerlink" title="什么是产品意识"></a>什么是产品意识</h3><p>产品意识，本质就是一种思维方式，一种站在产品角度思考问题的方式。如果细分一下，产品意识包含：商业意识、用户意识和数据意识。</p><h4 id="商业意识"><a href="#商业意识" class="headerlink" title="商业意识"></a>商业意识</h4><p>所谓商业意识，就是所做的产品是要有商业价值的。比如说成功的商业产品有 Windows、iPhone、Google 等，这些产品不仅满足用户需求，同时也能创造商业价值，让这些公司变成成功的商业公司，雇用了大批优秀的程序员，从而可以继续研究更多产生商业价值的产品。</p><p>比如说程序员热衷于做个 Github 客户端、博客系统，虽然说确实有用，但是却没什么商业价值，没有用户愿意付钱，导致难以持续。</p><p>商业意识的另一方面其实是成本，成本意识也是程序员容易忽视的。比如说：</p><ul><li>有时候为了炫技，采用了更难更酷的技术方案，而忽视了所采用的方案会导致很高的开发成本；</li><li>花了太长时间去开会而忽略了开会的成本；</li><li>有时候又为了省钱，舍不得买一些成熟的商业组件或服务，反而是浪费了更多成本。</li></ul><p>如果程序员有商业意识，就可以在项目中有更好的成本意识，为项目节约时间、经济等成本，帮助团队打造更有价值的产品。</p><h4 id="用户意识"><a href="#用户意识" class="headerlink" title="用户意识"></a>用户意识</h4><p>所谓用户意识，就是说做产品时，你要能挖掘出用户的真实需求，让产品有好的用户体验。这需要你要有同理心，能站在用户的角度去思考和体验产品。</p><p>大部分程序员可能更多专注于程序上，所以在用户意识上确实有所欠缺。举例来说：</p><ul><li>一个产品功能，产品经理在细节上没有定义清楚，程序员可能并不会主动提出，最终做出来的产品会不好用；</li><li>在做技术方案时，更追求技术炫酷，而不是用户体验更好；</li><li>在设计接口时，并没有考虑调用者的便利性。</li></ul><p>如果程序员能跳出纯技术的局限，多一点用户意识，想到的问题将会多了很多维度，比如说：</p><ul><li>能让自己的负责的模块有更好的体验；</li><li>让自己的技术方案更好地满足用户需求，用户更满意；</li><li>让自己设计的接口、API 更好用，与同事愉快合作。</li></ul><p>做到这样，无论对产品还是对自身，都是价值的提升。</p><h4 id="数据意识"><a href="#数据意识" class="headerlink" title="数据意识"></a>数据意识</h4><p>所谓数据意识，就是在产品设计、产品运营时，通过数据来发现问题、证实结果。</p><p>典型的有 A/B 测试，通过数据来发现用户更喜欢哪个功能，哪个功能带来更多的收入。像微博的“时间乱序”功能，虽然很多大 v 吐槽，但是数据证明了这是一个好的产品设计，最终还是一样上线。上线后新浪根据数据不断优化，到现在反倒是很多人喜欢这个功能。</p><p>程序员虽然逻辑很好，但是大多对数据倒是不敏感，对编译警告、测试覆盖率、程序 Crash 的比例、API 错误率、一个函数内上千行代码、性能指标等等这些数据经常选择性忽略。</p><h3 id="如何培养产品意识？"><a href="#如何培养产品意识？" class="headerlink" title="如何培养产品意识？"></a>如何培养产品意识？</h3><h4 id="首先要解放思想"><a href="#首先要解放思想" class="headerlink" title="首先要解放思想"></a>首先要解放思想</h4><p>解放思想，其实就是说，对于程序员，不要总是单纯的用技术眼光看问题，也可以从产品的角度看问题。这两者有什么区别呢？</p><p><strong>技术思维会关注用什么技术，关注技术细节，关注功能“如何”实现；产品思维会关注用户体验，关注一个功能所创造的价值，会去思考为什么要或者不要一个功能。</strong></p><p>这两种思维不同，也很容易导致沟通上的误解。比如程序员会更多考虑技术实现，产品经理会更多考虑产品设计。如果都能往前迈一步，程序员有产品意识、产品思维，产品经理能有一点技术思维、工程思维，那么相互沟通起来就会更通畅。</p><p>这两种思维之间的差别，其实也正是要培养产品意识的关键点。要想培养产品意识，就是要从纯粹的技术思维，有意识地培养产品思维。从关注技术、技术细节，到关注用户体验，关注产品创造的价值。</p><h4 id="然后要改变习惯"><a href="#然后要改变习惯" class="headerlink" title="然后要改变习惯"></a>然后要改变习惯</h4><p>改变习惯是是指在日常使用产品、开发产品的时候，多站在产品的角度思考，去思考它的商业价值、用户体验、使用场景等等。</p><p>比如你学习专栏用的极客时间 App，你聊天用的微信。使用一些具体功能时，可以思考一下这些问题：</p><ul><li>这个产品的商业价值是什么？</li><li>为什么要有这个功能？是为了满足用户哪方面需求的？</li><li>这个产品目标用户是谁？</li><li>这个功能的使用场景是什么？</li><li>这个功能的体验好不好？有没有更好的方式提升体验？</li></ul><p>如果你是程序员，在开发功能、设计架构的时候，也不妨跳出技术之外，从产品角度思考一下：</p><ul><li>这个功能的需求是什么？我是否完全理解了需求？</li><li>如果你是这个功能的用户，你觉得还有哪些地方值得改进？</li><li>哪些技术可以帮助提升用户体验？</li><li>这个 API 用起来是不是好用？有没有更好的设计？</li><li>除了对产品的思考，日常工作中，遇到一些问题，也可以从产品思维的角度去想想。</li></ul><p>产品意识，主要包括商业意识、用户意识和数据意识。要提升产品意识，首先要解放思想，然后要改变习惯，最后要多实践。</p><h2 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h2><p><strong>在需求变更这个事情上，没有赢家，每个人都是受害者。</strong></p><p><strong>方案一：增强需求变更流程，让需求变更规范起来。</strong><br>这个方案简单来说，就是通过严格的流程，来避免一些没有意义的变更，从而达到管理需求变更的目的。</p><p><strong>方案二：快速迭代，缩短版本周期。</strong></p><p><strong>而是要追本溯源，研究问题背后的原因，研究理论背后的来龙去脉。</strong></p><h3 id="为什么建筑工程中少有需求变更？"><a href="#为什么建筑工程中少有需求变更？" class="headerlink" title="为什么建筑工程中少有需求变更？"></a>为什么建筑工程中少有需求变更？</h3><p><strong>需求的确定性和需求变更的成本。</strong></p><h4 id="原因一：需求的确定性"><a href="#原因一：需求的确定性" class="headerlink" title="原因一：需求的确定性"></a>原因一：需求的确定性</h4><h4 id="原因二：需求变更的成本"><a href="#原因二：需求变更的成本" class="headerlink" title="原因二：需求变更的成本"></a>原因二：需求变更的成本</h4><h3 id="如何解决需求变更问题？"><a href="#如何解决需求变更问题？" class="headerlink" title="如何解决需求变更问题？"></a>如何解决需求变更问题？</h3><ul><li><p><strong>提升需求确定性，把需求分析做好，减少需求变更；</strong></p></li><li><p><strong>提高需求变更的成本，让客户或者产品经理不能太容易就变更需求，这样就可以达到减少需求变更的目的。</strong></p></li><li><p><strong>降低响应需求变更的成本，可以方便快捷地响应需求变更。</strong></p></li></ul><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p><strong>第一步：规范变更流程，提升客户变更成本。</strong></p><p><strong>第二步：用原型设计低成本响应需求变更；做好需求分析和确认，减少需求变更。</strong></p><p>​    <strong>通过原型设计的方式，不仅可以方便地与客户沟通需求，还可以灵活响应需求变更。</strong>    </p><p><strong>第三步：通过灵活的架构和强大的配置，低成本响应客户需求变更。</strong></p><ol><li>提升需求确定性，来减少需求的变更。这种方案的优势就是对需求理解透彻，后期返工少，缺点是对产品经理的需求分析能力要求很高。</li><li>提高需求变更的成本，规范需求变更流程，减少需求变更。这种方案的优势就是可以马上起到效果，缺点就是过于繁琐的流程不利于项目协作。</li><li>降低响应需求变更的成本，积极应对需求变更。这种方案的优势在于可以快速响应需求变更，能快速试错尽快调整，缺点在于对软件架构和项目管理要求比较高。</li></ol><h2 id="30-个软件开发常见问题解决策略"><a href="#30-个软件开发常见问题解决策略" class="headerlink" title="30 个软件开发常见问题解决策略"></a>30 个软件开发常见问题解决策略</h2>]]></content>
    
    
    <categories>
      
      <category>CS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>软件工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELK</title>
    <link href="/2021/10/20/cloud/ELK/ELK/"/>
    <url>/2021/10/20/cloud/ELK/ELK/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>主要功能：</p><ul><li>分布式搜索引擎</li><li>大数据实时分析引擎</li></ul><p>目标：</p><ul><li>开发：产品基本功能，底层工作原理，数据建模最佳实践</li><li>运维：容量规划：性能优化，问题诊断，滚动升级</li><li>方案：搜索与如何解决搜索的相关性问题、大数据分析实践与项目实战，理论知识运用到实际场景</li></ul><p>Elastic 认证</p><p>内容：</p><ul><li>环境搭建</li><li>数据分析</li><li>集群管理</li><li>实践</li></ul><h2 id="简介、历史"><a href="#简介、历史" class="headerlink" title="简介、历史"></a>简介、历史</h2><h3 id="安装与查看插件"><a href="#安装与查看插件" class="headerlink" title="安装与查看插件"></a>安装与查看插件</h3><pre><code class="hljs shell">docker network create elasticdocker pull docker.elastic.co/elasticsearch/elasticsearch:7.15.1docker run --name es01-test --net elastic -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.15.1docker pull docker.elastic.co/kibana/kibana:7.15.1docker run --name kib01-test --net elastic -p 5601:5601 -e &quot;ELASTICSEARCH_HOSTS=http://es01-test:9200&quot; docker.elastic.co/kibana/kibana:7.15.1</code></pre><pre><code class="hljs sh">docker pull docker.elastic.co/logstash/logstash:7.15.1</code></pre><pre><code class="hljs shell">bin/elasticsearch-plugin listbin/elasticsearch-plugin install</code></pre><h3 id="运行多个-Elasticsearch-实例"><a href="#运行多个-Elasticsearch-实例" class="headerlink" title="运行多个 Elasticsearch 实例"></a>运行多个 Elasticsearch 实例</h3><pre><code class="hljs shell">/bin/elasticsearch -E node.name=node1 -E cluster.name=test -E path.data=node1_data -d/bin/elasticsearch -E node.name=node1 -E cluster.name=test -E path.data=node2_data -d/bin/elasticsearch -E node.name=node1 -E cluster.name=test -E path.data=node3_data -d</code></pre><p>删除进程</p><pre><code class="hljs shell">ps |grep elasticsearchkill pid</code></pre><p>查看节点</p><p>_cat/nodes</p><h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><h4 id="Dev-Tools"><a href="#Dev-Tools" class="headerlink" title="Dev Tools"></a>Dev Tools</h4><p>快捷键</p><p>kibana-plugin install plugin_location</p><h4 id="在-Docker-中运行-Elasticsearch-Kibana-和-Cerebro"><a href="#在-Docker-中运行-Elasticsearch-Kibana-和-Cerebro" class="headerlink" title="在 Docker 中运行 Elasticsearch Kibana 和 Cerebro"></a>在 Docker 中运行 Elasticsearch Kibana 和 Cerebro</h4><h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><p>bin/logstash -f logstash.conf</p><h2 id="基本概念：索引、文档和-RESTFul-API"><a href="#基本概念：索引、文档和-RESTFul-API" class="headerlink" title="基本概念：索引、文档和 RESTFul API"></a>基本概念：索引、文档和 RESTFul API</h2><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul><li>Elasticsearch 是面向文档的，文档是所有可搜索数据的最小单位</li><li></li></ul><p>文档的元数据</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>Index - 文档的容器，是一类文档的结合</li><li>索引的 Mapping 和 Settings</li></ul><p>索引的不同语义</p><ul><li>名词：</li><li>动词 保存文档</li><li>名称：一个 B 树索引，一个倒排索引</li></ul><p>TYPE：7.0 一个 Index 可以设置成多个 Types</p><h3 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h3><p>通过 HTTP 请求</p><p>基本 API</p><h2 id="基本概念：节点、集群、分片"><a href="#基本概念：节点、集群、分片" class="headerlink" title="基本概念：节点、集群、分片"></a>基本概念：节点、集群、分片</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><ul><li>是一个 Elasticsearch  的实例<ul><li>本质上就是一个 Java 进程</li></ul></li><li>每个节点都有名字，通过配置文件配置，或者启动时候 -E node.name=node1 指定</li><li>每个节点在启动之后，会分配一个 UID，保存在 data 目录下</li></ul><h4 id="Master-eligible-nodes-和-Master-Node"><a href="#Master-eligible-nodes-和-Master-Node" class="headerlink" title="Master-eligible nodes 和 Master Node"></a>Master-eligible nodes 和 Master Node</h4><ul><li>每个节点启动后，默认就是一个 Master eligible 节点，可以设置 node.master: false 禁止</li><li>Master-eligible 节点可以参加选主流程，成为 Master 节点</li><li>当第一个节点启动时，自动被选举成为 Master 节点</li><li>每个节点上都保存了集群的状态，只有 Master 节点才能修改集群的状态信息<ul><li>集群状态（Cluster State），维护了一个集群中，必要的信息<ul><li>所有的节点信息</li><li>所有的索引和其相关的 Mapping 与 Setting 信息</li><li>分片的路由信息</li></ul></li></ul></li></ul><h4 id="Data-Node"><a href="#Data-Node" class="headerlink" title="Data Node"></a>Data Node</h4><p>保存分片数据</p><h4 id="Coordinating-Node"><a href="#Coordinating-Node" class="headerlink" title="Coordinating Node"></a>Coordinating Node</h4><p>负责接收 Client 的请求，将请求分发到合适的界定啊，最终把结果汇集到一起</p><p>每个节点默认都起到了 Coordinating Node 的职责</p><h4 id="其他节点"><a href="#其他节点" class="headerlink" title="其他节点"></a>其他节点</h4><ul><li>Hot &amp; Warm Node<ul><li>冷热节点</li></ul></li><li>Machine Learning Node<ul><li>用来跑机器学习的 Job，异常检测</li></ul></li><li>Tribe Node<ul><li>Tribe Node 连接到不同的 Elasticsearch 集群，并且支持将这些集群当成一个单独的集群处理</li></ul></li></ul><h4 id="配置节点类型"><a href="#配置节点类型" class="headerlink" title="配置节点类型"></a>配置节点类型</h4><ul><li>开发环境中一个节点可设置多种类型</li><li>生产环境中建议设置为单一节点</li></ul><h3 id="分片（Primary-Shard-amp-Replica-Shard）"><a href="#分片（Primary-Shard-amp-Replica-Shard）" class="headerlink" title="分片（Primary Shard &amp; Replica Shard）"></a>分片（Primary Shard &amp; Replica Shard）</h3><ul><li>主分片，用以解决数据水平扩展的问题，通过主分片，可以将数据分布到集群内的所有节点上<ul><li>一个分片是一个运行的 Lucene 的实例</li><li>主分片数在索引创建时指定，后续不允许修改，除非 Reindex</li></ul></li><li>副本，用以解决数据高可用的问题。分片是主分片的拷贝<ul><li>副本分片数，可以动态调整</li><li>增加副本数，可以在一定程度上提高服务的可用性（读取的吞吐）</li></ul></li></ul><h4 id="分片的设定"><a href="#分片的设定" class="headerlink" title="分片的设定"></a>分片的设定</h4><ul><li>生产环境分片的设定，需要提前做好容量规划<ul><li>分片数量过小<ul><li>导致后续无法增加节点实现水平扩展</li><li>单个分片的数据量太大，导致数据重新分配耗时</li></ul></li><li>分片数设置过大，7.0 开始，默认主分片设置成 1 ，解决了 over-sharding 的问题<ul><li>影响搜索结果的相关性打分，影响统计结果的准确性</li><li>单个节点上过多的分片，会导致资源浪费，同时也会影响性能</li></ul></li></ul></li></ul><h4 id="查看集群的健康状况"><a href="#查看集群的健康状况" class="headerlink" title="查看集群的健康状况"></a>查看集群的健康状况</h4><p>GET _cluster/health</p><ul><li>Green  主分片与副本都正常分配</li><li>Yellow 主分片正常，有副本分片未能正常分配</li><li>Red    有主分片未能分配 </li></ul><h2 id="11-文档的-CRUD-与批量操作"><a href="#11-文档的-CRUD-与批量操作" class="headerlink" title="11. 文档的 CRUD 与批量操作"></a>11. 文档的 CRUD 与批量操作</h2><h3 id="文档的-CRUD"><a href="#文档的-CRUD" class="headerlink" title="文档的 CRUD"></a>文档的 CRUD</h3><ul><li>Index</li><li>Create</li><li>Read</li><li>Update</li><li>Delete</li></ul><h3 id="Create-一个文档"><a href="#Create-一个文档" class="headerlink" title="Create 一个文档"></a>Create 一个文档</h3><ul><li>支持自动生成文档 ID  和指定文档 ID 两种方式</li><li>通过调用 “post /users/_doc”<ul><li>系统会自动生成 document ID</li></ul></li><li>使用 HTTP PU user/_create/1 创建时，URI 中显示指定 _create，此时如果该 id 的文档已经存在，操作失败</li></ul><h3 id="Get-一个文档"><a href="#Get-一个文档" class="headerlink" title="Get 一个文档"></a>Get 一个文档</h3><ul><li>找到文档，返回 HTTP 200<ul><li>文档元信息<ul><li>_index / _type /</li><li>版本信息，同一个 ID 的文档，即使别删除，Version 号也会不断增加</li><li>_source 中默认包含了文档的所有原始信息</li></ul></li></ul></li><li>找不到文档，返回 HTTP 404</li></ul><h3 id="Index-文档"><a href="#Index-文档" class="headerlink" title="Index 文档"></a>Index 文档</h3><ul><li>Index 和 Create 不一样的地方：如果文档不存在，就索引新的文档。否则现有文档会被删除，新的文档被索引，版本信息 +1</li></ul><h3 id="Update-文档"><a href="#Update-文档" class="headerlink" title="Update 文档"></a>Update 文档</h3><ul><li>Update 方法不会删除原来的文档，而是实现真正的数据更新</li><li>Post 方法  / Payload 需要包含在 “doc” 中</li></ul><h3 id="Bulk-API"><a href="#Bulk-API" class="headerlink" title="Bulk API"></a>Bulk API</h3><ul><li>支持在一次 API 调用中，对不同的索引进行操作</li><li>支持四种类型操作<ul><li>Index</li><li>Create</li><li>Update</li><li>Delete</li></ul></li><li>可以在 URI 中指定 Index，也可以在请求的 Payload 中进行</li><li>操作中单条操作失败，并不会影响其他操作</li><li>返回结果包括了每一条操作执行的结果</li></ul><h3 id="批量读取-mget"><a href="#批量读取-mget" class="headerlink" title="批量读取 - mget"></a>批量读取 - mget</h3><p>批量操作:，可以减少网络连接所产生的开销，提高性能。</p><pre><code class="hljs json">GET /_mget&#123;    <span class="hljs-attr">&quot;docs&quot;</span>: [    &#123;        <span class="hljs-attr">&quot;_index&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>,        <span class="hljs-attr">&quot;_id&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>    &#125;,    &#123;        <span class="hljs-attr">&quot;_index&quot;</span>: <span class="hljs-string">&quot;comment&quot;</span>,        <span class="hljs-attr">&quot;_id&quot;</span>: <span class="hljs-string">&quot;2&quot;</span>    &#125;    ]&#125;</code></pre><h3 id="批量查询-msearch"><a href="#批量查询-msearch" class="headerlink" title="批量查询 - msearch"></a>批量查询 - msearch</h3><h3 id="常见错误返回"><a href="#常见错误返回" class="headerlink" title="常见错误返回"></a>常见错误返回</h3><table><thead><tr><th>问题</th><th>原因</th></tr></thead><tbody><tr><td>无法连接</td><td>网络故障或集群挂了</td></tr><tr><td>连接无法关闭</td><td>网络故障或节点出错</td></tr><tr><td>429</td><td>集群过于繁忙</td></tr><tr><td>4xx</td><td>请求体格式有错</td></tr><tr><td>500</td><td>集群内部错误</td></tr></tbody></table><h3 id="Resume"><a href="#Resume" class="headerlink" title="Resume"></a>Resume</h3><p>注意： 批量操作时不要发送大量数据</p><h2 id="12-倒排索引"><a href="#12-倒排索引" class="headerlink" title="12. 倒排索引"></a>12. 倒排索引</h2><h3 id="正排，倒排"><a href="#正排，倒排" class="headerlink" title="正排，倒排"></a>正排，倒排</h3><ul><li>正排，目录</li><li>倒排，单词 -&gt; 统计次数 -&gt; 文档号：位置</li></ul><h3 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a>核心组成</h3><ul><li>单词词典（Term Dictionary），记录所有文档的单词，记录单词倒排列表的关联关系<ul><li>单词词典一般比较大，可以通过 B+ 树或哈希拉链法实现，以满足高性能的插入与查询</li></ul></li><li>倒排列表（Posting List），记录了单词对应的文档结合，由倒排索引组成<ul><li>倒排索引项（Posting）<ul><li>文档 ID</li><li>词频 TF ，该单词在文档中出现的次数，用于相关性评分</li><li>位置（Position），单词在文档中分词的位置。用于语句搜索（phrase query）‘</li><li>偏移（Offset），记录单词的开始结束位置，实现高亮显示</li></ul></li></ul></li></ul><h3 id="Elasticsearch-的倒排索引"><a href="#Elasticsearch-的倒排索引" class="headerlink" title="Elasticsearch 的倒排索引"></a>Elasticsearch 的倒排索引</h3><ul><li>Elasticsearch 的 JSON 文档中的每个字段，都有自己的倒排索引</li><li>可以指定对某些字段不做索引<ul><li>优点：节省存储空间</li><li>缺点：字段无法被搜索</li></ul></li></ul><h2 id="13-通过-Analyzer-进行分词"><a href="#13-通过-Analyzer-进行分词" class="headerlink" title="13. 通过 Analyzer 进行分词"></a>13. 通过 Analyzer 进行分词</h2><h3 id="Analysis-与-Analyzer"><a href="#Analysis-与-Analyzer" class="headerlink" title="Analysis 与 Analyzer"></a>Analysis 与 Analyzer</h3><ul><li>分词</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>Character Filters — 针对原始文本处理，去除 HTML</li><li>Tokenizer — 按照规则切分为单词</li><li>Token Filters — 将切分的单词进行加工，小写，删除 stopwords，增加同义词</li></ul><h3 id="Elasticsearch-的内置分词器"><a href="#Elasticsearch-的内置分词器" class="headerlink" title="Elasticsearch 的内置分词器"></a>Elasticsearch 的内置分词器</h3><ul><li>Standard Analyzer — 默认分词器，按词切分，小写处理</li><li>Simple Analyzer — 按照非字母切分（符号被过滤），小写处理</li><li>Stop Analyzer — 小写处理，停用词过滤（the, a, is）</li><li>Whitespace Analyzer – 按照空格切分，不转小写</li><li>Keyword Analyzer — 不分词，直接将输入当作输出</li><li>Patter Analyzer — 正则表达式，默认 \W+ （非字符分隔）</li><li>Language — 提供了 30 多种常见语言的分词器</li><li>Customer Analyzer — 自定义分词器</li></ul><h3 id="使用-analyzer-API"><a href="#使用-analyzer-API" class="headerlink" title="使用 _analyzer API"></a>使用 _analyzer API</h3><ul><li>直接指定 Analyzer 进行测试</li><li>指定索引的字段进行测试</li><li>自定义分词器进行测试</li></ul><h3 id="Standard-Analyzer"><a href="#Standard-Analyzer" class="headerlink" title="Standard Analyzer"></a>Standard Analyzer</h3><ul><li>默认分词器</li><li>按词切分</li><li>小写处理</li></ul><h3 id="Simple-Analyzer"><a href="#Simple-Analyzer" class="headerlink" title="Simple Analyzer"></a>Simple Analyzer</h3><ul><li>按照非字母切分，非字母的都被去除</li><li>小写处理</li></ul><h3 id="Whitespace-Analyzer"><a href="#Whitespace-Analyzer" class="headerlink" title="Whitespace Analyzer"></a>Whitespace Analyzer</h3><ul><li>按照空格切分</li></ul><h3 id="Stop-Analyzer"><a href="#Stop-Analyzer" class="headerlink" title="Stop Analyzer"></a>Stop Analyzer</h3><ul><li>相比 Simple Analyzer 多了 stop filter<ul><li>会把 the, a, is 等修饰性词去除</li></ul></li></ul><h3 id="Keyword-Analyzer"><a href="#Keyword-Analyzer" class="headerlink" title="Keyword Analyzer"></a>Keyword Analyzer</h3><ul><li>不分词，直接将输入当一个 term 输出</li></ul><h3 id="Pattern-Analyzer"><a href="#Pattern-Analyzer" class="headerlink" title="Pattern Analyzer"></a>Pattern Analyzer</h3><ul><li>通过正则表达式进行分词</li><li>默认 \W+ ，非字符的符号进行分割</li><li>小写处理</li></ul><h3 id="Language-Analyzer"><a href="#Language-Analyzer" class="headerlink" title="Language Analyzer"></a>Language Analyzer</h3><ul><li>指定语言</li></ul><h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><ul><li><p>切分为一个词，而不是一个字</p></li><li><p>ICU Analyzer</p><ul><li>需要安装 plugin</li><li>支持 Unicode 支持，对亚洲语言有更好的处理</li></ul></li><li><p>更多的中文分词器</p><ul><li>IK  支持自定义词库</li><li>THULAC  清华</li></ul></li></ul><h2 id="14-Search-API-概览"><a href="#14-Search-API-概览" class="headerlink" title="14. Search API 概览"></a>14. Search API 概览</h2><ul><li>URI Search<ul><li>在 URL 中使用查询参数</li></ul></li><li>Request Body Search<ul><li>使用 Elasticsearch 提供的，基于 JSON 格式的更加完备的 Query Domain Specific Language（DSL）</li></ul></li></ul><h3 id="指定查询的索引"><a href="#指定查询的索引" class="headerlink" title="指定查询的索引"></a>指定查询的索引</h3><table><thead><tr><th>语法</th><th>范围</th></tr></thead><tbody><tr><td>/_search</td><td>集群上所有的索引</td></tr><tr><td>/index1/_search</td><td>index1</td></tr><tr><td>/index1,index-2/_search</td><td>index1 和 index2</td></tr><tr><td>/index*/_search</td><td>以 index 开头的索引</td></tr></tbody></table><h3 id="URI-查询"><a href="#URI-查询" class="headerlink" title="URI 查询"></a>URI 查询</h3><ul><li>使用 “q”，指定查询字符串</li><li>“query string syntax”， KV 键值对</li></ul><pre><code class="hljs shell">curl -XGET &quot;http://elasticsearch:9200/kibana_sample_data_ecommerce/_search?q=customer_first_name:Eddie&quot;</code></pre><p>Request Body</p><pre><code class="hljs shell">curl -XGET &quot;http://elasticsearch:9200/kibana_sample_data_ecommerce/_search&quot; -H &quot;&#x27;Content-Type:application/json&#x27; -d&quot;&#123;  &quot;query&quot;:&#123;    &quot;match_all&quot;:&#123;&#125;  &#125;&#125;</code></pre><p>搜索 Reponse</p><ul><li>took 花费的时间</li><li>total 复合条件的总文档数</li><li>hints 结果集，默认前 10 个文档</li><li>_index 索引名</li><li>_id 文档的 id</li><li>_score 相关度评分</li><li>_source 文档原始信息</li></ul><h3 id="搜索的相关性"><a href="#搜索的相关性" class="headerlink" title="搜索的相关性"></a>搜索的相关性</h3><ul><li>搜索是用户和所搜引擎的对话</li><li>用户关心的搜索结果的相关性<ul><li>是否可以找到所有相关的内容</li><li>有多少不相关的内容被返回了</li><li>文档的打分是否合理</li><li>结合业务需求，平衡结果排名</li></ul></li></ul><h3 id="衡量相关性"><a href="#衡量相关性" class="headerlink" title="衡量相关性"></a>衡量相关性</h3><ul><li>information retrieval<ul><li>Percision（查准率）  尽可能返回较少的无关文档</li><li>Recall（查全率）  尽可能返回较多的相关文档</li><li>Ranking  是否能够按照相关度进行排序</li></ul></li></ul><h2 id="15-URI-Search"><a href="#15-URI-Search" class="headerlink" title="15. URI Search"></a>15. URI Search</h2><p>通过 URI query 实现搜索</p><ul><li>q 指定查询语句，使用 Query String Synctax</li><li>df 默认字段，不指定时，会对所有字段进行查询</li><li>Sort 排序 / from 和 size 用于分页</li><li>Profile 可以查看查询是如何被执行的</li></ul><h3 id="Query-String-Synctax（1）"><a href="#Query-String-Synctax（1）" class="headerlink" title="Query String Synctax（1）"></a>Query String Synctax（1）</h3><ul><li>指定字段 v.s 泛查询<ul><li>q=title:2012 / q=2012</li></ul></li><li>Term v.s Phrase<ul><li>Beautiful Mind — 等效于 Beautiful OR Mind</li><li>“Beautiful Mind” — 等效于 Beautiful AND Mind。Phrase 查询，还要求前后保持一致</li></ul></li><li>分组与引号<ul><li>title:(Beautiful AND Mind)</li><li>title=”Beautiful Mind”</li></ul></li></ul><h3 id="Query-String-Synctax（2）"><a href="#Query-String-Synctax（2）" class="headerlink" title="Query String Synctax（2）"></a>Query String Synctax（2）</h3><ul><li>布尔操作</li><li>分组</li></ul><h3 id="Query-String-Synctax（3）"><a href="#Query-String-Synctax（3）" class="headerlink" title="Query String Synctax（3）"></a>Query String Synctax（3）</h3><ul><li>范围查询<ul><li>区间表示：[] 闭区间，{} 开区间<ul><li>year:{2019 TO 2018}</li><li>year:[* TO 2018]</li></ul></li></ul></li><li>算术符号<ul><li>year:&gt;2010</li><li>year:(&gt;2010 &amp;&amp; &lt;=2018)</li></ul></li></ul><h3 id="Query-String-Synctax（4）"><a href="#Query-String-Synctax（4）" class="headerlink" title="Query String Synctax（4）"></a>Query String Synctax（4）</h3><ul><li>通配符查询（通配符查询效率低，占用内存大，不建议使用。特别是放在最前面）<ul><li>? 代表 1 个字符， * 代表 0 或多个字符</li></ul></li><li>正则表达<ul><li>title:[bt]oy</li></ul></li><li>模糊匹配与近似度查询<ul><li>tiltle:befutifl~1</li><li>title:”lord rings”~2</li></ul></li></ul><h2 id="16-Request-Body-与-Query-DSL"><a href="#16-Request-Body-与-Query-DSL" class="headerlink" title="16. Request Body 与 Query DSL"></a>16. Request Body 与 Query DSL</h2><h3 id="Request-Body-Search"><a href="#Request-Body-Search" class="headerlink" title="Request Body Search"></a>Request Body Search</h3><ul><li>将查询语句通过 HTTP Request Body 发送给 Elasticsearch </li><li>Query DSL<ul><li>sort</li></ul></li></ul><h3 id="source-filltering"><a href="#source-filltering" class="headerlink" title="_source filltering"></a>_source filltering</h3><h3 id="脚本字段"><a href="#脚本字段" class="headerlink" title="脚本字段"></a>脚本字段</h3><h3 id="使用查询表达式-Match"><a href="#使用查询表达式-Match" class="headerlink" title="使用查询表达式 - Match"></a>使用查询表达式 - Match</h3><h3 id="短语搜索-Match-Phrase"><a href="#短语搜索-Match-Phrase" class="headerlink" title="短语搜索 - Match Phrase"></a>短语搜索 - Match Phrase</h3><p>operator: and、slop</p><h2 id="17-Query-String-与-Simple-Query-String-查询"><a href="#17-Query-String-与-Simple-Query-String-查询" class="headerlink" title="17. Query String 与 Simple Query String 查询"></a>17. Query String 与 Simple Query String 查询</h2><h2 id="18-Dynamic-Mapping-与常见字段类型"><a href="#18-Dynamic-Mapping-与常见字段类型" class="headerlink" title="18. Dynamic Mapping 与常见字段类型"></a>18. Dynamic Mapping 与常见字段类型</h2><ul><li><p>mapping</p><ul><li>定义索引中的字段的名称</li></ul></li><li><p>类型自动识别</p><ul><li>JSON 类型</li></ul></li><li><p>mapping  true  false strict</p></li></ul><h2 id="19-显示-Mapping-设置与常见参数介绍"><a href="#19-显示-Mapping-设置与常见参数介绍" class="headerlink" title="19. 显示 Mapping 设置与常见参数介绍"></a>19. 显示 Mapping 设置与常见参数介绍</h2><ul><li><p>对字段设置 index 为 false，不建立倒排索引</p></li><li><p>copy_to</p></li></ul><h2 id="20-多字段特性及-mapping-中自定义-Analyzer"><a href="#20-多字段特性及-mapping-中自定义-Analyzer" class="headerlink" title="20. 多字段特性及 mapping 中自定义 Analyzer"></a>20. 多字段特性及 mapping 中自定义 Analyzer</h2><h3 id="多字段类型"><a href="#多字段类型" class="headerlink" title="多字段类型"></a>多字段类型</h3><p>keyword</p><p>text</p><p>精确值不需要被分词处理</p><h3 id="自定义分词"><a href="#自定义分词" class="headerlink" title="自定义分词"></a>自定义分词</h3><ul><li>Character Filters</li><li>Tokenizer</li><li>Token Filters</li></ul><h2 id="21-Index-Template-与-Dynamic-Template"><a href="#21-Index-Template-与-Dynamic-Template" class="headerlink" title="21. Index Template 与 Dynamic Template"></a>21. Index Template 与 Dynamic Template</h2><p>Index Template 帮助你设定 mappings 和 Settings，并按照一定的规则，自动匹配到新索引</p><h3 id="Dynamic-Template"><a href="#Dynamic-Template" class="headerlink" title="Dynamic Template"></a>Dynamic Template</h3><h2 id="22-聚合分析"><a href="#22-聚合分析" class="headerlink" title="22. 聚合分析"></a>22. 聚合分析</h2><h3 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h3><ul><li><p>实时性高，性能高</p></li><li><p>得到一个数据的概览</p></li><li><p>可视化报表</p></li><li><p>分类</p><ul><li>Bucket</li><li>Metric</li><li>Pipeline</li><li>Matrix</li></ul></li></ul><h3 id="Bucket-amp-Metric"><a href="#Bucket-amp-Metric" class="headerlink" title="Bucket &amp; Metric"></a>Bucket &amp; Metric</h3><h4 id="Bucket"><a href="#Bucket" class="headerlink" title="Bucket"></a>Bucket</h4><ul><li>分桶</li></ul><h4 id="Metric"><a href="#Metric" class="headerlink" title="Metric"></a>Metric</h4><ul><li>基于数据集计算结果</li><li>avg  min  max</li></ul><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><h2 id="23-总结一"><a href="#23-总结一" class="headerlink" title="23. 总结一"></a>23. 总结一</h2><h2 id="24-基于词项和基于全文的查询"><a href="#24-基于词项和基于全文的查询" class="headerlink" title="24. 基于词项和基于全文的查询"></a>24. 基于词项和基于全文的查询</h2><h3 id="基于-Term-的查询"><a href="#基于-Term-的查询" class="headerlink" title="基于 Term 的查询"></a>基于 Term 的查询</h3><ul><li>是语义查询的最小单位</li><li>不会做分词</li></ul><p>跳过算分步骤，constant_score，提高系统性能</p><h3 id="基于全文的查询"><a href="#基于全文的查询" class="headerlink" title="基于全文的查询"></a>基于全文的查询</h3><ul><li>会进行分词</li><li>可以加入 Operator</li></ul><h2 id="25-结构化搜索"><a href="#25-结构化搜索" class="headerlink" title="25. 结构化搜索"></a>25. 结构化搜索</h2><p>Term 查询  包含而不是精确匹配</p><p>会算分</p><h2 id="26-搜索的相关性算分"><a href="#26-搜索的相关性算分" class="headerlink" title="26. 搜索的相关性算分"></a>26. 搜索的相关性算分</h2><p>词频 TF  </p><p>Stop World</p><p>DF 检索词在所有文档中出现的频率</p><p>逆文档频率 IDF</p><p>TF-IDF 香农理论</p><p>Lucene 中 TF-IDF 评分公式</p><p>BM 25  当TF 值增加到一定值，影响下降</p><p> Explain API 查看 TF-IDF</p><p>Boosting Relevance 参数</p><h2 id="27-Query-amp-Filtering-与多字符串多字段查询"><a href="#27-Query-amp-Filtering-与多字符串多字段查询" class="headerlink" title="27. Query&amp;Filtering 与多字符串多字段查询"></a>27. Query&amp;Filtering 与多字符串多字段查询</h2><p>bool 查询 must should must_not filter</p><pre><code class="hljs http">POST new/_search&#123;&quot;query&quot; &quot;boosting&quot;:   &quot;match&quot;     &quot;content&quot;&#125;</code></pre><p>支持嵌套</p><p>should 算分，结构会对算分产生影响</p><p>控制字段的 Boosting </p><h2 id="28-单字符串多字段查询"><a href="#28-单字符串多字段查询" class="headerlink" title="28. 单字符串多字段查询"></a>28. 单字符串多字段查询</h2><h2 id="36-配置集群搜索"><a href="#36-配置集群搜索" class="headerlink" title="36. 配置集群搜索"></a>36. 配置集群搜索</h2><h3 id="跨集群搜索-Cross-Cluster-Search"><a href="#跨集群搜索-Cross-Cluster-Search" class="headerlink" title="跨集群搜索 - Cross Cluster Search"></a>跨集群搜索 - Cross Cluster Search</h3><p>配置及查询</p><h2 id="选主与脑裂"><a href="#选主与脑裂" class="headerlink" title="选主与脑裂"></a>选主与脑裂</h2><p>Data Node  </p><p>通过增加数据节点，可以解决水平扩展问题</p><h2 id="分片与故障转移"><a href="#分片与故障转移" class="headerlink" title="分片与故障转移"></a>分片与故障转移</h2>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes,es</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELK</title>
    <link href="/2021/10/20/cloud/tmp/ELK/ELK/"/>
    <url>/2021/10/20/cloud/tmp/ELK/ELK/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="ELK"><a href="#ELK" class="headerlink" title="ELK"></a>ELK</h1><h2 id="基本"><a href="#基本" class="headerlink" title="基本"></a>基本</h2><h3 id="What"><a href="#What" class="headerlink" title="What"></a>What</h3><p>主要功能：</p><ul><li>分布式搜索引擎</li><li>大数据实时分析引擎</li></ul><p>目标：</p><ul><li>开发：产品基本功能，底层工作原理，数据建模最佳实践</li><li>运维：容量规划：性能优化，问题诊断，滚动升级</li><li>方案：搜索与如何解决搜索的相关性问题、大数据分析实践与项目实战，理论知识运用到实际场景</li></ul><p>Elastic 认证</p><p>内容：</p><ul><li>环境搭建</li><li>数据分析</li><li>集群管理</li><li>实践</li></ul><h2 id="简介、历史"><a href="#简介、历史" class="headerlink" title="简介、历史"></a>简介、历史</h2><h3 id="安装与查看插件"><a href="#安装与查看插件" class="headerlink" title="安装与查看插件"></a>安装与查看插件</h3><pre><code class="hljs shell">docker network create elasticdocker pull docker.elastic.co/elasticsearch/elasticsearch:7.15.1docker run --name es01-test --net elastic -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; docker.elastic.co/elasticsearch/elasticsearch:7.15.1docker pull docker.elastic.co/kibana/kibana:7.15.1docker run --name kib01-test --net elastic -p 5601:5601 -e &quot;ELASTICSEARCH_HOSTS=http://es01-test:9200&quot; docker.elastic.co/kibana/kibana:7.15.1</code></pre><pre><code class="hljs sh">docker pull docker.elastic.co/logstash/logstash:7.15.1</code></pre><pre><code class="hljs shell">bin/elasticsearch-plugin listbin/elasticsearch-plugin install</code></pre><h3 id="运行多个-Elasticsearch-实例"><a href="#运行多个-Elasticsearch-实例" class="headerlink" title="运行多个 Elasticsearch 实例"></a>运行多个 Elasticsearch 实例</h3><pre><code class="hljs shell">/bin/elasticsearch -E node.name=node1 -E cluster.name=test -E path.data=node1_data -d/bin/elasticsearch -E node.name=node1 -E cluster.name=test -E path.data=node2_data -d/bin/elasticsearch -E node.name=node1 -E cluster.name=test -E path.data=node3_data -d</code></pre><p>删除进程</p><pre><code class="hljs shell">ps |grep elasticsearchkill pid</code></pre><p>查看节点</p><p>_cat/nodes</p><h3 id="Kibana"><a href="#Kibana" class="headerlink" title="Kibana"></a>Kibana</h3><h4 id="Dev-Tools"><a href="#Dev-Tools" class="headerlink" title="Dev Tools"></a>Dev Tools</h4><p>快捷键</p><p>kibana-plugin install plugin_location</p><h4 id="在-Docker-中运行-Elasticsearch-Kibana-和-Cerebro"><a href="#在-Docker-中运行-Elasticsearch-Kibana-和-Cerebro" class="headerlink" title="在 Docker 中运行 Elasticsearch Kibana 和 Cerebro"></a>在 Docker 中运行 Elasticsearch Kibana 和 Cerebro</h4><h3 id="Logstash"><a href="#Logstash" class="headerlink" title="Logstash"></a>Logstash</h3><p>bin/logstash -f logstash.conf</p><h2 id="基本概念：索引、文档和-RESTFul-API"><a href="#基本概念：索引、文档和-RESTFul-API" class="headerlink" title="基本概念：索引、文档和 RESTFul API"></a>基本概念：索引、文档和 RESTFul API</h2><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul><li>Elasticsearch 是面向文档的，文档是所有可搜索数据的最小单位</li><li></li></ul><p>文档的元数据</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>Index - 文档的容器，是一类文档的结合</li><li>索引的 Mapping 和 Settings</li></ul><p>索引的不同语义</p><ul><li>名词：</li><li>动词 保存文档</li><li>名称：一个 B 树索引，一个倒排索引</li></ul><p>TYPE：7.0 一个 Index 可以设置成多个 Types</p><h3 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h3><p>通过 HTTP 请求</p><p>基本 API</p><h2 id="基本概念：节点、集群、分片"><a href="#基本概念：节点、集群、分片" class="headerlink" title="基本概念：节点、集群、分片"></a>基本概念：节点、集群、分片</h2><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><ul><li>是一个 Elasticsearch  的实例<ul><li>本质上就是一个 Java 进程</li></ul></li><li>每个节点都有名字，通过配置文件配置，或者启动时候 -E node.name=node1 指定</li><li>每个节点在启动之后，会分配一个 UID，保存在 data 目录下</li></ul><h4 id="Master-eligible-nodes-和-Master-Node"><a href="#Master-eligible-nodes-和-Master-Node" class="headerlink" title="Master-eligible nodes 和 Master Node"></a>Master-eligible nodes 和 Master Node</h4><ul><li>每个节点启动后，默认就是一个 Master eligible 节点，可以设置 node.master: false 禁止</li><li>Master-eligible 节点可以参加选主流程，成为 Master 节点</li><li>当第一个节点启动时，自动被选举成为 Master 节点</li><li>每个节点上都保存了集群的状态，只有 Master 节点才能修改集群的状态信息<ul><li>集群状态（Cluster State），维护了一个集群中，必要的信息<ul><li>所有的节点信息</li><li>所有的索引和其相关的 Mapping 与 Setting 信息</li><li>分片的路由信息</li></ul></li></ul></li></ul><h4 id="Data-Node"><a href="#Data-Node" class="headerlink" title="Data Node"></a>Data Node</h4><p>保存分片数据</p><h4 id="Coordinating-Node"><a href="#Coordinating-Node" class="headerlink" title="Coordinating Node"></a>Coordinating Node</h4><p>负责接收 Client 的请求，将请求分发到合适的界定啊，最终把结果汇集到一起</p><p>每个节点默认都起到了 Coordinating Node 的职责</p><h4 id="其他节点"><a href="#其他节点" class="headerlink" title="其他节点"></a>其他节点</h4><ul><li>Hot &amp; Warm Node<ul><li>冷热节点</li></ul></li><li>Machine Learning Node<ul><li>用来跑机器学习的 Job，异常检测</li></ul></li><li>Tribe Node<ul><li>Tribe Node 连接到不同的 Elasticsearch 集群，并且支持将这些集群当成一个单独的集群处理</li></ul></li></ul><h4 id="配置节点类型"><a href="#配置节点类型" class="headerlink" title="配置节点类型"></a>配置节点类型</h4><ul><li>开发环境中一个节点可设置多种类型</li><li>生产环境中建议设置为单一节点</li></ul><h3 id="分片（Primary-Shard-amp-Replica-Shard）"><a href="#分片（Primary-Shard-amp-Replica-Shard）" class="headerlink" title="分片（Primary Shard &amp; Replica Shard）"></a>分片（Primary Shard &amp; Replica Shard）</h3><ul><li>主分片，用以解决数据水平扩展的问题，通过主分片，可以将数据分布到集群内的所有节点上<ul><li>一个分片是一个运行的 Lucene 的实例</li><li>主分片数在索引创建时指定，后续不允许修改，除非 Reindex</li></ul></li><li>副本，用以解决数据高可用的问题。分片是主分片的拷贝<ul><li>副本分片数，可以动态调整</li><li>增加副本数，可以在一定程度上提高服务的可用性（读取的吞吐）</li></ul></li></ul><h4 id="分片的设定"><a href="#分片的设定" class="headerlink" title="分片的设定"></a>分片的设定</h4><ul><li>生产环境分片的设定，需要提前做好容量规划<ul><li>分片数量过小<ul><li>导致后续无法增加节点实现水平扩展</li><li>单个分片的数据量太大，导致数据重新分配耗时</li></ul></li><li>分片数设置过大，7.0 开始，默认主分片设置成 1 ，解决了 over-sharding 的问题<ul><li>影响搜索结果的相关性打分，影响统计结果的准确性</li><li>单个节点上过多的分片，会导致资源浪费，同时也会影响性能</li></ul></li></ul></li></ul><h4 id="查看集群的健康状况"><a href="#查看集群的健康状况" class="headerlink" title="查看集群的健康状况"></a>查看集群的健康状况</h4><p>GET _cluster/health</p><ul><li>Green  主分片与副本都正常分配</li><li>Yellow 主分片正常，有副本分片未能正常分配</li><li>Red    有主分片未能分配 </li></ul><h2 id="11-文档的-CRUD-与批量操作"><a href="#11-文档的-CRUD-与批量操作" class="headerlink" title="11. 文档的 CRUD 与批量操作"></a>11. 文档的 CRUD 与批量操作</h2><h3 id="文档的-CRUD"><a href="#文档的-CRUD" class="headerlink" title="文档的 CRUD"></a>文档的 CRUD</h3><ul><li>Index</li><li>Create</li><li>Read</li><li>Update</li><li>Delete</li></ul><h3 id="Create-一个文档"><a href="#Create-一个文档" class="headerlink" title="Create 一个文档"></a>Create 一个文档</h3><ul><li>支持自动生成文档 ID  和指定文档 ID 两种方式</li><li>通过调用 “post /users/_doc”<ul><li>系统会自动生成 document ID</li></ul></li><li>使用 HTTP PU user/_create/1 创建时，URI 中显示指定 _create，此时如果该 id 的文档已经存在，操作失败</li></ul><h3 id="Get-一个文档"><a href="#Get-一个文档" class="headerlink" title="Get 一个文档"></a>Get 一个文档</h3><ul><li>找到文档，返回 HTTP 200<ul><li>文档元信息<ul><li>_index / _type /</li><li>版本信息，同一个 ID 的文档，即使别删除，Version 号也会不断增加</li><li>_source 中默认包含了文档的所有原始信息</li></ul></li></ul></li><li>找不到文档，返回 HTTP 404</li></ul><h3 id="Index-文档"><a href="#Index-文档" class="headerlink" title="Index 文档"></a>Index 文档</h3><ul><li>Index 和 Create 不一样的地方：如果文档不存在，就索引新的文档。否则现有文档会被删除，新的文档被索引，版本信息 +1</li></ul><h3 id="Update-文档"><a href="#Update-文档" class="headerlink" title="Update 文档"></a>Update 文档</h3><ul><li>Update 方法不会删除原来的文档，而是实现真正的数据更新</li><li>Post 方法  / Payload 需要包含在 “doc” 中</li></ul><h3 id="Bulk-API"><a href="#Bulk-API" class="headerlink" title="Bulk API"></a>Bulk API</h3><ul><li>支持在一次 API 调用中，对不同的索引进行操作</li><li>支持四种类型操作<ul><li>Index</li><li>Create</li><li>Update</li><li>Delete</li></ul></li><li>可以在 URI 中指定 Index，也可以在请求的 Payload 中进行</li><li>操作中单条操作失败，并不会影响其他操作</li><li>返回结果包括了每一条操作执行的结果</li></ul><h3 id="批量读取-mget"><a href="#批量读取-mget" class="headerlink" title="批量读取 - mget"></a>批量读取 - mget</h3><p>批量操作:，可以减少网络连接所产生的开销，提高性能。</p><pre><code class="hljs json">GET /_mget&#123;    <span class="hljs-attr">&quot;docs&quot;</span>: [    &#123;        <span class="hljs-attr">&quot;_index&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>,        <span class="hljs-attr">&quot;_id&quot;</span>: <span class="hljs-string">&quot;1&quot;</span>    &#125;,    &#123;        <span class="hljs-attr">&quot;_index&quot;</span>: <span class="hljs-string">&quot;comment&quot;</span>,        <span class="hljs-attr">&quot;_id&quot;</span>: <span class="hljs-string">&quot;2&quot;</span>    &#125;    ]&#125;</code></pre><h3 id="批量查询-msearch"><a href="#批量查询-msearch" class="headerlink" title="批量查询 - msearch"></a>批量查询 - msearch</h3><h3 id="常见错误返回"><a href="#常见错误返回" class="headerlink" title="常见错误返回"></a>常见错误返回</h3><table><thead><tr><th>问题</th><th>原因</th></tr></thead><tbody><tr><td>无法连接</td><td>网络故障或集群挂了</td></tr><tr><td>连接无法关闭</td><td>网络故障或节点出错</td></tr><tr><td>429</td><td>集群过于繁忙</td></tr><tr><td>4xx</td><td>请求体格式有错</td></tr><tr><td>500</td><td>集群内部错误</td></tr></tbody></table><h3 id="Resume"><a href="#Resume" class="headerlink" title="Resume"></a>Resume</h3><p>注意： 批量操作时不要发送大量数据</p><h2 id="12-倒排索引"><a href="#12-倒排索引" class="headerlink" title="12. 倒排索引"></a>12. 倒排索引</h2><h3 id="正排，倒排"><a href="#正排，倒排" class="headerlink" title="正排，倒排"></a>正排，倒排</h3><ul><li>正排，目录</li><li>倒排，单词 -&gt; 统计次数 -&gt; 文档号：位置</li></ul><h3 id="核心组成"><a href="#核心组成" class="headerlink" title="核心组成"></a>核心组成</h3><ul><li>单词词典（Term Dictionary），记录所有文档的单词，记录单词倒排列表的关联关系<ul><li>单词词典一般比较大，可以通过 B+ 树或哈希拉链法实现，以满足高性能的插入与查询</li></ul></li><li>倒排列表（Posting List），记录了单词对应的文档结合，由倒排索引组成<ul><li>倒排索引项（Posting）<ul><li>文档 ID</li><li>词频 TF ，该单词在文档中出现的次数，用于相关性评分</li><li>位置（Position），单词在文档中分词的位置。用于语句搜索（phrase query）‘</li><li>偏移（Offset），记录单词的开始结束位置，实现高亮显示</li></ul></li></ul></li></ul><h3 id="Elasticsearch-的倒排索引"><a href="#Elasticsearch-的倒排索引" class="headerlink" title="Elasticsearch 的倒排索引"></a>Elasticsearch 的倒排索引</h3><ul><li>Elasticsearch 的 JSON 文档中的每个字段，都有自己的倒排索引</li><li>可以指定对某些字段不做索引<ul><li>优点：节省存储空间</li><li>缺点：字段无法被搜索</li></ul></li></ul><h2 id="13-通过-Analyzer-进行分词"><a href="#13-通过-Analyzer-进行分词" class="headerlink" title="13. 通过 Analyzer 进行分词"></a>13. 通过 Analyzer 进行分词</h2><h3 id="Analysis-与-Analyzer"><a href="#Analysis-与-Analyzer" class="headerlink" title="Analysis 与 Analyzer"></a>Analysis 与 Analyzer</h3><ul><li>分词</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><ul><li>Character Filters — 针对原始文本处理，去除 HTML</li><li>Tokenizer — 按照规则切分为单词</li><li>Token Filters — 将切分的单词进行加工，小写，删除 stopwords，增加同义词</li></ul><h3 id="Elasticsearch-的内置分词器"><a href="#Elasticsearch-的内置分词器" class="headerlink" title="Elasticsearch 的内置分词器"></a>Elasticsearch 的内置分词器</h3><ul><li>Standard Analyzer — 默认分词器，按词切分，小写处理</li><li>Simple Analyzer — 按照非字母切分（符号被过滤），小写处理</li><li>Stop Analyzer — 小写处理，停用词过滤（the, a, is）</li><li>Whitespace Analyzer – 按照空格切分，不转小写</li><li>Keyword Analyzer — 不分词，直接将输入当作输出</li><li>Patter Analyzer — 正则表达式，默认 \W+ （非字符分隔）</li><li>Language — 提供了 30 多种常见语言的分词器</li><li>Customer Analyzer — 自定义分词器</li></ul><h3 id="使用-analyzer-API"><a href="#使用-analyzer-API" class="headerlink" title="使用 _analyzer API"></a>使用 _analyzer API</h3><ul><li>直接指定 Analyzer 进行测试</li><li>指定索引的字段进行测试</li><li>自定义分词器进行测试</li></ul><h3 id="Standard-Analyzer"><a href="#Standard-Analyzer" class="headerlink" title="Standard Analyzer"></a>Standard Analyzer</h3><ul><li>默认分词器</li><li>按词切分</li><li>小写处理</li></ul><h3 id="Simple-Analyzer"><a href="#Simple-Analyzer" class="headerlink" title="Simple Analyzer"></a>Simple Analyzer</h3><ul><li>按照非字母切分，非字母的都被去除</li><li>小写处理</li></ul><h3 id="Whitespace-Analyzer"><a href="#Whitespace-Analyzer" class="headerlink" title="Whitespace Analyzer"></a>Whitespace Analyzer</h3><ul><li>按照空格切分</li></ul><h3 id="Stop-Analyzer"><a href="#Stop-Analyzer" class="headerlink" title="Stop Analyzer"></a>Stop Analyzer</h3><ul><li>相比 Simple Analyzer 多了 stop filter<ul><li>会把 the, a, is 等修饰性词去除</li></ul></li></ul><h3 id="Keyword-Analyzer"><a href="#Keyword-Analyzer" class="headerlink" title="Keyword Analyzer"></a>Keyword Analyzer</h3><ul><li>不分词，直接将输入当一个 term 输出</li></ul><h3 id="Pattern-Analyzer"><a href="#Pattern-Analyzer" class="headerlink" title="Pattern Analyzer"></a>Pattern Analyzer</h3><ul><li>通过正则表达式进行分词</li><li>默认 \W+ ，非字符的符号进行分割</li><li>小写处理</li></ul><h3 id="Language-Analyzer"><a href="#Language-Analyzer" class="headerlink" title="Language Analyzer"></a>Language Analyzer</h3><ul><li>指定语言</li></ul><h3 id="中文分词"><a href="#中文分词" class="headerlink" title="中文分词"></a>中文分词</h3><ul><li><p>切分为一个词，而不是一个字</p></li><li><p>ICU Analyzer</p><ul><li>需要安装 plugin</li><li>支持 Unicode 支持，对亚洲语言有更好的处理</li></ul></li><li><p>更多的中文分词器</p><ul><li>IK  支持自定义词库</li><li>THULAC  清华</li></ul></li></ul><h2 id="14-Search-API-概览"><a href="#14-Search-API-概览" class="headerlink" title="14. Search API 概览"></a>14. Search API 概览</h2><ul><li>URI Search<ul><li>在 URL 中使用查询参数</li></ul></li><li>Request Body Search<ul><li>使用 Elasticsearch 提供的，基于 JSON 格式的更加完备的 Query Domain Specific Language（DSL）</li></ul></li></ul><h3 id="指定查询的索引"><a href="#指定查询的索引" class="headerlink" title="指定查询的索引"></a>指定查询的索引</h3><table><thead><tr><th>语法</th><th>范围</th></tr></thead><tbody><tr><td>/_search</td><td>集群上所有的索引</td></tr><tr><td>/index1/_search</td><td>index1</td></tr><tr><td>/index1,index-2/_search</td><td>index1 和 index2</td></tr><tr><td>/index*/_search</td><td>以 index 开头的索引</td></tr></tbody></table><h3 id="URI-查询"><a href="#URI-查询" class="headerlink" title="URI 查询"></a>URI 查询</h3><ul><li>使用 “q”，指定查询字符串</li><li>“query string syntax”， KV 键值对</li></ul><pre><code class="hljs shell">curl -XGET &quot;http://elasticsearch:9200/kibana_sample_data_ecommerce/_search?q=customer_first_name:Eddie&quot;</code></pre><p>Request Body</p><pre><code class="hljs shell">curl -XGET &quot;http://elasticsearch:9200/kibana_sample_data_ecommerce/_search&quot; -H &quot;&#x27;Content-Type:application/json&#x27; -d&quot;&#123;  &quot;query&quot;:&#123;    &quot;match_all&quot;:&#123;&#125;  &#125;&#125;</code></pre><p>搜索 Reponse</p><ul><li>took 花费的时间</li><li>total 复合条件的总文档数</li><li>hints 结果集，默认前 10 个文档</li><li>_index 索引名</li><li>_id 文档的 id</li><li>_score 相关度评分</li><li>_source 文档原始信息</li></ul><h3 id="搜索的相关性"><a href="#搜索的相关性" class="headerlink" title="搜索的相关性"></a>搜索的相关性</h3><ul><li>搜索是用户和所搜引擎的对话</li><li>用户关心的搜索结果的相关性<ul><li>是否可以找到所有相关的内容</li><li>有多少不相关的内容被返回了</li><li>文档的打分是否合理</li><li>结合业务需求，平衡结果排名</li></ul></li></ul><h3 id="衡量相关性"><a href="#衡量相关性" class="headerlink" title="衡量相关性"></a>衡量相关性</h3><ul><li>information retrieval<ul><li>Percision（查准率）  尽可能返回较少的无关文档</li><li>Recall（查全率）  尽可能返回较多的相关文档</li><li>Ranking  是否能够按照相关度进行排序</li></ul></li></ul><h2 id="15-URI-Search"><a href="#15-URI-Search" class="headerlink" title="15. URI Search"></a>15. URI Search</h2><p>通过 URI query 实现搜索</p><ul><li>q 指定查询语句，使用 Query String Synctax</li><li>df 默认字段，不指定时，会对所有字段进行查询</li><li>Sort 排序 / from 和 size 用于分页</li><li>Profile 可以查看查询是如何被执行的</li></ul><h3 id="Query-String-Synctax（1）"><a href="#Query-String-Synctax（1）" class="headerlink" title="Query String Synctax（1）"></a>Query String Synctax（1）</h3><ul><li>指定字段 v.s 泛查询<ul><li>q=title:2012 / q=2012</li></ul></li><li>Term v.s Phrase<ul><li>Beautiful Mind — 等效于 Beautiful OR Mind</li><li>“Beautiful Mind” — 等效于 Beautiful AND Mind。Phrase 查询，还要求前后保持一致</li></ul></li><li>分组与引号<ul><li>title:(Beautiful AND Mind)</li><li>title=”Beautiful Mind”</li></ul></li></ul><h3 id="Query-String-Synctax（2）"><a href="#Query-String-Synctax（2）" class="headerlink" title="Query String Synctax（2）"></a>Query String Synctax（2）</h3><ul><li>布尔操作</li><li>分组</li></ul><h3 id="Query-String-Synctax（3）"><a href="#Query-String-Synctax（3）" class="headerlink" title="Query String Synctax（3）"></a>Query String Synctax（3）</h3><ul><li>范围查询<ul><li>区间表示：[] 闭区间，{} 开区间<ul><li>year:{2019 TO 2018}</li><li>year:[* TO 2018]</li></ul></li></ul></li><li>算术符号<ul><li>year:&gt;2010</li><li>year:(&gt;2010 &amp;&amp; &lt;=2018)</li></ul></li></ul><h3 id="Query-String-Synctax（4）"><a href="#Query-String-Synctax（4）" class="headerlink" title="Query String Synctax（4）"></a>Query String Synctax（4）</h3><ul><li>通配符查询（通配符查询效率低，占用内存大，不建议使用。特别是放在最前面）<ul><li>? 代表 1 个字符， * 代表 0 或多个字符</li></ul></li><li>正则表达<ul><li>title:[bt]oy</li></ul></li><li>模糊匹配与近似度查询<ul><li>tiltle:befutifl~1</li><li>title:”lord rings”~2</li></ul></li></ul><h2 id="16-Request-Body-与-Query-DSL"><a href="#16-Request-Body-与-Query-DSL" class="headerlink" title="16. Request Body 与 Query DSL"></a>16. Request Body 与 Query DSL</h2><h3 id="Request-Body-Search"><a href="#Request-Body-Search" class="headerlink" title="Request Body Search"></a>Request Body Search</h3><ul><li>将查询语句通过 HTTP Request Body 发送给 Elasticsearch </li><li>Query DSL<ul><li>sort</li></ul></li></ul><h3 id="source-filltering"><a href="#source-filltering" class="headerlink" title="_source filltering"></a>_source filltering</h3><h3 id="脚本字段"><a href="#脚本字段" class="headerlink" title="脚本字段"></a>脚本字段</h3><h3 id="使用查询表达式-Match"><a href="#使用查询表达式-Match" class="headerlink" title="使用查询表达式 - Match"></a>使用查询表达式 - Match</h3><h3 id="短语搜索-Match-Phrase"><a href="#短语搜索-Match-Phrase" class="headerlink" title="短语搜索 - Match Phrase"></a>短语搜索 - Match Phrase</h3><p>operator: and、slop</p><h2 id="17-Query-String-与-Simple-Query-String-查询"><a href="#17-Query-String-与-Simple-Query-String-查询" class="headerlink" title="17. Query String 与 Simple Query String 查询"></a>17. Query String 与 Simple Query String 查询</h2><h2 id="18-Dynamic-Mapping-与常见字段类型"><a href="#18-Dynamic-Mapping-与常见字段类型" class="headerlink" title="18. Dynamic Mapping 与常见字段类型"></a>18. Dynamic Mapping 与常见字段类型</h2><ul><li><p>mapping</p><ul><li>定义索引中的字段的名称</li></ul></li><li><p>类型自动识别</p><ul><li>JSON 类型</li></ul></li><li><p>mapping  true  false strict</p></li></ul><h2 id="19-显示-Mapping-设置与常见参数介绍"><a href="#19-显示-Mapping-设置与常见参数介绍" class="headerlink" title="19. 显示 Mapping 设置与常见参数介绍"></a>19. 显示 Mapping 设置与常见参数介绍</h2><ul><li><p>对字段设置 index 为 false，不建立倒排索引</p></li><li><p>copy_to</p></li></ul><h2 id="20-多字段特性及-mapping-中自定义-Analyzer"><a href="#20-多字段特性及-mapping-中自定义-Analyzer" class="headerlink" title="20. 多字段特性及 mapping 中自定义 Analyzer"></a>20. 多字段特性及 mapping 中自定义 Analyzer</h2><h3 id="多字段类型"><a href="#多字段类型" class="headerlink" title="多字段类型"></a>多字段类型</h3><p>keyword</p><p>text</p><p>精确值不需要被分词处理</p><h3 id="自定义分词"><a href="#自定义分词" class="headerlink" title="自定义分词"></a>自定义分词</h3><ul><li>Character Filters</li><li>Tokenizer</li><li>Token Filters</li></ul><h2 id="21-Index-Template-与-Dynamic-Template"><a href="#21-Index-Template-与-Dynamic-Template" class="headerlink" title="21. Index Template 与 Dynamic Template"></a>21. Index Template 与 Dynamic Template</h2><p>Index Template 帮助你设定 mappings 和 Settings，并按照一定的规则，自动匹配到新索引</p><h3 id="Dynamic-Template"><a href="#Dynamic-Template" class="headerlink" title="Dynamic Template"></a>Dynamic Template</h3><h2 id="22-聚合分析"><a href="#22-聚合分析" class="headerlink" title="22. 聚合分析"></a>22. 聚合分析</h2><h3 id="Aggregation"><a href="#Aggregation" class="headerlink" title="Aggregation"></a>Aggregation</h3><ul><li><p>实时性高，性能高</p></li><li><p>得到一个数据的概览</p></li><li><p>可视化报表</p></li><li><p>分类</p><ul><li>Bucket</li><li>Metric</li><li>Pipeline</li><li>Matrix</li></ul></li></ul><h3 id="Bucket-amp-Metric"><a href="#Bucket-amp-Metric" class="headerlink" title="Bucket &amp; Metric"></a>Bucket &amp; Metric</h3><h4 id="Bucket"><a href="#Bucket" class="headerlink" title="Bucket"></a>Bucket</h4><ul><li>分桶</li></ul><h4 id="Metric"><a href="#Metric" class="headerlink" title="Metric"></a>Metric</h4><ul><li>基于数据集计算结果</li><li>avg  min  max</li></ul><h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><h2 id="23-总结一"><a href="#23-总结一" class="headerlink" title="23. 总结一"></a>23. 总结一</h2><h2 id="24-基于词项和基于全文的查询"><a href="#24-基于词项和基于全文的查询" class="headerlink" title="24. 基于词项和基于全文的查询"></a>24. 基于词项和基于全文的查询</h2><h3 id="基于-Term-的查询"><a href="#基于-Term-的查询" class="headerlink" title="基于 Term 的查询"></a>基于 Term 的查询</h3><ul><li>是语义查询的最小单位</li><li>不会做分词</li></ul><p>跳过算分步骤，constant_score，提高系统性能</p><h3 id="基于全文的查询"><a href="#基于全文的查询" class="headerlink" title="基于全文的查询"></a>基于全文的查询</h3><ul><li>会进行分词</li><li>可以加入 Operator</li></ul><h2 id="25-结构化搜索"><a href="#25-结构化搜索" class="headerlink" title="25. 结构化搜索"></a>25. 结构化搜索</h2><p>Term 查询  包含而不是精确匹配</p><p>会算分</p><h2 id="26-搜索的相关性算分"><a href="#26-搜索的相关性算分" class="headerlink" title="26. 搜索的相关性算分"></a>26. 搜索的相关性算分</h2><p>词频 TF  </p><p>Stop World</p><p>DF 检索词在所有文档中出现的频率</p><p>逆文档频率 IDF</p><p>TF-IDF 香农理论</p><p>Lucene 中 TF-IDF 评分公式</p><p>BM 25  当TF 值增加到一定值，影响下降</p><p> Explain API 查看 TF-IDF</p><p>Boosting Relevance 参数</p><h2 id="27-Query-amp-Filtering-与多字符串多字段查询"><a href="#27-Query-amp-Filtering-与多字符串多字段查询" class="headerlink" title="27. Query&amp;Filtering 与多字符串多字段查询"></a>27. Query&amp;Filtering 与多字符串多字段查询</h2><p>bool 查询 must should must_not filter</p><pre><code class="hljs http">POST new/_search&#123;&quot;query&quot; &quot;boosting&quot;:   &quot;match&quot;     &quot;content&quot;&#125;</code></pre><p>支持嵌套</p><p>should 算分，结构会对算分产生影响</p><p>控制字段的 Boosting </p><h2 id="28-单字符串多字段查询"><a href="#28-单字符串多字段查询" class="headerlink" title="28. 单字符串多字段查询"></a>28. 单字符串多字段查询</h2><h2 id="36-配置集群搜索"><a href="#36-配置集群搜索" class="headerlink" title="36. 配置集群搜索"></a>36. 配置集群搜索</h2><h3 id="跨集群搜索-Cross-Cluster-Search"><a href="#跨集群搜索-Cross-Cluster-Search" class="headerlink" title="跨集群搜索 - Cross Cluster Search"></a>跨集群搜索 - Cross Cluster Search</h3><p>配置及查询</p><h2 id="选主与脑裂"><a href="#选主与脑裂" class="headerlink" title="选主与脑裂"></a>选主与脑裂</h2><p>Data Node  </p><p>通过增加数据节点，可以解决水平扩展问题</p><h2 id="分片与故障转移"><a href="#分片与故障转移" class="headerlink" title="分片与故障转移"></a>分片与故障转移</h2>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ELK, Stack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node &amp; Pod &amp; Container</title>
    <link href="/2021/10/19/cloud/tmp/k8s%E5%9F%BA%E7%A1%80/Node%20&amp;%20Pod%20&amp;%20Container/"/>
    <url>/2021/10/19/cloud/tmp/k8s%E5%9F%BA%E7%A1%80/Node%20&amp;%20Pod%20&amp;%20Container/</url>
    
    <content type="html"><![CDATA[<h1 id="Node-amp-Pod-amp-Container"><a href="#Node-amp-Pod-amp-Container" class="headerlink" title="Node &amp; Pod &amp; Container"></a>Node &amp; Pod &amp; Container</h1><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://linchpiner.github.io/k8s-multi-container-pods.html">Multi-Container Pods in Kubernetes</a></p><p><a href="https://www.ianlewis.org/en/almighty-pause-container">The Almighty Pause Container</a></p>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes,</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes(1-7)</title>
    <link href="/2021/10/15/cloud/K8S/k8s%E5%9F%BA%E7%A1%80/Kubernetes(1-7)/"/>
    <url>/2021/10/15/cloud/K8S/k8s%E5%9F%BA%E7%A1%80/Kubernetes(1-7)/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="1-初体验"><a href="#1-初体验" class="headerlink" title="1. 初体验"></a>1. 初体验</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ol><li>katacode </li><li>搭建 Rancher</li></ol><pre><code class="hljs shell">docker run -d --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher:v2.0.0docker logs -f rancher</code></pre><ol start="3"><li>Windows 安装 minikube</li></ol><pre><code class="hljs shell">choco install kubernetes-clikubectl version --client<span class="hljs-meta">#</span><span class="bash"> If you<span class="hljs-string">&#x27;re using cmd.exe, run: cd %USERPROFILE%</span></span>cd ~mkdir .kubecd .kube</code></pre><p>4.[kubeadm](<a href="https://k8s.qikqiak.com/docs/16.%E7%94%A8">https://k8s.qikqiak.com/docs/16.用</a> kubeadm 搭建集群环境.html)（测试）</p><p>5.<a href="https://blog.qikqiak.com/post/manual-install-high-available-kubernetes-cluster/">二进制纯手动搭建</a>（生产）</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>集群是一组安装了 Kubernetes 的节点，这些节点可以是物理服务或者虚拟机。</p><p>Master 负责管理集群。</p><p>Node 是 Kubernetes 集群中的工作机器，可以是物理机或虚拟机。每个节点都有一个 kubectl ，kubectl 用来管理节点并与 Kubernetes Master 节点进行通信的代理。 节点上还应该具有处理容器操作的容器运行时，例如 Docker或rkt。</p><p>一个 Kubernetes 工作集群至少有三个节点。Master 管理集群，Node 用于托管正在运行的应用程序。</p><p>当在 Kubernetes 上部署应用程序时，可以告诉 Master 启动应用程序容器。Master 调度容器在集群的节点上运行。节点使用 Master 公开的 Kubernetes API 与 Master 通信。用户也可以直接使用 Kubernetes 的 API 与集群交互。</p><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod 是一组紧密关联的容器集合，它们共享 PID、IPC、Network 和 UTS namespace，是 Kubernetes 调度的基本单位。Pod 的设计理念是支持多个容器在一个 Pod 中共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。</p><p><img src="https://www.qikqiak.com/k8s-book/docs/images/k8s-pod.png" alt="k8s pod"></p><p>在 Kubernetes 中，所有对象都是用 manifest （yaml 或 json）来定义，比如一个简单的 nginx 服务可以定义为 nginx.yaml，它包含一个镜像为 nginx 的容器</p><pre><code class="hljs yaml"><span class="hljs-string">apiVersion:v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span>   <span class="hljs-attr">spec:</span>     <span class="hljs-attr">containers:</span>     <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>       <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>       <span class="hljs-attr">ports:</span>       <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span></code></pre><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>Label 是识别 Kubernetes 对象的标签，以 key/value 的方式附加到对象上（key 最长不能超过 63 字节，value 可以为空，也可以是不超过 253 字节的字符串）。Label 不提供唯一性，并且实际上经常是很多对象都使用相同的 label 来标志具体的应用。Label 定义好后其他对象可以使用 Label Selector 来选择一组相同 label 的对象 （比如 Service 用 label 来选择一组 Pod。</p><p>Label Selector 支持以下几种方式：</p><ul><li>等式，如 app=nginx 和 env != production</li><li>集合，如 env in (production, qa)</li><li>多个 label（它们之间是 AND 关系），如 app=nginx,env=test</li></ul><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespasce 是对一组资源和对象的抽象集合。</p><p>比如可以用来将系统内部的对象划分为不同的项目组或用户组。</p><p>常见的 pods, services, deployments 等都是属于某一个 namespace 的（默认是 default），而 Node, PersistentVolumes 等则不属于任何 namespace。</p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment 确保任意时间都有指定数量的 Pod “副本” 在运行。如果为耨个 Pod 创建了 Deployment 并且制定三个副本，它会创建 3 个 Pod，并且持续监控它们。如果某个 Pod 不响应，那么 Deployment 会替换它，保持总数为 3。</p><p>如果之前不响应的 Pod 恢复了，目前有 4  个 Pod，那么 Deployment 会将其中一个终止保持总数为 3. 如果在运行中将副本总数改为 5，Deployment 会立刻启动 2 个新 Pod，保证总数为 5.Deployment 还支持回滚和滚动升级。</p><p>当创建 Deployment 时，需要指定两个东西：</p><ul><li>Pod 模板：用来创建 Pod 副本的模板。</li><li>Label 标签：Deployment 需要监控的 Pod 的标签。</li></ul><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service 是应用服务的抽象，通过 labels 为应用提供负载均衡和服务发现。匹配 labels 的 Pod IP 和端口列表组成 endpoints，由 kube-proxy 负责将服务 IP 负载均衡到这些 endpoints 上。</p><p>每个 Service 都会自动分配一个 cluster IP （仅在集群内部可访问的虚拟地址）和 DNS 名，其他容器可以通过该地址或 DNS 来访问服务，而不需要了解后端容器的运行。</p><p><img src="https://www.qikqiak.com/k8s-book/docs/images/k8s-service.png" alt="k8s service"></p><h2 id="2-基本概念与组件"><a href="#2-基本概念与组件" class="headerlink" title="2. 基本概念与组件"></a>2. 基本概念与组件</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="资源对象："><a href="#资源对象：" class="headerlink" title="资源对象："></a>资源对象：</h4><ul><li>Master：Master 节点是 Kubernetes 集群的控制节点，负责整个集群的管理和控制。Master 节点上包含以下组件：</li><li>kube-apiserver：集群控制的入口，提供 HTTP REST 服务</li><li>kube-controller-manager：Kubernetes 集群中所有资源对象的自动化控制中心</li><li>kube-scheduler：负责 Pod 的调度</li><li>Node：Node 节点是 Kubernetes 集群中的工作节点，Node 上的工作负载由 Master 节点分配，工作负载主要是运行容器应用。Node 节点上包含以下组件：<ul><li>kubelet：负责 Pod 的创建、启动、监控、重启、销毁等工作，同时与 Master 节点协作，实现集群管理的基本功能。</li><li>kube-proxy：实现 Kubernetes Service 的通信和负载均衡</li><li>运行容器化(Pod)应用</li></ul></li><li>Pod: Pod 是 Kubernetes 最基本的部署调度单元。每个 Pod 可以由一个或多个业务容器和一个根容器(Pause 容器)组成。一个 Pod 表示某个应用的一个实例</li><li>ReplicaSet：是 Pod 副本的抽象，用于解决 Pod 的扩容和伸缩</li><li>Deployment：Deployment 表示部署，在内部使用ReplicaSet 来实现。可以通过 Deployment 来生成相应的 ReplicaSet 完成 Pod 副本的创建</li><li>Service：Service 是 Kubernetes 最重要的资源对象。Kubernetes 中的 Service 对象可以对应微服务架构中的微服务。Service 定义了服务的访问入口，服务的调用者通过这个地址访问 Service 后端的 Pod 副本实例。Service 通过 Label Selector 同后端的 Pod 副本建立关系，Deployment 保证后端Pod 副本的数量，也就是保证服务的伸缩性。</li></ul><p><img src="https://www.qikqiak.com/k8s-book/docs/images/k8s-basic.png" alt="k8s basic"></p><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><ul><li>etcd 保存整个集群的状态，是一个数据库</li><li>apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制</li><li>controller manager 负责维护集群的状态，比如故障检测、自动拓展、滚动更新等</li><li>scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上</li><li>kubelet 负责维护容器的生命周期，同时也负责 Volume（CSI）和 网络 （CNI）的管理</li><li>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）</li><li>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡</li></ul><h4 id="推荐的插件"><a href="#推荐的插件" class="headerlink" title="推荐的插件"></a>推荐的插件</h4><ul><li>kube-dns 负责为整个集群提供 DNS 服务</li><li>Ingress Controller 为服务提供外网入口</li><li>Heapster 提供资源控制</li><li>Dashboard 提供 GUI</li></ul><h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h4 id="组件间的通信原理"><a href="#组件间的通信原理" class="headerlink" title="组件间的通信原理"></a>组件间的通信原理</h4><ul><li>apiserver 负责 etcd 存储的所有操作，且只有 apiserver 才直接操作 etcd 集群</li><li>apiserver 对内（集群中的其他组件）和对外（用户）提供统一的 REST API，其他组件均通过 apiserver 进行通信<ul><li>controller manager、scheduler、kube-proxy 和 kubectl 等均通过 apiserver watch API 检测资源变化情况，并对资源作相应的操作</li><li>所有需要更新资源状态的操作均通过 apiserver 的 REST API 进行</li></ul></li><li>apiserver 也会直接调用 kubectl API （如 logs, exec, attach 等），默认不校验 kubectl 证书，DNA可以通过 –kubectl-certificate-authority 开启（而 GKE 通过 SSH 隧道保护它们之间的通信）</li></ul><h4 id="创建-Pod-的流程"><a href="#创建-Pod-的流程" class="headerlink" title="创建 Pod 的流程"></a>创建 Pod 的流程</h4><p><img src="C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20211015144510312.png" alt="image-20211015144510312"></p><ol><li>用户通过 REST API 创建 Pod</li><li>API Server 将该 Pod 信息更新到 etcd</li><li>Scheduler 检测到有未绑定 Node 的 Pod，开始调度并更新 Pod 的 Node 绑定</li><li>Kubectl 检测到有新的 Pod 被调度过来，使用 container runtime 将 Pod 运行起来</li><li>kubectl 利用 container runtime 获取该 Pod 状态，并更新到 API Server</li></ol><h2 id="6-用-kubeadm-搭建集群环境"><a href="#6-用-kubeadm-搭建集群环境" class="headerlink" title="6. 用 kubeadm 搭建集群环境"></a>6. 用 kubeadm 搭建集群环境</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20211015145835774.png" alt="image-20211015145835774"></p><ul><li>核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境</li><li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）</li><li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等）</li><li>接口层：kubectl 命令行工具、容器端 SDK 以及 集群联邦</li><li>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴<ul><li>Kubernetes 外部：日志、监控、配置管理、CI、CD、Workflow 等</li><li>Kubernetes 内部：CRI、CNI、CVI、镜像仓库、Cloud Provider 、集群自身的配置和管理等</li></ul></li></ul><h2 id="7-深入理解-POD"><a href="#7-深入理解-POD" class="headerlink" title="7. 深入理解 POD"></a>7. 深入理解 POD</h2><h3 id="YAML-文件"><a href="#YAML-文件" class="headerlink" title="YAML 文件"></a>YAML 文件</h3><blockquote><p>YAML Ain’t a Markup Language. YAML 不是一种标记语言，后缀为 .yaml或.yml，YAML FAQ 建议使用 YAML</p></blockquote><h3 id="YAML-基础"><a href="#YAML-基础" class="headerlink" title="YAML 基础"></a>YAML 基础</h3><h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用 tab，只允许使用空格</li><li>缩进的空格数不重要，只要相同层级的元素左侧对齐即可，至少一个空格</li><li>#表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul><h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p>Maps 就是一个 key:value 的键值对</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span></code></pre><p>第一行的 — 是分隔符，是可选的，在单一文件中，可用 — 区分多个文件。上面的 YAML 转换为 JSON 格式为：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;apiVersion&quot;</span>: <span class="hljs-string">&quot;v1&quot;</span>,    <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;pod&quot;</span>&#125;</code></pre><p>在创建一个相对复杂一点的 YAML 文件时，创建一个 KEY 对应的值不是字符串而是一个 Maps</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube100-site</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">web</span></code></pre><p>上面的 YAML 文件，metadata 这个 KEY 对应的值就是一个 Maps，而嵌套的 labels 这个 KEY 的值又是一个 Map。</p><blockquote><p>注意：在 YAML 文件中绝对不要使用 tab 键</p></blockquote><p>将上面的 YAML 文件转换成 JSON 文件</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;apiVersion&quot;</span>: <span class="hljs-string">&quot;v1&quot;</span>,    <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;Pod&quot;</span>,    <span class="hljs-attr">&quot;metadata&quot;</span>: &#123;        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;kube100-site&quot;</span>,        <span class="hljs-attr">&quot;labels&quot;</span>: &#123;            <span class="hljs-attr">&quot;app&quot;</span>: <span class="hljs-string">&quot;web&quot;</span>        &#125;    &#125;&#125;</code></pre><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>数组</p><pre><code class="hljs yaml"><span class="hljs-string">args</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Cat</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Dog</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Fish</span></code></pre><p>可以有任何数量的项在列表中，每个项的定义以破折号 - 开头的，与父元素直接可以缩进一个空格。对应的 JSon 格式如下</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;args&quot;</span>: [<span class="hljs-string">&quot;Cat&quot;</span>, <span class="hljs-string">&quot;Dog&quot;</span>, <span class="hljs-string">&quot;Fish&quot;</span>]&#125;</code></pre><p>list 的自相也可以是 Maps，Maps 的子项也可以是list</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube100-site</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">web</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">front-end</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>      <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">flaskapp-demo</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">jcdemo/flaskapp</span>      <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">5000</span></code></pre><p>转换为 JSON</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;apiVersion&quot;</span>: <span class="hljs-string">&quot;v1&quot;</span>,    <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;Pod&quot;</span>,    <span class="hljs-attr">&quot;metadata&quot;</span>: &#123;        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;kube100-site&quot;</span>,        <span class="hljs-attr">&quot;labels&quot;</span>: &#123;            <span class="hljs-attr">&quot;app&quot;</span>: <span class="hljs-string">&quot;web&quot;</span>        &#125;    &#125;,    <span class="hljs-attr">&quot;spec&quot;</span>: &#123;        <span class="hljs-attr">&quot;containers&quot;</span>: [&#123;            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;front-end&quot;</span>,            <span class="hljs-attr">&quot;image&quot;</span>: <span class="hljs-string">&quot;nginx&quot;</span>,            <span class="hljs-attr">&quot;ports&quot;</span>: [&#123;                <span class="hljs-attr">&quot;containerPort&quot;</span>: <span class="hljs-number">80</span>            &#125;]        &#125;]    &#125;, &#123;        &quot;name&quot;: &quot;flaskapp-demo&quot;,        &quot;image&quot;: &quot;jcdemo/flaskapp&quot;,        &quot;ports&quot;: [&#123;            &quot;containerPort&quot;: 5000        &#125;]    &#125;&#125;</code></pre><h3 id="使用-YAML-创建-Pod"><a href="#使用-YAML-创建-Pod" class="headerlink" title="使用 YAML 创建 Pod"></a>使用 YAML 创建 Pod</h3><p>API 说明 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/</a></p><h4 id="创建-Pod"><a href="#创建-Pod" class="headerlink" title="创建 Pod"></a>创建 Pod</h4><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube100-site</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">web</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">front-end</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>      <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">flaskapp-demo</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">jcdemo/flaskapp</span>      <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">5000</span></code></pre><p>文件内容：</p><ul><li>apiVersion，这里它的值是 v1，这个版本号需要根据安装的 Kubernetes  版本和资源换类型进行变化</li><li>kind， 资源类型可以是 Pod、Deployment，Job、Ingress、Service</li><li>metadata，这里表示定义的 Pod 的一些 meta 信息，比如名称、namespace 标签</li><li>spec：包括一些 containers、storage、volumes或者其他 Kubernetes 需要知道的参数，以及诸如是否在容器失败时重新启动容器的属性。</li></ul><p>容器定义例子</p><pre><code class="hljs yaml"><span class="hljs-string">...spec:</span>    <span class="hljs-attr">containers:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">front-end</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>      <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><span class="hljs-string">...</span></code></pre><p>容器可选的设置属性：</p><pre><code class="hljs yaml"><span class="hljs-string">name</span><span class="hljs-string">image</span><span class="hljs-string">command</span><span class="hljs-string">args</span><span class="hljs-string">workingDir</span><span class="hljs-string">ports</span><span class="hljs-string">env</span><span class="hljs-string">resources</span><span class="hljs-string">volumeMounts</span><span class="hljs-string">livenessProbe</span><span class="hljs-string">readinessProbe</span><span class="hljs-string">livecycle</span><span class="hljs-string">terminationMessagePath</span><span class="hljs-string">imagePullPolicy</span><span class="hljs-string">securityContext</span><span class="hljs-string">stdin</span><span class="hljs-string">stdinOnce</span><span class="hljs-string">tty</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将创建 Pod 的 YAML 文件保存成 pod.yaml，使用 kubectl 创建 Pod</span>kubectl create -f pod.yaml<span class="hljs-meta">#</span><span class="bash"> 查看 Pod 状态</span>kubectl get pods<span class="hljs-meta">#</span><span class="bash"> 查看 deployment 状态</span>kubectl get deployments<span class="hljs-meta">#</span><span class="bash"> 排查问题</span>kubectl describe</code></pre><h4 id="创建-Deployment"><a href="#创建-Deployment" class="headerlink" title="创建 Deployment"></a>创建 Deployment</h4><p>定义一个 Deployment</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube100-site</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span></code></pre><blockquote><p>注意这里 apiVersion 对应的值是 apps/v1，当然 kind 要指定为 Deployment。然后指定一些 meta 信息，比如名称，或者标签之类。 spec 选项 replicas 设置副本数。</p></blockquote><p>完整的 Deployment 的 YAML 文件</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube100-site</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-attr">app:</span> <span class="hljs-string">web</span>  <span class="hljs-attr">template:</span>    <span class="hljs-attr">metadata:</span>      <span class="hljs-attr">labels:</span>        <span class="hljs-attr">app:</span> <span class="hljs-string">web</span>    <span class="hljs-attr">spec:</span>      <span class="hljs-attr">containers:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">front-end</span>          <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>          <span class="hljs-attr">ports:</span>            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPorts:</span> <span class="hljs-number">80</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">flaskapp-demo</span>          <span class="hljs-attr">image:</span> <span class="hljs-string">jcdemo/flaskapp</span>          <span class="hljs-attr">ports:</span>            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">5000</span></code></pre><blockquote><p><strong>template</strong>就是对 Pod 对象的定义</p></blockquote><h3 id="静态-Pod"><a href="#静态-Pod" class="headerlink" title="静态 Pod"></a>静态 Pod</h3><blockquote><p>静态 Pod 直接由特定节点上的 kubectl 进程来管理，不通过 Master 节点上的 apiserver。无法与我们常用的控制器 Deployment 或者 Daemonset 进行关联，它由 kubectl 进程自己来监控，当 pod 崩溃时重启该 pod，kubelete 也无法对他们进行健康检查。</p><p>静态 Pod 始终绑定在某一个 kubectl ，并且始终运行在同一个节点上。kubectl 会自动为每个静态 Pod 在 Kubernetes 的 apiserver 上创建一个镜像 Pod（Mirror Pod），因此我们可以在 apiserver 中查询到该 pod，但是不能通过apiserver进行控制。</p><p>创建静态 Pod 有两种方式：配置文件和 HTTP 两种方式</p></blockquote><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件就是放在特定目录下的标准的 JSON 或 YAML 格式的 Pod 定义文件。用 kubelet –pod-manifest-path=<the directory> 来启动 kubelet 进程，kubelet 定期的去扫描这个目录，更具这个目录下出现或消失的 YAML/JSON 文件来创建或删除静态 Pod。</p><p>通过以下命令找到 kubelet 对应的启动配置文件</p><pre><code class="hljs shell">systemctl status kubelet</code></pre><p>配置文件路径为</p><pre><code class="hljs shell">/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code></pre><p>打开这个文件可以看到环境变量配置</p><pre><code class="hljs shell">Environment=&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true&quot;</code></pre><p>通过 kubeadm 安装的集群环境，对应的 kubelet 已经配置了静态 Pod 文件的路径，/etc/kubernetes/manifests，只需要在该目录下创建一个标准的 Pod 的 JSON 或 YAML 文件即可。</p><p>若 kubectl 启动参数中没有配置 –pod-manifest-path 参数，添加上这个参数后重启 kubectl 即可</p><pre><code class="hljs shell">cat &lt;&lt;EOF &gt; /etc/kubernetes/manifest/static-web.yamlapiVersion: v1kind: Podmetadata:  name: static-web  labels:    app: staticspec:  containers:    - name: web      image: nginx      ports:        - name: web          containerPort: 80EOF</code></pre><h3 id="通过-HTTP-创建静态-Pods"><a href="#通过-HTTP-创建静态-Pods" class="headerlink" title="通过 HTTP 创建静态 Pods"></a>通过 HTTP 创建静态 Pods</h3><p>kubectl  周期地从 -manifest-url= 参数指定的地址下载我呢间，并且把它翻译成 JSON/TAML 格式的 Pod 定义，以后的操作方式与 -pod-manifest-path= 相同，kubectl 会不时地重新下载该文件，当文件变化时对应地终止或启动静态 Pod</p><h3 id="静态-Pods-的动作行为"><a href="#静态-Pods-的动作行为" class="headerlink" title="静态 Pods 的动作行为"></a>静态 Pods 的动作行为</h3><p>kubelet 启动时，由 –pod-manifest-path= or –manifest-url= 参数指定的目录下定义的所有 Pod 都会自动创建。</p><p>不能通过 API 服务器来删除静态 pod（例如，通过<a href="https://kubernetes.io/docs/user-guide/kubectl/">kubectl</a>命令）kebelet 不会删除它</p><h3 id="静态-Pods-的动态增加和删除"><a href="#静态-Pods-的动态增加和删除" class="headerlink" title="静态 Pods 的动态增加和删除"></a>静态 Pods 的动态增加和删除</h3><p>运行中的kubelet周期扫描配置的目录（我们这个例子中就是/etc/kubernetes/manifests）下文件的变化，当这个目录中有文件出现或消失时创建或删除pods。</p><p>用 kubeadm 安装的集群，master 节点上面的几个重要组件都是用静态 Pod 的方式运行的</p><h3 id="Pod-Hook"><a href="#Pod-Hook" class="headerlink" title="Pod Hook"></a>Pod Hook</h3><p>PostStart：容器创建后立即执行，不能保证钩子在 容器 ENTRYPOINT 之前运行。主要用于<strong>资源部署、环境准备</strong>。钩子如果花太长时间以至于不能运行或者挂起，容器将不能达到 running 状态。</p><p>PreStop：在容器终止之前立即被调用，是阻塞的，必须再删除容器的调用发出之前完成。主要用于<strong>关闭应用程序、通知其他系统</strong>。在钩子执行期间挂起，Pod 阶段将停留在 running 状态并不会达到 failed 状态。</p><blockquote><p>钩子失败，会杀死容器。应该让钩子函数尽可能的轻量。有些情况下，长时间运行命令是合理的，在停止容器前预先保存状态。</p></blockquote><h3 id="实现钩子函数的方式"><a href="#实现钩子函数的方式" class="headerlink" title="实现钩子函数的方式"></a>实现钩子函数的方式</h3><p>Exec 执行一段特定的命令，该命令消耗的资源会被计入容器</p><p>HTTP 对容器上的特定的端点执行 HTTP 请求</p><h3 id="示例：PostStart-环境准备"><a href="#示例：PostStart-环境准备" class="headerlink" title="示例：PostStart 环境准备"></a>示例：PostStart 环境准备</h3><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">hook-demo1</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hook-demo1</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>    <span class="hljs-attr">lifecycle:</span>      <span class="hljs-attr">postStart:</span>        <span class="hljs-attr">exec:</span>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;</span>]</code></pre><h3 id="删除资源对象"><a href="#删除资源对象" class="headerlink" title="删除资源对象"></a>删除资源对象</h3><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">hook-demo2</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hook-demo2</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>    <span class="hljs-attr">lifecycle:</span>      <span class="hljs-attr">preStop:</span>        <span class="hljs-attr">exec:</span>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/usr/sbin/nginx&quot;</span>,<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;quit&quot;</span>]<span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">hook-demo2</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">hook</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hook-demo2</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>    <span class="hljs-attr">ports:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">webport</span>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>    <span class="hljs-attr">volumeMounts:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">message</span>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/</span>    <span class="hljs-attr">lifecycle:</span>      <span class="hljs-attr">preStop:</span>        <span class="hljs-attr">exec:</span>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;/bin/sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;echo Hello from the preStop Handler &gt; /usr/share/message&#x27;</span>]  <span class="hljs-attr">volumes:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">message</span>    <span class="hljs-attr">hostPath:</span>      <span class="hljs-attr">path:</span> <span class="hljs-string">/tmp</span></code></pre><h3 id="健康检查-探针"><a href="#健康检查-探针" class="headerlink" title="健康检查-探针"></a>健康检查-探针</h3><p><code>liveness probe</code>（存活探针）</p><ul><li>kubelet 通过使用 liveness probe 来确定你的应用程序是否正在运行，通俗点将就是是否还活着。一般来说，如果你的程序一旦崩溃了， Kubernetes 就会立刻知道这个程序已经终止了，然后就会重启这个程序。而我们的 liveness probe 的目的就是来捕获到当前应用程序还没有终止，还没有崩溃，如果出现了这些情况，那么就重启处于该状态下的容器，使应用程序在存在 bug 的情况下依然能够继续运行下去。</li></ul><p><code>readiness probe</code>（可读性探针）</p><ul><li>kubelet 使用 readiness probe 来确定容器是否已经就绪可以接收流量过来了。这个探针通俗点讲就是说是否准备好了，现在可以开始工作了。只有当 Pod 中的容器都处于就绪状态的时候 kubelet 才会认定该 Pod 处于就绪状态，因为一个 Pod 下面可能会有多个容器。当然 Pod 如果处于非就绪状态，那么我们就会将他从我们的工作队列(实际上就是我们后面需要重点学习的 Service)中移除出来，这样我们的流量就不会被路由到这个 Pod 里面来了。</li></ul><h3 id="初始化容器-Init-Container"><a href="#初始化容器-Init-Container" class="headerlink" title="初始化容器 Init Container"></a>初始化容器 Init Container</h3><p><code>Init Container</code>就是用来做初始化工作的容器，可以是一个或者多个，如果有多个的话，这些容器会按定义的顺序依次执行，只有所有的<code>Init Container</code>执行完后，主容器才会被启动。我们知道一个<code>Pod</code>里面的所有容器是共享数据卷和网络命名空间的，所以<code>Init Container</code>里面产生的数据可以被主容器使用到的。</p><p><code>PostStart</code>和<code>PreStop</code>包括<code>liveness</code>和<code>readiness</code>是属于主容器的生命周期范围内的，而<code>Init Container</code>是独立于主容器之外的，当然他们都属于<code>Pod</code>的生命周期范畴之内的</p><p><code>infra</code>镜像</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="等待其他模块Ready"><a href="#等待其他模块Ready" class="headerlink" title="等待其他模块Ready"></a>等待其他模块Ready</h4><p>用来解决服务之间的依赖问题</p><p>比如我们有一个 Web 服务，该服务又依赖于另外一个数据库服务，但是在我们启动这个 Web 服务的时候我们并不能保证依赖的这个数据库服务就已经启动起来了，所以可能会出现一段时间内 Web 服务连接数据库异常。要解决这个问题的话我们就可以在 Web 服务的 Pod 中使用一个 InitContainer，在这个初始化容器中去检查数据库是否已经准备好了，准备好了过后初始化容器就结束退出，然后我们的主容器 Web 服务被启动起来，这个时候去连接数据库就不会有问题了。</p><h4 id="做初始化配置"><a href="#做初始化配置" class="headerlink" title="做初始化配置"></a>做初始化配置</h4><p>比如集群里检测所有已经存在的成员节点，为主容器准备好集群的配置信息，这样主容器起来后就能用这个配置信息加入集群。</p><h4 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h4><p>将 pod 注册到一个中央数据库、配置中心</p><h4 id="服务依赖示例"><a href="#服务依赖示例" class="headerlink" title="服务依赖示例"></a>服务依赖示例</h4><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">init-pod1</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">init</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">init-container</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;echi The app is running &amp;&amp; sleep 3600&#x27;</span>]  <span class="hljs-attr">initContainers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">init-myservice</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span>]  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">init-mydb</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#x27;</span>]</code></pre><p>Service 对应的 YAML</p><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">myservice</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">ports:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">6376</span><span class="hljs-meta">---</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">mydb</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">ports:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">6377</span></code></pre><p><code>在Pod启动过程中，初始化容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。如果由于运行时或失败退出，导致容器启动失败，它会根据Pod的restartPolicy指定的策略进行重试。 然而，如果 Pod 的 restartPolicy 设置为 Always，Init 容器失败时会使用 RestartPolicy 策略。</code></p><p>在所有的初始化容器没有成功之前，<code>Pod</code>将不会变成 <code>Ready</code>状态。正在初始化中的<code>Pod</code>处于<code>Pending</code>状态，但应该会将条件<code>Initializing</code>设置为 true。</p><h4 id="初始化配置工作-Pod"><a href="#初始化配置工作-Pod" class="headerlink" title="初始化配置工作 Pod"></a>初始化配置工作 Pod</h4><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">init-demo</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>    <span class="hljs-attr">ports:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>    <span class="hljs-attr">volumeMounts:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">workdir</span>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span>  <span class="hljs-attr">initContainers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">install</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>    <span class="hljs-attr">command:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">wget</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;-O&quot;</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/work-dir/index.html&quot;</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">http://www.baidu.com</span>    <span class="hljs-attr">volumeMounts:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">workdir</span>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/work-dir&quot;</span>  <span class="hljs-attr">volumes:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">workdir</span>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;</code></pre><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>spec.volumes 指的是 Pod 中的卷，spec.containers.volumeMounts，是指指定的卷 mount 到容器指定的位置，相当于 docker 里面的 -v 宿主机目录：容器目录，emptyDir{}，相当于一个共享卷，是一个临时的目录，生命周期等同于 Pod 的生命周期。</p><p>初始化容器执行完，会下载一个 html 文件映射到 emptyDir{}，而主容器也适合 spec.volumes 里的 emptyDir{} 进行映射，所以 nginx 容器的 /usr/share/nginx/html 目录下回映射到 index.html 文件</p><p>验证 kubectl get pod init-demo</p><p>在 init-demo 容器里的 nginx 容器里打开一个shell</p><pre><code class="hljs shell">kubectl exec -it init-demo -- /bin/bash</code></pre>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes(1-7)</title>
    <link href="/2021/10/15/cloud/tmp/k8s%E5%9F%BA%E7%A1%80/Kubernetes(1-7)/"/>
    <url>/2021/10/15/cloud/tmp/k8s%E5%9F%BA%E7%A1%80/Kubernetes(1-7)/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h1><h2 id="1-初体验"><a href="#1-初体验" class="headerlink" title="1. 初体验"></a>1. 初体验</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ol><li>katacode </li><li>搭建 Rancher</li></ol><pre><code class="hljs shell">docker run -d --restart=unless-stopped -p 80:80 -p 443:443 rancher/rancher:v2.0.0docker logs -f rancher</code></pre><ol start="3"><li>Windows 安装 minikube</li></ol><pre><code class="hljs shell">choco install kubernetes-clikubectl version --client<span class="hljs-meta">#</span><span class="bash"> If you<span class="hljs-string">&#x27;re using cmd.exe, run: cd %USERPROFILE%</span></span>cd ~mkdir .kubecd .kube</code></pre><p>4.[kubeadm](<a href="https://k8s.qikqiak.com/docs/16.%E7%94%A8">https://k8s.qikqiak.com/docs/16.用</a> kubeadm 搭建集群环境.html)（测试）</p><p>5.<a href="https://blog.qikqiak.com/post/manual-install-high-available-kubernetes-cluster/">二进制纯手动搭建</a>（生产）</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h3><p>集群是一组安装了 Kubernetes 的节点，这些节点可以是物理服务或者虚拟机。</p><p>Master 负责管理集群。</p><p>Node 是 Kubernetes 集群中的工作机器，可以是物理机或虚拟机。每个节点都有一个 kubectl ，kubectl 用来管理节点并与 Kubernetes Master 节点进行通信的代理。 节点上还应该具有处理容器操作的容器运行时，例如 Docker或rkt。</p><p>一个 Kubernetes 工作集群至少有三个节点。Master 管理集群，Node 用于托管正在运行的应用程序。</p><p>当在 Kubernetes 上部署应用程序时，可以告诉 Master 启动应用程序容器。Master 调度容器在集群的节点上运行。节点使用 Master 公开的 Kubernetes API 与 Master 通信。用户也可以直接使用 Kubernetes 的 API 与集群交互。</p><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><p>Pod 是一组紧密关联的容器集合，它们共享 PID、IPC、Network 和 UTS namespace，是 Kubernetes 调度的基本单位。Pod 的设计理念是支持多个容器在一个 Pod 中共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。</p><p><img src="https://www.qikqiak.com/k8s-book/docs/images/k8s-pod.png" alt="k8s pod"></p><p>在 Kubernetes 中，所有对象都是用 manifest （yaml 或 json）来定义，比如一个简单的 nginx 服务可以定义为 nginx.yaml，它包含一个镜像为 nginx 的容器</p><pre><code class="hljs yaml"><span class="hljs-string">apiVersion:v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">nginx</span>   <span class="hljs-attr">spec:</span>     <span class="hljs-attr">containers:</span>     <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>       <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>       <span class="hljs-attr">ports:</span>       <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span></code></pre><h3 id="Label"><a href="#Label" class="headerlink" title="Label"></a>Label</h3><p>Label 是识别 Kubernetes 对象的标签，以 key/value 的方式附加到对象上（key 最长不能超过 63 字节，value 可以为空，也可以是不超过 253 字节的字符串）。Label 不提供唯一性，并且实际上经常是很多对象都使用相同的 label 来标志具体的应用。Label 定义好后其他对象可以使用 Label Selector 来选择一组相同 label 的对象 （比如 Service 用 label 来选择一组 Pod。</p><p>Label Selector 支持以下几种方式：</p><ul><li>等式，如 app=nginx 和 env != production</li><li>集合，如 env in (production, qa)</li><li>多个 label（它们之间是 AND 关系），如 app=nginx,env=test</li></ul><h3 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h3><p>Namespasce 是对一组资源和对象的抽象集合。</p><p>比如可以用来将系统内部的对象划分为不同的项目组或用户组。</p><p>常见的 pods, services, deployments 等都是属于某一个 namespace 的（默认是 default），而 Node, PersistentVolumes 等则不属于任何 namespace。</p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Deployment 确保任意时间都有指定数量的 Pod “副本” 在运行。如果为耨个 Pod 创建了 Deployment 并且制定三个副本，它会创建 3 个 Pod，并且持续监控它们。如果某个 Pod 不响应，那么 Deployment 会替换它，保持总数为 3。</p><p>如果之前不响应的 Pod 恢复了，目前有 4  个 Pod，那么 Deployment 会将其中一个终止保持总数为 3. 如果在运行中将副本总数改为 5，Deployment 会立刻启动 2 个新 Pod，保证总数为 5.Deployment 还支持回滚和滚动升级。</p><p>当创建 Deployment 时，需要指定两个东西：</p><ul><li>Pod 模板：用来创建 Pod 副本的模板。</li><li>Label 标签：Deployment 需要监控的 Pod 的标签。</li></ul><h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><p>Service 是应用服务的抽象，通过 labels 为应用提供负载均衡和服务发现。匹配 labels 的 Pod IP 和端口列表组成 endpoints，由 kube-proxy 负责将服务 IP 负载均衡到这些 endpoints 上。</p><p>每个 Service 都会自动分配一个 cluster IP （仅在集群内部可访问的虚拟地址）和 DNS 名，其他容器可以通过该地址或 DNS 来访问服务，而不需要了解后端容器的运行。</p><p><img src="https://www.qikqiak.com/k8s-book/docs/images/k8s-service.png" alt="k8s service"></p><h2 id="2-基本概念与组件"><a href="#2-基本概念与组件" class="headerlink" title="2. 基本概念与组件"></a>2. 基本概念与组件</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="资源对象："><a href="#资源对象：" class="headerlink" title="资源对象："></a>资源对象：</h4><ul><li>Master：Master 节点是 Kubernetes 集群的控制节点，负责整个集群的管理和控制。Master 节点上包含以下组件：</li><li>kube-apiserver：集群控制的入口，提供 HTTP REST 服务</li><li>kube-controller-manager：Kubernetes 集群中所有资源对象的自动化控制中心</li><li>kube-scheduler：负责 Pod 的调度</li><li>Node：Node 节点是 Kubernetes 集群中的工作节点，Node 上的工作负载由 Master 节点分配，工作负载主要是运行容器应用。Node 节点上包含以下组件：<ul><li>kubelet：负责 Pod 的创建、启动、监控、重启、销毁等工作，同时与 Master 节点协作，实现集群管理的基本功能。</li><li>kube-proxy：实现 Kubernetes Service 的通信和负载均衡</li><li>运行容器化(Pod)应用</li></ul></li><li>Pod: Pod 是 Kubernetes 最基本的部署调度单元。每个 Pod 可以由一个或多个业务容器和一个根容器(Pause 容器)组成。一个 Pod 表示某个应用的一个实例</li><li>ReplicaSet：是 Pod 副本的抽象，用于解决 Pod 的扩容和伸缩</li><li>Deployment：Deployment 表示部署，在内部使用ReplicaSet 来实现。可以通过 Deployment 来生成相应的 ReplicaSet 完成 Pod 副本的创建</li><li>Service：Service 是 Kubernetes 最重要的资源对象。Kubernetes 中的 Service 对象可以对应微服务架构中的微服务。Service 定义了服务的访问入口，服务的调用者通过这个地址访问 Service 后端的 Pod 副本实例。Service 通过 Label Selector 同后端的 Pod 副本建立关系，Deployment 保证后端Pod 副本的数量，也就是保证服务的伸缩性。</li></ul><p><img src="https://www.qikqiak.com/k8s-book/docs/images/k8s-basic.png" alt="k8s basic"></p><h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h4><ul><li>etcd 保存整个集群的状态，是一个数据库</li><li>apiserver 提供了资源操作的唯一入口，并提供认证、授权、访问控制、API 注册和发现等机制</li><li>controller manager 负责维护集群的状态，比如故障检测、自动拓展、滚动更新等</li><li>scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上</li><li>kubelet 负责维护容器的生命周期，同时也负责 Volume（CSI）和 网络 （CNI）的管理</li><li>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）</li><li>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡</li></ul><h4 id="推荐的插件"><a href="#推荐的插件" class="headerlink" title="推荐的插件"></a>推荐的插件</h4><ul><li>kube-dns 负责为整个集群提供 DNS 服务</li><li>Ingress Controller 为服务提供外网入口</li><li>Heapster 提供资源控制</li><li>Dashboard 提供 GUI</li></ul><h3 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h3><h4 id="组件间的通信原理"><a href="#组件间的通信原理" class="headerlink" title="组件间的通信原理"></a>组件间的通信原理</h4><ul><li>apiserver 负责 etcd 存储的所有操作，且只有 apiserver 才直接操作 etcd 集群</li><li>apiserver 对内（集群中的其他组件）和对外（用户）提供统一的 REST API，其他组件均通过 apiserver 进行通信<ul><li>controller manager、scheduler、kube-proxy 和 kubectl 等均通过 apiserver watch API 检测资源变化情况，并对资源作相应的操作</li><li>所有需要更新资源状态的操作均通过 apiserver 的 REST API 进行</li></ul></li><li>apiserver 也会直接调用 kubectl API （如 logs, exec, attach 等），默认不校验 kubectl 证书，DNA可以通过 –kubectl-certificate-authority 开启（而 GKE 通过 SSH 隧道保护它们之间的通信）</li></ul><h4 id="创建-Pod-的流程"><a href="#创建-Pod-的流程" class="headerlink" title="创建 Pod 的流程"></a>创建 Pod 的流程</h4><p><img src="C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20211015144510312.png" alt="image-20211015144510312"></p><ol><li>用户通过 REST API 创建 Pod</li><li>API Server 将该 Pod 信息更新到 etcd</li><li>Scheduler 检测到有未绑定 Node 的 Pod，开始调度并更新 Pod 的 Node 绑定</li><li>Kubectl 检测到有新的 Pod 被调度过来，使用 container runtime 将 Pod 运行起来</li><li>kubectl 利用 container runtime 获取该 Pod 状态，并更新到 API Server</li></ol><h2 id="6-用-kubeadm-搭建集群环境"><a href="#6-用-kubeadm-搭建集群环境" class="headerlink" title="6. 用 kubeadm 搭建集群环境"></a>6. 用 kubeadm 搭建集群环境</h2><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p><img src="C:\Users\86176\AppData\Roaming\Typora\typora-user-images\image-20211015145835774.png" alt="image-20211015145835774"></p><ul><li>核心层：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境</li><li>应用层：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）</li><li>管理层：系统度量（如基础设施、容器和网络的度量），自动化（如自动扩展、动态 Provision 等）以及策略管理（RBAC、Quota、PSP、NetworkPolicy 等）</li><li>接口层：kubectl 命令行工具、容器端 SDK 以及 集群联邦</li><li>生态系统：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴<ul><li>Kubernetes 外部：日志、监控、配置管理、CI、CD、Workflow 等</li><li>Kubernetes 内部：CRI、CNI、CVI、镜像仓库、Cloud Provider 、集群自身的配置和管理等</li></ul></li></ul><h2 id="7-深入理解-POD"><a href="#7-深入理解-POD" class="headerlink" title="7. 深入理解 POD"></a>7. 深入理解 POD</h2><h3 id="YAML-文件"><a href="#YAML-文件" class="headerlink" title="YAML 文件"></a>YAML 文件</h3><blockquote><p>YAML Ain’t a Markup Language. YAML 不是一种标记语言，后缀为 .yaml或.yml，YAML FAQ 建议使用 YAML</p></blockquote><h3 id="YAML-基础"><a href="#YAML-基础" class="headerlink" title="YAML 基础"></a>YAML 基础</h3><h4 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h4><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进不允许使用 tab，只允许使用空格</li><li>缩进的空格数不重要，只要相同层级的元素左侧对齐即可，至少一个空格</li><li>#表示注释，从这个字符一直到行尾，都会被解析器忽略</li></ul><h3 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h3><p>Maps 就是一个 key:value 的键值对</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span></code></pre><p>第一行的 — 是分隔符，是可选的，在单一文件中，可用 — 区分多个文件。上面的 YAML 转换为 JSON 格式为：</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;apiVersion&quot;</span>: <span class="hljs-string">&quot;v1&quot;</span>,    <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;pod&quot;</span>&#125;</code></pre><p>在创建一个相对复杂一点的 YAML 文件时，创建一个 KEY 对应的值不是字符串而是一个 Maps</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube100-site</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">web</span></code></pre><p>上面的 YAML 文件，metadata 这个 KEY 对应的值就是一个 Maps，而嵌套的 labels 这个 KEY 的值又是一个 Map。</p><blockquote><p>注意：在 YAML 文件中绝对不要使用 tab 键</p></blockquote><p>将上面的 YAML 文件转换成 JSON 文件</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;apiVersion&quot;</span>: <span class="hljs-string">&quot;v1&quot;</span>,    <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;Pod&quot;</span>,    <span class="hljs-attr">&quot;metadata&quot;</span>: &#123;        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;kube100-site&quot;</span>,        <span class="hljs-attr">&quot;labels&quot;</span>: &#123;            <span class="hljs-attr">&quot;app&quot;</span>: <span class="hljs-string">&quot;web&quot;</span>        &#125;    &#125;&#125;</code></pre><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>数组</p><pre><code class="hljs yaml"><span class="hljs-string">args</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Cat</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Dog</span>  <span class="hljs-bullet">-</span> <span class="hljs-string">Fish</span></code></pre><p>可以有任何数量的项在列表中，每个项的定义以破折号 - 开头的，与父元素直接可以缩进一个空格。对应的 JSon 格式如下</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;args&quot;</span>: [<span class="hljs-string">&quot;Cat&quot;</span>, <span class="hljs-string">&quot;Dog&quot;</span>, <span class="hljs-string">&quot;Fish&quot;</span>]&#125;</code></pre><p>list 的自相也可以是 Maps，Maps 的子项也可以是list</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube100-site</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">web</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">front-end</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>      <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">flaskapp-demo</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">jcdemo/flaskapp</span>      <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">5000</span></code></pre><p>转换为 JSON</p><pre><code class="hljs json">&#123;    <span class="hljs-attr">&quot;apiVersion&quot;</span>: <span class="hljs-string">&quot;v1&quot;</span>,    <span class="hljs-attr">&quot;kind&quot;</span>: <span class="hljs-string">&quot;Pod&quot;</span>,    <span class="hljs-attr">&quot;metadata&quot;</span>: &#123;        <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;kube100-site&quot;</span>,        <span class="hljs-attr">&quot;labels&quot;</span>: &#123;            <span class="hljs-attr">&quot;app&quot;</span>: <span class="hljs-string">&quot;web&quot;</span>        &#125;    &#125;,    <span class="hljs-attr">&quot;spec&quot;</span>: &#123;        <span class="hljs-attr">&quot;containers&quot;</span>: [&#123;            <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;front-end&quot;</span>,            <span class="hljs-attr">&quot;image&quot;</span>: <span class="hljs-string">&quot;nginx&quot;</span>,            <span class="hljs-attr">&quot;ports&quot;</span>: [&#123;                <span class="hljs-attr">&quot;containerPort&quot;</span>: <span class="hljs-number">80</span>            &#125;]        &#125;]    &#125;, &#123;        &quot;name&quot;: &quot;flaskapp-demo&quot;,        &quot;image&quot;: &quot;jcdemo/flaskapp&quot;,        &quot;ports&quot;: [&#123;            &quot;containerPort&quot;: 5000        &#125;]    &#125;&#125;</code></pre><h3 id="使用-YAML-创建-Pod"><a href="#使用-YAML-创建-Pod" class="headerlink" title="使用 YAML 创建 Pod"></a>使用 YAML 创建 Pod</h3><p>API 说明 <a href="https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/">https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.10/</a></p><h4 id="创建-Pod"><a href="#创建-Pod" class="headerlink" title="创建 Pod"></a>创建 Pod</h4><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube100-site</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">web</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">front-end</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>      <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">flaskapp-demo</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">jcdemo/flaskapp</span>      <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">5000</span></code></pre><p>文件内容：</p><ul><li>apiVersion，这里它的值是 v1，这个版本号需要根据安装的 Kubernetes  版本和资源换类型进行变化</li><li>kind， 资源类型可以是 Pod、Deployment，Job、Ingress、Service</li><li>metadata，这里表示定义的 Pod 的一些 meta 信息，比如名称、namespace 标签</li><li>spec：包括一些 containers、storage、volumes或者其他 Kubernetes 需要知道的参数，以及诸如是否在容器失败时重新启动容器的属性。</li></ul><p>容器定义例子</p><pre><code class="hljs yaml"><span class="hljs-string">...spec:</span>    <span class="hljs-attr">containers:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">front-end</span>      <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>      <span class="hljs-attr">ports:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span><span class="hljs-string">...</span></code></pre><p>容器可选的设置属性：</p><pre><code class="hljs yaml"><span class="hljs-string">name</span><span class="hljs-string">image</span><span class="hljs-string">command</span><span class="hljs-string">args</span><span class="hljs-string">workingDir</span><span class="hljs-string">ports</span><span class="hljs-string">env</span><span class="hljs-string">resources</span><span class="hljs-string">volumeMounts</span><span class="hljs-string">livenessProbe</span><span class="hljs-string">readinessProbe</span><span class="hljs-string">livecycle</span><span class="hljs-string">terminationMessagePath</span><span class="hljs-string">imagePullPolicy</span><span class="hljs-string">securityContext</span><span class="hljs-string">stdin</span><span class="hljs-string">stdinOnce</span><span class="hljs-string">tty</span></code></pre><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 将创建 Pod 的 YAML 文件保存成 pod.yaml，使用 kubectl 创建 Pod</span>kubectl create -f pod.yaml<span class="hljs-meta">#</span><span class="bash"> 查看 Pod 状态</span>kubectl get pods<span class="hljs-meta">#</span><span class="bash"> 查看 deployment 状态</span>kubectl get deployments<span class="hljs-meta">#</span><span class="bash"> 排查问题</span>kubectl describe</code></pre><h4 id="创建-Deployment"><a href="#创建-Deployment" class="headerlink" title="创建 Deployment"></a>创建 Deployment</h4><p>定义一个 Deployment</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube100-site</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span></code></pre><blockquote><p>注意这里 apiVersion 对应的值是 apps/v1，当然 kind 要指定为 Deployment。然后指定一些 meta 信息，比如名称，或者标签之类。 spec 选项 replicas 设置副本数。</p></blockquote><p>完整的 Deployment 的 YAML 文件</p><pre><code class="hljs yaml"><span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">apps/v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Deployment</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">kube100-site</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">replicas:</span> <span class="hljs-number">2</span>  <span class="hljs-attr">selector:</span>    <span class="hljs-attr">matchLabels:</span>      <span class="hljs-attr">app:</span> <span class="hljs-string">web</span>  <span class="hljs-attr">template:</span>    <span class="hljs-attr">metadata:</span>      <span class="hljs-attr">labels:</span>        <span class="hljs-attr">app:</span> <span class="hljs-string">web</span>    <span class="hljs-attr">spec:</span>      <span class="hljs-attr">containers:</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">front-end</span>          <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>          <span class="hljs-attr">ports:</span>            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPorts:</span> <span class="hljs-number">80</span>        <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">flaskapp-demo</span>          <span class="hljs-attr">image:</span> <span class="hljs-string">jcdemo/flaskapp</span>          <span class="hljs-attr">ports:</span>            <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">5000</span></code></pre><blockquote><p><strong>template</strong>就是对 Pod 对象的定义</p></blockquote><h3 id="静态-Pod"><a href="#静态-Pod" class="headerlink" title="静态 Pod"></a>静态 Pod</h3><blockquote><p>静态 Pod 直接由特定节点上的 kubectl 进程来管理，不通过 Master 节点上的 apiserver。无法与我们常用的控制器 Deployment 或者 Daemonset 进行关联，它由 kubectl 进程自己来监控，当 pod 崩溃时重启该 pod，kubelete 也无法对他们进行健康检查。</p><p>静态 Pod 始终绑定在某一个 kubectl ，并且始终运行在同一个节点上。kubectl 会自动为每个静态 Pod 在 Kubernetes 的 apiserver 上创建一个镜像 Pod（Mirror Pod），因此我们可以在 apiserver 中查询到该 pod，但是不能通过apiserver进行控制。</p><p>创建静态 Pod 有两种方式：配置文件和 HTTP 两种方式</p></blockquote><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件就是放在特定目录下的标准的 JSON 或 YAML 格式的 Pod 定义文件。用 kubelet –pod-manifest-path=<the directory> 来启动 kubelet 进程，kubelet 定期的去扫描这个目录，更具这个目录下出现或消失的 YAML/JSON 文件来创建或删除静态 Pod。</p><p>通过以下命令找到 kubelet 对应的启动配置文件</p><pre><code class="hljs shell">systemctl status kubelet</code></pre><p>配置文件路径为</p><pre><code class="hljs shell">/etc/systemd/system/kubelet.service.d/10-kubeadm.conf</code></pre><p>打开这个文件可以看到环境变量配置</p><pre><code class="hljs shell">Environment=&quot;KUBELET_SYSTEM_PODS_ARGS=--pod-manifest-path=/etc/kubernetes/manifests --allow-privileged=true&quot;</code></pre><p>通过 kubeadm 安装的集群环境，对应的 kubelet 已经配置了静态 Pod 文件的路径，/etc/kubernetes/manifests，只需要在该目录下创建一个标准的 Pod 的 JSON 或 YAML 文件即可。</p><p>若 kubectl 启动参数中没有配置 –pod-manifest-path 参数，添加上这个参数后重启 kubectl 即可</p><pre><code class="hljs shell">cat &lt;&lt;EOF &gt; /etc/kubernetes/manifest/static-web.yamlapiVersion: v1kind: Podmetadata:  name: static-web  labels:    app: staticspec:  containers:    - name: web      image: nginx      ports:        - name: web          containerPort: 80EOF</code></pre><h3 id="通过-HTTP-创建静态-Pods"><a href="#通过-HTTP-创建静态-Pods" class="headerlink" title="通过 HTTP 创建静态 Pods"></a>通过 HTTP 创建静态 Pods</h3><p>kubectl  周期地从 -manifest-url= 参数指定的地址下载我呢间，并且把它翻译成 JSON/TAML 格式的 Pod 定义，以后的操作方式与 -pod-manifest-path= 相同，kubectl 会不时地重新下载该文件，当文件变化时对应地终止或启动静态 Pod</p><h3 id="静态-Pods-的动作行为"><a href="#静态-Pods-的动作行为" class="headerlink" title="静态 Pods 的动作行为"></a>静态 Pods 的动作行为</h3><p>kubelet 启动时，由 –pod-manifest-path= or –manifest-url= 参数指定的目录下定义的所有 Pod 都会自动创建。</p><p>不能通过 API 服务器来删除静态 pod（例如，通过<a href="https://kubernetes.io/docs/user-guide/kubectl/">kubectl</a>命令）kebelet 不会删除它</p><h3 id="静态-Pods-的动态增加和删除"><a href="#静态-Pods-的动态增加和删除" class="headerlink" title="静态 Pods 的动态增加和删除"></a>静态 Pods 的动态增加和删除</h3><p>运行中的kubelet周期扫描配置的目录（我们这个例子中就是/etc/kubernetes/manifests）下文件的变化，当这个目录中有文件出现或消失时创建或删除pods。</p><p>用 kubeadm 安装的集群，master 节点上面的几个重要组件都是用静态 Pod 的方式运行的</p><h3 id="Pod-Hook"><a href="#Pod-Hook" class="headerlink" title="Pod Hook"></a>Pod Hook</h3><p>PostStart：容器创建后立即执行，不能保证钩子在 容器 ENTRYPOINT 之前运行。主要用于<strong>资源部署、环境准备</strong>。钩子如果花太长时间以至于不能运行或者挂起，容器将不能达到 running 状态。</p><p>PreStop：在容器终止之前立即被调用，是阻塞的，必须再删除容器的调用发出之前完成。主要用于<strong>关闭应用程序、通知其他系统</strong>。在钩子执行期间挂起，Pod 阶段将停留在 running 状态并不会达到 failed 状态。</p><blockquote><p>钩子失败，会杀死容器。应该让钩子函数尽可能的轻量。有些情况下，长时间运行命令是合理的，在停止容器前预先保存状态。</p></blockquote><h3 id="实现钩子函数的方式"><a href="#实现钩子函数的方式" class="headerlink" title="实现钩子函数的方式"></a>实现钩子函数的方式</h3><p>Exec 执行一段特定的命令，该命令消耗的资源会被计入容器</p><p>HTTP 对容器上的特定的端点执行 HTTP 请求</p><h3 id="示例：PostStart-环境准备"><a href="#示例：PostStart-环境准备" class="headerlink" title="示例：PostStart 环境准备"></a>示例：PostStart 环境准备</h3><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">hook-demo1</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hook-demo1</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>    <span class="hljs-attr">lifecycle:</span>      <span class="hljs-attr">postStart:</span>        <span class="hljs-attr">exec:</span>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/bin/sh&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, <span class="hljs-string">&quot;echo Hello from the postStart handler &gt; /usr/share/message&quot;</span>]</code></pre><h3 id="删除资源对象"><a href="#删除资源对象" class="headerlink" title="删除资源对象"></a>删除资源对象</h3><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">hook-demo2</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hook-demo2</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>    <span class="hljs-attr">lifecycle:</span>      <span class="hljs-attr">preStop:</span>        <span class="hljs-attr">exec:</span>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;/usr/sbin/nginx&quot;</span>,<span class="hljs-string">&quot;-s&quot;</span>,<span class="hljs-string">&quot;quit&quot;</span>]<span class="hljs-meta">---</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">hook-demo2</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">hook</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hook-demo2</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>    <span class="hljs-attr">ports:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">webport</span>      <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>    <span class="hljs-attr">volumeMounts:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">message</span>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/</span>    <span class="hljs-attr">lifecycle:</span>      <span class="hljs-attr">preStop:</span>        <span class="hljs-attr">exec:</span>          <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;/bin/sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;echo Hello from the preStop Handler &gt; /usr/share/message&#x27;</span>]  <span class="hljs-attr">volumes:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">message</span>    <span class="hljs-attr">hostPath:</span>      <span class="hljs-attr">path:</span> <span class="hljs-string">/tmp</span></code></pre><h3 id="健康检查-探针"><a href="#健康检查-探针" class="headerlink" title="健康检查-探针"></a>健康检查-探针</h3><p><code>liveness probe</code>（存活探针）</p><ul><li>kubelet 通过使用 liveness probe 来确定你的应用程序是否正在运行，通俗点将就是是否还活着。一般来说，如果你的程序一旦崩溃了， Kubernetes 就会立刻知道这个程序已经终止了，然后就会重启这个程序。而我们的 liveness probe 的目的就是来捕获到当前应用程序还没有终止，还没有崩溃，如果出现了这些情况，那么就重启处于该状态下的容器，使应用程序在存在 bug 的情况下依然能够继续运行下去。</li></ul><p><code>readiness probe</code>（可读性探针）</p><ul><li>kubelet 使用 readiness probe 来确定容器是否已经就绪可以接收流量过来了。这个探针通俗点讲就是说是否准备好了，现在可以开始工作了。只有当 Pod 中的容器都处于就绪状态的时候 kubelet 才会认定该 Pod 处于就绪状态，因为一个 Pod 下面可能会有多个容器。当然 Pod 如果处于非就绪状态，那么我们就会将他从我们的工作队列(实际上就是我们后面需要重点学习的 Service)中移除出来，这样我们的流量就不会被路由到这个 Pod 里面来了。</li></ul><h3 id="初始化容器-Init-Container"><a href="#初始化容器-Init-Container" class="headerlink" title="初始化容器 Init Container"></a>初始化容器 Init Container</h3><p><code>Init Container</code>就是用来做初始化工作的容器，可以是一个或者多个，如果有多个的话，这些容器会按定义的顺序依次执行，只有所有的<code>Init Container</code>执行完后，主容器才会被启动。我们知道一个<code>Pod</code>里面的所有容器是共享数据卷和网络命名空间的，所以<code>Init Container</code>里面产生的数据可以被主容器使用到的。</p><p><code>PostStart</code>和<code>PreStop</code>包括<code>liveness</code>和<code>readiness</code>是属于主容器的生命周期范围内的，而<code>Init Container</code>是独立于主容器之外的，当然他们都属于<code>Pod</code>的生命周期范畴之内的</p><p><code>infra</code>镜像</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="等待其他模块Ready"><a href="#等待其他模块Ready" class="headerlink" title="等待其他模块Ready"></a>等待其他模块Ready</h4><p>用来解决服务之间的依赖问题</p><p>比如我们有一个 Web 服务，该服务又依赖于另外一个数据库服务，但是在我们启动这个 Web 服务的时候我们并不能保证依赖的这个数据库服务就已经启动起来了，所以可能会出现一段时间内 Web 服务连接数据库异常。要解决这个问题的话我们就可以在 Web 服务的 Pod 中使用一个 InitContainer，在这个初始化容器中去检查数据库是否已经准备好了，准备好了过后初始化容器就结束退出，然后我们的主容器 Web 服务被启动起来，这个时候去连接数据库就不会有问题了。</p><h4 id="做初始化配置"><a href="#做初始化配置" class="headerlink" title="做初始化配置"></a>做初始化配置</h4><p>比如集群里检测所有已经存在的成员节点，为主容器准备好集群的配置信息，这样主容器起来后就能用这个配置信息加入集群。</p><h4 id="其他场景"><a href="#其他场景" class="headerlink" title="其他场景"></a>其他场景</h4><p>将 pod 注册到一个中央数据库、配置中心</p><h4 id="服务依赖示例"><a href="#服务依赖示例" class="headerlink" title="服务依赖示例"></a>服务依赖示例</h4><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">init-pod1</span>  <span class="hljs-attr">labels:</span>    <span class="hljs-attr">app:</span> <span class="hljs-string">init</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">init-container</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;echi The app is running &amp;&amp; sleep 3600&#x27;</span>]  <span class="hljs-attr">initContainers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">init-myservice</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;until nslookup myservice; do echo waiting for myservice; sleep 2; done;&#x27;</span>]  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">init-mydb</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>    <span class="hljs-attr">command:</span> [<span class="hljs-string">&#x27;sh&#x27;</span>, <span class="hljs-string">&#x27;-c&#x27;</span>, <span class="hljs-string">&#x27;until nslookup mydb; do echo waiting for mydb; sleep 2; done;&#x27;</span>]</code></pre><p>Service 对应的 YAML</p><pre><code class="hljs yaml"><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">myservice</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">ports:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">6376</span><span class="hljs-meta">---</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Service</span><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">mydb</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">ports:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">protocol:</span> <span class="hljs-string">TCP</span>    <span class="hljs-attr">port:</span> <span class="hljs-number">80</span>    <span class="hljs-attr">targetPort:</span> <span class="hljs-number">6377</span></code></pre><p><code>在Pod启动过程中，初始化容器会按顺序在网络和数据卷初始化之后启动。每个容器必须在下一个容器启动之前成功退出。如果由于运行时或失败退出，导致容器启动失败，它会根据Pod的restartPolicy指定的策略进行重试。 然而，如果 Pod 的 restartPolicy 设置为 Always，Init 容器失败时会使用 RestartPolicy 策略。</code></p><p>在所有的初始化容器没有成功之前，<code>Pod</code>将不会变成 <code>Ready</code>状态。正在初始化中的<code>Pod</code>处于<code>Pending</code>状态，但应该会将条件<code>Initializing</code>设置为 true。</p><h4 id="初始化配置工作-Pod"><a href="#初始化配置工作-Pod" class="headerlink" title="初始化配置工作 Pod"></a>初始化配置工作 Pod</h4><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">v1</span><span class="hljs-attr">kind:</span> <span class="hljs-string">Pod</span><span class="hljs-attr">metadata:</span>  <span class="hljs-attr">name:</span> <span class="hljs-string">init-demo</span><span class="hljs-attr">spec:</span>  <span class="hljs-attr">containers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">nginx</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">nginx</span>    <span class="hljs-attr">ports:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">containerPort:</span> <span class="hljs-number">80</span>    <span class="hljs-attr">volumeMounts:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">workdir</span>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">/usr/share/nginx/html</span>  <span class="hljs-attr">initContainers:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">install</span>    <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span>    <span class="hljs-attr">command:</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">wget</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;-O&quot;</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;/work-dir/index.html&quot;</span>    <span class="hljs-bullet">-</span> <span class="hljs-string">http://www.baidu.com</span>    <span class="hljs-attr">volumeMounts:</span>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">workdir</span>      <span class="hljs-attr">mountPath:</span> <span class="hljs-string">&quot;/work-dir&quot;</span>  <span class="hljs-attr">volumes:</span>  <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">workdir</span>    <span class="hljs-attr">emptyDir:</span> &#123;&#125;</code></pre><h3 id="Volumes"><a href="#Volumes" class="headerlink" title="Volumes"></a>Volumes</h3><p>spec.volumes 指的是 Pod 中的卷，spec.containers.volumeMounts，是指指定的卷 mount 到容器指定的位置，相当于 docker 里面的 -v 宿主机目录：容器目录，emptyDir{}，相当于一个共享卷，是一个临时的目录，生命周期等同于 Pod 的生命周期。</p><p>初始化容器执行完，会下载一个 html 文件映射到 emptyDir{}，而主容器也适合 spec.volumes 里的 emptyDir{} 进行映射，所以 nginx 容器的 /usr/share/nginx/html 目录下回映射到 index.html 文件</p><p>验证 kubectl get pod init-demo</p><p>在 init-demo 容器里的 nginx 容器里打开一个shell</p><pre><code class="hljs shell">kubectl exec -it init-demo -- /bin/bash</code></pre>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker</title>
    <link href="/2021/10/15/cloud/install/Docker%20Install/"/>
    <url>/2021/10/15/cloud/install/Docker%20Install/</url>
    
    <content type="html"><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h2><p>docker-intstall-on-centos7.sh</p><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看内核版本</span>uname -r<span class="hljs-meta">#</span><span class="bash"> 更新 yum 包</span>yum -y update<span class="hljs-meta">#</span><span class="bash"> 卸载旧版 docker</span>yum remove -y docker docker-common docker-selinux docker-engine<span class="hljs-meta">#</span><span class="bash"> 安装依赖包</span>yum install -y yum-utils device-mapper-persistent-data lvm2<span class="hljs-meta">#</span><span class="bash"> 添加 yum 源</span>yum-config-manager --add-repo http://download.docker.com/linux/centos/docker-ce.repoyum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<span class="hljs-meta">#</span><span class="bash"> 查看docker 版本</span>yum list docker-ce --showduplicates | sort -r<span class="hljs-meta">#</span><span class="bash"> 选择 docker 版本安装</span>yum -y install docker-ce-3:20.10.9-3.el7<span class="hljs-meta">#</span><span class="bash"> 启动 Docker</span>systemctl start docker<span class="hljs-meta">#</span><span class="bash"> 开机启动 docker</span>systemctl enable docker<span class="hljs-meta">#</span><span class="bash"> 安装 docker compose</span>curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composedocker-compose -vsystemctl daemon-reloadsudo service docker restartsudo service docker status</code></pre><pre><code class="hljs javascript">注意 yum -y update：升级所有包同时也升级软件和系统内核； yum -y upgrade：只升级所有包，不升级软件和系统内核</code></pre><ul><li>docker compose 安装</li></ul><pre><code class="hljs shell">curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/local/bin/docker-composechmod +x /usr/local/bin/docker-composedocker-compose -v</code></pre><h3 id="On-ubuntu"><a href="#On-ubuntu" class="headerlink" title="On ubuntu"></a>On ubuntu</h3><pre><code class="hljs sh">curl -sSL https://get.daocloud.io/docker | sh<span class="hljs-comment"># 启动 Docker</span>systemctl start docker<span class="hljs-comment"># 开机启动 docker</span>systemctl <span class="hljs-built_in">enable</span> docker<span class="hljs-comment"># 安装 docker compose</span>curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.4/docker-compose-`uname -s`-`uname -m` &gt; /usr/<span class="hljs-built_in">local</span>/bin/docker-composechmod +x /usr/<span class="hljs-built_in">local</span>/bin/docker-composedocker-compose -vsystemctl daemon-reloadsudo service docker restartsudo service docker status</code></pre><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><pre><code class="hljs shell">docker pull ubuntu:16.04docker run -it --rm ubuntu:16.04 /bin/bash # -t 分配伪终端 -i 让容器的标准输入保持打开docker image ls  # docker image ls列表中的镜像体积总和并非是所有镜像实际硬盘消耗docker system df # 查看镜像、容器、数据卷所占用的空间docker container startdocker run container -d # -d 在后台运行而不是把执行命令的结果输出在当前宿主机下docker logs # 查看容器运行结果docker container ls # 查看容器信息docker container stop # 终止一个运行中的容器docker exec -i ID bash # 对后台 docker 进行操作docker container rm ID # 删除处于终于状态的容器docker container prune # 清理掉所有处于终止状态的容器docker container -aq # 清理掉所有处于终止状态的容器docker image rm ID # 删除本地的镜像，也可使用镜像名docker image rmi ID # 删除本地的镜像，也可使用镜像名docker run --name webserver -d -p 80:80 nginx # --name 命名 -p 端口映射docker diff name # 查看改动docker commit --author &quot;&quot; --message &quot;&quot; webserver nginx:v2docker history nginx:v2 # 查看镜像内的历史记录docker build -t nginx:v3 . # 基于 Dockerfile 生成镜像docker save xxx | gzip &gt; xxx-latest.tar.gz # 保存镜像docker load -i xxx-latest.tar.gz # 加载镜像docker save &lt;镜像名&gt; | bzip2 | pv | ssh &lt;用户名&gt;@&lt;主机名&gt; &#x27;cat | docker load&#x27; # 将镜像迁移到另一个机器docker search name # 查询镜像，automated资源允许用户验证镜像的来源和内容docker tag ubuntu:17.10 username/ubuntu:17.10 # 命名docker push username/ubuntu:17.10 # username 替换为 自己的 Docker 账号用户名docker run -d -p 5000:5000 --restart=always --name registry registry # 构建私有的镜像仓库</code></pre><h3 id="命令行补全"><a href="#命令行补全" class="headerlink" title="命令行补全"></a>命令行补全</h3><pre><code class="hljs shell">yum install -y bash-completionsource /usr/share/bash-completion/bash_completionsource /usr/share/bash-completion/completions/docker</code></pre><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> nginx<span class="hljs-keyword">RUN</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;h1&gt;Hello, Docker!&lt;/h1&gt;&#x27;</span> &gt; /usr/share/nginx/html/index.html</span></code></pre><pre><code class="hljs shell">docker build [选项] &lt;上下文路径/URL/-&gt;</code></pre><h2 id="私有仓库"><a href="#私有仓库" class="headerlink" title="私有仓库"></a>私有仓库</h2><p>将上传的镜像放到本地的 /opt/data/registry 目录</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> docker run -d \</span>    -p 5000:5000 \    -v /opt/data/registry:/var/lib/registry \    registry</code></pre><p>在私有仓库上传、搜索、下载镜像</p><p> docker tag IMAGE[:TAG]  [REGISTRY_HOST[:REGISTRY_PORT]/]REPOSITORY[:TAG]</p><h2 id="常用-docker-命令"><a href="#常用-docker-命令" class="headerlink" title="常用 docker 命令"></a>常用 docker 命令</h2><h3 id="容器信息"><a href="#容器信息" class="headerlink" title="容器信息"></a>容器信息</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">[[查看docker]]容器版本</span>docker version<span class="hljs-meta">#</span><span class="bash">[[查看docker]]容器信息</span>docker info<span class="hljs-meta">#</span><span class="bash">[[查看docker]]容器帮助</span>docker --help</code></pre><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">[[列出本地images]]</span>docker images<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#含中间映像层</span></span>docker images -a<span class="hljs-meta">#</span><span class="bash">[[只显示镜像ID]]</span>docker images -q<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#含中间映像层</span></span>docker images -qa   <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#显示镜像摘要信息(DIGEST列)</span></span>docker images --digests<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#显示镜像完整信息</span></span>docker images --no-trunc<span class="hljs-meta">#</span><span class="bash">[[搜索仓库MySQL]]镜像</span>docker search mysql<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># --filter=stars=600：只显示 starts&gt;=600 的镜像</span></span>docker search --filter=stars=600 mysql<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># --no-trunc 显示镜像完整 DESCRIPTION 描述</span></span>docker search --no-trunc mysql<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># --automated ：只列出 AUTOMATED=OK 的镜像</span></span>docker search  --automated mysql<span class="hljs-meta">#</span><span class="bash">[[搜索仓库MySQL]]镜像</span>docker search mysql<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># --filter=stars=600：只显示 starts&gt;=600 的镜像</span></span>docker search --filter=stars=600 mysql<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># --no-trunc 显示镜像完整 DESCRIPTION 描述</span></span>docker search --no-trunc mysql<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># --automated ：只列出 AUTOMATED=OK 的镜像</span></span>docker search  --automated mysql<span class="hljs-meta">#</span><span class="bash">[[下载Redis官方最新镜像，相当于：docker]] pull redis:latest</span>docker pull redis<span class="hljs-meta">#</span><span class="bash">[[下载仓库所有Redis]]镜像</span>docker pull -a redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#下载私人仓库镜像</span></span>docker pull bitnami/redis<span class="hljs-meta">#</span><span class="bash">[[单个镜像删除，相当于：docker]] rmi redis:latest</span>docker rmi redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#强制删除(针对基于镜像有运行的容器进程)</span></span>docker rmi -f redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#多个镜像删除，不同镜像间以空格间隔</span></span>docker rmi -f redis tomcat nginx<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#删除本地全部镜像</span></span>docker rmi -f $(docker images -q)<span class="hljs-meta">#</span><span class="bash">[[（1）编写dockerfile]]</span>cd /docker/dockerfilevim mycentos<span class="hljs-meta">#</span><span class="bash">[[（2）构建docker]]镜像</span>docker build -f /docker/dockerfile/mycentos -t mycentos:1.1</code></pre><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">[[新建并启动容器，参数：-i]]  以交互模式运行容器；-t  为容器重新分配一个伪输入终端；--name  为容器指定一个名称</span>docker run -i -t --name mycentos<span class="hljs-meta">#</span><span class="bash">[[后台启动容器，参数：-d]]  已守护方式启动容器</span>docker run -d mycentos<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#启动一个或多个已经被停止的容器</span></span>docker start redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#重启容器</span></span>docker restart redis[[top]]支持 ps 命令参数，格式：docker top [OPTIONS] CONTAINER [ps OPTIONS]<span class="hljs-meta">#</span><span class="bash">[[列出redis]]容器中运行进程</span>docker top redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#查看所有运行容器的进程信息</span></span>for i in  `docker ps |grep Up|awk &#x27;&#123;print $1&#125;&#x27;`;do echo \ &amp;&amp;docker top $i; done<span class="hljs-meta">#</span><span class="bash">[[查看redis]]容器日志，默认参数</span>docker logs rabbitmq<span class="hljs-meta">#</span><span class="bash">[[查看redis容器日志，参数：-f]]  跟踪日志输出；-t   显示时间戳；--tail  仅列出最新N条容器日志；</span>docker logs -f -t --tail=20 redis<span class="hljs-meta">#</span><span class="bash">[[查看容器redis从2019年05月21日后的最新10]]条日志。</span>docker logs --since=&quot;2019-05-21&quot; --tail=10 redis<span class="hljs-meta">#</span><span class="bash">[[使用run]]方式在创建时进入</span>docker run -it centos /bin/bash<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#关闭容器并退出</span></span>exit<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#仅退出容器，不关闭</span></span>快捷键：Ctrl + P + Q<span class="hljs-meta">#</span><span class="bash">[[直接进入centos]] 容器启动命令的终端，不会启动新进程，多个attach连接共享容器屏幕，参数：--sig-proxy=<span class="hljs-literal">false</span>  确保CTRL-D或CTRL-C不会关闭容器</span>docker attach --sig-proxy=false centos <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#在 centos 容器中打开新的交互模式终端，可以启动新进程，参数：-i  即使没有附加也保持STDIN 打开；-t  分配一个伪终端</span></span>docker exec -i -t  centos /bin/bash<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#以交互模式在容器中执行命令，结果返回到当前终端屏幕</span></span>docker exec -i -t centos ls -l /tmp<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#以分离模式在容器中执行命令，程序后台运行，结果不会反馈到当前终端</span></span>docker exec -d centos  touch cache.txt <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#查看正在运行的容器</span></span>docker ps<span class="hljs-meta">#</span><span class="bash">[[查看正在运行的容器的ID]]</span>docker ps -q<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#查看正在运行+历史运行过的容器</span></span>docker ps -a<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#显示运行容器总文件大小</span></span>docker ps -s<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#显示最近创建容器</span></span>docker ps -l<span class="hljs-meta">#</span><span class="bash">[[显示最近创建的3]]个容器</span>docker ps -n 3<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#不截断输出</span></span>docker ps --no-trunc <span class="hljs-meta">#</span><span class="bash">[[获取镜像redis]]的元信息</span>docker inspect redis<span class="hljs-meta">#</span><span class="bash">[[获取正在运行的容器redis]]的 IP</span>docker inspect --format=&#x27;&#123;&#123;range .NetworkSettings.Networks&#125;&#125;&#123;&#123;.IPAddress&#125;&#125;&#123;&#123;end&#125;&#125;&#x27; redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#停止一个运行中的容器</span></span>docker stop redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#杀掉一个运行中的容器</span></span>docker kill redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#删除一个已停止的容器</span></span>docker rm redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#删除一个运行中的容器</span></span>docker rm -f redis<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">#删除多个容器</span></span>docker rm -f $(docker ps -a -q)docker ps -a -q | xargs docker rm<span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># -l 移除容器间的网络连接，连接名为 db</span></span>docker rm -l db <span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment"># -v 删除容器，并删除容器挂载的数据卷</span></span>docker rm -v redis<span class="hljs-meta">#</span><span class="bash">[[基于当前redis容器创建一个新的镜像；参数：-a]] 提交的镜像作者；-c 使用Dockerfile指令来创建镜像；-m :提交时的说明文字；-p :在commit时，将容器暂停</span>docker commit -a=&quot;DeepInThought&quot; -m=&quot;my redis&quot; [redis容器ID]  myredis:v1.1<span class="hljs-meta">#</span><span class="bash">[[将rabbitmq容器中的文件copy]]至本地路径</span>docker cp rabbitmq:/[container_path] [local_path]<span class="hljs-meta">#</span><span class="bash">[[将主机文件copy至rabbitmq]]容器</span>docker cp [local_path] rabbitmq:/[container_path]/<span class="hljs-meta">#</span><span class="bash">[[将主机文件copy至rabbitmq]]容器，目录重命名为[container_path]（注意与非重命名copy的区别）</span>docker cp [local_path] rabbitmq:/[container_path]</code></pre><h3 id=""><a href="#" class="headerlink" title=""></a></h3>]]></content>
    
    
    <categories>
      
      <category>Cloud Native</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SQL</title>
    <link href="/2021/09/09/tmp/SQL/SQL/"/>
    <url>/2021/09/09/tmp/SQL/SQL/</url>
    
    <content type="html"><![CDATA[<h1 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h1><p>[TOC]</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h3><blockquote><pre><code class="hljs mysql">INSERT INTO table(column1, column2,...)VALUES (value1, value2,...);</code></pre></blockquote><h3 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h3><blockquote><pre><code class="hljs mysql">SELECT * FROM artists LIMIT [Number to Limit By];</code></pre><p> 用于规定要返回的记录的数目。</p></blockquote><pre><code class="hljs mysql">select * from table limit 2,1;                 &#x2F;&#x2F;含义是跳过2条取出1条数据，limit后面是从第2条开始读，读取1条信息，即读取第3条数据</code></pre><h3 id="OFFSET"><a href="#OFFSET" class="headerlink" title="OFFSET"></a>OFFSET</h3><blockquote><pre><code class="hljs mysql">SELECT * FROM artists LIMIT 5 OFFSET [Number of rows to skip];</code></pre></blockquote><pre><code class="hljs mysql">select * from table limit 2 offset 1;      &#x2F;&#x2F;含义是从第1条（不包括）数据开始取出2条数据，limit后面跟的是2条数据，offset后面是从第1条开始读取，即读取第2,3条</code></pre><h3 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;  &gt;="></a>&gt;  &gt;=</h3><h3 id="BETWEEN"><a href="#BETWEEN" class="headerlink" title="BETWEEN"></a>BETWEEN</h3><blockquote><pre><code class="hljs mysql">expression BETWEEN low AND high;expression &gt;&#x3D; low and expression &lt;&#x3D; high</code></pre></blockquote><h3 id="gt-lt-gt"><a href="#gt-lt-gt" class="headerlink" title="!=  -&gt; &lt;&gt;"></a>!=  -&gt; &lt;&gt;</h3><blockquote><p>除..之外</p></blockquote><h3 id="IS-NOT"><a href="#IS-NOT" class="headerlink" title="IS NOT"></a>IS NOT</h3><blockquote><pre><code class="hljs mysql">WHERE expression IS (NOT) NULL</code></pre></blockquote><h3 id="AND-OR"><a href="#AND-OR" class="headerlink" title="AND   OR"></a>AND   OR</h3><h3 id="IN"><a href="#IN" class="headerlink" title="IN"></a>IN</h3><blockquote><pre><code class="hljs mysql">expression IN (value1,value2,...)</code></pre></blockquote><h3 id=""><a href="#" class="headerlink" title="()"></a>()</h3><blockquote><pre><code class="hljs mysql">括号内为一个整体</code></pre></blockquote><h3 id="LIKE"><a href="#LIKE" class="headerlink" title="LIKE"></a>LIKE</h3><blockquote><pre><code class="hljs mysql">expression LIKE pattern</code></pre></blockquote><table><thead><tr><th align="left">Expression</th><th align="left">Meaning</th></tr></thead><tbody><tr><td align="left">LIKE <code>&#39;Kim%&#39;</code></td><td align="left">Begins with <code>Kim</code></td></tr><tr><td align="left">LIKE <code>&#39;%er&#39;</code></td><td align="left">Ends with er</td></tr><tr><td align="left">LIKE <code>&#39;%ch%&#39;</code></td><td align="left">Contains <code>ch</code></td></tr><tr><td align="left">LIKE <code>&#39;Le_&#39;</code></td><td align="left">Begins with <code>Le</code> and is followed by at most one character e.g., Les, Len…</td></tr><tr><td align="left">LIKE <code>&#39;_uy&#39;</code></td><td align="left">Ends with <code>uy</code> and is preceded by at most one character e.g., guy</td></tr><tr><td align="left">LIKE <code>&#39;%are_&#39;</code></td><td align="left">Contains <code>are</code>, begins with any number of characters and ends with at most one character</td></tr><tr><td align="left">LIKE <code>&#39;_are%&#39;</code></td><td align="left">Contains <code>are</code>, begins with at most one character and ends with any number of characters</td></tr></tbody></table><h3 id="MAX"><a href="#MAX" class="headerlink" title="MAX()"></a>MAX()</h3><blockquote><pre><code class="hljs mysql">MAX(expression)</code></pre></blockquote><h3 id="MIN"><a href="#MIN" class="headerlink" title="MIN()"></a>MIN()</h3><blockquote><pre><code class="hljs mysql">MIN(expression)</code></pre></blockquote><h3 id="AVG"><a href="#AVG" class="headerlink" title="AVG()"></a>AVG()</h3><blockquote><pre><code class="hljs mysql">AVG (ALL | DISTINCT expression)</code></pre><p>AVG 会忽略 NULL</p></blockquote><h3 id="ROUND"><a href="#ROUND" class="headerlink" title="ROUND()"></a>ROUND()</h3><blockquote><pre><code class="hljs mysql">SELECT ROUND(column_name,decimals) FROM table_name</code></pre></blockquote><table><thead><tr><th>Expression</th><th>Meaning</th></tr></thead><tbody><tr><td>column_name</td><td>必需。要舍入的字段。</td></tr><tr><td>decimals</td><td>必需。规定要返回的小数位数。</td></tr></tbody></table><h3 id="SUM"><a href="#SUM" class="headerlink" title="SUM"></a>SUM</h3><blockquote><pre><code class="hljs mysql"></code></pre></blockquote><h3 id="COUNT"><a href="#COUNT" class="headerlink" title="COUNT()"></a>COUNT()</h3><blockquote><pre><code class="hljs mysql">SELECT COUNT(column_name) FROM table_name</code></pre></blockquote><h3 id="GROUP-BY"><a href="#GROUP-BY" class="headerlink" title="GROUP BY"></a>GROUP BY</h3><blockquote><pre><code class="hljs mysql">SELECT     column1, column2, aggregate_function(expression)FROM    table_nameWHERE    conditionGROUP BY column1;</code></pre></blockquote><p>GROUP BY column1, column2;</p><p><strong>将所有具有相同 1 字段值和 2 字段值的记录放到一个分组里</strong></p><h3 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h3><blockquote><pre><code class="hljs mysql">SELECT     select_listFROM    table_nameORDER BY    (expr | column) ASC,   (expr | column) DESC;</code></pre></blockquote><p>ASC 升序，默认为升序</p><p>DESC 降序</p><p><strong>多个字段排序，每个字段后面都要标注，不标默认 ASC</strong></p><h3 id="CASE"><a href="#CASE" class="headerlink" title="CASE"></a>CASE</h3><blockquote><pre><code class="hljs mysql">CASE expr  WHEN expr_to_match THEN result  [ ... ]  [ ELSE else_result ]END</code></pre></blockquote><h3 id="IF"><a href="#IF" class="headerlink" title="IF()"></a>IF()</h3><blockquote><pre><code class="hljs mysq;">IF(expr, true_result, else_result)</code></pre></blockquote><h3 id="DAY"><a href="#DAY" class="headerlink" title="DAY()"></a>DAY()</h3><blockquote><pre><code class="hljs mysql">DAY(date)</code></pre></blockquote><h3 id="MONTH"><a href="#MONTH" class="headerlink" title="MONTH()"></a>MONTH()</h3><blockquote><pre><code class="hljs mysql">MONTH(date)</code></pre></blockquote><h3 id="YEAR"><a href="#YEAR" class="headerlink" title="YEAR()"></a>YEAR()</h3><blockquote><pre><code class="hljs mysql">YEAR(date)</code></pre></blockquote><h3 id="SYSDATETIME"><a href="#SYSDATETIME" class="headerlink" title="SYSDATETIME()"></a>SYSDATETIME()</h3><blockquote> <pre><code class="hljs mysql">SYSDATETIME()</code></pre></blockquote><h3 id="ISDATE"><a href="#ISDATE" class="headerlink" title="ISDATE()"></a>ISDATE()</h3><blockquote><pre><code class="hljs mysql">ISDATE()</code></pre><p>Check if the expression is a valid date</p></blockquote><h3 id="DATE-SUB"><a href="#DATE-SUB" class="headerlink" title="DATE_SUB()"></a>DATE_SUB()</h3><blockquote><pre><code class="hljs mysql">DATE_SUB(date,INTERVAL expr type)</code></pre><p><strong>DATE_SUB() 函数从日期减去指定的时间间隔</strong></p><p><em>date</em> 参数是合法的日期表达式。<em>expr</em> 参数是希望添加的时间间隔。</p></blockquote><h3 id="SUBSTRING-INDEX"><a href="#SUBSTRING-INDEX" class="headerlink" title="SUBSTRING_INDEX()"></a>SUBSTRING_INDEX()</h3><blockquote><pre><code class="hljs mysql">SUBSTRING_INDEX(string, delimiter, number)</code></pre><p> substring_index（“待截取有用部分的字符串”，“截取数据依据的字符”，截取字符的位置N）</p></blockquote><h3 id="SUBSTRING"><a href="#SUBSTRING" class="headerlink" title="SUBSTRING()"></a>SUBSTRING()</h3><blockquote><pre><code class="hljs mysql">SUBSTRING(string, start, length)SUBSTRING(string FROM start FOR length)</code></pre></blockquote><h3 id="JOIN"><a href="#JOIN" class="headerlink" title="JOIN"></a>JOIN</h3><p><img src="https://raw.githubusercontent.com/1ch0/Figure-bed/main/img/sql-join.png" alt="SQL JOINS"></p>]]></content>
    
    
    <categories>
      
      <category>SQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>sql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Web</title>
    <link href="/2021/09/08/go/go_web/Go%20Web/"/>
    <url>/2021/09/08/go/go_web/Go%20Web/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="Go-Web"><a href="#Go-Web" class="headerlink" title="Go Web"></a>Go Web</h1><h2 id="01-net-http"><a href="#01-net-http" class="headerlink" title="01 net/http"></a>01 net/http</h2><p><strong>库函数  &gt; 结构定义 &gt; 结构函数</strong></p><blockquote><p>创建服务 &gt; 创建连接 &gt; 监听请求 &gt; </p></blockquote><h3 id="server-源码："><a href="#server-源码：" class="headerlink" title="server 源码："></a>server 源码：</h3><ol><li><p>http.ListenAndServe 创建 server 数据结构, server.ListenAndServe</p></li><li><p>net. listen     Server.serve</p></li><li><p>c.serve   l.accept 接受请求  srv.NewConn 创建连接结构（ httpconn ） go c.serve(connCtx)</p></li><li><p>先判断是否升级为 https ，新建 读文本的 reader  和 写文本 buffer ， 读取数据</p></li><li><p>serverHanler{c.server}.ServeHTTP(w, w.req)</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> serverHandle <span class="hljs-keyword">struct</span> &#123;    srv *Server&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(sh serverHandle)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(rw ResponseWriter, req *Request)</span></span> &#123;    handle := sh.srv.Handler    <span class="hljs-keyword">if</span> handler == <span class="hljs-literal">nil</span> &#123;        handler = DefualtServeMux    &#125;    ...    handler.ServeHTTP(rw, req)&#125;</code></pre></li></ol><ol start="6"><li><p>serveHandler{c.server}.ServeHTTP(w, w.req) 判断 handler 是否为 nil，nil 则使用 DefaultServeMux,</p></li><li><p>DefaultServeMux.Handle   http.handle()  http.handleFunc() 去处理，map 形式 </p></li></ol><p>实现</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="实现-Handler-路由"><a href="#实现-Handler-路由" class="headerlink" title="实现 Handler 路由"></a>实现 Handler 路由</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> framework<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-keyword">type</span> Core <span class="hljs-keyword">struct</span> &#123;    &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCore</span><span class="hljs-params">()</span> *<span class="hljs-title">Core</span></span> &#123;    <span class="hljs-keyword">return</span> &amp;Core&#123;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Core)</span> <span class="hljs-title">HttpHandler</span><span class="hljs-params">(rep http.Reponse, req http.Request)</span></span> &#123;    &#125;</code></pre><h4 id="创建-server-数据结构"><a href="#创建-server-数据结构" class="headerlink" title="创建 server 数据结构"></a>创建 server 数据结构</h4><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./fromework&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;    server := &amp;http.Serve&#123;        Handler: framework.NewCore(),        Addr: <span class="hljs-string">&quot;:8080&quot;</span>,    &#125;    server.ListenAndServe()&#125;</code></pre><hr><p>go doc context|grep “^func”</p><hr><h5 id="http-FileServer"><a href="#http-FileServer" class="headerlink" title="http.FileServer()"></a>http.FileServer()</h5><ol><li>http.FileServer 创建 FileHandler 数据结构</li><li>FileHandler 结构体中包含 FileSystem 接口，FileSystem 接口包含Open 方法</li><li>http.Dir 的 Open 方法 实现  FileSystem 接口 的 Open 方法</li><li>http.Dir 的 Open 方法对表示字符串的文件路径进行判断：<ol><li>先判断 分隔符是否为 “/“且该字符串中是否包含分隔符，若不满足 返回 nil 和 error信息 “http: invalid character in file path”</li><li>将 http.Dir 从 Dir 类型转换为 string 类型，判断该是否为空，若为空，将 dir 赋值为 “.”</li><li>使用 path.Clean ，filepath.FromSlash 和 filepath.Join 方法获得路径全名</li><li>使用 os.Open 方法打开文件，如果打开失败，返回错误信息，如果成功以读模式打开文件</li></ol></li></ol><p>​     RuneSelf = utf8.0x80</p><p>​    r &lt; RuneSelf 代表 Rune 为单字节，rune为utf-8 unicode   4个字节  int32，</p><p>​    byte 代表 uint8，代表ASCII 码的一个字符</p><ul><li>表示非ASCII字符的多字节串的第一个字节总是在0xC0到0xFD的范围里，并指出这个字符包含多少个字节。<strong>多字节串的其余字节都在0x80到0xBF范围里</strong>，这使得重新同步非常容易，并使编码无国界，且很少受丢失字节的影响。</li><li>将高位设置为0时，它是一个单字节值。</li><li>将两个高位设置为10时，这是一个连续字节。</li><li>否则，它是一个多字节序列的第一个字节，前导1位的数量表示该序列总共有多少个字节(110…表示两个字节，1110…表示三个字节，依此类推)。</li></ul><h2 id="03-ROUTE"><a href="#03-ROUTE" class="headerlink" title="03 ROUTE"></a>03 ROUTE</h2><h2 id="04-MiddleWare"><a href="#04-MiddleWare" class="headerlink" title="04 MiddleWare"></a>04 MiddleWare</h2><h2 id="05-封装"><a href="#05-封装" class="headerlink" title="05 封装"></a>05 封装</h2>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go,web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Onion Model 洋葱模型</title>
    <link href="/2021/09/07/go/go_web/OnionModel/"/>
    <url>/2021/09/07/go/go_web/OnionModel/</url>
    
    <content type="html"><![CDATA[<h1 id="Onion-Model-洋葱模型"><a href="#Onion-Model-洋葱模型" class="headerlink" title="Onion Model 洋葱模型"></a>Onion Model 洋葱模型</h1><blockquote><p>请求进来，一层一层的通过中间件执行<code>next</code>函数进入到你设置的下一个中间件中，并且可以通过<code>context</code>对象一直向下传递下去，当到达最后一个中间件的时候，又向上返回到最初的地方。</p></blockquote><p>代码示例：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math&quot;</span>)<span class="hljs-keyword">type</span> Context <span class="hljs-keyword">struct</span> &#123;handlers []<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Context)</span></span>index <span class="hljs-keyword">int8</span>&#125;<span class="hljs-keyword">const</span> abortIndex = math.MaxInt8 / <span class="hljs-number">2</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Context)</span> <span class="hljs-title">Use</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>(c *Context)</span> )</span> &#123;this.handlers = <span class="hljs-built_in">append</span>(this.handlers, f)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Context)</span> <span class="hljs-title">GET</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>, f <span class="hljs-keyword">func</span>(c *Context)</span>)</span>  &#123;this.handlers = <span class="hljs-built_in">append</span>(this.handlers, f)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Context)</span> <span class="hljs-title">Next</span><span class="hljs-params">()</span></span>  &#123;<span class="hljs-keyword">if</span> this.index &lt; <span class="hljs-keyword">int8</span>(<span class="hljs-built_in">len</span>(this.handlers)) &#123;this.index++this.handlers[this.index](this)&#125;<span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Context)</span> <span class="hljs-title">Abort</span><span class="hljs-params">()</span></span>  &#123;this.index = abortIndex&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(this *Context)</span> <span class="hljs-title">Run</span><span class="hljs-params">()</span></span>  &#123;this.handlers[<span class="hljs-number">0</span>](this)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;c := &amp;Context&#123;&#125;c.Use(middle3())c.Use(middle2())c.Use(middle1())c.GET(<span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Context)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;ONION&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&quot;</span>)&#125;)c.Run()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middle1</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">(c *Context)</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Context)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;middle1----BEGIN&quot;</span>)c.Next()fmt.Println(<span class="hljs-string">&quot;middle1----END&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middle2</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">(c *Context)</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Context)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;middle2----BEGIN&quot;</span>)c.Abort()c.Next()fmt.Println(<span class="hljs-string">&quot;middle2----END&quot;</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">middle3</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">(c *Context)</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(c *Context)</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;middle3----BEGIN&quot;</span>)c.Next()fmt.Println(<span class="hljs-string">&quot;middle3----END&quot;</span>)&#125;&#125;</code></pre><p>运行结果：</p><pre><code class="hljs shell">middle3----BEGINmiddle2----BEGINmiddle1----BEGIN<span class="hljs-meta">ONION&gt;</span><span class="bash">&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;</span>middle1----ENDmiddle2----ENDmiddle3----END</code></pre>]]></content>
    
    
    <categories>
      
      <category>GO WEB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang, Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO 设计模式</title>
    <link href="/2021/08/07/go/design_parttern/singleton/"/>
    <url>/2021/08/07/go/design_parttern/singleton/</url>
    
    <content type="html"><![CDATA[<h1 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h1><blockquote><p>一个类只允许创建一个实例。</p><p>在业务概念中，在系统中只应该保存一份的数据，适合用单例模式。</p></blockquote><ol><li>饿汉式</li></ol><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<span class="hljs-keyword">type</span> Singleton <span class="hljs-keyword">struct</span> &#123;&#125;<span class="hljs-keyword">var</span> singleton *Singleton<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>  &#123;singleton = &amp;Singleton&#123;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> *<span class="hljs-title">Singleton</span></span> &#123;<span class="hljs-keyword">return</span> singleton&#125;</code></pre><ol start="2"><li>懒汉式</li></ol><pre><code class="hljs go"><span class="hljs-keyword">package</span> singleton<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><span class="hljs-keyword">type</span> Singleton <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-keyword">var</span> (lazySingleton *Singletononce = sync.Once&#123;&#125;)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetLazyInstance</span><span class="hljs-params">()</span> *<span class="hljs-title">Singleton</span></span> &#123;<span class="hljs-keyword">if</span> lazySingleton == <span class="hljs-literal">nil</span> &#123;once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;lazySingleton = &amp;Singleton&#123;&#125;&#125;)&#125;<span class="hljs-keyword">return</span> lazySingleton&#125;</code></pre>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黄奇帆-消费互联网的四大问题</title>
    <link href="/2021/07/20/tmp/Life/%E9%BB%84%E5%A5%87%E5%B8%86-%E6%B6%88%E8%B4%B9%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2021/07/20/tmp/Life/%E9%BB%84%E5%A5%87%E5%B8%86-%E6%B6%88%E8%B4%B9%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E5%9B%9B%E5%A4%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="消费互联网的四大问题"><a href="#消费互联网的四大问题" class="headerlink" title="消费互联网的四大问题"></a>消费互联网的四大问题</h1><ol><li>零和效益</li><li>利用人性的弱点设计各种产品</li><li>企业数据采集没有底线</li><li>互联网杀熟</li></ol>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>life</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机定律、理念、名言</title>
    <link href="/2021/07/15/tmp/CS/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9A%E5%BE%8B/"/>
    <url>/2021/07/15/tmp/CS/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9A%E5%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机定律、理念、名言"><a href="#计算机定律、理念、名言" class="headerlink" title="计算机定律、理念、名言"></a>计算机定律、理念、名言</h1><h2 id="计算机定律"><a href="#计算机定律" class="headerlink" title="计算机定律"></a>计算机定律</h2><p><img src="https://raw.githubusercontent.com/1ch0/Figure-bed/main/img/desktop1.jpg"></p><h3 id="Gartner-的技术成熟度曲线（The-Hype-Cycle）"><a href="#Gartner-的技术成熟度曲线（The-Hype-Cycle）" class="headerlink" title="Gartner 的技术成熟度曲线（The Hype Cycle）"></a>Gartner 的技术成熟度曲线（The Hype Cycle）</h3><blockquote><p>Gartner 的技术成熟度曲线又叫技术循环曲线，是企业用来评估新科技是否要采用或采用<br>时机的一种可视化方法，它利用时间轴与该技术在市面上的可见度（媒体曝光度）决定要<br>不要采用，以及什么时候采用这种新科技</p></blockquote><h3 id="Moore’s-law-——-摩尔定律"><a href="#Moore’s-law-——-摩尔定律" class="headerlink" title="Moore’s law —— 摩尔定律"></a>Moore’s law —— 摩尔定律</h3><blockquote><p>“ <a href="https://zh.wikipedia.org/wiki/%E9%9B%86%E6%88%90%E7%94%B5%E8%B7%AF">集成电路</a>上可容纳的<a href="https://zh.wikipedia.org/wiki/%E6%99%B6%E4%BD%93%E7%AE%A1">晶体管</a>数目，约每隔两年便会增加一倍。”</p><p>——<a href="https://zh.wikipedia.org/wiki/%E6%88%88%E7%99%BB%C2%B7%E6%91%A9%E5%B0%94">戈登·摩尔</a></p></blockquote><p>经常被引用的“18个月”，是由英特尔<a href="https://zh.wikipedia.org/wiki/%E9%A6%96%E5%B8%AD%E6%89%A7%E8%A1%8C%E5%AE%98">首席执行官</a>大卫·豪斯（David House）提出：预计18个月会将芯片的性能提高一倍（即更多的晶体管使其更快），是一种以<a href="https://zh.wikipedia.org/wiki/%E5%80%8D%E6%95%B8%E5%A2%9E%E9%95%B7">倍数增长</a>的观测。</p><p>尽管近现代的数十年间摩尔定律均成立，但它仍应被视为是对现象的观测或对未来的推测，而不应被视为一个物理定律或者自然界的规律。</p><p>从另一角度看，未来的增长率在逻辑上无法保证会跟过去的数据一样，也就是逻辑上无法保证摩尔定律会持续下去。虽然预计摩尔定律将持续到至少2020年。[<a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B[[cite_note-3]]">3]</a>然而，2010年<a href="https://zh.wikipedia.org/wiki/%E5%9B%BD%E9%99%85%E5%8D%8A%E5%AF%BC%E4%BD%93%E6%8A%80%E6%9C%AF%E5%8F%91%E5%B1%95%E8%93%9D%E5%9B%BE">国际半导体技术发展路线图</a>的更新增长已经在2013年年底放缓[<a href="https://zh.wikipedia.org/wiki/%E6%91%A9%E5%B0%94%E5%AE%9A%E5%BE%8B[[cite_note-4]]">4]</a>；又比如说英特尔在22纳米跟14纳米的CPU制程上已经放慢了技术更新的脚步。</p><h3 id="Conway’s-Law-——-康威定律"><a href="#Conway’s-Law-——-康威定律" class="headerlink" title="Conway’s Law —— 康威定律"></a>Conway’s Law —— 康威定律</h3><blockquote><p>“设计系统的架构受制于产生这些设计的组织的沟通结构。”</p><p>——M. Conway</p></blockquote><p>即系统设计本质上反映了企业的组织机构。系统各个模块间的接口也反映了企业各个部门之间的信息流动和合作方式。</p><p>康威定律源于模块的设计者需要互相之间频繁沟通。而跨部门交流比较难。</p><p>康威的原文中提出的各定律：</p><ul><li>第一定律 组织沟通方式会通过系统设计表达出来</li><li>第二定律 时间再多一件事情也不可能做的完美，但总有时间做完一件事情</li><li>第三定律 线型系统和线型组织架构间有潜在的异质同态特性</li><li>第四定律 大的系统组织总是比小系统更倾向于分解</li></ul><h3 id="Zipf’s-law-——-齐夫定律"><a href="#Zipf’s-law-——-齐夫定律" class="headerlink" title="Zipf’s law —— 齐夫定律"></a>Zipf’s law —— 齐夫定律</h3><blockquote><p>在自然语言的语料库里，一个单词出现的频率与它在频率表里的排名成反比，呈现幂律分布</p></blockquote><h3 id="CAP-theorem-——-CAP定理"><a href="#CAP-theorem-——-CAP定理" class="headerlink" title="CAP theorem —— CAP定理"></a><strong>CAP theorem</strong> —— CAP定理</h3><blockquote><p><strong>CAP定理</strong>（CAP theorem），又被称作<strong>布鲁尔定理</strong>（Brewer’s theorem），它指出对于一个<a href="https://zh.wikipedia.org/wiki/%E5%88%86%E5%B8%83%E5%BC%8F%E8%AE%A1%E7%AE%97">分布式计算系统</a>来说，<a href="https://zh.wikipedia.org/wiki/%E4%B8%89%E9%9A%BE%E5%9B%B0%E5%A2%83">不可能同时满足以下三点</a>：</p><ul><li>一致性（<strong>C</strong>onsistency） （等同于所有节点访问同一份最新的数据副本）</li><li><a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E7%94%A8%E6%80%A7">可用性</a>（<strong>A</strong>vailability）（每次请求都能获取到非错的响应——但是不保证获取的数据为最新数据）</li><li><a href="https://zh.wikipedia.org/w/index.php?title=%E7%BD%91%E7%BB%9C%E5%88%86%E5%8C%BA&action=edit&redlink=1">分区容错性</a>（<strong>P</strong>artition tolerance）（以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。）</li></ul></blockquote><p>根据定理，分布式系统只能满足三项中的两项而不可能满足全部三项。理解CAP理论的最简单方式是想象两个节点分处分区两侧。允许至少一个节点更新状态会导致数据不一致，即丧失了C性质。如果为了保证数据一致性，将分区一侧的节点设置为不可用，那么又丧失了A性质。除非两个节点可以互相通信，才能既保证C又保证A，这又会导致丧失P性质。</p><h3 id="Law-of-holes"><a href="#Law-of-holes" class="headerlink" title="Law of holes"></a>Law of holes</h3><blockquote><p>“if you find yourself in a hole, stop digging.”</p></blockquote><p>挖坑会让它更深，因此更难脱身，这被用来比喻当处于一个无法维持的位置时，最好不要再继续下去，使情况恶化。</p><h2 id="计算机理念"><a href="#计算机理念" class="headerlink" title="计算机理念"></a>计算机理念</h2><h3 id="DESIGN-FOR-FAILURE"><a href="#DESIGN-FOR-FAILURE" class="headerlink" title="DESIGN FOR FAILURE"></a><a href="http://www.v-wiki.net/design-for-failure/">DESIGN FOR FAILURE</a></h3><blockquote><p>The concept of “Design for Failure” is often used to describe the approach that assumes that there will be a hardware or system failure somewhere, sometime – and instead of architecting for hardware and server clustering and availability, to design applications so that recovery can be performed quickly.</p></blockquote><p>“The Amazon model is the “design for failure” model. Under the “design for failure” model, combinations of your software and management tools take responsibility for application availability. The actual infrastructure availability is entirely irrelevant to your application availability. 100% uptime should be achievable even when your cloud provider has a massive, data-center-wide outage</p><blockquote><p>为失败而设计 “的概念经常被用来描述这样一种方法：假设在某个地方、某个时间会出现硬件或系统故障–而不是为硬件和服务器集群和可用性进行架构设计，以使应用程序可以快速恢复。</p></blockquote><p>“亚马逊模式 “是 “为失败而设计 “的模式。在 “为失败而设计 “的模式下，你的软件和管理工具的组合对应用程序的可用性负责。实际的基础设施的可用性与你的应用程序的可用性完全没有关系。即使你的云计算供应商发生大规模的、数据中心范围内的故障，100%的正常运行时间也应该是可以实现的。</p><h2 id="计算机名言"><a href="#计算机名言" class="headerlink" title="计算机名言"></a>计算机名言</h2><blockquote><p>Don’t communicate by sharing memory, share memory by communicating.Go Proverbs.</p><p>​                                                                                                                                        —— Rob Pike</p></blockquote><blockquote><p>“the only thing a Big Bang rewrite guarantees is a Big Bang!”                                       </p><p>​                                                                                                                                     —— Martin Fowler</p></blockquote><blockquote><p>编程世界同样如此，如果你不满足于只做一个 CRUD“码农”，而是想成为一个优秀的工程师，那就一定要积极锻炼直觉思考和快速类比的能力，尤其是在找不到 bug 的时候。这才是编程学习中能给人最快进步的方法和路径。</p><p>​                                                                                                                                        —— 景霄</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Computer Science</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ComputerLaw</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO专家编程</title>
    <link href="/2021/04/23/book/go/GO%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/04/23/book/go/GO%E4%B8%93%E5%AE%B6%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="GO专家编程"><a href="#GO专家编程" class="headerlink" title="GO专家编程"></a>GO专家编程</h1><h2 id="常见数据结构实现原理"><a href="#常见数据结构实现原理" class="headerlink" title="常见数据结构实现原理"></a>常见数据结构实现原理</h2><p>本章主要介绍常见的数据结构，比如channel、slice、map等，通过对其底层实现原理的分析，来加深认识，以此避免一些使用过程中的误区。</p><h3 id="Chan"><a href="#Chan" class="headerlink" title="Chan"></a>Chan</h3><ul><li><ol><li><p>前言</p><ul><li>channel是Golang在语言层面提供的goroutine间的通信方式，比Unix管道更易用也更轻便。channel主要用于进程内各goroutine间通信，如果需要跨进程通信，建议使用分布式系统的方法来解决。</li><li>本章从源码角度分析channel的实现机制，实际上这部分源码非常简单易读。</li></ul></li></ol></li><li><ol start="2"><li><p>chan数据结构</p><ul><li><p>2.0</p><ul><li><p>src/runtime/chan.go:hchan定义了channel的数据结构：</p><p>type hchan struct {</p><pre><code>qcount   uint           // 当前队列中剩余元素个数dataqsiz uint           // 环形队列长度，即可以存放的元素个数buf      unsafe.Pointer // 环形队列指针elemsize uint16         // 每个元素的大小closed   uint32            // 标识关闭状态elemtype *_type         // 元素类型sendx    uint           // 队列下标，指示元素写入时存放到队列中的位置recvx    uint           // 队列下标，指示元素从队列的该位置读出recvq    waitq          // 等待读消息的goroutine队列sendq    waitq          // 等待写消息的goroutine队列lock mutex              // 互斥锁，chan不允许并发读写</code></pre><p>}</p></li></ul></li></ul></li></ol></li></ul><pre><code>    - 从数据结构可以看出channel由队列、类型信息、goroutine等待队列组成，下面分别说明滚其原理。- 2.1 环形队列    - chan内部实现了一个环形队列作为其缓冲区，队列的长度时创建chan时指定的。    -       dataqsiz指示了队列长度为6，即可缓存6个元素；      buf指向队列的内存，队列中还剩余两个元素；      qcount表示队列中还有两个元素；      sendx指示后续写入的数据存储的位置，取值[0, 6)；      recvx指示从该位置读取数据, 取值[0, 6)；- 2.2 等待队列    - 从channel读数据，如果channel缓冲区为空或者没有缓冲区，当前goroutine会被阻塞    - 向channel写数据，如果channel缓冲已满或者没有缓冲区，当前goroutine会被阻塞    - 被阻塞的goroutine将会挂在channel的等待队列中        - 因读阻塞的goroutine会被channel写入数据的goroutine唤醒        - 因写阻塞的goroutine会被从channel读数据的goroutine唤醒        - 下入展示了一个没有缓冲区的channel，有几个goroutine阻塞等待读数据：        - 注意：一般情况下recvq和sendq至少由一个为空。只有一个例外，那就是同一个goroutine使用select语句向channel一边写数据，一边读数据。- 2.3 类型信息    - 一个channel只能传递一种类型的值，类型信息存储在hchan数据结构中。        - elemtype代表类型，用于数据传递过程中的赋值        - elemsize代表类型大小，用于在buf中定位元素位置- 2.4 锁    - 一个channel同时仅允许被被一个goroutine读写    - 为简单起见，本章后续部分说明读写过程时不再涉及加锁和解锁。</code></pre><ul><li><ol start="3"><li><p>channel读写</p><ul><li><p>3.1 创建channel</p><ul><li><p>创建channel的过程实际上是初始化hchcan结构。其中类型信息和缓冲区长度由make语句传入，buf的大小则与元素大小和缓冲区长度共同决定。</p></li><li><p>创建channel的伪代码如下</p><pre><code class="hljs swift"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makechan</span><span class="hljs-params">(t *chantype, size int)</span></span> *hchan &#123;    <span class="hljs-keyword">var</span> <span class="hljs-built_in">c</span> *hchan    <span class="hljs-built_in">c</span> = new(hchan)    <span class="hljs-built_in">c</span>.buf = malloc(元素类型大小*size)    <span class="hljs-built_in">c</span>.elemsize = 元素类型大小    <span class="hljs-built_in">c</span>.elemtype = 元素类型    <span class="hljs-built_in">c</span>.dataqsiz = size    <span class="hljs-keyword">return</span> <span class="hljs-built_in">c</span>&#125;</code></pre></li></ul></li></ul></li></ol></li></ul><pre><code>- 3.2 向channel写数据    - 向一个channel中写数据简单过程如下：        - 1. 如果等待队列recvq不为空，说明缓冲区中没有数据或者没有缓冲区，此时直接从recvq取出G，并把数据写入，最后把该G唤醒，结束发送过程；        - 3. 如果缓冲区中没有空余位置，将待发送数据写入G，将当前G加入sendq，进入睡眠，等待被读goroutine唤醒；    - 简单流程图如下：- 3.3 从channel读数据    - 从一个channel读数据简单过程如下：        - 1. 如果等待发送队列sendq不为空，且没有缓冲区，直接从sendq中取出G，把G中数据读出，最后把G唤醒，结束读取过程；        - 2. 如果等待发送队列sendq不为空，此时说明缓冲区已满，从缓冲区汇总首部读出数据，把G中数据写入缓冲区尾部，把G唤醒，结束读取过程。        - 3. 如果缓冲区中有数据，则从缓冲区取出数据，结束读取过程；        - 4. 将当前goroutine加入recvq，进入睡眠，等待被写goroutine唤醒；    - 简单流程图如下：- 3.4 关闭channel    - 关闭channe时会把recvq中的G全部唤醒，本该写入G的数据位置为nil。把sendq中的G全部唤醒，但这些G会panic。    - 除此之外，panic出现的常见场景还有：        - 1. 关闭值为nil的channel        - 2. 关闭已经被关闭的channel        - 3. 向已经关闭的channel写数据</code></pre><ul><li><ol start="4"><li><p>常见用法</p><ul><li><p>4.1 单向channel</p><ul><li><p>顾名思义，单向channel指只能用于发送或者接收数据，实际上也没有单向channel</p></li><li><p>我们知道chnanel可以通过参数传递，所谓单向channel只是对channel的一种使用限制，这跟C语言使用const修饰函数参数为只读是一个道理。</p><ul><li>func readChan(chanName &lt;-chan int): 通过形参限定函数内部只能从channel中读取数据</li><li>func writeChan(chanName chan&lt;- int): 同故宫形参限定函数内部只能向channel中写入数据</li></ul></li><li><p>一个简单的示例程序如下：</p><p>func readChan(chanName &lt;-chan int) {</p><pre><code>&lt;- chanName</code></pre><p>}</p><p>func writeChan(chanName chan&lt;- int) {</p><pre><code>chanName &lt;- 1</code></pre><p>}</p><p>func main() {</p><pre><code>var mychan = make(chan int, 10)writeChan(mychan)readChan(mychan)</code></pre><p>}</p></li></ul></li></ul></li></ol></li></ul><pre><code>    - mychan是个正常的channel，而readChan()参数限制了传入的channel只能用来读，writeChan()参数限制了传入的channel只能用来写、- 4.2 select    - 使用select可以监控多channel，比如监控多个channel，当其中某一个channel有数据时，就从其读出数据。    - 示例      package main      import (        &quot;fmt&quot;        &quot;time&quot;      )      func addNumberToChan(chanName chan int) &#123;          for &#123;                chanName &lt;- 1                time.Sleep(1 * time.Second)          &#125;      &#125;      func main() &#123;             var chan1 = make(chan int, 10)             var chan2 = make(chan int, 10)             go addNumberToChan(chan1)             go addNumberToChan(chan2)             for &#123;                   select &#123;                   case e := &lt;- chan1 :                           fmt.Printf(&quot;Get element from chan1: %d\n&quot;, e)                   case e := &lt;- chan2 :                  fmt.Printf(&quot;Get element from chan2: %d\n&quot;, e)                  default:                  fmt.Printf(&quot;No element in chan1 and chan2.\n&quot;)                  time.Sleep(1 * time.Second)                   &#125;             &#125;      &#125;        - 程序中创建两个channel： chan1和chan2。函数addNumberToChan()函数会向两个channel中周期性写入数据。通过select可以监控两个channel，任意一个可读时就从其中读出数据。        - 程序输出如下：          D:\SourceCode\GoExpert\src&gt;go run main.go          Get element from chan1: 1          Get element from chan2: 1          No element in chan1 and chan2.          Get element from chan2: 1          Get element from chan1: 1          No element in chan1 and chan2.          Get element from chan2: 1          Get element from chan1: 1          No element in chan1 and chan2.- 从输出可见，从channel中读出数据的吮吸是随机的，事实上select语句的多个case执行顺序是随机的，关于select的实现原理会有专门章节分析    - 通过这个示例说明：select的case语句读channel不会阻塞，尽管channel中没有数据。这是由于case语句编译后调用读channel时会明确传入不阻塞的参数，此时读不到数据时不会将当前goroutien加入到等待队列，而是直接返回。</code></pre><ul><li><p>4.3 range</p><ul><li><p>通过range可以持续从chanel中读出数据，好像在遍历一个数组一样，当channel中没有数据时会阻塞当前goroutine，与读channel时阻塞处理机制一样。</p><p>func chanRange(chanName chan int) {</p><pre><code>    for e := range chanName &#123;        fmt.Printf(&quot;Get element from chan: %d\n&quot;, e)    &#125;&#125;</code></pre></li></ul></li></ul><pre><code>- 注意：如果向此channel写数据的goroutine退出时，系统检测到这种情况后会panic，否则range将会永久阻塞。</code></pre><h3 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h3><ul><li><ol><li><p>前言</p><ul><li>Slice又称动态数组，依托数组实现，可以方便的进行扩容、传递等，实际使用中比数组更灵活。</li><li>正因为灵活，如果不了解其内部实现机制，有可能遭遇莫名的异常现象，Slice的实现原理很简单，本节试图根据真实的使用场景，子啊源码中总结实现原理。</li></ul></li></ol></li><li><ol start="2"><li>热身环节</li></ol><p>按照惯例，我们开始前先看几段代码用于检测对Slice的理解程度。</p></li></ul><pre><code>- 2.1 题目一    - 下面程序输出什么      package main      import (          &quot;fmt&quot;      )      func main() &#123;          var array [10]int          var slice = array[5:6]          fmt.Println(&quot;lenth of slice: &quot;, len(slice))          fmt.Println(&quot;capacity of slice: &quot;, cap(slice))          fmt.Println(&amp;slice[0] == &amp;array[5])      &#125;</code></pre><ul><li><p>程序解释：</p><p>main函数中定义了一个10个长度的整型数组array，然后定义了一个切片slice，切取数组的第6个元素，最后打印slice的长度和容量，判断切片的第一个元素和数组的第6个元素地址是否相等。</p><pre><code>  - 参考答案：    slice根据数组array创建，与数组共享存储空间，slice起始位置是array[5]，长度为1，容量为5，slice[0]和array[5]地址相同。</code></pre></li></ul><pre><code>​    </code></pre><ul><li><p>2.2 题目二</p><ul><li><p>下面程序输出什么？</p><pre><code>package mainimport (    &quot;fmt&quot;)func AddElement(slice []int, e int) []int &#123;    return append(slice, e)&#125;func main() &#123;    var slice []int    slice = append(slice, 1, 2, 3)    newSlice := AddElement(slice, 4)    fmt.Println(&amp;slice[0] == &amp;newSlice[0])&#125;</code></pre></li></ul></li></ul><pre><code>- 程序解释：      函数AddElement()接受一个切片和一个元素，把元素append进切片中，并返回切片。main()函数中定义一个切片，并向切片中append 3个元素，接着调用AddElement()继续向切片append进第4个元素同时定义一个新的切片newSlice。最后判断新切片newSlice与旧切片slice是否共用一块存储空间。- 参考答案：append函数执行时会判断切片容量是否能够存放新增元素，如果不能，则会重新申请存储空间，新存储空间将是原来的2倍或1.25倍（取决于扩展原空间大小），本例中实际执行了两次append操作，第一次空间增长到4，所以第二次append不会再扩容，所以新旧两个切片将共用一块存储空间。程序会输出”true”。- 2.3 题目三- 下面程序由Golang源码改编而来，程序输出什么？  package main  import (          &quot;fmt&quot;      )      func main() &#123;          orderLen := 5          order := make([]uint16, 2 * orderLen)          pollorder := order[:orderLen:orderLen]          lockorder := order[orderLen:][:orderLen:orderLen]          fmt.Println(&quot;len(pollorder) = &quot;, len(pollorder))          fmt.Println(&quot;cap(pollorder) = &quot;, cap(pollorder))          fmt.Println(&quot;len(lockorder) = &quot;, len(lockorder))          fmt.Println(&quot;cap(lockorder) = &quot;, cap(lockorder))      &#125;    - 程序解释：  该段程序源自select的实现代码，程序中定义一个长度为10的切片order，pollorder和lockorder分别是对order切片做了order[low:high:max]操作生成的切片，最后程序分别打印pollorder和lockorder的容量和长度。</code></pre><ul><li><p>参考答案：</p><pre><code>order[low:high:max]操作意思是对order进行切片，新切片范围是[low, high),新切片容量是max。order长度为2倍的orderLen，pollorder切片指的是order的前半部分切片，lockorder指的是order的后半部分切片，即原order分成了两段。所以，pollorder和lockerorder的长度和容量都是orderLen，即5。</code></pre></li><li><ol start="3"><li>Slice实现原理</li></ol><p>Slice依托数据实现，底层数组对用户屏蔽，在底层数组容量不足时可以自动重分配并生成新的Slice。</p></li></ul><pre><code>- 3.1 Slice数据结构    - 源码包中src/runtime/slice.go:slice定义了Slice的数据结构：      type slice struct &#123;          array unsafe.Pointer          len   int          cap   int      &#125;    - 从数据结构看Slice很清晰，array指针指向底层数组，len表示切片长度，cap表示底层数组容量。- 3.2 使用make创建Slice    - 使用make来创建Slice时，可以同时指定长度和容量，创建时底层会发呢配一个数组，数组的长度即容量。    - 例如，语句slice := make([]int, 5, 10)所创建的Slice，结构如下图所示：    - 该Slice长度为5，即可以使用下标slice[0] ~ slice[4]来操作里面的元素，capacity为10，表示后续向slice添加新的元素时可以不必重新分配内存，直接使用预留内存即可。- 3.3 使用数组创建Slice    - 使用数组来创建Slice时，Slice将与原数组公用一部分内存。    - 例如，语句slice := array[5:7]所创建的Slice，结构如下图所示：    - 切牌你从数组array[5]开始，到数组array[7]结束（不含array[7]），即切片长度为2，数组后面的内容都作为切片的预留内存，即capacity为5。    - 数组和切片操作可能作用于同一块内存，这也是使用过程中需要注意的地方。- 3.4 Slice扩容    - 使用append向Slice追加元素时，如果Slice空间不足，将会出发Slice扩容，扩容实际上是重新分配一块更大的内存，将原Slice数据拷贝进新Slice，然后返回新Slice，扩容后再将数据追加进去。    - 例如，当向一个capacity为5，且length也为5的Slice再次追加1个元素时，就会发生扩容，如下图所示：    - 扩容操作只关心容量，会把原Slice数据拷贝到新Slice，追加数据由append再扩容结束后完成。上图可见，扩容后新 的Slice长度仍然是5，但容量由5提升到了10，原Slice的数据也都拷贝到了新Slice指向的数组中。    - 扩容容量的选择遵循以下规则：      如果原Slice容量小于1024，则新Slice容量将扩大为原来的2倍。      如果原Slice容量小于等于1024，则新Slice容量将扩大为原来的1.25倍。</code></pre><ul><li><p>使用append()向Slice添加一个元素的实现步骤如下：</p><p>假如Slice容量够用，则将新元素追加进去，Slice.len++，返回原Slice</p><pre><code>    原Slice容量不够，则将Slice先扩容，扩容后得到新的Slice    将新元素追加进新Slice,Slice.len++，返回新的Slice。</code></pre></li></ul><ul><li><p>3.5 Slice Copy</p><ul><li>使用copy()内置函数拷贝两个切片时，会将源切片的数据逐个拷贝到目的切片指向的数组中，拷贝数量取两个切片长度的最小值。<ul><li>例如长度为10的切片拷贝到长度为5的切片时，将会拷贝5个元素。</li><li>也就是说，copy过程中不会发生扩容。</li></ul></li></ul></li><li><p>3.6 特殊切片</p><ul><li><p>根据数组或切片生成新的切片一般使用slice := array[start:end]方式，这种新生成的切片并没有指定切片的容量，实际上新切片的容量是从start开始直至array的结束。</p><ul><li><p>比如下面两个切片，长度和容量都是一致的，使用共同的内存地址：</p><p>sliceA := make([]int, 5, 10)</p><pre><code>sliceB := sliceA[0:5]</code></pre></li></ul></li></ul></li></ul><pre><code>- 根据数组或切片生成切片还有另一种写法，即切片同时也指定容量，即slice[start:end:cap], 其中cap即为新切片的容量，当然容量不能超过原切片实际值，如下所示：   sliceA := make([]int, 5, 10)  //length = 5; capacity = 10          sliceB := sliceA[0:5]         //length = 5; capacity = 10          sliceC := sliceA[0:5:5]       //length = 5; capacity = 5</code></pre><ul><li><ol start="4"><li><p>编程Tips</p><ul><li>创建切片时可根据实际需要预分配容量，尽量避免追加过程中扩容操作，有利于提升性能；</li><li>切片拷贝时需要判断实际拷贝的元素个数</li><li>谨慎使用多个切片操作同一个数组，以防读写冲突</li></ul></li></ol></li><li><ol start="5"><li><p>Slice总结</p><ul><li>每个切片都指向一个底层数组</li><li>每个切片都保存了当前切片的长度、底层数组可用容量</li><li>使用len()计算切片长度时间复杂度为O(1)，不需要遍历切片</li><li>使用cap()计算切片容量时间复杂度为O(1)，不需要遍历切片</li><li>通过函数传递切片时，不会拷贝整个切片，因为切片本身只是个结构体而已</li><li>使用append()向切片追加元素时有可能触发扩容，扩容后将会生成新的切片</li></ul></li></ol></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li><ol><li><p>map数据结构</p><ul><li><p>Golang的map使用哈希表作为底层实现，一个哈希表里可以有多个哈希表节点，也即bucket，而每个bucket就保存了map中的一个或一组键值对。</p></li><li><p>map数据结构由 runtime/map.go: hmap 定义：</p><p>type hmap struct {<br>   count     int // 当前保存的元素个数<br>   …<br>   B         uint8<br>   …<br>   buckets    unsafe.Pointer // bucket数组指针，数组的大小为2^B<br>   …<br>}</p></li></ul></li></ol></li></ul><pre><code>- 下图展示了一个拥有4个bucket的map:    - 本例中, hmap.B=2， 而hmap.buckets长度是2^B为4. 元素经过哈希运算后会落到某个bucket中进行存储。查找过程类似。- bucket很多时候被翻译为桶，所谓的哈希桶实际上就是bucket。</code></pre><ul><li><ol start="2"><li><p>bucket数据结构</p><ul><li><p>bucket数据结构由runtime/map.go:bmap定义：</p><p>type bmap struct {<br>   tophash [8]uint8 //存储哈希值的高8位<br>   data    byte[1]  //key value数据:key/key/key/…/value/value/value…<br>   overflow *bmap   //溢出bucket的地址<br>}</p></li></ul></li></ol></li></ul><pre><code>- 每个bucket可以存储8个键值对。    - tophash是个长度为8的数组，哈希值相同的键（准确的说是哈希值低位相同的键）存入当前bucket时会将哈希值的高位存储在该数组中，以方便后续匹配。    - data区存放的是key-value数据，存放顺序是key/key/key/…value/value/value，如此存放是为了节省字节对齐带来的空间浪费。    - overflow 指针指向的是下一个bucket，据此将所有冲突的键连接起来。    - 注意：上述中data和overflow并不是在结构体中显示定义的，而是直接通过指针运算进行访问的。- 下图展示bucket存放8个key-value对：</code></pre><ul><li><ol start="3"><li><p>哈希冲突</p><ul><li>当有两个或以上数量的键被哈希到了同一个bucket时，我们称这些键发生了冲突。Go使用链地址法来解决键冲突。</li><li>由于每个bucket可以存放8个键值对，所以同一个bucket存放超过8个键值对时就会再创建一个键值对，用类似链表的方式将bucket连接起来。</li><li>下图展示产生冲突后的map：</li><li>bucket数据结构指示下一个bucket的指针称为overflow bucket，意为当前bucket盛不下而溢出的部分。事实上哈希冲突并不是好事情，它降低了存取效率，好的哈希算法可以保证哈希值的随机性，但冲突过多也是要控制的，后面会再详细介绍。</li></ul></li></ol></li><li><ol start="4"><li><p>负载因子</p><ul><li><p>负载因子用于衡量一个哈希表冲突情况，公式为：</p><ul><li>例如，对于一个bucket数量为4，包含4个键值对的哈希表来说，这个哈希表的负载因子为1.</li></ul></li><li><p>哈希表需要将负载因子控制在合适的大小，超过其阈值需要进行rehash，也即键值对重新组织：</p><ul><li>哈希因子过小，说明空间利用率低</li><li>哈希因子过大，说明冲突严重，存取效率低</li></ul></li><li><p>每个哈希表的实现对负载因子容忍程度不同，比如Redis实现中负载因子大于1时就会触发rehash，而Go则在在负载因子达到6.5时才会触发rehash，因为Redis的每个bucket只能存1个键值对，而Go的bucket可能存8个键值对，所以Go可以容忍更高的负载因子。</p></li></ul></li></ol></li><li><ol start="5"><li><p>渐进式扩容</p><ul><li><p>5.1 扩容的前提条件</p><ul><li><p>为了保证访问效率，当新元素将要添加进map时，都会检查是否需要扩容，扩容实际上是以空间换时间的手段。</p></li><li><p>触发扩容的条件有二个：</p><ul><li>负载因子 &gt; 6.5时，也即平均每个bucket存储的键值对达到6.5个。</li><li>overflow数量 &gt; 2^15时，也即overflow数量超过32768时。</li></ul></li></ul></li><li><p>5.2 增量扩容</p><ul><li><p>当负载因子过大时，就新建一个bucket，新的bucket长度是原来的2倍，然后旧bucket数据搬迁到新的bucket。</p></li><li><p>考虑到如果map存储了数以亿计的key-value，一次性搬迁将会造成比较大的延时，Go采用逐步搬迁策略，即每次访问map时都会触发一次搬迁，每次搬迁2个键值对。</p></li><li><p>下图展示了包含一个bucket满载的map(为了描述方便，图中bucket省略了value区域):</p><ul><li>当前map存储了7个键值对，只有1个bucket。此地负载因子为7。再次插入数据时将会触发扩容操作，扩容之后再将新插入键写入新的bucket。</li></ul></li><li><p>当第8个键值对插入时，将会触发扩容，扩容后示意图如下：</p><ul><li>hmap数据结构中oldbuckets成员指原bucket，而buckets指向了新申请的bucket。新的键值对被插入新的bucket中。</li><li>后续对map的访问操作会触发迁移，将oldbuckets中的键值对逐步的搬迁过来。当oldbuckets中的键值对全部搬迁完毕后，删除oldbuckets。</li></ul></li><li><p>搬迁完成后的示意图如下：</p><ul><li>数据搬迁过程中原bucket中的键值对将存在于新bucket的前面，新插入的键值对将存在于新bucket的后面。</li><li>实际搬迁过程中比较复杂，将在后续源码分析中详细介绍。</li></ul></li></ul></li><li><p>5.3 等量扩容</p><ul><li>所谓等量扩容，实际上并不是扩大容量，buckets数量不变，重新做一遍类似增量扩容的搬迁动作，把松散的键值对重新排列一次，以使bucket的使用率更高，进而保证更快的存取。</li><li>在极端场景下，比如不断地增删，而键值对正好集中在一小部分的bucket，这样会造成overflow的bucket数量增多，但负载因子又不高，从而无法执行增量搬迁的情况，如下图所示：</li><li>上图可见，overflow的bucket中大部分是空的，访问效率会很差。此时进行一次等量扩容，即buckets数量不变，经过重新组织后overflow的bucket数量会减少，即节省了空间又会提高访问效率。</li></ul></li></ul></li></ol></li><li><ol start="6"><li><p>查找过程</p><ul><li><p>查找过程如下：</p><ul><li>根据key值算出哈希值</li><li>取哈希值低位与hmap.B取模确定bucket位置</li><li>取哈希值高位在tophash数组中查询</li><li>如果tophash[i]中存储值也哈希值相等，则去找到该bucket中的key值进行比较</li><li>当前bucket没有找到，则继续从下个overflow的bucket中查找。</li><li>如果当前处于搬迁过程，则优先从oldbuckets查找</li></ul></li><li><p>注：如果查找不到，也不会返回空值，而是返回相应类型的0值。</p></li></ul></li></ol></li><li><ol start="7"><li><p>插入过程</p><ul><li><p>新元素插入过程如下：</p><ul><li>根据key值算出哈希值</li><li>取哈希值低位与hmap.B取模确定bucket位置</li><li>查找该key是否已经存在，如果存在则直接更新值</li><li>如果没找到将key，将key插入</li></ul></li></ul></li></ol></li></ul><h3 id="Struct"><a href="#Struct" class="headerlink" title="Struct"></a>Struct</h3><ul><li><ol><li><p>前言</p><ul><li>Go的struct声明允许字段附带Tag来对字段做一些标记。</li><li>该Tag不仅仅是一个字符串那么简单，因为其主要用于反射场景，reflect包中提供了操作Tag的方法，所以Tag写法也要遵循一定的规则。</li></ul></li></ol></li><li><ol start="2"><li><p>Tag的本质</p><ul><li><p>2.1 Tag规则</p><ul><li><p>Tag本身是一个字符串，但字符串中却是：以空格分隔的 key:value 对。</p><ul><li>key: 必须是非空字符串，字符串不能包含控制字符、空格、引号、冒号。</li><li>value: 以双引号标记的字符串</li><li>注意：冒号前后不能有空格</li></ul></li><li><p>如下代码所示，如此写没有实际意义，仅用于说明Tag规则</p><p>type Server struct {</p><pre><code>ServerName string `key1: &quot;value1&quot; key11:&quot;value11&quot;`ServerIP   string `key2: &quot;value2&quot;`</code></pre><p>}</p></li></ul></li></ul></li></ol></li></ul><pre><code>    - 上述代码ServerName字段的Tag包含两个key-value对。ServerIP字段的Tag只包含一个key-value对。- 2.2 Tag是Struct的一部分    - 前面说过，Tag只有在反射场景中才有用，而反射包中提供了操作Tag的方法。在说方法前，有必要先了解一下Go是如何管理struct字段的。    - 以下是reflect包中的类型声明，省略了部分与本文无关的字段。      // A StructField describes a single field in a struct.      type StructField struct &#123;          // Name is the field name.          Name string          ...          Type      Type      // field type          Tag       StructTag // field tag string          ...      &#125;      type StructTag string    - 可见，描述一个结构体成员的结构中包含了StructTag，而其本身是一个string。也就是说Tag其实是结构体字段的一个组成部分。    - 2.3 获取Tag        - StructTag提供了Get(key string) string方法来获取Tag，示例如下：          package main          import (              &quot;reflect&quot;              &quot;fmt&quot;          )          type Server struct &#123;              ServerName string `key1:&quot;value1&quot; key11:&quot;value11&quot;`              ServerIP   string `key2:&quot;value2&quot;`          &#125;          func main() &#123;              s := Server&#123;&#125;              st := reflect.TypeOf(s)              field1 := st.Field(0)              fmt.Printf(&quot;key1:%v\n&quot;, field1.Tag.Get(&quot;key1&quot;))              fmt.Printf(&quot;key11:%v\n&quot;, field1.Tag.Get(&quot;key11&quot;))              filed2 := st.Field(1)              fmt.Printf(&quot;key2:%v\n&quot;, filed2.Tag.Get(&quot;key2&quot;))          &#125;        - 程序输出如下：          key1:value1          key11:value11          key2:value2</code></pre><ul><li><ol start="3"><li><p>Tag存在的意义</p><ul><li>本文示例中tag没有任何实际意义，这是为了阐述tag的定义与操作方法，也为了避免与你之前见过的诸如json:xxx混淆。</li><li>使用反射可以动态的给结构体成员赋值，正是因为有tag，在赋值前可以使用tag来决定赋值的动作。</li><li>比如，官方的encoding/json包，可以将一个JSON数据Unmarshal进一个结构体，此过程中就使用了Tag。该包定义一些规则，只要参考该规则设置tag就可以将不同的JSON数据转换成结构体。</li><li>总之：正是基于struct的tag特性，才有了诸如json、orm等等的应用。理解这个关系是至关重要的。或许，你可以定义另一种tag规则，来处理你特有的数据。</li></ul></li></ol></li><li><ol start="4"><li><p>Tag常见用法</p><ul><li>常见的tag用法，主要是JSON数据解析、ORM映射等。</li></ul></li></ol></li></ul><h3 id="Iota"><a href="#Iota" class="headerlink" title="Iota"></a>Iota</h3><ul><li><ol><li><p>前言</p><ul><li>我们知道iota常用于const表达式中，我们还知道其值是从零开始，const声明块中每增加一行iota值自增1。</li><li>使用iota可以简化常量定义，但其规则必须要牢牢掌握，否则在我们阅读别人源码时可能会造成误解或障碍。本节我们尝试全面的总结其使用场景，另外花一小部分时间看一下其实现原理，从原理上把握可以更深刻的记忆这些规则。</li></ul></li></ol></li><li><ol start="2"><li>热身</li></ol><p>按照惯例，我们看几个有意思的小例子，用于检测我们对于iota的理解是否准确。</p></li></ul><pre><code>- 2.1 题目一    - 下面常量定义源于GO源码，下面每个常量的值是多少？      type Priority int      const (          LOG_EMERG Priority = iota          LOG_ALERT          LOG_CRIT          LOG_ERR          LOG_WARNING          LOG_NOTICE          LOG_INFO          LOG_DEBUG      )    - 题目解释：      上面代码源于日志模块，定义了一组代表日志级别的常量，常量类型为Priority，实际为int类型。</code></pre><ul><li><p>参考答案：</p><p>iota初始值为0，也即LOG_EMERG值为0，下面每个常量递增1。</p></li></ul><ul><li><p>2.2 题目二</p><ul><li><p>下面代码取自Go源码，请问每个常量值是多少？</p><p>const (</p><pre><code>    mutexLocked = 1 &lt;&lt; iota // mutex is locked    mutexWoken    mutexStarving    mutexWaiterShift = iota    starvationThresholdNs = 1e6)</code></pre></li></ul></li></ul><pre><code>- 题目解释：  以上代码取自Go互斥锁Mutex的实现，用于指示各种状态位的地址偏移。- 参考答案：  mutexLocked == 1；mutexWoken == 2；mutexStarving == 4；mutexWaiterShift == 3；starvationThresholdNs == 1000000。- 2.3 题目三- 请问每个常量值是多少？  const (      bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1          bit1, mask1          _, _          bit3, mask3      )    - 题目解释：  以上代码取自Go官方文档。- 参考答案：bit0 == 1， mask0 == 0， bit1 == 2， mask1 == 1， bit3 == 8， mask3 == 7</code></pre><ul><li><ol start="3"><li><p>规则</p><ul><li><p>很多书上或博客描述的规则是这样的：</p><ul><li>iota在const关键字出现时被重置为0</li><li>const声明块中每新增一行iota值自增1</li></ul></li><li><p>我曾经也这么理解，看过编译器代码后发现，其实规则只有一条：</p><ul><li>iota代表了const声明块的行索引（下标从0开始）</li></ul></li><li><p>这样理解更贴近编译器实现逻辑，也更准确。除此之外，const声明还有个特点，即第一个常量必须指定一个表达式，后续的常量如果没有表达式，则继承上面的表达式。</p></li><li><p>下面再来根据这个规则看下这段代码：</p><p>const (<br>   bit0, mask0 = 1 &lt;&lt; iota, 1&lt;&lt;iota - 1   //const声明第0行，即iota==0<br>   bit1, mask1                            //const声明第1行，即iota==1, 表达式继承上面的语句<br>   _, _                                   //const声明第2行，即iota==2<br>   bit3, mask3                            //const声明第3行，即iota==3<br>)</p></li></ul></li></ol></li></ul><pre><code>    - 第0行的表达式展开即bit0, mask0 = 1 &lt;&lt; 0, 1&lt;&lt;0 - 1，所以bit0 == 1，mask0 == 0；    - 第1行没有指定表达式继承第一行，即bit1, mask1 = 1 &lt;&lt; 1, 1&lt;&lt;1 - 1，所以bit1 == 2，mask1 == 1；    - 第2行没有定义常量    - 第3行没有指定表达式继承第一行，即bit3, mask3 = 1 &lt;&lt; 3, 1&lt;&lt;3 - 1，所以bit0 == 8，mask0 == 7；</code></pre><ul><li><ol start="4"><li><p>编译原理</p><ul><li><p>const块中每一行在GO中使用spec数据结构描述，spec声明如下：</p><p>   // A ValueSpec node represents a constant or variable declaration<br>   // (ConstSpec or VarSpec production).<br>   //<br>   ValueSpec struct {</p><pre><code>   Doc     *CommentGroup // associated documentation; or nil   Names   []*Ident      // value names (len(Names) &gt; 0)   Type    Expr          // value type; or nil   Values  []Expr        // initial values; or nil   Comment *CommentGroup // line comments; or nil</code></pre><p>   }</p></li></ul></li></ol></li></ul><pre><code>- 这里我们只关注ValueSpec.Names， 这个切片中保存了一行中定义的常量，如果一行定义N个常量，那么ValueSpec.Names切片长度即为N。- const块实际上是spec类型的切片，用于表示const中的多行。- 所以编译期间构造常量时的伪算法如下：     for iota, spec := range ValueSpecs &#123;          for i, name := range spec.Names &#123;              obj := NewConst(name, iota...) //此处将iota传入，用于构造常量              ...          &#125;      &#125;- 从上面可以更清晰的看出iota实际上是遍历const块的索引，每行中即便多次使用iota，其值也不会递增。</code></pre><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li><ol><li><p>string标准概念</p><ul><li><p>Go标准库 builtin 给出了所有内置类型的定义</p></li><li><p>源代码位于 src/builtin/builtin.go，其中关于string的描述如下：</p><p>// string is the set of all strings of 8-bit bytes, conventionally but not<br>// necessarily representing UTF-8-encoded text. A string may be empty, but<br>// not nil. Values of string type are immutable.<br>type string string</p></li></ul></li></ol></li></ul><pre><code>- 所以striing是8比特字节的集合，通常是但并不一定非得是UTF-8编码的文本。- 另外，还提到了两点，非常重要：    - string可以为空（长度为0），但不会是nil    - string对象不可以修改</code></pre><ul><li><ol start="2"><li><p>string数据结构</p><ul><li><p>源码包 src/runtime/string.go: stringStruct 定义了string的数据结构：</p><p>type stringStruct struct {<br>   str unsafe.Pointer<br>   len int<br>}</p></li></ul></li></ol></li></ul><pre><code>- 其数据结构很简单：    - stringStruct.str：字符串的首地址；    - stringStruct.len：字符串的长度；- string数据结构跟切片有些类似，只不过切片还有一个表示容量的成员，事实上string和切片，准确的说是byte切片经常发生转换。这个后面再详细介绍。</code></pre><ul><li><ol start="3"><li><p>string操作</p><ul><li><p>声明</p><ul><li><p>如下代码所示，可以声明一个string变量变赋予初值：</p><p> var str string<br> str = “Hello World”</p></li></ul></li></ul></li></ol></li></ul><pre><code>    - 字符串构建过程是先根据字符串构建stringStruct，再转换成string。转换的源码如下：      func gostringnocopy(str *byte) string &#123; // 根据字符串地址构建string          ss := stringStruct&#123;str: unsafe.Pointer(str), len: findnull(str)&#125; // 先构造stringStruct          s := *(*string)(unsafe.Pointer(&amp;ss))                             // 再将stringStruct转换成string          return s      &#125;    - string在runtime包中就是stringStruct，对外呈现叫做string。- []byte转string    - byte切片可以很方便的转换成string，如下所示：      func GetStringBySlice(s []byte) string &#123;          return string(s)      &#125;    - 需要注意的是这种转换需要一次内存拷贝。    - 转换过程如下：        - 根据切片的长度申请内存空间，假设内存地址为p，切片长度为len(b)；        - 构建string（string.str = p；string.len = len；）        - 拷贝数据(切片中数据拷贝到新申请的内存空间)    - 转换示意图：- string转[]byte    - string也可以方便的转成byte切片，如下所示：      func GetSliceByString(str string) []byte &#123;          return []byte(str)      &#125;    - string转换成byte切片，也需要一次内存拷贝，其过程如下：        - 申请切片内存空间        - 将string拷贝到切片    - 转换示意图：- 字符串拼接    - 字符串可以很方便的拼接，像下面这样：      str := &quot;Str1&quot; + &quot;Str2&quot; + &quot;Str3&quot;    - 即便有非常多的字符串需要拼接，性能上也有比较好的保证，因为新字符串的内存空间是一次分配完成的，所以性能消耗主要在拷贝数据上。    - 一个拼接语句的字符串编译时都会被存放到一个切片中，拼接过程需要遍历两次切片，第一次遍历获取总的字符串长度，据此申请内存，第二次遍历会把字符串逐个拷贝过去。    - 字符串拼接伪代码如下：      func concatstrings(a []string) string &#123; // 字符串拼接          length := 0        // 拼接后总的字符串长度          for _, str := range a &#123;              length += len(str)          &#125;          s, b := rawstring(length) // 生成指定大小的字符串，返回一个string和切片，二者共享内存空间          for _, str := range a &#123;              copy(b, str)    // string无法修改，只能通过切片修改              b = b[len(str):]          &#125;          return s      &#125;    - 因为string是无法直接修改的，所以这里使用rawstring()方法初始化一个指定大小的string，同时返回一个切片，二者共享同一块内存空间，后面向切片中拷贝数据，也就间接修改了string。    - rawstring()源代码如下：      func rawstring(size int) (s string, b []byte) &#123; // 生成一个新的string，返回的string和切片共享相同的空间          p := mallocgc(uintptr(size), nil, false)          stringStructOf(&amp;s).str = p          stringStructOf(&amp;s).len = size          *(*slice)(unsafe.Pointer(&amp;b)) = slice&#123;p, size, size&#125;          return      &#125;- 为什么字符串不允许修改？    - 像C++语言中的string，其本身拥有内存空间，修改string是支持的。但Go的实现中，string不包含内存空间，只有一个内存的指针，这样做的好处是string变得非常轻量，可以很方便的进行传递而不用担心内存拷贝。    - 因为string通常指向字符串字面量，而字符串字面量存储位置是只读段，而不是堆或栈上，所以才有了string不可修改的约定。- []byte转换成string一定会拷贝内存吗？    - byte切片转换成string的场景很多，为了性能上的考虑，有时候只是临时需要字符串的场景下，byte切片转换成string时并不会拷贝内存，俄日是直接返回一个string，这个string的指针（string.str）指向切片的内存。    - 比如，编译器会识别如下临时场景：        - 使用m[string(b)]来查找map（map是string为key，临时把切片b转成string）；        - 字符串拼接，如”&lt;” + “string(b)” + “&gt;”；        - 字符串比较：string(b) == “foo”    - 因为是临时把byte切片转换成string，也就避免了因byte切片同容改成而导致string引用失败的情况，所以此时可以不必拷贝内存新建一个string。- string和[]byte如何取舍    - string和[]byte都可以表示字符串，但因数据结构不同，其衍生出来的方法也不同，要根据实际应用场景来选择。    - string 擅长的场景：        - 需要字符串比较的场景；        - 不需要nil字符串的场景；    - []byte擅长的场景：        - 修改字符串的场景，尤其是修改粒度为1个字节；        - 函数返回值，需要用nil表示含义的场景；        - 需要切片操作的场景；    - 虽然看起来string适用的场景不如[]byte多，但因为string直观，在实际应用中还是大量存在，在偏底层的实现中[]byte使用更多。</code></pre><h2 id="常见控制结构实现原理"><a href="#常见控制结构实现原理" class="headerlink" title="常见控制结构实现原理"></a>常见控制结构实现原理</h2><p>本章主要介绍常见的控制结构，比如defer、select、range等，通过对其底层实现原理的分析，来加深认识，以此避免一些使用过程中的误区。</p><h3 id="Defer"><a href="#Defer" class="headerlink" title="Defer"></a>Defer</h3><ul><li><ol><li><p>前言</p><ul><li>defer语句用于延迟函数的调用，每次defer都会把一个函数压入栈中，函数返回前再把延迟的函数取出并执行。</li><li>为了方便描述，我们把创建defer的函数称为主函数，defer语句后面的函数称为延迟函数。</li><li>延迟函数可能有输入参数，这些参数可能来演于定义defer的函数，延迟函数也可能引用主函数用于返回的变量，也就是说延迟函数可能会影响主函数的一些行为，这些场景下，如果不了解defer的规则很容易出错。</li><li>其实官方说明的defer的三个原则很清楚，本届视图汇总defer的使用场景并简单说明。</li></ul></li></ol></li><li><ol start="2"><li>热身</li></ol><p>按照惯例，我们看几个有意思的题目，用于检验对defer的了解程度。</p></li></ul><pre><code>- 2.1 题目一    - 下面函数输出结果是什么？      func deferFuncParameter() &#123;          var aInt = 1          defer fmt.Println(aInt)          aInt = 2          return      &#125;    - 题目说明：      函数deferFuncParameter()定义一个整型变量并初始化为1，然后使用defer语句打印出变量值，最后修改变量值为2.</code></pre><ul><li><p>参考答案：</p><p>输出1。延迟函数fmt.Println(aInt)的参数在defer语句出现时就已经确定了，所以无论后面如何修改aInt变量都不会影响延迟函数。</p></li></ul><ul><li><p>2.2 题目二</p><ul><li><p>下面程序输出什么？</p><p>package main</p><pre><code>import &quot;fmt&quot;func printArray(array *[3]int) &#123;    for i := range array &#123;        fmt.Println(array[i])    &#125;&#125;func deferFuncParameter() &#123;    var aArray = [3]int&#123;1, 2, 3&#125;    defer printArray(&amp;aArray)    aArray[0] = 10    return&#125;func main() &#123;    deferFuncParameter()&#125;</code></pre></li></ul></li></ul><pre><code>- 函数说明：  函数deferFuncParameter()定义一个数组，通过defer延迟函数printArray()的调用，最后修改数组第一个元素。printArray()函数接受数组的指针并把数组全部打印出来。- 参考答案：  输出10、2、3三个值。延迟函数printArray()的参数在defer语句出现时就已经确定了，即数组的地址，由于延迟函数执行时机是在return语句之前，所以对数组的最终修改值会被打印出来。- 2.3 题目三- 下面函数输出什么？  func deferFuncReturn() (result int) &#123;      i := 1          defer func() &#123;             result++          &#125;()          return i      &#125;    - 函数说明：  函数拥有一个具名返回值result，函数内部声明一个变量i，defer指定一个延迟函数，最后返回变量i。延迟函数中递增result。- 参考答案：函数输出2。函数的return语句并不是原子的，实际执行分为设置返回值–&gt;ret，defer语句实际执行在返回前，即拥有defer的函数返回过程是：设置返回值–&gt;执行defer–&gt;ret。所以return语句先把result设置为i的值，即1，defer语句中又把result递增1，所以最终返回2。</code></pre><ul><li><ol start="3"><li>defer规则</li></ol><p>Golang官方博客里总结了defer的行为规则，只有三条，我们围绕这三条进行说明。</p></li></ul><pre><code>- 3.1 规则一：延迟函数的参数在defer语句出现时就已经确定下来了    - 官方给出一个例子，如下所示：      func a() &#123;          i := 0          defer fmt.Println(i)          i++          return      &#125;    - defer语句中的fmt.Println()参数i值在defer出现时就已经确定下来，实际上是拷贝了一份。后面对变量i的修改不会影响fmt.Println()函数的执行，仍然打印”0”。    - 注意：对于指针类型参数，规则仍然适用，只不过延迟函数的参数是一个地址值，这种情况下，defer后面的语句对变量的修改可能会影响延迟函数。- 3.2 规则二：延迟函数执行按后进先出顺序执行，即先出现的defer最后执行    - 这个规则很好理解，定义defer类似于入栈操作，执行defer类似于出栈操作。    - 设计defer的初衷是简化函数返回时资源清理的动作，资源往往有依赖顺序，比如先申请A资源，再根据A资源申请B资源，根据B资源申请C资源，即申请顺序是:A–&gt;B–&gt;C，释放时往往又要反向进行。这就是把defer设计成LIFO的原因。    - 每申请到一个用完需要释放的资源时，立即定义一个defer来释放资源是个很好的习惯。- 3.3 规则三：延迟函数可能操作主函数的具名返回值  定义defer的函数，即主函数可能有返回值，返回值有没有名字没有关系，defer所作用的函数，即延迟函数可能会影响到返回值。  若要理解延迟函数是如何影响主函数返回值的，只要明白函数是如何返回的就足够了。    - 3.3.1 函数返回过程        - 有一个事实必须要了解，关键字return不是一个原子操作，实际上return只代理汇编指令ret，即将跳转程序执行。比如语句return i，实际上分两步进行，即将i值存入栈中作为返回值，然后执行跳转，而defer的执行时机正是跳转前，所以说defer执行时还是有机会操作返回值的。        - 举个实际的例子进行说明这个过程：          func deferFuncReturn() (result int) &#123;              i := 1              defer func() &#123;                 result++              &#125;()              return i          &#125;            - 该函数的return语句可以拆分成下面两行：              result = i              return            - 而延迟函数的执行正是在return之前，即加入defer后的执行过程如下：              result = i              result++              return            - 所以上面函数实际返回i++值。        - 关于主函数有不同的返回方式，但返回机制就如上机介绍所说，只要把return语句拆开都可以很好的理解，下面分别举例说明    - 3.3.2 主函数拥有匿名返回值，返回字面值        - 一个主函数拥有一个匿名的返回值，返回时使用字面值，比如返回”1”、”2”、”Hello”这样的值，这种情况下defer语句是无法操作返回值的。        - 一个返回字面值的函数，如下所示：          func foo() int &#123;              var i int              defer func() &#123;                  i++              &#125;()              return 1          &#125;        - 上面的return语句，直接把1写入栈中作为返回值，延迟函数无法操作该返回值，所以就无法影响返回值。    - 3.3.3 主函数拥有匿名返回值，返回变量        - 一个主函数拥有一个匿名的返回值，返回使用本地或全局变量，这种情况下defer语句可以引用到返回值，但不会改变返回值。        - 一个返回本地变量的函数，如下所示：          func foo() int &#123;              var i int              defer func() &#123;                  i++              &#125;()              return i          &#125;        - 上面的函数，返回一个局部变量，同时defer函数也会操作这个局部变量。对于匿名返回值来说，可以假定仍然有一个变量存储返回值，假定返回值变量为”anony”，上面的返回语句可以拆分成以下过程：          anony = i          i++          return        - 由于i是整型，会将值拷贝给anony，所以defer语句中修改i值，对函数返回值不造成影响。    - 3.3.4 主函数拥有具名返回值        - 主函声明语句中带名字的返回值，会被初始化成一个局部变量，函数内部可以像使用局部变量一样使用该返回值。如果defer语句操作该返回值，可能会改变返回结果。        - 一个影响函返回值的例子：          func foo() (ret int) &#123;              defer func() &#123;                  ret++              &#125;()              return 0          &#125;        - 上面的函数拆解出来，如下所示：          ret = 0          ret++          return        - 函数真正返回前，在defer中对返回值做了+1操作，所以函数最终返回1.</code></pre><ul><li><ol start="4"><li>defer实现原理</li></ol><p>本节我们尝试了解一些defer的实现机制。</p></li></ul><pre><code>- 4.1 defer数据结构    - 源码包 src/src/runtime/runtime2.go: _defer 定义了defer的数据结构：      type _defer struct &#123;          sp      uintptr   //函数栈指针          pc      uintptr   //程序计数器          fn      *funcval  //函数地址          link    *_defer   //指向自身结构的指针，用于链接多个defer      &#125;    - 我们知道defer后面一定要接一个函数的，所以defer的数据结构跟一般函数类似，也有栈地址、程序计数器、函数地址等等。    - 与函数不同的一点是它含有一个指针，可用于指向另一个defer，每个goroutine数据结构中实际上也有一个defer指针，该指针指向一个defer的单链表，每次声明一个defer时就将defer插入到单链表表头，每次执行defer时就从单链表表头取出一个defer执行。    - 下图展示多个defer被链接的过程：    - 从上图可以看到，新声明的defer总是添加到链表头部。    - 函数返回前执行defer则是从链表首部依次取出执行，不再赘述。    - 一个goroutine可能连续调用多个函数，defer添加过程跟上述流程一致，进入函数时添加defer，离开函数时取出defer，所以即便调用多个函数，也总是能保证defer是按LIFO方式执行的。- 4.2 defer的创建和执行    - 源码包 src/runtime/panic.go 定义了两个方法分别用于创建defer和执行defer。        - deferproc(): 在声明defer处调用，其将defer哈数存入goroutine的链表中        - deferreturn()：在return指令，准确的讲是在ret指令前调用，其将defer从goroutine链表中取出并执行。    - 可以简单这么理解，在编译阶段，声明defer处插入了函数deferproc()，在函数return前插入了函数deferreturn()。</code></pre><ul><li><ol start="5"><li><p>总结</p><ul><li>defer定义的延迟函数在defer语句出现时就已经确定下来了</li><li>defer定义顺序与实际执行顺序相反</li><li>return不是原子操作，执行过程是：保存返回值（若有）-&gt; 执行defer(若有) -&gt; 执行ret跳转</li><li>申请资源后立即使用defer关闭资源是好习惯</li></ul></li></ol></li></ul><h3 id="Defer陷阱"><a href="#Defer陷阱" class="headerlink" title="Defer陷阱"></a>Defer陷阱</h3><ul><li><ol><li><p>前言</p><ul><li><p>项目中，有时为了让程序更健壮，也即不panic，我们或许会使用 recover() 来接收异常并处理。</p></li><li><p>比如以下代码：</p><p>func NoPanic() {<br>   if err := recover(); err != nil {</p><pre><code>   fmt.Println(&quot;Recover success...&quot;)</code></pre><p>   }<br>}</p><p>func Dived(n int) {<br>   defer NoPanic()</p><p>   fmt.Println(1/n)<br>}</p></li></ul></li></ol></li></ul><pre><code>- func NoPanic() 会自动接收异常，并打印相关日志，算是一个通用的异常处理函数。- 业务处理函数中只要使用了defer NoPanic()，那么就不会再有panic发生。- 关于是否应该使用recover接收异常，以及什么场景下使用等问题不在本节讨论范围内。- 本节关注的是这种用法的一个变体，曾经出现在笔者经历的一个真实项目，在该变体下，recover再也无法接收异常。</code></pre><ul><li><ol start="2"><li><p>recover使用误区</p><ul><li><p>在项目中，有众多的数据库更新操作，正常的更新操作需要提交，而失败的就需要回滚，如果异常分支比较多，就会有很多重复的回滚代码，所以有人尝试了一个做法：即在defer中判断是否出现异常，有异常则回滚，否则提交。</p></li><li><p>简化代码如下所示：</p><p>func IsPanic() bool {<br>   if err := recover(); err != nil {</p><pre><code>   fmt.Println(&quot;Recover success...&quot;)   return true</code></pre><p>   }</p><p>   return false<br>}</p><p>func UpdateTable() {<br>   // defer中决定提交还是回滚<br>   defer func() {</p><pre><code>   if IsPanic() &#123;       // Rollback transaction   &#125; else &#123;       // Commit transaction   &#125;</code></pre><p>   }()</p><p>   // Database update operation…<br>}</p></li></ul></li></ol></li></ul><pre><code>    - func IsPanic() bool 用来接收异常，返回值用来说明是否发生了异常。    - func UpdateTable()函数中，使用defer来判断最终应该提交还是回滚。    - 上面代码初步看起来还算合理，但是此处的IsPanic()再也不会返回true，不是IsPanic()函数的问题，而是其调用的位置不对。</code></pre><ul><li><ol start="3"><li><p>recover 失效的条件</p><ul><li><p>上面代码IsPanic()失效了，其原因是违反了recover的一个限制，导致recover()失效（永远返回nil）。</p></li><li><p>以下三个条件会让recover()返回nil:</p><ul><li>panic时指定的参数为nil；（一般panic语句如panic(“xxx failed…”)）</li><li>当前协程没有发生panic；</li><li>recover没有被defer方法直接调用；</li></ul></li><li><p>前两条都比较容易理解，上述例子正是匹配第3个条件。</p></li><li><p>本例中，recover() 调用栈为“defer （匿名）函数” –&gt; IsPanic() –&gt; recover()。也就是说，recover并没有被defer方法直接调用。符合第3个条件，所以recover() 永远返回nil。</p></li></ul></li></ol></li></ul><h3 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h3><ul><li><ol><li><p>前言</p><ul><li>select是Golang在语言层面提供的多路IO复用的机制，其可以检查多个channel是否ready(即是否可读或可写)，使用起来非常方便。</li><li>本章试图根据源码总结其实现原理，从而发现一些使用误区或解释一些不太常见的现象。</li></ul></li></ol></li><li><ol start="2"><li>热身环节</li></ol><p>我们先看几个题目，用于测试对select的了解程度，每个题目代表一个知识点，本章后面的部分会进行略为详细的介绍。</p></li></ul><pre><code>- 2.1 题目1    - 下面的程序输出是什么？      package main      import (          &quot;fmt&quot;          &quot;time&quot;      )      func main() &#123;          chan1 := make(chan int)          chan2 := make(chan int)          go func() &#123;              chan1 &lt;- 1              time.Sleep(5 * time.Second)          &#125;()          go func() &#123;              chan2 &lt;- 1              time.Sleep(5 * time.Second)          &#125;()          select &#123;          case &lt;-chan1:              fmt.Println(&quot;chan1 ready.&quot;)          case &lt;-chan2:              fmt.Println(&quot;chan2 ready.&quot;)          default:              fmt.Println(&quot;default&quot;)          &#125;          fmt.Println(&quot;main exit.&quot;)      &#125;      程序中声明两个channel，分别为chan1和ch</code></pre><ul><li><p>函数说明：</p><p>程序中声明两个channel，分别为chan1和chan2，依次启动两个协程，分别向两个channel中写入一个数据就进入睡眠。select语句两个case分别检测chan1和chan2是否可读，如果都不可读则执行default语句。</p><pre><code>  - 参考答案：    select中各个case执行顺序是随机的，如果某个case中的channel已经ready，则执行相应的语句并退出select流程，如果所有case中的channel都未ready，则执行default中的语句然后退出select流程。另外，由于启动的协程和select语句并不能保证执行顺序，所以也有可能select执行时协程还未向channel中写入数据，所以select直接执行default语句并退出。所以，以下三种输出都有可能：</code></pre></li></ul><pre><code>​    ​    - 可能的输出一：​    ​          chan1 ready.  main exit.​          ​          ​    ​    - 可能的输出二：​              chan2 ready.  main exit.    - 可能的输出三：          default  main exit.</code></pre><ul><li><p>2.2 题目2</p><ul><li><p>下面的程序执行到select时会发生什么？</p><pre><code>package mainimport (    &quot;fmt&quot;    &quot;time&quot;)func main() &#123;    chan1 := make(chan int)    chan2 := make(chan int)    writeFlag := false    go func() &#123;        for &#123;            if writeFlag &#123;                chan1 &lt;- 1            &#125;            time.Sleep(time.Second)        &#125;    &#125;()    go func() &#123;        for &#123;            if writeFlag &#123;                chan2 &lt;- 1            &#125;            time.Sleep(time.Second)        &#125;    &#125;()    select &#123;    case &lt;-chan1:        fmt.Println(&quot;chan1 ready.&quot;)    case &lt;-chan2:        fmt.Println(&quot;chan2 ready.&quot;)    &#125;    fmt.Println(&quot;main exit.&quot;)&#125;</code></pre></li></ul></li></ul><pre><code>- 函数说明：      程序中声明两个channel，分别为chan1和chan2，依次启动两个协程，协程会判断一个bool类型的变量writeFlag来决定是否要向channel中写入数据，由于writeFlag永远为false，所以实际上协程什么也没做。select语句两个case分别检测chan1和chan2是否可读，这个select语句不包含default语句。- 参考答案：select会按照随机的顺序检测各case语句中channel是否ready，如果某个case中的channel已经ready则执行相应的case语句然后退出select流程，如果所有的channel都未ready且没有default的话，则会阻塞等待各个channel。所以上述程序会一直阻塞。- 2.3 题目3- 下面程序有什么问题？  package main  import (          &quot;fmt&quot;      )      func main() &#123;          chan1 := make(chan int)          chan2 := make(chan int)          go func() &#123;              close(chan1)          &#125;()          go func() &#123;              close(chan2)          &#125;()          select &#123;          case &lt;-chan1:              fmt.Println(&quot;chan1 ready.&quot;)          case &lt;-chan2:              fmt.Println(&quot;chan2 ready.&quot;)          &#125;          fmt.Println(&quot;main exit.&quot;)      &#125;    - 函数说明：  程序中声明两个channel，分别为chan1和chan2，依次启动两个协程，协程分别关闭两个channel。select语句两个case分别检测chan1和chan2是否可读，这个select语句不包含default语句。</code></pre><ul><li><p>参考答案：</p><pre><code>select会按照随机的顺序检测各case语句汇总channel是否ready，烤炉到已关闭的channel也是刻度的，所以上述程序中select不会阻塞，具体执行哪个case语句是随机的。</code></pre></li><li><p>2.4 题目4</p><pre><code>  - 下面程序会发生什么？    package main    func main() &#123;    select &#123;        &#125;    &#125;</code></pre></li></ul><pre><code>​          - 函数说明：      上面程序中只有一个空的select语句。- 参考答案：  对于空的select语句，程序会被阻塞，准确的说是当前协程被阻塞，同时Golang自带死锁检测机制，当发现当前协程再也没有机会被唤醒时，则会panic。所以上述程序会panic。</code></pre><ul><li><ol start="3"><li>实现原理</li></ol><p>Golang实现select时，定义了一个数据结构表示每各case语句（含default，default实际上是一种特殊的case），select执行过程可以类比成一个函数，函数输入case数组，输出选中的case，然后程序流程转到选中的case块。</p></li></ul><pre><code>- 3.1 case数据结构    - 源码包src/runtime/select.go:scase定义了表示case语句的数据结构：      <pre><code class="hljs go"><span class="hljs-keyword">type</span> scase <span class="hljs-keyword">struct</span> &#123;    c           *hchan         <span class="hljs-comment">// chan</span>    kind        <span class="hljs-keyword">uint16</span>    elem        unsafe.Pointer <span class="hljs-comment">// data element</span>&#125;</code></pre></code></pre><ul><li><p>scase.c为当前case语句所操作的channel指针，这也说明了一个case语句只能操作一个channel。</p><pre><code>  - scase.kind表示该case的类型，分为读channel、写channel和default，三种类型分别由常量定义：</code></pre><ul><li>caseRecv: case语句中尝试读取scase.c中的数据<pre><code>  - caseSend: case语句中尝试向scase.c中写入数据  - caseDefault: default语句</code></pre></li></ul></li><li><p>scase.elem表示缓冲区地址，根据scase.kind不同，有不同的用途：</p><ul><li>scase.kind == caseRecv: scase.elem表示读出channel的数据存放地址<pre><code>  - scase.kind == caseSend: scase.elem表示将要写入channel的数据存放地址</code></pre></li></ul></li><li><p>3.2 select实现逻辑</p><ul><li><p>源码包src/runtime/select.go:selectgo()定义了select选择case的函数：</p><p>func selectgo(cas0 *scase, order0 *uint16, ncases int) (int, bool)</p></li></ul></li></ul><pre><code>- 函数参数：    - cas0为scase数组的首地址，selectgo()就是从这些scase中找出一个返回        - order0为一个两倍cas0数组长度的buffer，保存scase随机序列pollorder和scase中channel地址序列lockorder        - pollorder：每次selectgo执行都会把scase序列打乱，以达到随机检测case的目的            - lockorder：所有case语句中channel序列，以达到去重防止对channel枷锁时重复加锁的目的    - ncases表示scase数组的长度- 函数返回值：    - 1. int：选中case的编号，这个case编号跟代码一致        - 2. bool：是否成功从channel中读取了数据，如果选中的case是从channel中读数据，则该返回值表示是否读取成功。        - selectgo实现伪代码如下：      <pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">selectgo</span><span class="hljs-params">(cas0 *scase, order0 *<span class="hljs-keyword">uint16</span>, ncases <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">bool</span>)</span></span> &#123;    <span class="hljs-comment">//1. 锁定scase语句中所有的channel</span>    <span class="hljs-comment">//2. 按照随机顺序检测scase中的channel是否ready</span>    <span class="hljs-comment">//   2.1 如果case可读，则读取channel中数据，解锁所有的channel，然后返回(case index, true)</span>    <span class="hljs-comment">//   2.2 如果case可写，则将数据写入channel，解锁所有的channel，然后返回(case index, false)</span>    <span class="hljs-comment">//   2.3 所有case都未ready，则解锁所有的channel，然后返回（default index, false）</span>    <span class="hljs-comment">//3. 所有case都未ready，且没有default语句</span>    <span class="hljs-comment">//   3.1 将当前协程加入到所有channel的等待队列</span>    <span class="hljs-comment">//   3.2 当将协程转入阻塞，等待被唤醒</span>    <span class="hljs-comment">//4. 唤醒后返回channel对应的case index</span>    <span class="hljs-comment">//   4.1 如果是读操作，解锁所有的channel，然后返回(case index, true)</span>    <span class="hljs-comment">//   4.2 如果是写操作，解锁所有的channel，然后返回(case index, false)</span>&#125;</code></pre>- 特别说明：    - 对于读channel的case来说，如 case elem, ok := &lt;-chan1: ,如果channel有可能被其他协程关闭的情况下，一定要检测读取是否成功，因为close的channel也有可能返回，此时ok == false</code></pre><ul><li><ol start="4"><li><p>总结</p><ul><li>select语句中除default外，每个case操作一个channel，要么读要么写</li><li>select语句中除default外，各case执行顺序是随机的</li><li>select语句中如果没有default语句，则会阻塞等待任一case</li><li>select语句中读操作要判断是否成功读取，关闭的channel也可以读取</li></ul></li></ol></li></ul><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><ul><li><ol><li><p>前言</p><ul><li>range是Golang提供的一种迭代遍历手段，可操作的类型有数组、切片、Map、channel等，实际使用频率非常高。</li><li>探索range的实现机制是很有意思的事情，这可能会改变你使用range的习惯。</li></ul></li></ol></li><li><ol start="2"><li><p>热身</p><ul><li><p>2.1 题目一：切片遍历</p><ul><li><p>下面函数通过遍历切片，打印切片的下标和元素值，请问性能上有没有可优化的空间？</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RangeSlice</span><span class="hljs-params">(slice []<span class="hljs-keyword">int</span>)</span></span> &#123;       <span class="hljs-keyword">for</span> index, value := <span class="hljs-keyword">range</span> slice &#123;             _, _ = index, value        &#125;&#125;</code></pre></li></ul></li></ul></li></ol></li><li><p>程序解释：</p><p>函数中使用for-range对切片进行遍历，获取切片的下表和元素素值，这里忽略函数的实际意义。</p><pre><code>  - 参考答案：    遍历过程中每次迭代会对index和value进行赋值，如果数据量大或者value类型为string时，对value的赋值操作可能是多余的，可以在for-range中忽略value值，使用slice[index]引用value值。</code></pre></li></ul><pre><code>​    </code></pre><ul><li><p>2.2 题目二：map遍历</p><ul><li><p>下面函数通过遍历map，打印map的key和value，请问性能上有没有可优化的空间</p><pre><code><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">RangeMap</span><span class="hljs-params">(myMap <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>)</span></span> &#123;    <span class="hljs-keyword">for</span> key, _ := <span class="hljs-keyword">range</span> myMap &#123;        _, _ = key, myMap[key]    &#125;&#125;</code></pre></code></pre></li><li><p>程序解释：</p><p>函数中使用for-range对map进行遍历，获取map的key值，并根据key值获取value值，这里忽略函数的实际意义。</p></li><li><p>参考答案：</p><p>  函数中for-range语句中只获取key值，然后根据key值获取value值，虽然看似减少了一次赋值，但通过key值查找value值得性能消耗可能高于赋值消耗。能否优化取决于map所存储数据结构特征、结合实际情况进行。</p></li></ul></li><li><p>2.3 题目三：动态遍历</p><pre><code>  - 请问如下程序能否正常结束？    <pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;        v := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;       <span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> v &#123;          v = <span class="hljs-built_in">append</span>(v, i)        &#125; &#125;</code></pre></code></pre><ul><li><p>程序解释：</p><p>main()函数中定义一个切片v,通过range遍历v，遍历过程中不断向v中添加新的元素。</p></li><li><p>参考答案：</p><p>能够正常结束。循环内改变切片的长度，不影响循环次数，训话次数在循环开始前就已经确定了。</p></li></ul></li><li><ol start="3"><li>实现原理</li></ol><p>对于for-range语句的实现，可以从编译器源码中找到答案。<br>编译器源码gofrontend/go/statements.cc/For_range_statement::do_lower()方法中有如下注释。</p><p>// Arrange to do a loop appropriate for the type.  We will produce<br>//   for INIT ; COND ; POST {<br>//           ITER_INIT<br>//           INDEX = INDEX_TEMP<br>//           VALUE = VALUE_TEMP // If there is a value<br>//           original statements<br>//   }<br>可见range实际上是一个C风格的循环结构。range支持数组、数组指针、切片、map和channel类型，对于不同类型有些细节上的差异。</p></li></ul><pre><code>- 3.1 range for slice    - 下面的注释解释了遍历slice的过程：      // The loop we generate:      //   for_temp := range      //   len_temp := len(for_temp)      //   for index_temp = 0; index_temp &lt; len_temp; index_temp++ &#123;      //           value_temp = for_temp[index_temp]      //           index = index_temp      //           value = value_temp      //           original body      //   &#125;    - 遍历slice前会先获取slice的长度len_temp作为循环次数、循环体中，每次循环会先获取元素值，如果for-range中接收index和value的话，则会会index和value进行一次赋值。    - 由于循环开始前循环次数就已经确定了，所以循环过程中新添加的元素是没办法遍历到的。    - 另外，数组于数组指针的遍历过程于slice基本一致，不再赘述。- 3.2 range for map    - 下面的注释解释了遍历map的过程：      // The loop we generate:      //   var hiter map_iteration_struct      //   for mapiterinit(type, range, &amp;hiter); hiter.key != nil; mapiternext(&amp;hiter) &#123;      //           index_temp = *hiter.key      //           value_temp = *hiter.val      //           index = index_temp      //           value = value_temp      //           original body      //   &#125;    - 遍历map时没有指定循环次数，循环体与遍历slice类似。由于map底层实现与slice不同，map底层使用hash表实现，插入数据位置是随机的，所以遍历过程中新插入的数据不能保证遍历到。- 3.3 range for channel    - 遍历channel是最特殊的，这是由channel的实现机制决定的：      // The loop we generate:      //   for &#123;      //           index_temp, ok_temp = &lt;-range      //           if !ok_temp &#123;      //                   break      //           &#125;      //           index = index_temp      //           original body      //   &#125;    - chanel遍历是一次从channel读取数据，读取前是不知道里面有多少个元素的。如果channel中没有元素，则会阻塞等待，如果channel已被关闭，则会解除阻塞并退出循环。    - 注：上述注释中index_temp实际上是有误的，应该为value_temp，因为index对于channel是没有意义的。    - 使用for-range遍历channel时只能获取一个返回值</code></pre><ul><li><ol start="4"><li><p>编程Tips</p><ul><li>遍历过程中可以视情况放弃接收index或value，可以一定程度上提升性能</li><li>遍历channel时，如果channel中没有数据，可能会阻塞</li><li>尽量避免遍历过程中修改原数据</li></ul></li></ol></li><li><ol start="5"><li><p>总结</p><ul><li>for-range的实现实际上时C风格的for循环</li><li>使用index, value接收range返回值会发生一次数据拷贝</li></ul></li></ol></li></ul><h3 id="Mutex"><a href="#Mutex" class="headerlink" title="Mutex"></a>Mutex</h3><ul><li><ol><li><p>前言</p><ul><li>互斥锁是并发程序中对共享资源进行访问控制的主要手段，对此Go语言提供了非常简单易用的Mutex，Mutex为一结构体类型，对外暴露两个方法Lock() 和Unlock() 分别用于加锁和解锁。</li><li>Mutex使用起来非常方便，但其其内容实现却复杂得多，这包括Mutex的几种状态。另外，我们也项探究一下Mutex重复解锁引起panic的原因。</li><li>按照惯例，本节内容从源码入手，提取出实现原理，又不会过分纠结于实现细节。</li></ul></li></ol></li><li><ol start="2"><li><p>Mutex数据结构</p><ul><li><p>2.1 Mutex结构体</p><ul><li><p>源码包 src/sync/mutex.go:Mutex 定义了互斥锁的数据结构：</p><p>type Mutex struct {</p><pre><code>  state int32  sema  uint32</code></pre><p>}</p></li></ul></li></ul></li></ol></li><li><p>Mutex.state 表示互斥锁的状态，比如是否被锁定等。</p><pre><code>  - Mutex.sema表示信号量，协程阻塞等待该信号量，解锁的协程释放信号量从而唤醒等待信号量的协程。  - 我们看到Mutex.state是32位的整型变量，内部实现时把该变量分成四份，用于记录Mutex的四种状态。  - 下图展示Mutex的内存布局：</code></pre><ul><li>Locked: 表示该Mutex是否已被锁定，0：没有锁定 1：已被锁定。<pre><code>  - Woken：表示是否又协程已被唤醒，0：没有协程唤醒 1：已有协程唤醒，正在加锁过程中。  - Starving：表示该Mutex是否出于饥饿状态，0：没有饥饿 1：饥饿状态，说明有协程组赛了超过1ms。  - Waiter：表示阻塞等待所得协程个数，协程解锁时根据此值来判断是否需要释放信号量。</code></pre></li></ul></li><li><p>协程之间抢锁实际上是抢给Locked赋值得权利，能给Locked域置1，就说明抢锁成功。抢不到的话就阻塞等待Mutex.sema信号量，一旦持有锁的协程解锁，等待的协程会一次被唤醒。</p><pre><code>  - Woken和Starving主要用于可攻至协程间的枪锁过测化工你，后面再进行了解。</code></pre></li><li><p>2.2 Mutex方法</p><ul><li><p>Mutex对外提供两个方法，实际上也只有这两个方法：</p><ul><li>Lock()：加锁方法<ul><li>Unlock(): 解锁方法</li></ul></li></ul></li><li><p>下面我们分析一下加锁和解锁的过程，加锁分成功和失败两种情况，成功的话直接获取锁，失败后当前协程被阻塞，同样，解锁时根据是否有阻塞协程也有两种处理。</p></li></ul></li><li><ol start="3"><li><p>加解锁过程</p><ul><li><p>3.1 简单加锁</p><ul><li>假定当前只有一个协程在加锁，没有其他协程干扰，那么过程如下图所示：</li><li>加锁过程会去判断Locked标志位是否为0，如果是0则把Locked置为1，代表加锁成功。从上图可见，加锁成功后，只是Locked置为1，其他状态位没发生变化。</li></ul></li><li><p>3.2 加锁被阻塞</p><ul><li>假定加锁时，锁已被其他协程占用了，此时加锁过程如下图所示：</li><li>从上图可看到，当协程B对一个已被占用的锁再次加锁时，Waiter计数器增加了1，此时协程B将被阻塞，直到Locked值变为0后才会被唤醒。</li></ul></li><li><p>3.3 简单解锁</p><ul><li>假定解锁时，没有其他协程阻塞，此时解锁过程如下图所示：</li><li>由于没有其他协程阻塞等待加锁，所以此时解锁时只需要把Locked置为0即可，不需要释放信号量。</li></ul></li><li><p>3.4 解锁并唤醒协程</p><ul><li>假定解锁时，有1个或多个协程阻塞，此时解锁过程如下图所示：</li><li>协程A解锁过程分为两个步骤，一是把Locked置为0，二是查看到Waiter&gt;0，所以释放一个信号量，唤醒一个阻塞的协程，被唤醒的协程B把Locked置为1，于是协程B获得锁。</li></ul></li></ul></li></ol></li><li><ol start="4"><li>自旋过程</li></ol><p>加锁时，如果当前Locked位为1，说明该锁当前由其他协程持有，尝试加锁的协程并不是马上转入阻塞，而是会持续地探测Locked位是否变为0，这个过程即为自旋过程。<br>自旋时间很短，但如果在自旋过程中发现锁已被释放，那么协程可以立即获取锁。此时即便有协程被唤醒也无法获取锁，只能再次阻塞。<br>自旋地好处是，当加锁失败时不必立即转入阻塞，有一定机会获取到锁，这样可以避免协程地切换。</p></li></ul><pre><code>- 4.1 什么是自旋    - 自旋对应于CPU的&quot;PAUSE&quot;指令，CPU对该指令什么都不做，相当于CPU空转，对程序而言相当于sleep了一小段时间，时间非常短，当前实现是30个时钟周期。    - 自旋过程中会持续探测Locked是否变为0，连续两次探测间隔就是执行这些PAUSE指令，它不同于sleep，不需要将协程转为睡眠状态。- 4.2 自旋条件    - 加锁时程序会自动判断是否可以自旋，无限制的自旋将会给CPU带来巨大压力，所以判断是否可以自旋就很重要了。    - 自旋必须满足以下所有条件：        - 自旋次数要足够小，通常为4，即自旋最多4次。        - CPU核数要大于1，否则自旋没有意义，因为此时不可能有其他协程释放锁。        - 协程调度机制中的Process刷零要大于1，比如使用GOMAXPROCS()将处理器设置为1就不能启用自旋        - 协程调度机制中的可运行队列必须为空，否则会延迟协程调度    - 可见，自旋的条件是很苛刻的，总而言之就是不忙的时候才会启用自旋。- 4.3 自旋的优势    - 自旋的优势是更充分的利用CPU，尽量避免协程切换。因为当前申请加锁的协程拥有CPU，如果经过短时间的自旋可以获得锁，当前协程可以继续运行，不必进入阻塞状态。- 4.4 自旋的问题    - 如果自旋过程中获得锁，那么之前被阻塞的协程将无法获得锁，如果加锁的协程特别多，每次都通过自旋获得锁，那么之前被阻塞的进行将很难获得锁，从而进入饥饿状态。    - 为了避免协程长时间无法获取锁，自1.8版本以来增加了一个状态，即Mutex的Starving状态。这个状态下不会自旋，一旦有协程释放锁，那么一定会唤醒一个协程并成功加锁。</code></pre><ul><li><ol start="5"><li>Mutex模式</li></ol><p>前面分析加锁和解锁过程中只关注了Waiter和Locked位的变化，现在我们看一下Starving位的作用。<br>每个Mutex都有两个模式，称为Normal和Starving。下面分别说明滚这两个模式。</p></li></ul><pre><code>- 5.1 normal模式    - 默认情况下，Mutex的模式为normal。    - 该模式下，协程如果加锁不成功不会立即转入阻塞排队，而是判断是否满足自旋的条件，如果满足则会启动自旋过程，尝试抢锁。- 5.2 starvation模式    - 自旋过程中能抢到锁，一定意味着同一时刻有协程释放了锁，我们指导释放锁时如果发现有阻塞等待的协程，还会释放一个信号量来唤醒一个等待协程，被唤醒的协程得到CPU后开始运行，此时发现锁已被抢占了，自己只好再次阻塞，不过阻塞前会判断自上次阻塞到本次阻塞经过多长时间，如果超过1ms的话会将Mutex标记为&quot;饥饿&quot;模式，然后再阻塞。    - 出于饥饿模式下，不会启动自旋过程，也即一旦有协程释放了锁，那么一定会唤醒协程，被唤醒的协程将会成功获取锁，同时也会把等待计数减1.</code></pre><ul><li><ol start="6"><li><p>Woken状态</p><ul><li>Woken状态用于加锁和解锁过程的通信，举个例子，同一时刻，两个协程一个在加锁，一个在解锁，在加锁的协程可能在自旋过程中，此时把Woken标记为1，用于通知解锁协程不必释放信号量了，好比在说：你只管解锁好了，不必释放信号量，我马上就拿到锁了。</li></ul></li></ol></li><li><ol start="7"><li><p>为什么重复解锁要panic</p><ul><li>可能你会想，为什么Go不能实现得更健壮些，多次执行Unlock()也不要panic？</li><li>仔细想想Unlock得逻辑就可以理解，这实际上很难做到。Unlock过程分为将Locked置为0，然后判断Waiter值，如果值&gt;0，则释放信号量。</li><li>如果多次Unlock(),那么可能每次释放一个信号量，这样会唤醒多个协程，多个协程唤醒后会继续在Lock()的逻辑里抢锁，势必会增加Lock()实现的复杂度，也会引起不必要的协程切换。</li></ul></li></ol></li><li><ol start="8"><li><p>编程Tips</p><ul><li><p>8.1 使用defer避免死锁</p><ul><li>加锁后立即使用的defer对其解锁，可以有效的避免死锁。</li></ul></li><li><p>8.2 加锁和解锁应该成对出现</p><ul><li>加锁和解锁最好出现在同一个层次的代码块中，比如同一个函数。</li><li>重复解锁会引起panic，应避免这种操作的可能性。</li></ul></li></ul></li></ol></li></ul><h3 id="Remutex"><a href="#Remutex" class="headerlink" title="Remutex"></a>Remutex</h3><ul><li><ol><li><p>前言</p><ul><li><p>前面我们聊了互斥锁Mutex，所谓读写锁REMutex，完整的表述应该是读写互斥锁，可以说是Mutex的一个改进版，在某些场景下可以发挥更加灵活的控制能力，比如：读取数据频率远远大于写数据频率的场景。</p></li><li><p>例如，程序中写操作少而读操作多，简单的说，如果执行过程是1次写然后N次读的话，使用Mutex，这个过程将是串行的，因为即便N次读操作互相之间并不影响，但也都需要持有Mutex后才可以操作。如果使用读写锁，多个读操作可以同时持有锁，并发能力将大大提升。</p></li><li><p>实现读写锁需要解决如下几个问题：</p><ul><li><ol><li>写锁需要阻塞写锁：一个协程拥有写锁时，其他协程写锁定需要阻塞。</li></ol></li><li><ol start="2"><li>写锁需要阻塞读锁：一个协程拥有写锁时，其他协程读锁定需要阻塞</li></ol></li><li><ol start="3"><li>读锁需要阻塞写锁：一个协程拥有读锁时，其他协程写锁定需要阻塞</li></ol></li><li><ol start="4"><li>读锁不能阻塞读锁：一个协程拥有读锁时，其他协程也可以拥有读锁</li></ol></li></ul></li><li><p>下面我们将按照这个思路，即读写锁如何解决这些问题的，来分析读写锁的实现。</p></li><li><p>读写锁基于Mutex实现，实现源码非常简单和简洁，又有一定的技巧在里面。</p></li></ul></li></ol></li><li><ol start="2"><li><p>读写锁数据结构</p><ul><li><p>2.1 类型定义</p><ul><li><p>源码包 src/sync/remutex.go: RWMutex 定义了读写锁数据结构：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> RWMutex <span class="hljs-keyword">struct</span> &#123;    w           Mutex  <span class="hljs-comment">//用于控制多个写锁，获得写锁首先要获取该锁，如果有一个写锁在进行，那么再到来的写锁将会阻塞于此</span>    writerSem   <span class="hljs-keyword">uint32</span> <span class="hljs-comment">//写阻塞等待的信号量，最后一个读者释放锁时会释放信号量</span>    readerSem   <span class="hljs-keyword">uint32</span> <span class="hljs-comment">//读阻塞的协程等待的信号量，持有写锁的协程释放锁后会释放信号量</span>    readerCount <span class="hljs-keyword">int32</span>  <span class="hljs-comment">//记录读者个数</span>    readerWait  <span class="hljs-keyword">int32</span>  <span class="hljs-comment">//记录写阻塞时读者个数</span>&#125;</code></pre></li></ul></li></ul></li></ol></li><li><p>由以上数据结构可见，读写锁内部仍有一个互斥锁，用于将两个写操作隔离开来，其他的几个都用于隔离度操作和写操作。</p><pre><code>  - 下面我们简单看下RWMutex提供的4个接口，后面再根据使用场景具体分析这几个成员是如何配合工作的。</code></pre></li><li><p>2.2 接口定义</p><p>RWMutex提供4个简单的接口来提供服务：</p><pre><code>RLock()：读锁定RUnlock()：解除读锁定Lock(): 写锁定，与Mutex完全一致Unlock()：解除写锁定，与Mutex完全一致</code></pre></li></ul><pre><code>- 2.2.1 Lock()实现逻辑    - 写锁定操作需要做两件事：        - 获取互斥锁            - 阻塞等待所有读操作结束（如果有的话）    - 所以 func (rw *RWMutex) Lock()接口实现流程如下图所示：- 2.2.2 Unlock() 实现逻辑    - 解除写锁定要做两件事：        - 唤醒因读锁定而被阻塞的协程（如果有的话）            - 解除写互斥    - 所以 func (rw *RWMutex) Unlock() 接口实现流程如下图所示：- 2.2.3 RLock()实现逻辑    - 读锁定需要做两件事：        - 增加读操作数，即readerCount++            - 阻塞等待写操作结束（如果有的话）    - 所以 func (rw *RWMutex) RLock() 接口实现流程如下图所示：- 2.2.4 RUnlock()实现逻辑    - 解除读锁定需要做两件事：        - 减少读操作计数，即readerCount-            - 唤醒等待写操作的流程（如果有的话）    - 所以 func (rw *RWMutex) RUnlock() 接口实现流程如下图所示：        - 注意：即便有协程阻塞等待写操作，并不是所有的解除读锁定操作都会唤醒该协程，而是最后一个解除读锁定的协程才会释放信号量将该协程唤醒，因为只有当所有读操作的协程释放锁后才可以唤醒协程。</code></pre><ul><li><ol start="3"><li>场景分析</li></ol><p>上面我们简单看了下4个接口实现原理，接下来我们看一下事如何解决耆那买呢提到的几个问题的。</p></li></ul><pre><code>- 3.1 写操作是如何阻止写操作的    - 读写锁包含一个互斥锁（Mutex），写锁定必须要先获取该互斥锁，如果互斥锁已被协程A获取（）</code></pre><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>本章主要介绍协程及其调度机制。</p><p>协程是GO语言最大的特色之一，本章我们从协程的概念、GO协程的实现、GO协程调度机制等角度来分析。</p><h3 id="协程调度"><a href="#协程调度" class="headerlink" title="协程调度"></a>协程调度</h3><ul><li><ol><li><p>前言</p><ul><li>Goroutine调度是一个很复杂的机制，尽管Go源码中提供了大量的注释，但其对原理没有一个好的理解的情况下去读源码收获不会很大。下面尝试用简单的语言描述一下Goroutine调度机制，在此基础上再去研读源码效果可能会更好一些。</li></ul></li></ol></li><li><ol start="2"><li><p>线程池的缺陷</p><ul><li>我们指导，在高并发应用中频繁创建线程会造成不必要的开销，所以有了线程池。线程池中预先保存一定数量的线程，而新任务将不再以创建线程的方式去执行，而是将任务发布到任务队列，线程池中的线程不断地从任务队列中取出任务并执行，可以有效地减少线程创建和销毁所带来地开销。</li><li>下图展示一个典型的线程池：</li><li>为了方便下面的叙述，我们把任务队列中的每一个任务称作G，而G往往代表一个函数。线程池中的worker线程不断地从任务队列中取出任务并执行。而worker线程的调度则交给操作系统进行调度。</li><li>如果worker线程执行的G任务中发生系统调用，则操作系统会将该线程置为阻塞状态，也意味着该线程在怠工，也意味着消费任务队列的worker线程变少了，也就是说线程消费任务队列的能力变弱了。</li><li>如果任务队列中的大部分任务都会进行系统调用，则会让这种状态恶化，大部分worker线程进入阻塞状态，从而任务队列中的任务产生堆积。</li><li>解决这个问题的一个思路就是重新审视线程池中的线程的数量，增加线程池中线程数量可以一定程度上提高消费能力，但随着线程数量增多，由于过多线程争抢CPU，消费能力会有上限，甚至出现消费能力下降。如下图所示：</li></ul></li></ol></li><li><ol start="3"><li><p>Goroutine调度器</p><ul><li><p>线程数过多，意味着操作系统会不断地切换线程，频繁的上下文切换就成了性能瓶颈。Go提供一种机制，可以在线程中自己实现调度，上下文切换更轻量，从而达到了线程数少，而并发数并不少的效果。而线程汇总调度的就是Goroutine。</p></li><li><p>早期Go版本，比如1.9.2版本的源码注释中有关于调度器的解释。</p></li><li><p>Goroutine调度器的工作就是把”ready-to-run”的goroutine分发到线程中。</p></li><li><p>Goroutine主要概念如下：</p><ul><li>G（Goroutine）：即Go协程，每个go关键字都会创建一个协程。</li><li>M（Machine）：工程线程，在Go中称为Machine。</li><li>P（Processor）：处理器（Go中定义的一个概念，不是指CPU），包含运行Go代码的必要资源，也有调度goroutine的能力。</li></ul></li><li><p>M必须拥有P才可以执行G中的代码，P含有一个包含多个G的队列，P可以调度G交由M执行。其关系如下图所示：</p><ul><li>图中M是交给操作系统调度的线程，M持有一个P，P将G调度进M中执行。P同时还维护着一个包含G的队列（途中灰色部分），可以按照一定的策略将G调度到M中执行。</li><li>P的个数在程序启动时决定，默认情况下等同于CPU的核数，由于M必须持有一个P才可以运行Go代码，所以同时运行的M个数，也即线程数一般等同于CPU的个数，以达到尽可能地使用CPU而又不至于产生过多地线程切换开销。</li><li>程序中可以使用 runtime.GOMAXPROCS() 设置P地个数，在某些IO密集型地场景下可以在一定程度上提高性能。这个后面再详细介绍。</li></ul></li></ul></li></ol></li><li><ol start="4"><li><p>Goroutine调度策略</p><ul><li><p>4.1 队列轮转</p><ul><li>上图中可见每个P维护者一个包含G的队列，不考虑G进入系统调用或IO操作的情况下，P周期性的将G调度到M中执行，执行一小段时间，将上下问保存下来，然后将G放到队列尾部，然后从队列中重新取出一个G进行调度。</li><li>除了每个P维护的G队列以外，还有一个全局的队列，每个P会周期地查看全局队列汇总是否有G待运行并将其调度到M中执行，全局队列中G地来源，主要有从系统调用中恢复的G。之所以P会周期性地查看全局队列，也是为了防止全局队列中的G被饿死。</li></ul></li><li><p>4.2 系统调用</p><ul><li><p>上面说到P的个数默认等于CPU核数，每个M必须持有一个P才可以执行G，一般情况下M的个数会略大于P的个数，着多出来的M将会在G产生系统调用时发挥作用。类似线程池，Go也提供一个M的池子，需要时从池子中获取，用完放回池子，不够用时就再创建一个。</p></li><li><p>当M运行的某个G产生系统调用时，如下如图所示：</p></li><li><p>如图所示，当Go即将进入系统调用时，M0将释放P，进而某个空闲的M1获取P，继续执行P队列中剩下的G。而M0由于陷入系统Wong调用而被阻塞，M1接替M0的工作，只要P不空闲，就可以保证充分利用CPU。</p></li><li><p>M1的来源有可能时M的缓存池，也可能是新建的。当G0系统调用结束后，根据M0是否能获取到P，将会将G0做不同的处理：</p><ul><li><ol><li>如果有空闲的P，则获取一个P，继续执行G0。</li></ol></li><li><ol start="2"><li>如果没有空闲的P，则将G0放入全局队列，等待被其他的P调度。然后M0将进入缓存池睡眠。</li></ol></li></ul></li></ul></li><li><p>4.3 工作量窃取</p><ul><li>多个P中维护的G队列有可能是不均衡的，比如下图：</li><li>竖线左侧中右边的P已经将G全部执行完，然后去查询全局队列，全局队列中也没有G，而另一个M中除了正在运行的G外，队列中还有3个G待运行。此时，空闲的P会将其他P中的G偷取一部分过来，一般每次偷取一半。有趣按如右图所示。</li></ul></li></ul></li></ol></li><li><ol start="5"><li><p>GOMAXPROCS设置对性能的影响</p><ul><li>一般来讲，程序运行时就将GOMAXPROCS大小设置为CPU核数，可让Go程序充分利用CPU。</li><li>在某些IO密集型的应用里，这个值可能并不意味着性能最好。</li><li>理论上当某个Goroutine进入系统调用时，会有一个新的M被启用或创建，继续占满CPU。</li><li>但由于Go调度器检测到M被阻塞是有一定延迟，也即旧的M被阻塞和新的M得到运行之间是有一定间隔的，所以在IO密集型应用中不妨把GOMAXPROCS设置的大一些，获取会有好的效果。</li></ul></li></ol></li><li><ol start="6"><li><p>参考文章</p><ul><li>6.1 《The Go scheduler》</li></ul></li></ol></li></ul><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>本章主要介绍GO语言的自动垃圾回收机制。</p><p>自动垃圾回收是GO语言最大的特色之一，也是很有争议的话题。因为自动垃圾回收解放了程序员，使其不用担心内存泄露的问题，争议在于垃圾回收的性能，在某些应用场景下垃圾回收会暂时停止程序运行。</p><p>本章从内存分配原理讲起，然后再看垃圾回收原理，最后再聊一些与垃圾回收性能优化相关的话题。</p><h3 id="内存分配原理"><a href="#内存分配原理" class="headerlink" title="内存分配原理"></a>内存分配原理</h3><ul><li><ol><li><p>前言</p><ul><li>编写过C语言程序的肯定知道通过malloc()方法动态申请内存，其中内存分配器使用的是glibc提供的ptmalloc2。</li><li>除了glibc，业界比较出名的内存分配器有Google的tcmalloc和Facebook的jemalloc。二者在避免内存碎片和性能上均比glibc有比较大的优势，在多线程环境中效果更明显。</li><li>Golang中也实现了内存分配器，原理与tcmalloc类似，简单的说就是维护一块大的全局内存，每个线程（Golang中为P）维护一块小的私有内存，私有内存不足再从全局申请。</li><li>另外，内存分配与GC（垃圾回收）关系密切，所以了解GC前有必要了解内存分配的原理。</li></ul></li></ol></li><li><ol start="2"><li><p>基础概念</p><ul><li><p>2.0 前言</p><ul><li>为了方便自主管理内存，做法便是先向系统申请一块内存，然后将内存切割成小块，通过一定的内存分配算法管理内存。</li><li>以64位系统为例，Golang程序启动时会向系统申请的内存如下图所示：</li><li>预申请的内存分为spans、bitmap、arena三部分。其中arena即为所谓的堆区，应用中需要的内存从这里分配。其中spans和bitmap是为了管理arena区而存在的。</li><li>arena的大小为512G，为了方便管理把arena区域划分成一个个的page，每个page为8KB，一共有512GB/8KB个页；</li><li>spans区域存放span的指针，每个指针对应一个或多个page，所以span区域的大小为（512GB/8KB）*指针大小8byte = 512M</li><li>bitmap区域大小也是通过arena计算出来，不过主要用于GC。</li></ul></li><li><p>2.1 span</p><p>span是用于管理arena页的关键数据结构，每个span中包含1个或多个连续页，为了满足小对象分配，span中的一页会划分更小的粒度，而对于大对象比如超过页大小，则通过多页实现。</p></li></ul></li></ol></li></ul><pre><code>    - 2.1.1 class        - 根据对象大小，划分了一系列class，每个class都代表一个固定大小的对象，以及每个span的大小。如下表所示：          // class  bytes/obj  bytes/span  objects  waste bytes          //     1          8        8192     1024            0          //     2         16        8192      512            0          //     3         32        8192      256            0          //     4         48        8192      170           32          //     5         64        8192      128            0          //     6         80        8192      102           32          //     7         96        8192       85           32          //     8        112        8192       73           16          //     9        128        8192       64            0          //    10        144        8192       56          128          //    11        160        8192       51           32          //    12        176        8192       46           96          //    13        192        8192       42          128          //    14        208        8192       39           80          //    15        224        8192       36          128          //    16        240        8192       34           32          //    17        256        8192       32            0          //    18        288        8192       28          128          //    19        320        8192       25          192          //    20        352        8192       23           96          //    21        384        8192       21          128          //    22        416        8192       19          288          //    23        448        8192       18          128          //    24        480        8192       17           32          //    25        512        8192       16            0          //    26        576        8192       14          128          //    27        640        8192       12          512          //    28        704        8192       11          448          //    29        768        8192       10          512          //    30        896        8192        9          128          //    31       1024        8192        8            0          //    32       1152        8192        7          128          //    33       1280        8192        6          512          //    34       1408       16384       11          896          //    35       1536        8192        5          512          //    36       1792       16384        9          256          //    37       2048        8192        4            0          //    38       2304       16384        7          256          //    39       2688        8192        3          128          //    40       3072       24576        8            0          //    41       3200       16384        5          384          //    42       3456       24576        7          384          //    43       4096        8192        2            0          //    44       4864       24576        5          256          //    45       5376       16384        3          256          //    46       6144       24576        4            0          //    47       6528       32768        5          128          //    48       6784       40960        6          256          //    49       6912       49152        7          768          //    50       8192        8192        1            0          //    51       9472       57344        6          512          //    52       9728       49152        5          512          //    53      10240       40960        4            0          //    54      10880       32768        3          128          //    55      12288       24576        2            0          //    56      13568       40960        3          256          //    57      14336       57344        4            0          //    58      16384       16384        1            0          //    59      18432       73728        4            0          //    60      19072       57344        3          128          //    61      20480       40960        2            0          //    62      21760       65536        3          256          //    63      24576       24576        1            0          //    64      27264       81920        3          128          //    65      28672       57344        2            0          //    66      32768       32768        1            0        - 上表中每列含义如下：            - class：ckass ID，每个span结构中都有一个class ID，表示该span可处理的对象类型            - bytes/obj：该class代表对象的字节数            - bytes/span：每个span占用堆的字节数，也即页数*页大小            - objects：每个span可分配的对象个数，也即（bytes/spans）/ （bytes/obj）            - waste bytes：每个span产生的内存碎片，也即（bytes/spans） %（bytes/pbj）        - 上表可见最大的对象是32K大小，超过32K大小的由特殊的class表示，该class ID为0，每个class只包含一个对象。    - 2.1.2 span数据结构        - span是内存管理的基本单位，每个span用于管理特定的class对象，根据对象大小，span将一个或多个页拆分成多个块进行管理。        - src/runtime/mheap.go:mspan 定义了其数据结构：          type mspan struct &#123;              next *mspan            //链表前向指针，用于将span链接起来              prev *mspan            //链表前向指针，用于将span链接起来              startAddr uintptr // 起始地址，也即所管理页的地址              npages    uintptr // 管理的页数              nelems uintptr // 块个数，也即有多少个块可供分配              allocBits  *gcBits //分配位图，每一位代表一个块是否已分配              allocCount  uint16     // 已分配块的个数              spanclass   spanClass  // class表中的class ID              elemsize    uintptr    // class表中的对象大小，也即块大小          &#125;        - 以class 10为例，span和管理的内存如下图所示：            - spanclass为10，参照class表可得出npages=1,nelems=56,elemsize为144.其中startAddr是在span初始化时就指定了某个页的地址。allocBits指向一个位图，每位代表一个块是否被分配，本例中有两个块已经被分配，其allocCount也为2.            - next和prev用于将多个span链接起来，着有利于管理多个span，接下来会进行说明。- 2.2 cache    - 有了管理内存的基本单位span，还要有个数据结构来管理span，这个数据结构叫mcentral，各线程需要内存时从mcentral管理的span中申请内存，为了避免多线程申请内存时不断地加锁，Golang为每个线程分配了span的缓存，这个缓存即是cache。    - src/runtime/mcache.go:macche 定义了cache的数据结构：      type mcache struct &#123;          alloc [67*2]*mspan // 按class分组的mspan列表      &#125;    - alloc为mspan的指针数组，数组大小为class总数的2倍。数组中每个元素代表了一种class类型的span列表，每种class类型都有两组span列表，每一组列表所表示的对象中包含了指针，第二组列表中所表示的对象不含有指针，这么做是为了提高GC扫描性能，对于不包含指针的soan列表，没必要去扫描。    - 根据对象是否包含指针，将对象分为noscan和scan两类，其中noscan代表没有指针，而scan则代表有指针，需要GC进行扫描。    - mcache和span的对应关系如下图所示：    - mcache在初始化时是没有任何span的，在使用过程汇总会动态地从central中获取并缓存下来，根据使用请开给你，每种class地span个数也不相同。上图所示，class 0 的span数比class1的要多，说明本线程中分配的小对象要多谢。- 2.3 central    - cache作为线程的私有资源为单个线程服务，而central则是全局资源，为多个线程服务，当某个线程内存不足时会向central申请，当某个线程释放内存时又会回收进central。    - src/runtime/mcentral.go:mcentral 定义了central数据结构：      type mcentral struct &#123;          lock      mutex     //互斥锁          spanclass spanClass // span class ID          nonempty  mSpanList // non-empty 指还有空闲块的span列表          empty     mSpanList // 指没有空闲块的span列表          nmalloc uint64      // 已累计分配的对象个数      &#125;        - lock: 线程间互斥锁，防止多线程读写冲突        - spanclass : 每个mcentral管理着一组有相同class的span列表        - nonempty: 指还有内存可用的span列表        - empty: 指没有内存可用的span列表        - nmalloc: 指累计分配的对象个数    - 线程从central获取span步骤如下：        - 加锁        - 从nonempty列表获取一个可用span，并将其从链表中删除        - 将取出的span放入empty链表        - 将span返回给线程        - 解锁        - 线程将该span缓存进cache    - 线程将span归还步骤如下：        - 加锁        - 将span从empty列表删除        - 将span加入noneempty列表        - 解锁    - 上述线程从central中获取span和归还span只是简单流程，为简单起见，并未对具体细节展开。- 2.4 heap    - 从mecntral数据结构可见，每个mcentral对象只管理特定的class规格的span，事实上每种class都会对应一个mcentral，这个mcentral的集合存放于mheap数据结构中。    - src/runtime/mheao.go:mheadp 定义了heap的数据结构：      type mheap struct &#123;          lock      mutex          spans []*mspan          bitmap        uintptr     //指向bitmap首地址，bitmap是从高地址向低地址增长的          arena_start uintptr        //指示arena区首地址          arena_used  uintptr        //指示arena区已使用地址位置          central [67*2]struct &#123;              mcentral mcentral              pad      [sys.CacheLineSize - unsafe.Sizeof(mcentral&#123;&#125;)%sys.CacheLineSize]byte          &#125;      &#125;        - lock： 互斥锁        - spans: 指向spans区域，用于映射span和page的关系        - bitmap：bitmap的起始地址        - arena_start: arena区域首地址        - arena_used: 当前arena已使用区域的最大地址        - central: 每种class对应的两个mcentral    - 从数据结构可见，mheap管理着全部的内存，事实上Golang就是通过一个mheap类型的全局变量进行内存管理的。    - mheap内存管理示意图如下：        - 系统预分配的内存分为spans、bitmap、arean三个区域，通过mheap管理起来。接下来看内存分配过程。</code></pre><ul><li><ol start="3"><li><p>内存分配过程</p><ul><li><p>针对待分配对象的大小不同有不同的分配逻辑：</p><ul><li>(0, 16B) 且不包含指针的对象： Tiny分配</li><li>(0, 16B) 包含指针的对象：正常分配</li><li>[16B, 32KB] : 正常分配</li><li>(32KB, -) : 大对象分配</li><li>其中Tiny分配和大对象分配都属于内存管理的优化范畴，这里暂时仅关注一般的分配方法。</li></ul></li><li><p>以申请size为n的内存为例，分配步骤如下：</p><p>获取当前线程的私有缓存mcache<br>根据size计算出适合的class的ID<br>从mcache的alloc[class]链表中查询可用的span<br>如果mcache没有可用的span则从mcentral申请一个新的span加入mcache中<br>如果mcentral中也没有可用的span则从mheap中申请一个新的span加入mcentral<br>从该span中获取到空闲对象地址并返回</p></li></ul></li></ol></li></ul><ul><li><ol start="4"><li><p>总结</p><ul><li><p>Golang内存分配是个相当复杂的过程，其中还掺杂了GC的处理，这里仅仅对其关键数据结构进行了说明，了解其原理而又不至于深陷实现细节。</p><p>Golang程序启动时申请一大块内存，并划分成spans、bitmap、arena区域<br>arena区域按页划分成一个个小块<br>span管理一个或多个页<br>mcentral管理多个span供线程申请使用<br>mcache作为线程私有资源，资源来源于mcentral</p></li></ul></li></ol></li></ul><h3 id="垃圾回收原理"><a href="#垃圾回收原理" class="headerlink" title="垃圾回收原理"></a>垃圾回收原理</h3><p>GC: Garbage Collection</p><ul><li><ol><li><p>前言</p><ul><li>所谓的垃圾就是不再需要的内存块，这些垃圾如果不及时清理就没法再次被分配使用，在不支持垃圾回收的编程语言里，这些垃圾内存就是泄露的内存。</li><li>Golang的垃圾回收（GC）也是内存管理的一部分，了解垃圾回收最好先了解前面介绍的内存分配原理。</li></ul></li></ol></li><li><ol start="2"><li>垃圾回收算法</li></ol><p>业界常见的垃圾回收算法有以下几种：</p></li></ul><pre><code>- 1. 引用计数：    - 概念：        - 对每个对象维护一个引用计数，当引用该对象的对象被销毁时，引用计数减1，当引用计数器为0时回收该对象。    - 优点：        - 对象可以很快地被回收，不会出现内存耗尽或达到某个阈值时才回收。    - 缺点：        - 不能很好地处理循环引用，而且实时维护引用计数，也有一定地代价。    - 代表语言：        - Python、PHP、Swift- 2. 标记-清除：    - 概念：        - 从根变量开始遍历所有引用的对象，引用的对象标记为“被引用”，没有被标记的进行回收。    - 优点：        - 解决了引用计数的缺点、    - 缺点：        - 需要STW，即要暂时停掉程序运行。    - 代表语言：        - Golang（其采用三色标记法）- 3. 分代收集：    - 概念：        - 按照对象生命周期长短划分不同的代空间，生命周期长的放入老年代，而短的放入新生代，不同代表有不同的回收算法和回收频率。    - 优点：        - 回收性能好    - 缺点：        - 算法复杂    - 代表语言：        - JAVA</code></pre><ul><li><ol start="3"><li><p>Golang垃圾回收</p><ul><li><p>3.1 垃圾回收原理</p><ul><li>简单的说，垃圾回收的核心就是标记出哪些内存还在使用中（即被引用到），哪些内存不再使用了（即未被引用），把未被引用的内存回收掉，以供后续内存分配时使用。</li><li>下图展示了一段内存，内存中既有已分配掉的内存，也有未分配的内存，垃圾回收的目标就是把那些已经分配的但没有对象引用的内存找出来并回收掉：</li><li>上图中，内存块1、2、4号位上的内存块已被分配（数字1代表已被分配，0 未分配）。变量a, b为一指针，指向内存的1、2号位。内存块的4号位曾经被使用过，但现在没有任何对象引用了，就需要被回收掉。</li><li>垃圾回收开始时从root对象开始扫描，把root对象引用的内存标记为”被引用”，考虑到内存块中存放的可能是指针，所以还需要递归的进行标记，全部标记完成后，只保留被标记的内存，未被标记的全部标识为未分配即完成了回收。</li></ul></li><li><p>3.2 内存标记（Mark）</p><ul><li>前面介绍内存分配时，介绍过span数据结构，span中维护了一个个内存块，并由一个位图allocBits表示每个内存块的分配情况。在span数据结构中还有另一个位图gcmarkBits用于标记内存块被引用情况。</li><li>如上图所示，allocBits记录了每块内存分配情况，而gcmarkBits记录了每块内存标记情况。标记阶段对每块内存进行标记，有对象引用的的内存标记为1(如图中灰色所示)，没有引用到的保持默认为0.</li><li>allocBits和gcmarkBits数据结构是完全一样的，标记结束就是内存回收，回收时将allocBits指向gcmarkBits，则代表标记过的才是存活的，gcmarkBits则会在下次标记时重新分配内存，非常的巧妙。</li></ul></li><li><p>3.3 三色标记法</p><ul><li><p>前面介绍了对象标记状态的存储方式，还需要有一个标记队列来存放待标记的对象，可以简单想象成把对象从标记队列中取出，将对象的引用状态标记在span的gcmarkBits，把对象引用到的其他对象再放入队列中。</p></li><li><p>三色只是为了叙述上方便抽象出来的一种说法，实际上对象并没有颜色之分。这里的三色，对应了垃圾回收过程中对象的三种状态：</p><ul><li>灰色：对象还在标记队列中等待</li><li>黑色：对象已被标记，gcmarkBits对应的位为1（该对象不会在本次GC中被清理）</li><li>白色：对象未被标记，gcmarkBits对应的位为0（该对象将会在本次GC中被清理）</li></ul></li><li><p>例如，当前内存中有A~F一共6个对象，根对象a,b本身为栈上分配的局部变量，根对象a、b分别引用了对象A、B, 而B对象又引用了对象D，则GC开始前各对象的状态如下图所示:</p><ul><li>初始状态下所有对象都是白色的。</li><li>接着开始扫描根对象a、b:</li><li>由于根对象引用了对象A、B,那么A、B变为灰色对象，接下来就开始分析灰色对象，分析A时，A没有引用其他对象很快就转入黑色，B引用了D，则B转入黑色的同时还需要将D转为灰色，进行接下来的分析。如下图所示：</li><li>上图中灰色对象只有D，由于D没有引用其他对象，所以D转入黑色。标记过程结束：</li><li>最终，黑色的对象会被保留下来，白色对象会被回收掉。</li></ul></li></ul></li><li><p>3.4 Stop The World</p><ul><li>印度电影《苏丹》中有句描述摔跤的一句台词是：“所谓摔跤，就是把对手控制住，然后摔倒他。”</li><li>对于垃圾回收来说，回收过程中也需要控制住内存的变化，否则回收过程中指针传递会引起内存引用关系变化，如果错误的回收了还在使用的内存，结果将是灾难性的。</li><li>Golang中的STW（Stop The World）就是停掉所有的goroutine，专心做垃圾回收，待垃圾回收结束后再恢复goroutine。</li><li>STW时间的长短直接影响了应用的执行，时间过长对于一些web应用来说是不可接受的，这也是广受诟病的原因之一。</li><li>为了缩短STW的时间，Golang不断优化垃圾回收算法，这种情况得到了很大的改善。</li></ul></li></ul></li></ol></li><li><ol start="4"><li><p>垃圾回收优化</p><ul><li><p>4.1 写屏障(Write Barrier)</p><ul><li>前面说过STW目的是防止GC扫描时内存变化而停掉goroutine，而写屏障就是让goroutine与GC同时运行的手段。虽然写屏障不能完全消除STW，但是可以大大减少STW的时间。</li><li>写屏障类似一种开关，在GC的特定时机开启，开启后指针传递时会把指针标记，即本轮不回收，下次GC时再确定。</li><li>GC过程中新分配的内存会被立即标记，用的并不是写屏障技术，也即GC过程中分配的内存不会在本轮GC中回收。</li></ul></li><li><p>4.2 辅助GC(Mutator Assist)</p><ul><li>为了防止内存分配过快，在GC执行过程中，如果goroutine需要分配内存，那么这个goroutine会参与一部分GC的工作，即帮助GC做一部分工作，这个机制叫作Mutator Assist。</li></ul></li></ul></li></ol></li><li><ol start="5"><li><p>垃圾回收触发时机</p><ul><li><p>5.1 内存分配量达到阈值触发GC</p><ul><li>每次内存分配时都会检查当前内存分配量是否已达到阈值，如果达到阀值则立即启动GC。</li><li>阈值 = 上次GC内存分配量 * 内存增长率</li><li>内存增长率由环境变量GOGC控制，默认为100，即每当内存扩大一倍时启动GC。</li></ul></li><li><p>5.2 定期触发GC</p><ul><li><p>默认情况下，最长2分钟触发一次GC，这个间隔在src/runtime/proc.go:forcegcperiod变量中被声明：</p><p>// forcegcperiod is the maximum time in nanoseconds between garbage<br>// collections. If we go this long without a garbage collection, one<br>// is forced to run.<br>//<br>// This is a variable for testing purposes. It normally doesn’t change.<br>var forcegcperiod int64 = 2 * 60 * 1e9</p></li></ul></li></ul></li></ol></li></ul><pre><code>- 5.3 手动触发    - 程序代码中也可以使用runtime.GC()来手动触发GC。这主要用于GC性能测试和统计。</code></pre><ul><li><ol start="6"><li><p>GC性能优化</p><ul><li>GC性能与对象数量负相关，对象越多GC性能越差，对程序影响越大。</li><li>所以GC性能优化的思路之一就是减少对象分配个数，比如对象复用或使用大对象组合多个小对象等等。</li><li>另外，由于内存逃逸现象，有些隐式的内存分配也会产生，也有可能成为GC的负担。</li><li>关于GC性能优化的具体方法，后面单独介绍。</li></ul></li></ol></li></ul><h3 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h3><ul><li><ol><li><p>前言</p><ul><li><p>所谓逃逸分析（Escape analysis）是指由编译器决定内存分配的位置，不需要程序员指定。</p></li><li><p>函数中申请一个新的对象</p><ul><li>如果分配在栈中，则函数执行结束可自动将内存回收；</li><li>如果分配在堆中，则函数执行结束可交给GC（垃圾回收）处理；</li></ul></li><li><p>有了逃逸分析，返回函数局部变量将变得可能，除此之外，逃逸分析还跟闭包息息相关，了解哪些场景下对象会逃逸至关重要。</p></li></ul></li></ol></li><li><ol start="2"><li><p>逃逸策略</p><ul><li><p>每当函数中申请新的对象，编译器会根据该对象是否被函数外部引用来决定是否逃逸：</p><ul><li>如果函数外部没有引用，则优先放到栈中；</li><li>如果函数外部存在引用，则必定放到堆中；</li></ul></li><li><p>注意，对于函数外部没有引用的对象，也有可能放到堆中，比如内存过大超过栈的存储能力。</p></li></ul></li></ol></li><li><ol start="3"><li><p>逃逸场景</p><ul><li><p>3.1 指针逃逸</p><ul><li><p>我们知道Go可以返回局部变量指针，这其实是一个典型的变量逃逸案例，示例代码如下：</p><p>package main</p><p>type Student struct {</p><pre><code>Name stringAge  int</code></pre><p>}</p><p>func StudentRegister(name string, age int) *Student {</p><pre><code>s := new(Student) //局部变量s逃逸到堆s.Name = names.Age = agereturn s</code></pre><p>}</p><p>func main() {</p><pre><code>StudentRegister(&quot;Jim&quot;, 18)</code></pre><p>}</p></li></ul></li></ul></li></ol></li></ul><pre><code>    - 函数StudentRegister()内部s为局部变量，其值通过函数返回值返回，s本身为一指针，其指向的内存地址不会是栈而是堆，这就是典型的逃逸案例。    - 通过编译参数-gcflag=-m可以查看编译过程中的逃逸分析：      D:\SourceCode\GoExpert\src&gt;go build -gcflags=-m      # _/D_/SourceCode/GoExpert/src      .\main.go:8: can inline StudentRegister      .\main.go:17: can inline main      .\main.go:18: inlining call to StudentRegister      .\main.go:8: leaking param: name      .\main.go:9: new(Student) escapes to heap      .\main.go:18: main new(Student) does not escape    - 可见在StudentRegister()函数中，也即代码第9行显示”escapes to heap”，代表该行内存分配发生了逃逸现象。- 3.2 栈空间不足逃逸    - 看下面的代码，是否会产生逃逸呢？      package main      func Slice() &#123;          s := make([]int, 1000, 1000)          for index, _ := range s &#123;              s[index] = index          &#125;      &#125;      func main() &#123;          Slice()      &#125;    - 上面代码Slice()函数中分配了一个1000个长度的切片，是否逃逸取决于栈空间是否足够大。    - 直接查看编译提示，如下：      D:\SourceCode\GoExpert\src&gt;go build -gcflags=-m      # _/D_/SourceCode/GoExpert/src      .\main.go:4: Slice make([]int, 1000, 1000) does not escape    - 我们发现此处并没有发生逃逸。那么把切片长度扩大10倍即10000会如何呢?      D:\SourceCode\GoExpert\src&gt;go build -gcflags=-m      # _/D_/SourceCode/GoExpert/src      .\main.go:4: make([]int, 10000, 10000) escapes to heap    - 我们发现当切片长度扩大到10000时就会逃逸。    - 实际上当栈空间不足以存放当前对象时或无法判断当前切片长度时会将对象分配到堆中。- 3.3 动态类型逃逸    - 很多函数参数为interface类型，比如fmt.Println(a …interface&#123;&#125;)，编译期间很难确定其参数的具体类型，也会产生逃逸。    - 如下代码所示：      package main      import &quot;fmt&quot;      func main() &#123;          s := &quot;Escape&quot;          fmt.Println(s)      &#125;    - 上述代码s变量只是一个string类型变量，调用fmt.Println()时会产生逃逸：      D:\SourceCode\GoExpert\src&gt;go build -gcflags=-m      # _/D_/SourceCode/GoExpert/src      .\main.go:7: s escapes to heap      .\main.go:7: main ... argument does not escape- 3.4 闭包引用对象逃逸    - 某著名的开源框架实现了某个返回Fibonacci数列的函数：      func Fibonacci() func() int &#123;          a, b := 0, 1          return func() int &#123;              a, b = b, a+b              return a          &#125;      &#125;    - 该函数返回一个闭包，闭包引用了函数的局部变量a和b，使用时通过该函数获取该闭包，然后每次执行闭包都会依次输出Fibonacci数列。    - 完整的示例程序如下所示：      package main      import &quot;fmt&quot;      func Fibonacci() func() int &#123;          a, b := 0, 1          return func() int &#123;              a, b = b, a+b              return a          &#125;      &#125;      func main() &#123;          f := Fibonacci()          for i := 0; i &lt; 10; i++ &#123;              fmt.Printf(&quot;Fibonacci: %d\n&quot;, f())          &#125;      &#125;    - 上述代码通过Fibonacci()获取一个闭包，每次执行闭包就会打印一个Fibonacci数值。输出如下所示：      D:\SourceCode\GoExpert\src&gt;src.exe      Fibonacci: 1      Fibonacci: 1      Fibonacci: 2      Fibonacci: 3      Fibonacci: 5      Fibonacci: 8      Fibonacci: 13      Fibonacci: 21      Fibonacci: 34      Fibonacci: 55    - Fibonacci()函数中原本属于局部变量的a和b由于闭包的引用，不得不将二者放到堆上，以致产生逃逸：      D:\SourceCode\GoExpert\src&gt;go build -gcflags=-m      # _/D_/SourceCode/GoExpert/src      .\main.go:7: can inline Fibonacci.func1      .\main.go:7: func literal escapes to heap      .\main.go:7: func literal escapes to heap      .\main.go:8: &amp;a escapes to heap      .\main.go:6: moved to heap: a      .\main.go:8: &amp;b escapes to heap      .\main.go:6: moved to heap: b      .\main.go:17: f() escapes to heap      .\main.go:17: main ... argument does not escape</code></pre><ul><li><ol start="4"><li><p>逃逸总结</p><ul><li>栈上分配内存比在堆中分配内存有更高的效率</li><li>栈上分配的内存不需要GC处理</li><li>堆上分配的内存使用完毕会交给GC处理</li><li>逃逸分析目的是决定内分配地址是栈还是堆</li><li>逃逸分析在编译阶段完成</li></ul></li></ol></li><li><ol start="5"><li><p>编程Tips</p><ul><li>思考一下这个问题：函数传递指针真的比传值效率高吗？</li><li>我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加GC的负担，所以传递指针不一定是高效的。</li></ul></li></ol></li></ul><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><p>本章主要介绍GO语言开发过程中经常使用的并发控制手段。</p><p>我们考虑这么一种场景，协程A执行过程中需要创建子协程A1、A2、A3…An，协程A创建完子协程后就等待子协程退出。<br>针对这种场景，GO提供了三种解决方案：</p><p>Channel: 使用channel控制子协程<br>WaitGroup : 使用信号量机制控制子协程<br>Context: 使用上下文控制子协程<br>三种方案各有优劣，比如Channel优点是实现简单，清晰易懂，WaitGroup优点是子协程个数动态可调整，Context优点是对子协程派生出来的孙子协程的控制。<br>缺点是相对而言的，要结合实例应用场景进行选择。</p><h3 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h3><ul><li><ol><li><p>前言</p><ul><li>channel一般用于协程之间的通信，channel也可以用于并发控制。比如主协程启动N个子协程，主协程等待所有子协程退出后再继续后续流程，这种场景下channel也可轻易实现。</li></ul></li></ol></li><li><ol start="2"><li><p>场景示例</p><ul><li><p>下面程序展示一个使用channel控制子协程的例子：</p><p>package main</p><p>import (<br>   “time”<br>   “fmt”<br>)</p><p>func Process(ch chan int) {<br>   //Do some work…<br>   time.Sleep(time.Second)</p><p>   ch &lt;- 1 //管道中写入一个元素表示当前协程已结束<br>}</p><p>func main() {<br>   channels := make([]chan int, 10) //创建一个10个元素的切片，元素类型为channel</p><p>   for i:= 0; i &lt; 10; i++ {</p><pre><code>   channels[i] = make(chan int) //切片中放入一个channel   go Process(channels[i])      //启动协程，传一个管道用于通信</code></pre><p>   }</p><p>   for i, ch := range channels {  //遍历切片，等待子协程结束</p><pre><code>   &lt;-ch   fmt.Println(&quot;Routine &quot;, i, &quot; quit!&quot;)</code></pre><p>   }<br>}</p></li></ul></li></ol></li></ul><pre><code>- 上面程序通过创建N个channel来管理N个协程，每个协程都有一个channel用于跟父协程通信，父协程创建完所有协程后等待所有协程结束。- 这个例子中，父协程仅仅是等待子协程结束，其实父协程也可以向管道中写入数据通知子协程结束，这时子协程需要定期地探测管道中是否有消息出现。</code></pre><ul><li><ol start="3"><li><p>总结</p><ul><li>使用channel来控制子协程的优点是实现简单，缺点是当需要大量创建协程时就需要有相同数量的channel，而且对于子协程继续派生出来的协程不方便控制。</li><li>后面继续介绍的WaitGroup、Context看起来比channel优雅一些，在各种开源组件中使用频率比channel高得多。</li></ul></li></ol></li></ul><h3 id="WaitGroup"><a href="#WaitGroup" class="headerlink" title="WaitGroup"></a>WaitGroup</h3><ul><li><ol><li><p>前言</p><ul><li><p>WaitGroup是Golang应用开发过程中经常使用的并发控制技术。</p></li><li><p>WaitGroup，可理解为Wait-Goroutine-Group，即等待一组goroutine结束。比如某个goroutine需要等待其他几个goroutine全部完成，那么使用WaitGroup可以轻松实现。</p></li><li><p>下面程序展示了一个goroutine等待另外两个goroutine结束的例子：</p><p>package main</p><p>import (<br>   “fmt”<br>   “time”<br>   “sync”<br>)</p><p>func main() {<br>   var wg sync.WaitGroup</p><p>   wg.Add(2) //设置计数器，数值即为goroutine的个数<br>   go func() {</p><pre><code>   //Do some work   time.Sleep(1*time.Second)   fmt.Println(&quot;Goroutine 1 finished!&quot;)   wg.Done() //goroutine执行结束后将计数器减1</code></pre><p>   }()</p><p>   go func() {</p><pre><code>   //Do some work   time.Sleep(2*time.Second)   fmt.Println(&quot;Goroutine 2 finished!&quot;)   wg.Done() //goroutine执行结束后将计数器减1</code></pre><p>   }()</p><p>   wg.Wait() //主goroutine阻塞等待计数器变为0<br>   fmt.Printf(“All Goroutine finished!”)<br>}</p></li></ul></li></ol></li></ul><pre><code>- 简单的说，上面程序中wg内部维护了一个计数器：    - 启动goroutine前将计数器通过Add(2)将计数器设置为待启动的goroutine个数。    - 启动goroutine后，使用Wait()方法阻塞自己，等待计数器变为0。    - 每个goroutine执行结束通过Done()方法将计数器减1。    - 计数器变为0后，阻塞的goroutine被唤醒。- 其实WaitGroup也可以实现一组goroutine等待另一组goroutine，这有点像玩杂技，很容出错，如果不了解其实现原理更是如此。实际上，WaitGroup的实现源码非常简单。</code></pre><ul><li><ol start="2"><li><p>基础知识</p><ul><li><p>2.1 信号量</p><ul><li><p>信号量是Unix系统提供的一种保护共享资源的机制，用于防止多个线程同时访问某个资源。</p></li><li><p>可简单理解为信号量为一个数值：</p><ul><li>当信号量&gt;0时，表示资源可用，获取信号量时系统自动将信号量减1；</li><li>当信号量==0时，表示资源暂不可用，获取信号量时，当前线程会进入睡眠，当信号量为正时被唤醒；</li></ul></li><li><p>由于WaitGroup实现中也使用了信号量，在此做个简单介绍。</p></li></ul></li></ul></li></ol></li><li><ol start="3"><li><p>WaitGroup</p><ul><li><p>3.1 数据结构</p><ul><li><p>源码包中src/sync/waitgroup.go:WaitGroup定义了其数据结构：</p><p>type WaitGroup struct {</p><pre><code>state1 [3]uint32</code></pre><p>}</p></li></ul></li></ul></li></ol></li></ul><pre><code>    - state1是个长度为3的数组，其中包含了state和一个信号量，而state实际上是两个计数器：        - counter： 当前还未执行结束的goroutine计数器        - waiter count: 等待goroutine-group结束的goroutine数量，即有多少个等候者        - semaphore: 信号量    - 考虑到字节是否对齐，三者出现的位置不同，为简单起见，依照字节已对齐情况下，三者在内存中的位置如下所示：    - WaitGroup对外提供三个接口：        - Add(delta int): 将delta值加到counter中        - Wait()： waiter递增1，并阻塞等待信号量semaphore        - Done()： counter递减1，按照waiter数值释放相应次数信号量    - 下面分别介绍这三个函数的实现细节。- 3.2 Add(delta int)    - Add()做了两件事，一是把delta值累加到counter中，因为delta可以为负值，也就是说counter有可能变成0或负值，所以第二件事就是当counter值变为0时，根据waiter数值释放等量的信号量，把等待的goroutine全部唤醒，如果counter变为负值，则panic.    - Add()伪代码如下：      func (wg *WaitGroup) Add(delta int) &#123;          statep, semap := wg.state() //获取state和semaphore地址指针          state := atomic.AddUint64(statep, uint64(delta)&lt;&lt;32) //把delta左移32位累加到state，即累加到counter中          v := int32(state &gt;&gt; 32) //获取counter值          w := uint32(state)      //获取waiter值          if v &lt; 0 &#123;              //经过累加后counter值变为负值，panic              panic(&quot;sync: negative WaitGroup counter&quot;)          &#125;          //经过累加后，此时，counter &gt;= 0          //如果counter为正，说明不需要释放信号量，直接退出          //如果waiter为零，说明没有等待者，也不需要释放信号量，直接退出          if v &gt; 0 || w == 0 &#123;              return          &#125;          //此时，counter一定等于0，而waiter一定大于0（内部维护waiter，不会出现小于0的情况），          //先把counter置为0，再释放waiter个数的信号量          *statep = 0          for ; w != 0; w-- &#123;              runtime_Semrelease(semap, false) //释放信号量，执行一次释放一个，唤醒一个等待者          &#125;      &#125;      3.3 Wait()- 3.3 Wait()    - Wait()方法也做了两件事，一是累加waiter, 二是阻塞等待信号量      func (wg *WaitGroup) Wait() &#123;          statep, semap := wg.state() //获取state和semaphore地址指针          for &#123;              state := atomic.LoadUint64(statep) //获取state值              v := int32(state &gt;&gt; 32)            //获取counter值              w := uint32(state)                 //获取waiter值              if v == 0 &#123;                        //如果counter值为0，说明所有goroutine都退出了，不需要待待，直接返回                  return              &#125;              // 使用CAS（比较交换算法）累加waiter，累加可能会失败，失败后通过for loop下次重试              if atomic.CompareAndSwapUint64(statep, state, state+1) &#123;                  runtime_Semacquire(semap) //累加成功后，等待信号量唤醒自己                  return              &#125;          &#125;      &#125;    - 这里用到了CAS算法保证有多个goroutine同时执行Wait()时也能正确累加waiter。- 3.4 Done()    - Done()只做一件事，即把counter减1，我们知道Add()可以接受负值，所以Done实际上只是调用了Add(-1)。    - 源码如下：      func (wg *WaitGroup) Done() &#123;          wg.Add(-1)      &#125;    - Done()的执行逻辑就转到了Add()，实际上也正是最后一个完成的goroutine把等待者唤醒的。</code></pre><ul><li><ol start="4"><li><p>小结</p><ul><li><p>简单说来，WaitGroup通常用于等待一组“工作协程”结束的场景，其内部维护两个计数器，这里把它们称为“工作协程”计数器和“坐等协程”计数器，WaitGroup对外提供的三个方法分工非常明确：</p><ul><li>Add(delta int)方法用于增加“工作协程”计数，通常在启动新的“工作协程”之前调用；</li><li>Done()方法用于减少“工作协程”计数，每次调用递减1，通常在“工作协程”内部且在临近返回之前调用；</li><li>Wait()方法用于增加“坐等协程”计数，通常在所有”工作协程”全部启动之后调用；</li></ul></li><li><p>Done()方法除了负责递减“工作协程”计数以外，还会在“工作协程”计数变为0时检查“坐等协程”计数器并把“坐等协程”唤醒。</p></li><li><p>需要注意的是，Done()方法递减“工作协程”计数后，如果“工作协程”计数变成负数时，将会触发panic，这就要求Add()方法调用要早于Done()方法。</p></li><li><p>此外，通过Add()方法累加的“工作协程”计数要与实际需要等待的“工作协程”数量一致，否则也会触发panic。</p></li><li><p>当“工作协程”计数多于实际需要等待的“工作协程”数量时，“坐等协程”可能会永远无法被唤醒而产生列锁，此时，Go运行时检测到死锁会触发panic,</p></li><li><p>当“工作协程”计数小于实际需要等待的“工作协程”数量时，Done()会在“工作协程”计数变为负数时触发panic。</p></li></ul></li></ol></li></ul><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><ul><li><ol><li><p>前言</p><ul><li>Golang context是Golang应用开发常用的并发控制技术，它与WaitGroup最大的不同点是context对于派生goroutine有更强的控制力，它可以控制多级的goroutine。</li><li>context翻译成中文是”上下文”，即它可以控制一组呈树状结构的goroutine，每个goroutine拥有相同的上下文。</li><li>典型的使用场景如下图所示：</li><li>上图中由于goroutine派生出子goroutine，而子goroutine又继续派生新的goroutine，这种情况下使用WaitGroup就不太容易，因为子goroutine个数不容易确定。而使用context就可以很容易实现。</li></ul></li></ol></li><li><ol start="2"><li>Context实现原理</li></ol><p>context实际上只定义了接口，凡是实现该接口的类都可称为是一种context，官方包中实现了几个常用的context，分别可用于不同的场景。</p></li></ul><pre><code>- 2.1 接口定义  源码包中src/context/context.go:Context 定义了该接口：  type Context interface &#123;      Deadline() (deadline time.Time, ok bool)      Done() &lt;-chan struct&#123;&#125;      Err() error      Value(key interface&#123;&#125;) interface&#123;&#125;  &#125;  基础的context接口只定义了4个方法，下面分别简要说明一下：    - 2.1.1 Deadline()        - 该方法返回一个deadline和标识是否已设置deadline的bool值，如果没有设置deadline，则ok == false，此时deadline为一个初始值的time.Time值    - 2.1.2 Done()        - 该方法返回一个channel，需要在select-case语句中使用，如”case &lt;-context.Done():”。        - 当context关闭后，Done()返回一个被关闭的管道，关闭的管道仍然是可读的，据此goroutine可以收到关闭请求；        - 当context还未关闭时，Done()返回nil。    - 2.1.3 Err()        - 该方法描述context关闭的原因。关闭原因由context实现控制，不需要用户设置。比如Deadline context，关闭原因可能是因为deadline，也可能提前被主动关闭，那么关闭原因就会不同:            - 因deadline关闭：“context deadline exceeded”；            - 因主动关闭： “context canceled”。        - 当context关闭后，Err()返回context的关闭原因；        - 当context还未关闭时，Err()返回nil；    - 2.1.4 Value()        - 有一种context，它不是用于控制呈树状分布的goroutine，而是用于在树状分布的goroutine间传递信息。        - Value()方法就是用于此种类型的context，该方法根据key值查询map中的value。具体使用后面示例说明。- 2.2 空context    - context包中定义了一个空的context， 名为emptyCtx，用于context的根节点，空的context只是简单的实现了Context，本身不包含任何值，仅用于其他context的父节点。    - emptyCtx类型定义如下代码所示：      type emptyCtx int      func (*emptyCtx) Deadline() (deadline time.Time, ok bool) &#123;          return      &#125;      func (*emptyCtx) Done() &lt;-chan struct&#123;&#125; &#123;          return nil      &#125;      func (*emptyCtx) Err() error &#123;          return nil      &#125;      func (*emptyCtx) Value(key interface&#123;&#125;) interface&#123;&#125; &#123;          return nil      &#125;    - context包中定义了一个公用的emptCtx全局变量，名为background，可以使用context.Background()获取它，实现代码如下所示：      var background = new(emptyCtx)      func Background() Context &#123;          return background      &#125;    - context包提供了4个方法创建不同类型的context，使用这四个方法时如果没有父context，都需要传入backgroud，即backgroud作为其父节点：        - WithCancel()        - WithDeadline()        - WithTimeout()        - WithValue()    - context包中实现Context接口的struct，除了emptyCtx外，还有cancelCtx、timerCtx和valueCtx三种，正是基于这三种context实例，实现了上述4种类型的context。    - context包中各context类型之间的关系，如下图所示：    - struct cancelCtx、timerCtx、valueCtx都继承于Context，下面分别介绍这三个struct。- 2.3 cancelCtx  源码包中src/context/context.go:cancelCtx 定义了该类型context：  type cancelCtx struct &#123;      Context      mu       sync.Mutex            // protects following fields      done     chan struct&#123;&#125;         // created lazily, closed by first cancel call      children map[canceler]struct&#123;&#125; // set to nil by the first cancel call      err      error                 // set to non-nil by the first cancel call  &#125;  children中记录了由此context派生的所有child，此context被cancel时会把其中的所有child都cancel掉。  cancelCtx与deadline和value无关，所以只需要实现Done()和Err()外露接口即可。    - 2.3.1 Done()接口实现        - 按照Context定义，Done()接口只需要返回一个channel即可，对于cancelCtx来说只需要返回成员变量done即可。        - 这里直接看下源码，非常简单：          func (c *cancelCtx) Done() &lt;-chan struct&#123;&#125; &#123;              c.mu.Lock()              if c.done == nil &#123;                  c.done = make(chan struct&#123;&#125;)              &#125;              d := c.done              c.mu.Unlock()              return d          &#125;        - 由于cancelCtx没有指定初始化函数，所以cancelCtx.done可能还未分配，所以需要考虑初始化。        - cancelCtx.done会在context被cancel时关闭，所以cancelCtx.done的值一般经历如下三个阶段：nil –&gt; chan struct&#123;&#125; –&gt; closed chan。    - 2.3.2 Err()接口实现        - 按照Context定义，Err()只需要返回一个error告知context被关闭的原因。对于cancelCtx来说只需要返回成员变量err即可。        - 还是直接看下源码：          func (c *cancelCtx) Err() error &#123;              c.mu.Lock()              err := c.err              c.mu.Unlock()              return err          &#125;        - cancelCtx.err默认是nil，在context被cancel时指定一个error变量： var Canceled = errors.New(&quot;context canceled&quot;)。    - 2.3.3 cancel()接口实现        - cancel()内部方法是理解cancelCtx的最关键的方法，其作用是关闭自己和其后代，其后代存储在cancelCtx.children的map中，其中key值即后代对象，value值并没有意义，这里使用map只是为了方便查询而已。        - cancel方法实现伪代码如下所示：          func (c *cancelCtx) cancel(removeFromParent bool, err error) &#123;              c.mu.Lock()              c.err = err                          //设置一个error，说明关闭原因              close(c.done)                     //将channel关闭，以此通知派生的context              for child := range c.children &#123;   //遍历所有children，逐个调用cancel方法                  child.cancel(false, err)              &#125;              c.children = nil              c.mu.Unlock()              if removeFromParent &#123;            //正常情况下，需要将自己从parent删除                  removeChild(c.Context, c)              &#125;          &#125;        - 实际上，WithCancel()返回的第二个用于cancel context的方法正是此cancel()。    - 2.3.4 WithCancel()方法实现        - WithCancel()方法作了三件事：            - 初始化一个cancelCtx实例            - 将cancelCtx实例添加到其父节点的children中(如果父节点也可以被cancel的话)            - 返回cancelCtx实例和cancel()方法        - 其实现源码如下所示：          func WithCancel(parent Context) (ctx Context, cancel CancelFunc) &#123;              c := newCancelCtx(parent)              propagateCancel(parent, &amp;c)   //将自身添加到父节点              return &amp;c, func() &#123; c.cancel(true, Canceled) &#125;          &#125;        - 这里将自身添加到父节点的过程有必要简单说明一下：            - 如果父节点也支持cancel，也就是说其父节点肯定有children成员，那么把新context添加到children里即可；            - 如果父节点不支持cancel，就继续向上查询，直到找到一个支持cancel的节点，把新context添加到children里；            - 如果所有的父节点均不支持cancel，则启动一个协程等待父节点结束，然后再把当前context结束。    - 2.3.5 典型使用案例        - 一个典型的使用cancel context的例子如下所示：          package main          import (              &quot;fmt&quot;              &quot;time&quot;              &quot;context&quot;          )          func HandelRequest(ctx context.Context) &#123;              go WriteRedis(ctx)              go WriteDatabase(ctx)              for &#123;                  select &#123;                  case &lt;-ctx.Done():                      fmt.Println(&quot;HandelRequest Done.&quot;)                      return                  default:                      fmt.Println(&quot;HandelRequest running&quot;)                      time.Sleep(2 * time.Second)                  &#125;              &#125;          &#125;          func WriteRedis(ctx context.Context) &#123;              for &#123;                  select &#123;                  case &lt;-ctx.Done():                      fmt.Println(&quot;WriteRedis Done.&quot;)                      return                  default:                      fmt.Println(&quot;WriteRedis running&quot;)                      time.Sleep(2 * time.Second)                  &#125;              &#125;          &#125;          func WriteDatabase(ctx context.Context) &#123;              for &#123;                  select &#123;                  case &lt;-ctx.Done():                      fmt.Println(&quot;WriteDatabase Done.&quot;)                      return                  default:                      fmt.Println(&quot;WriteDatabase running&quot;)                      time.Sleep(2 * time.Second)                  &#125;              &#125;          &#125;          func main() &#123;              ctx, cancel := context.WithCancel(context.Background())              go HandelRequest(ctx)              time.Sleep(5 * time.Second)              fmt.Println(&quot;It&#39;s time to stop all sub goroutines!&quot;)              cancel()              //Just for test whether sub goroutines exit or not              time.Sleep(5 * time.Second)          &#125;        - 上面代码中协程HandelRequest()用于处理某个请求，其又会创建两个协程：WriteRedis()、WriteDatabase()，main协程创建context，并把context在各子协程间传递，main协程在适当的时机可以cancel掉所有子协程。        - 程序输出如下所示：          HandelRequest running          WriteDatabase running          WriteRedis running          HandelRequest running          WriteDatabase running          WriteRedis running          HandelRequest running          WriteDatabase running          WriteRedis running          It&#39;s time to stop all sub goroutines!          WriteDatabase Done.          HandelRequest Done.          WriteRedis Done.- 2.4 timerCtx  源码包中src/context/context.go:timerCtx 定义了该类型context：  type timerCtx struct &#123;      cancelCtx      timer *time.Timer // Under cancelCtx.mu.      deadline time.Time  &#125;  timerCtx在cancelCtx基础上增加了deadline用于标示自动cancel的最终时间，而timer就是一个触发自动cancel的定时器。  由此，衍生出WithDeadline()和WithTimeout()。实现上这两种类型实现原理一样，只不过使用语境不一样：  deadline: 指定最后期限，比如context将2018.10.20 00:00:00之时自动结束  timeout: 指定最长存活时间，比如context将在30s后结束。  对于接口来说，timerCtx在cancelCtx基础上还需要实现Deadline()和cancel()方法，其中cancel()方法是重写的。    - 2.4.1 Deadline()接口实现        - Deadline()方法仅仅是返回timerCtx.deadline而矣。而timerCtx.deadline是WithDeadline()或WithTimeout()方法设置的。    - 2.4.2 cancel()接口实现        - cancel()方法基本继承cancelCtx，只需要额外把timer关闭。        - timerCtx被关闭后，timerCtx.cancelCtx.err将会存储关闭原因：            - 如果deadline到来之前手动关闭，则关闭原因与cancelCtx显示一致；            - 如果deadline到来时自动关闭，则原因为：”context deadline exceeded”    - 2.4.3 WithDeadline()方法实现        - WithDeadline()方法实现步骤如下：            - 初始化一个timerCtx实例            - 将timerCtx实例添加到其父节点的children中(如果父节点也可以被cancel的话)            - 启动定时器，定时器到期后会自动cancel本context            - 返回timerCtx实例和cancel()方法        - 也就是说，timerCtx类型的context不仅支持手动cancel，也会在定时器到来后自动cancel。    - 2.4.4 WithTimeout()方法实现        - WithTimeout()实际调用了WithDeadline，二者实现原理一致。        - 看代码会非常清晰：          func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) &#123;              return WithDeadline(parent, time.Now().Add(timeout))          &#125;    - 2.4.5 典型使用案例        - 下面例子中使用WithTimeout()获得一个context并在其子协程中传递：          package main          import (              &quot;fmt&quot;              &quot;time&quot;              &quot;context&quot;          )          func HandelRequest(ctx context.Context) &#123;              go WriteRedis(ctx)              go WriteDatabase(ctx)              for &#123;                  select &#123;                  case &lt;-ctx.Done():                      fmt.Println(&quot;HandelRequest Done.&quot;)                      return                  default:                      fmt.Println(&quot;HandelRequest running&quot;)                      time.Sleep(2 * time.Second)                  &#125;              &#125;          &#125;          func WriteRedis(ctx context.Context) &#123;              for &#123;                  select &#123;                  case &lt;-ctx.Done():                      fmt.Println(&quot;WriteRedis Done.&quot;)                      return                  default:                      fmt.Println(&quot;WriteRedis running&quot;)                      time.Sleep(2 * time.Second)                  &#125;              &#125;          &#125;          func WriteDatabase(ctx context.Context) &#123;              for &#123;                  select &#123;                  case &lt;-ctx.Done():                      fmt.Println(&quot;WriteDatabase Done.&quot;)                      return                  default:                      fmt.Println(&quot;WriteDatabase running&quot;)                      time.Sleep(2 * time.Second)                  &#125;              &#125;          &#125;          func main() &#123;              ctx, _ := context.WithTimeout(context.Background(), 5 * time.Second)              go HandelRequest(ctx)              time.Sleep(10 * time.Second)          &#125;        - 主协程中创建一个10s超时的context，并将其传递给子协程，10s自动关闭context。程序输出如下：          HandelRequest running          WriteRedis running          WriteDatabase running          HandelRequest running          WriteRedis running          WriteDatabase running          HandelRequest running          WriteRedis running          WriteDatabase running          HandelRequest Done.          WriteDatabase Done.          WriteRedis Done.- 2.5 valueCtx  源码包中src/context/context.go:valueCtx 定义了该类型context：  type valueCtx struct &#123;      Context      key, val interface&#123;&#125;  &#125;  valueCtx只是在Context基础上增加了一个key-value对，用于在各级协程间传递一些数据。  由于valueCtx既不需要cancel，也不需要deadline，那么只需要实现Value()接口即可。    - 2.5.1 Value（）接口实现      由valueCtx数据结构定义可见，valueCtx.key和valueCtx.val分别代表其key和value值。 实现也很简单：      func (c *valueCtx) Value(key interface&#123;&#125;) interface&#123;&#125; &#123;          if c.key == key &#123;              return c.val          &#125;          return c.Context.Value(key)      &#125;      这里有个细节需要关注一下，即当前context查找不到key时，会向父节点查找，如果查询不到则最终返回interface&#123;&#125;。也就是说，可以通过子context查询到父的value值。    - 2.5.2 WithValue（）方法实现      WithValue()实现也是非常的简单, 伪代码如下：      func WithValue(parent Context, key, val interface&#123;&#125;) Context &#123;          if key == nil &#123;              panic(&quot;nil key&quot;)          &#125;          return &amp;valueCtx&#123;parent, key, val&#125;      &#125;</code></pre><ul><li><p>2.5.3 典型使用案例</p><p>下面示例程序展示valueCtx的用法：</p><pre><code>    package main    import (        &quot;fmt&quot;        &quot;time&quot;        &quot;context&quot;    )    func HandelRequest(ctx context.Context) &#123;        for &#123;            select &#123;            case &lt;-ctx.Done():                fmt.Println(&quot;HandelRequest Done.&quot;)                return            default:                fmt.Println(&quot;HandelRequest running, parameter: &quot;, ctx.Value(&quot;parameter&quot;))                time.Sleep(2 * time.Second)            &#125;        &#125;    &#125;    func main() &#123;        ctx := context.WithValue(context.Background(), &quot;parameter&quot;, &quot;1&quot;)        go HandelRequest(ctx)        time.Sleep(10 * time.Second)    &#125;    上例main()中通过WithValue()方法获得一个context，需要指定一个父context、key和value。然后通将该context传递给子协程HandelRequest，子协程可以读取到context的key-value。    注意：本例中子协程无法自动结束，因为context是不支持cancle的，也就是说&lt;-ctx.Done()永远无法返回。如果需要返回，需要在创建context时指定一个可以cancel的context作为父节点，使用父节点的cancel()在适当的时机结束整个context。</code></pre></li></ul><pre><code>​      </code></pre><ul><li><ol start="3"><li><p>总结</p><ul><li>Context仅仅是一个接口定义，根据实现的不同，可以衍生出不同的context类型；</li><li>cancelCtx实现了Context接口，通过WithCancel()创建cancelCtx实例；</li><li>timerCtx实现了Context接口，通过WithDeadline()和WithTimeout()创建timerCtx实例；</li><li>valueCtx实现了Context接口，通过WithValue()创建valueCtx实例；</li><li>三种context实例可互为父节点，从而可以组合成不同的应用形式；</li></ul></li></ol></li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><p>本章主要介绍GO语言反射机制。</p><h3 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h3><ul><li><ol><li><p>前言</p><ul><li>个人觉得，反射讲得最透彻的还是官方博客。官方博客略显晦涩，多读几遍就慢慢理解了。</li><li>本文既是学习笔记，也是总结。</li><li>官方博客地址：<a href="https://blog.golang.org/laws-of-reflection">https://blog.golang.org/laws-of-reflection</a></li></ul></li></ol></li><li><ol start="2"><li>反射概念</li></ol><p>官方对此有个非常简明的介绍，两句话耐人寻味：</p><p>反射提供一种让程序检查自身结构的能力<br>反射是困惑的源泉<br>第1条，再精确点的描述是“反射是一种检查interface变量的底层类型和值的机制”。<br>第2条，很有喜感的自嘲，不过往后看就笑不出来了，因为你很可能产生困惑.</p><p>想深入了解反射，必须深入理解类型和接口概念。下面开始复习一下这些基础概念。</p></li></ul><pre><code>- 2.1 关于静态类型    - 你肯定知道Go是静态类型语言，比如”int”、”float32”、”[]byte”等等。每个变量都有一个静态类型，且在编译时就确定了。    - 那么考虑一下如下一种类型声明:      type Myint int      var i int      var j Myint    - Q: i 和j 类型相同吗？    - A：i 和j类型是不同的。 二者拥有不同的静态类型，没有类型转换的话是不可以互相赋值的，尽管二者底层类型是一样的。- 2.2 特殊的静态类型interface    - interface类型是一种特殊的类型，它代表方法集合。 它可以存放任何实现了其方法的值。    - 经常被拿来举例的是io包里的这两个接口类型：      // Reader is the interface that wraps the basic Read method.      type Reader interface &#123;          Read(p []byte) (n int, err error)      &#125;      // Writer is the interface that wraps the basic Write method.      type Writer interface &#123;          Write(p []byte) (n int, err error)      &#125;    - 任何类型，比如某struct，只要实现了其中的Read()方法就被认为是实现了Reader接口，只要实现了Write()方法，就被认为是实现了Writer接口，不过方法参数和返回值要跟接口声明的一致。    - 接口类型的变量可以存储任何实现该接口的值。- 2.3 特殊的interface类型    - 最特殊的interface类型为空interface类型，即interface &#123;&#125;，前面说了，interface用来表示一组方法集合，所有实现该方法集合的类型都被认为是实现了该接口。那么空interface类型的方法集合为空，也就是说所有类型都可以认为是实现了该接口。    - 一个类型实现空interface并不重要，重要的是一个空interface类型变量可以存放所有值，记住是所有值，这才是最最重要的。 这也是有些人认为Go是动态类型的原因，这是个错觉。- 2.4 interface类型是如何表示的    - 前面讲了，interface类型的变量可以存放任何实现了该接口的值。还是以上面的io.Reader为例进行说明，io.Reader是一个接口类型，os.OpenFile()方法返回一个File结构体类型变量，该结构体类型实现了io.Reader的方法，那么io.Reader类型变量就可以用来接收该返回值。如下所示：      var r io.Reader      tty, err := os.OpenFile(&quot;/dev/tty&quot;, os.O_RDWR, 0)      if err != nil &#123;          return nil, err      &#125;      r = tty    - 那么问题来了。        - Q:  r的类型是什么？        - A: r的类型始终是io.Readerinterface类型，无论其存储什么值。        - Q：那File类型体现在哪里？        - A：r保存了一个(value, type)对来表示其所存储值的信息。 value即为r所持有元素的值，type即为所持有元素的底层类型        - Q：如何将r转换成另一个类型结构体变量？比如转换成io.Writer        - A：使用类型断言，如w = r.(io.Writer). 意思是如果r所持有的元素如果同样实现了io.Writer接口,那么就把值传递给w。</code></pre><ul><li><ol start="3"><li>反射三定律</li></ol><p>前面之所以讲类型，是为了引出interface，之所以讲interface是想说interface类型有个(value，type)对，而反射就是检查interface的这个(value, type)对的。具体一点说就是Go提供一组方法提取interface的value，提供另一组方法提取interface的type.</p><p>官方提供了三条定律来说明反射，比较清晰，下面也按照这三定律来总结。</p><p>反射包里有两个接口类型要先了解一下.</p><p>reflect.Type 提供一组接口处理interface的类型，即（value, type）中的type<br>reflect.Value提供一组接口处理interface的值,即(value, type)中的value<br>下面会提到反射对象，所谓反射对象即反射包里提供的两种类型的对象。</p><p>reflect.Type 类型对象<br>reflect.Value类型对象</p></li></ul><pre><code>- 3.1 反射第一定律：反射可以将interface类型变量转换成反射对象    - 下面示例，看看是如何通过反射获取一个变量的值和类型的：      package main      import (          &quot;fmt&quot;          &quot;reflect&quot;      )      func main() &#123;          var x float64 = 3.4          t := reflect.TypeOf(x)  //t is reflect.Type          fmt.Println(&quot;type:&quot;, t)          v := reflect.ValueOf(x) //v is reflect.Value          fmt.Println(&quot;value:&quot;, v)      &#125;    - 程序输出如下：      type: float64      value: 3.4    - 注意：反射是针对interface类型变量的，其中TypeOf()和ValueOf()接受的参数都是interface&#123;&#125;类型的，也即x值是被转成了interface传入的。    - 除了reflect.TypeOf()和reflect.ValueOf()，还有其他很多方法可以操作，本文先不过多介绍，否则一不小心会会引起困惑。- 3.2 反射第二定律：反射可以将反射对象还原成interface对象    - 之所以叫’反射’，反射对象与interface对象是可以互相转化的。看以下例子：      package main      import (          &quot;fmt&quot;          &quot;reflect&quot;      )      func main() &#123;          var x float64 = 3.4          v := reflect.ValueOf(x) //v is reflect.Value          var y float64 = v.Interface().(float64)          fmt.Println(&quot;value:&quot;, y)      &#125;    - 对象x转换成反射对象v，v又通过Interface()接口转换成interface对象，interface对象通过.(float64)类型断言获取float64类型的值。- 3.3 反射第三定律：反射对象可修改，value值必须是可设置的    - 通过反射可以将interface类型变量转换成反射对象，可以使用该反射对象设置其持有的值。在介绍何谓反射对象可修改前，先看一下失败的例子：      package main      import (          &quot;reflect&quot;      )      func main() &#123;          var x float64 = 3.4          v := reflect.ValueOf(x)          v.SetFloat(7.1) // Error: will panic.      &#125;    - 如下代码，通过反射对象v设置新值，会出现panic。报错如下：      panic: reflect: reflect.Value.SetFloat using unaddressable value    - 错误原因即是v是不可修改的。    - 反射对象是否可修改取决于其所存储的值，回想一下函数传参时是传值还是传址就不难理解上例中为何失败了。    - 上例中，传入reflect.ValueOf()函数的其实是x的值，而非x本身。即通过v修改其值是无法影响x的，也即是无效的修改，所以golang会报错。    - 想到此处，即可明白，如果构建v时使用x的地址就可实现修改了，但此时v代表的是指针地址，我们要设置的是指针所指向的内容，也即我们想要修改的是*v。 那怎么通过v修改x的值呢？    - reflect.Value提供了Elem()方法，可以获得指针向指向的value。看如下代码：      package main      import (      &quot;reflect&quot;          &quot;fmt&quot;      )      func main() &#123;          var x float64 = 3.4          v := reflect.ValueOf(&amp;x)          v.Elem().SetFloat(7.1)          fmt.Println(&quot;x :&quot;, v.Elem().Interface())      &#125;    - 输出为：      x : 7.1</code></pre><ul><li><ol start="4"><li><p>总结</p><ul><li><p>结合官方博客及本文，至少可以对反射理解个大概，还有很多方法没有涉及。</p></li><li><p>对反射的深入理解，个人觉得还需要继续看的内容：</p><p>参考业界，尤其是开源框架中是如何使用反射的<br>研究反射实现原理，探究其性能优化的手段</p></li></ul></li></ol></li></ul><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>Go语言提供了go test 命令行工具，使用该工具可以很方便的进行测试。</p><p>不仅Go语言源码中大量使用go test，在各种开源框架中的应用也极为普遍。</p><p>目前go test支持的测试类型有：</p><p>单元测试<br>性能测试<br>示例测试<br>本章，我们先快速掌握这几种测试的基本用法，然后我们根据源码来学习这些测试的实现机制。</p><h3 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h3><ul><li><p>单元测试</p><ul><li><ol><li><p>源代码目录结构</p><ul><li><p>我们在gotest包中创建两个文件，目录结构如下所示：</p><p>[GoExpert]<br>|–[src]<br>  |–[gotest]</p><pre><code> |--unit.go |--unit_test.go</code></pre></li></ul></li></ol></li></ul></li></ul><pre><code>    - 其中unit.go为源代码文件，unit_test.go为测试文件。要保证测试文件以“_test.go”结尾。- 2. 源代码文件    - 源代码文件unit.go中包含一个Add()方法，如下所示：      package gotest      // Add 方法用于演示go test使用      func Add(a int, b int) int &#123;          return a + b      &#125;    - Add()方法仅提供两数加法，实际项目中不可能出现类似的方法，此处仅供单元测试示例。- 3. 测试文件    - 测试文件unit_test.go中包含一个测试方法TestAdd()，如下所示：      package gotest_test      import (          &quot;testing&quot;          &quot;gotest&quot;      )      func TestAdd(t *testing.T) &#123;          var a = 1          var b = 2          var expected = 3          actual := gotest.Add(a, b)          if actual != expected &#123;              t.Errorf(&quot;Add(%d, %d) = %d; expected: %d&quot;, a, b, actual, expected)          &#125;      &#125;    - 通过package语句可以看到，测试文件属于“gotest_test”包，测试文件也可以跟源文件在同一个包，但常见的做法是创建一个包专用于测试，这样可以使测试文件和源文件隔离。GO源代码以及其他知名的开源框架通常会创建测试包，而且规则是在原包名上加上”_test”。    - 测试函数命名规则为”TestXxx”，其中“Test”为单元测试的固定开头，go test只会执行以此为开头的方法。紧跟“Test”是以首字母大写的单词，用于识别待测试函数。    - 测试函数参数并不是必须要使用的，但”testing.T”提供了丰富的方法帮助控制测试流程。    - t.Errorf()用于标记测试失败，标记失败还有几个方法，在介绍testing.T结构时再详细介绍。- 4. 执行测试    - 命令行下，使用go test命令即可启动单元测试，如下所示：      E:\OpenSource\GitHub\RainbowMango\GoExpertProgrammingSourceCode\GoExpert\src\gotest&gt;go test      PASS      ok      gotest  0.378s      E:\OpenSource\GitHub\RainbowMango\GoExpertProgrammingSourceCode\GoExpert\src\gotest&gt;    - 通过打印可知，测试通过，花费时间为0.378s。- 5. 总结    - 从上面可以看出，编写一个单元测试并执行是非常方便的，只需要遵循一定的规则：        - 测试文件名必须以”_test.go”结尾；        - 测试函数名必须以“TestXxx”开始；        - 命令行下使用”go test”即可启动测试；</code></pre><ul><li><p>性能测试</p><ul><li><ol><li><p>源代码目录结构</p><ul><li><p>我们在gotest包中创建两个文件，目录结构如下所示：</p><p>[GoExpert]<br>|–[src]<br>  |–[gotest]</p><pre><code> |--benchmark.go |--benchmark_test.go</code></pre></li></ul></li></ol></li></ul></li></ul><pre><code>    - 其中benchmark.go为源代码文件，benchmark_test.go为测试文件。- 2. 源代码文件    - 源代码文件benchmark.go中包含MakeSliceWithoutAlloc()和MakeSliceWithPreAlloc()两个方法，如下所示：      package gotest      // MakeSliceWithPreAlloc 不预分配      func MakeSliceWithoutAlloc() []int &#123;          var newSlice []int          for i := 0; i &lt; 100000; i++ &#123;              newSlice = append(newSlice, i)          &#125;          return newSlice      &#125;      // MakeSliceWithPreAlloc 通过预分配Slice的存储空间构造      func MakeSliceWithPreAlloc() []int &#123;          var newSlice []int          newSlice = make([]int, 0, 100000)          for i := 0; i &lt; 100000; i++ &#123;              newSlice = append(newSlice, i)          &#125;          return newSlice      &#125;    - 两个方法都会构造一个容量为100000的切片，所不同的是MakeSliceWithPreAlloc()会预先分配内存，而MakeSliceWithoutAlloc()不预先分配内存，二者理论上存在性能差异，本次就来测试一下二者的性能差异。- 3. 测试文件    - 测试文件benchmark_test.go中包含两个测试方法，用于测试源代码中两个方法的性能，测试文件如下所示：      package gotest_test      import (          &quot;testing&quot;          &quot;gotest&quot;      )      func BenchmarkMakeSliceWithoutAlloc(b *testing.B) &#123;          for i := 0; i &lt; b.N; i++ &#123;              gotest.MakeSliceWithoutAlloc()          &#125;      &#125;      func BenchmarkMakeSliceWithPreAlloc(b *testing.B) &#123;          for i := 0; i &lt; b.N; i++ &#123;              gotest.MakeSliceWithPreAlloc()          &#125;      &#125;    - 性能测试函数命名规则为”BenchmarkXxx”，其中”Xxx”为自定义的标识，需要以大写字母开始，通常为待测函数。    - testing.B提供了一系列的用于辅助性能测试的方法或成员，比如本例中的b.N表示循环执行的次数，而N值不用程序员特别关心，按照官方说法，N值是动态调整的，直到可靠地算出程序执行时间后才会停止，具体执行次数会在执行结束后打印出来。- 4. 执行测试    - 命令行下，使用go test -bench=.命令即可启动性能测试，如下所示：      E:\OpenSource\GitHub\RainbowMango\GoExpertProgrammingSourceCode\GoExpert\src\gotest&gt;go test -bench=.      BenchmarkMakeSliceWithoutAlloc-4            2000           1103822 ns/op      BenchmarkMakeSliceWithPreAlloc-4            5000            328944 ns/op      PASS      ok      gotest  4.445s    - 其中-bench为go test的flag，该flag指示go test进行性能测试，即执行测试文件中符合”BenchmarkXxx”规则的方法。    - 紧跟flag的为flag的参数，本例表示执行当前所有的性能测试。    - 通过输出可以直观的看出，BenchmarkMakeSliceWithoutAlloc执行了2000次，平均每次1103822纳秒，BenchmarkMakeSliceWithPreAlloc执行了5000次，平均每次328944纳秒。    - 从测试结果上看，虽然构造切片很快，但通过给切片预分配内存，性能还可以进一步提升，符合预期。关于原理分析，请参考Slice相关章节。- 5. 总结    - 从上面的例子可以看出，编写并执行性能测试是非常简单的，只需要遵循一些规则：        - 文件名必须以“_test.go”结尾；        - 函数名必须以“BenchmarkXxx”开始；        - 使用命令“go test -bench=.”即可开始性能测试；</code></pre><ul><li><p>示例测试</p><ul><li><ol><li><p>源代码目录结构</p><ul><li><p>我们在gotest包中创建两个文件，目录结构如下所示：</p><p>[GoExpert]<br>|–[src]<br>  |–[gotest]</p><pre><code> |--example.go |--example_test.go</code></pre></li></ul></li></ol></li></ul></li></ul><pre><code>    - 其中example.go为源代码文件，example_test.go为测试文件。- 2. 源代码文件    - 源代码文件example.go中包含SayHello()、SayGoodbye()和PrintNames()三个方法，如下所示：      package gotest      import &quot;fmt&quot;      // SayHello 打印一行字符串      func SayHello() &#123;          fmt.Println(&quot;Hello World&quot;)      &#125;      // SayGoodbye 打印两行字符串      func SayGoodbye() &#123;          fmt.Println(&quot;Hello,&quot;)          fmt.Println(&quot;goodbye&quot;)      &#125;      // PrintNames 打印学生姓名      func PrintNames() &#123;          students := make(map[int]string, 4)          students[1] = &quot;Jim&quot;          students[2] = &quot;Bob&quot;          students[3] = &quot;Tom&quot;          students[4] = &quot;Sue&quot;          for _, value := range students &#123;              fmt.Println(value)          &#125;      &#125;</code></pre><ul><li><p>这几个方法打印内容略有不同，分别代表一种典型的场景：</p><ul><li>SayHello()：只有一行打印输出<pre><code>  - SayGoodbye()：有两行打印输出  - PrintNames()：有多行打印输出，且由于Map数据结构的原因，多行打印次序是随机的。</code></pre></li></ul></li><li><ol start="3"><li><p>测试文件</p><ul><li><p>测试文件example_test.go中包含3个测试方法，于源代码文件中的3个方法一一对应，测试文件如下所示：</p><p>package gotest_test</p><p>   import “gotest”</p><p>   // 检测单行输出<br>   func ExampleSayHello() {</p><pre><code>   gotest.SayHello()   // OutPut: Hello World</code></pre><p>   }</p><p>   // 检测多行输出<br>   func ExampleSayGoodbye() {</p><pre><code>   gotest.SayGoodbye()   // OutPut:   // Hello,   // goodbye</code></pre><p>   }</p><p>   // 检测乱序输出<br>   func ExamplePrintNames() {</p><pre><code>   gotest.PrintNames()   // Unordered output:   // Jim   // Bob   // Tom   // Sue</code></pre><p>   }</p></li></ul></li></ol></li></ul><pre><code>- 例子测试函数命名规则为”ExampleXxx”，其中”Xxx”为自定义的标识，通常为待测函数名称。    - 这三个测试函数分别代表三种场景：    - ExampleSayHello()： 待测试函数只有一行输出，使用”// OutPut: “检测。        - ExampleSayGoodbye()：待测试函数有多行输出，使用”// OutPut: “检测，其中期望值也是多行。        - ExamplePrintNames()：待测试函数有多行输出，但输出次序不确定，使用”// Unordered output:”检测。- 注：字符串比较时会忽略前后的空白字符。</code></pre><ul><li><ol start="4"><li><p>执行测试</p><ul><li><p>命令行下，使用go test或go test example_test.go命令即可启动测试，如下所示：</p><p>E:\OpenSource\GitHub\RainbowMango\GoExpertProgrammingSourceCode\GoExpert\src\gotest&gt;go test example_test.go<br>   ok      command-line-arguments  0.331s</p></li></ul></li></ol></li></ul><ul><li><ol start="5"><li><p>总结</p><ul><li>例子测试函数名需要以”Example”开头；<ul><li>检测单行输出格式为“// Output: &lt;期望字符串&gt;”；</li><li>检测多行输出格式为“// Output: \ &lt;期望字符串&gt; \ &lt;期望字符串&gt;”，每个期望字符串占一行；</li><li>检测无序输出格式为”// Unordered output: \ &lt;期望字符串&gt; \ &lt;期望字符串&gt;”，每个期望字符串占一行；</li><li>测试字符串时会自动忽略字符串前后的空白字符；</li><li>如果测试函数中没有“Output”标识，则该测试函数不会被执行；</li><li>执行测试可以使用go test，此时该目录下的其他测试文件也会一并执行；</li><li>执行测试可以使用go test &lt;xxx_test.go&gt;，此时仅执行特定文件中的测试函数；</li></ul></li></ul></li></ol></li></ul><h3 id="进阶测试"><a href="#进阶测试" class="headerlink" title="进阶测试"></a>进阶测试</h3><p>前面我们通过简单示例快速了解了测试的用法。</p><p>本节，我们进一步探索测试的其他用法，以便应对稍微复杂一些的场景。</p><ul><li><p>子测试</p><ul><li><ol><li><p>简介</p><ul><li>简单的说，子测试提供一种在一个测试函数中执行多个测试的能力，比如原来有TestA、TestB和TestC三个测试函数，每个测试函数执行开始都需要做些相同的初始化工作，那么可以利用子测试将这三个测试合并到一个测试中，这样初始化工作只需要做一次。</li><li>除此之外，子测试还提供了诸多便利，下面我们逐一说明。</li></ul></li></ol></li><li><ol start="2"><li><p>简单例子</p><ul><li><p>我们先看一个简单的例子，以便快速了解子测试的基本用法。</p><p>package gotest_test</p><p>import (<br>   “testing”<br>   “gotest”<br>)</p><p>// sub1 为子测试，只做加法测试<br>func sub1(t *testing.T) {<br>   var a = 1<br>   var b = 2<br>   var expected = 3</p><p>   actual := gotest.Add(a, b)<br>   if actual != expected {</p><pre><code>   t.Errorf(&quot;Add(%d, %d) = %d; expected: %d&quot;, a, b, actual, expected)</code></pre><p>   }<br>}</p><p>// sub2 为子测试，只做加法测试<br>func sub2(t *testing.T) {<br>   var a = 1<br>   var b = 2<br>   var expected = 3</p><p>   actual := gotest.Add(a, b)<br>   if actual != expected {</p><pre><code>   t.Errorf(&quot;Add(%d, %d) = %d; expected: %d&quot;, a, b, actual, expected)</code></pre><p>   }<br>}</p><p>// sub3 为子测试，只做加法测试<br>func sub3(t *testing.T) {<br>   var a = 1<br>   var b = 2<br>   var expected = 3</p><p>   actual := gotest.Add(a, b)<br>   if actual != expected {</p><pre><code>   t.Errorf(&quot;Add(%d, %d) = %d; expected: %d&quot;, a, b, actual, expected)</code></pre><p>   }<br>}</p><p>// TestSub 内部调用sub1、sub2和sub3三个子测试<br>func TestSub(t *testing.T) {<br>   // setup code</p><p>   t.Run(“A=1”, sub1)<br>   t.Run(“A=2”, sub2)<br>   t.Run(“B=1”, sub3)</p><p>   // tear-down code<br>}</p></li></ul></li></ol></li></ul></li></ul><pre><code>    - 本例中TestSub()通过t.Run()依次执行三个子测试。t.Run()函数声明如下：      func (t *T) Run(name string, f func(t *T)) bool    - name参数为子测试的名字，f为子测试函数，本例中Run()一直阻塞到f执行结束后才返回，返回值为f的执行结果。    - Run()会启动新的协程来执行f，并阻塞等待f执行结束才返回，除非f中使用t.Parallel()设置子测试为并发。    - 本例中TestSub()把三个子测试合并起来，可以共享setup和tear-down部分的代码。    - 我们在命令行下，使用-v参数执行测试：      E:\OpenSource\GitHub\RainbowMango\GoExpertProgrammingSourceCode\GoExpert\src\gotest&gt;go test subunit_test.go -v      === RUN   TestSub      === RUN   TestSub/A=1      === RUN   TestSub/A=2      === RUN   TestSub/B=1      --- PASS: TestSub (0.00s)          --- PASS: TestSub/A=1 (0.00s)          --- PASS: TestSub/A=2 (0.00s)          --- PASS: TestSub/B=1 (0.00s)      PASS      ok      command-line-arguments  0.354s    - 从输出中可以看出，三个子测试都被执行到了，而且执行次序与调用次序一致。- 3. 子测试命名规则    - 通过上面的例子我们知道Run()方法第一个参数为子测试的名字，而实际上子测试的内部命名规则为：”*&lt;父测试名字&gt;/&lt;传递给Run的名字&gt;*”。比如，传递给Run()的名字是“A=1”，那么子测试名字为“TestSub/A=1”。这个在上面的命令行输出中也可以看出。- 4. 过滤筛选    - 通过测试的名字，可以在执行中过滤掉一部分测试。    - 比如，只执行上例中“A=*”的子测试，那么执行时使用-run Sub/A=参数即可：      E:\OpenSource\GitHub\RainbowMango\GoExpertProgrammingSourceCode\GoExpert\src\gotest&gt;go test subunit_test.go -v -run Sub/A=      === RUN   TestSub      === RUN   TestSub/A=1      === RUN   TestSub/A=2      --- PASS: TestSub (0.00s)          --- PASS: TestSub/A=1 (0.00s)          --- PASS: TestSub/A=2 (0.00s)      PASS      ok      command-line-arguments  0.340s    - 上例中，使用参数-run Sub/A=则只会执行TestSub/A=1和TestSub/A=2两个子测试。    - 对于子性能测试则使用-bench参数来筛选，此处不再赘述。    - 注意：此处的筛选不是严格的正则匹配，而是包含匹配。比如，-run A=那么所有测试（含子测试）的名字中如果包含“A=”则会被选中执行。- 5. 自测试并发    - 前面提到的多个子测试共享setup和teardown有一个前提是子测试没有并发，如果子测试使用t.Parallel()指定并发，那么就没办法共享teardown了，因为执行顺序很可能是setup-&gt;子测试1-&gt;teardown-&gt;子测试2…。    - 如果子测试可能并发，则可以把子测试通过Run()再嵌套一层，Run()可以保证其下的所有子测试执行结束后再返回。    - 为便于说明，我们创建文件subparallel_test.go用于说明：      package gotest_test      import (          &quot;testing&quot;          &quot;time&quot;      )      // 并发子测试，无实际测试工作，仅用于演示      func parallelTest1(t *testing.T) &#123;          t.Parallel()          time.Sleep(3 * time.Second)          // do some testing      &#125;      // 并发子测试，无实际测试工作，仅用于演示      func parallelTest2(t *testing.T) &#123;          t.Parallel()          time.Sleep(2 * time.Second)          // do some testing      &#125;      // 并发子测试，无实际测试工作，仅用于演示      func parallelTest3(t *testing.T) &#123;          t.Parallel()          time.Sleep(1 * time.Second)          // do some testing      &#125;      // TestSubParallel 通过把多个子测试放到一个组中并发执行，同时多个子测试可以共享setup和tear-down      func TestSubParallel(t *testing.T) &#123;          // setup          t.Logf(&quot;Setup&quot;)          t.Run(&quot;group&quot;, func(t *testing.T) &#123;              t.Run(&quot;Test1&quot;, parallelTest1)              t.Run(&quot;Test2&quot;, parallelTest2)              t.Run(&quot;Test3&quot;, parallelTest3)          &#125;)          // tear down          t.Logf(&quot;teardown&quot;)      &#125;    - 上面三个子测试中分别sleep了3s、2s、1s用于观察并发执行顺序。通过Run()将多个子测试“封装”到一个组中，可以保证所有子测试全部执行结束后再执行tear-down。    - 命令行下的输出如下：      E:\OpenSource\GitHub\RainbowMango\GoExpertProgrammingSourceCode\GoExpert\src\gotest&gt;go test subparallel_test.go -v -run SubParallel      === RUN   TestSubParallel      === RUN   TestSubParallel/group      === RUN   TestSubParallel/group/Test1      === RUN   TestSubParallel/group/Test2      === RUN   TestSubParallel/group/Test3      --- PASS: TestSubParallel (3.01s)              subparallel_test.go:25: Setup          --- PASS: TestSubParallel/group (0.00s)              --- PASS: TestSubParallel/group/Test3 (1.00s)              --- PASS: TestSubParallel/group/Test2 (2.01s)              --- PASS: TestSubParallel/group/Test1 (3.01s)              subparallel_test.go:34: teardown      PASS      ok      command-line-arguments  3.353s    - 通过该输出可以看出：        - 子测试是并发执行的（Test1最先被执行却最后结束）        - tear-down在所有子测试结束后才执行- 6. 总结    - 子测试适用于单元测试和性能测试；    - 子测试可以控制并发；    - 子测试提供一种类似table-driven风格的测试；    - 子测试可以共享setup和tear-down；</code></pre><ul><li><p>Main测试</p><ul><li><ol><li><p>简介</p><ul><li>我们知道子测试的一个方便之处在于可以让多个测试共享Setup和Tear-down。但这种程度的共享有时并不满足需求，有时希望在整个测试程序做一些全局的setup和Tear-down，这时就需要Main测试了。</li><li>所谓Main测试，即声明一个func TestMain(m *testing.M)，它是名字比较特殊的测试，参数类型为testing.M指针。如果声明了这样一个函数，当前测试程序将不是直接执行各项测试，而是将测试交给TestMain调度。</li></ul></li></ol></li><li><ol start="2"><li><p>示例</p><ul><li><p>下面通过一个例子来展示Main测试用法：</p><p>// TestMain 用于主动执行各种测试，可以测试前后做setup和tear-down操作<br>func TestMain(m *testing.M) {<br>   println(“TestMain setup.”)</p><p>   retCode := m.Run() // 执行测试，包括单元测试、性能测试和示例测试</p><p>   println(“TestMain tear-down.”)</p><p>   os.Exit(retCode)<br>}</p></li></ul></li></ol></li></ul></li></ul><pre><code>    - 上述例子中，日志打印的两行分别对应Setup和Tear-down代码，m.Run()即为执行所有的测试，m.Run()的返回结果通过os.Exit()返回。    - 如果所有测试均通过测试，m.Run()返回0，否同m.Run()返回1，代表测试失败。    - 有一点需要注意的是，TestMain执行时，命令行参数还未解析，如果测试程序需要依赖参数，可以使用flag.Parse()解析参数，m.Run()方法内部还会再次解析参数，此处解析不会影响原测试过程。</code></pre><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>本节，我们重点探索一下go test的实现原理。</p><p>首先，我们会先从数据结构入手，查看测试是如何被组织起来的。其次，我们会关注测试的关键实现方法，尽量呈现源码并配以示例来了解其实现原理。</p><p>为了叙述方便，本节部分源码隐去了部分与话题无关的代码，更多的源码解释，可以通过源码注释来了解。</p><ul><li><p>testing.common公共类</p><ul><li><ol><li><p>简介</p><ul><li>我们知道单元测试函数需要传递一个testing.T类型的参数，而性能测试函数需要传递一个testing.B类型的参数，该参数可用于控制测试的流程，比如标记测试失败等。</li><li>testing.T和testing.B属于testing包中的两个数据类型，该类型提供一系列的方法用于控制函数执行流程，考虑到二者有一定的相似性，所以Go实现时抽象出一个testing.common作为一个基础类型，而testing.T和testing.B则属于testing.common的扩展。</li><li>本节，我们重点看testing.common，通过其成员及方法，来了解其实现原理。</li></ul></li></ol></li><li><ol start="2"><li>数据结构</li></ol><p>// common holds the elements common between T and B and<br>// captures common methods such as Errorf.<br>type common struct {</p><pre><code>mu      sync.RWMutex        // guards this group of fieldsoutput  []byte              // Output generated by test or benchmark.w       io.Writer           // For flushToParent.ran     bool                // Test or benchmark (or one of its subtests) was executed.failed  bool                // Test or benchmark has failed.skipped bool                // Test of benchmark has been skipped.done    bool                // Test is finished and all subtests have completed.helpers map[string]struct&#123;&#125; // functions to be skipped when writing file/line infochatty     bool   // A copy of the chatty flag.finished   bool   // Test function has completed.hasSub     int32  // written atomicallyraceErrors int    // number of races detected during testrunner     string // function name of tRunner running the testparent   *commonlevel    int       // Nesting depth of test or benchmark.creator  []uintptr // If level &gt; 0, the stack trace at the point where the parent called t.Run.name     string    // Name of test or benchmark.start    time.Time // Time test or benchmark startedduration time.Durationbarrier  chan bool // To signal parallel subtests they may start.signal   chan bool // To signal a test is done.sub      []*T      // Queue of subtests to be run in parallel.</code></pre><p>}</p></li></ul></li></ul><pre><code>    - common.mu        - 读写锁，仅用于控制本数据内的成员访问。    - common.output        - 存储当前测试产生的日志，每产生一条日志则追加到该切片中，待测试结束后再一并输出。    - common.w        - 子测试执行结束需要把产生的日志输送到父测试中的output切片中，传递时需要考虑缩进等格式调整，通过w把日志传递到父测试。    - common.ran        - 仅表示是否已执行过。比如，根据某个规范筛选测试，如果没有测试被匹配到的话，则common.ran为false，表示没有测试运行过。    - common.failed        - 如果当前测试执行失败，则置为true。    - common.skipped        - 标记当前测试是否已跳过。    - common.done        - 表示当前测试及其子测试已结束，此状态下再执行Fail()之类的方法标记测试状态会产生panic。    - common.helpers        - 标记当前为函数为help函数，其中打印的日志，在记录日志时不会显示其文件名及行号。    - common.chatty        - 对应命令行中的-v参数，默认为false，true则打印更多详细日志。    - common.finished        - 如果当前测试结束，则置为true。    - common.hasSub        - 标记当前测试是否包含子测试，当测试使用t.Run()方法启动子测试时，t.hasSub则置为1。    - common.raceErrors        - 竞态检测错误数。    - common.runner        - 执行当前测试的函数名。    - common.parent        - 如果当前测试为子测试，则置为父测试的指针。    - common.level        - 测试嵌套层数，比如创建子测试时，子测试嵌套层数就会加1。    - common.creator        - 测试函数调用栈。    - common.name        - 记录每个测试函数名，比如测试函数TestAdd(t *testing.T), 其中t.name即“TestAdd”。        - 测试结束，打印测试结果会用到该成员。    - common.start        - 记录测试开始的时间。    - common.duration        - 记录测试所花费的时间。- 3. 成员方法    - common.Name()      // Name returns the name of the running test or benchmark.      func (c *common) Name() string &#123;          return c.name      &#125;        - 该方法直接返回common结构体中存储的名称。    - common.Fail()      // Fail marks the function as having failed but continues execution.      func (c *common) Fail() &#123;          if c.parent != nil &#123;              c.parent.Fail()          &#125;          c.mu.Lock()          defer c.mu.Unlock()          // c.done needs to be locked to synchronize checks to c.done in parent tests.          if c.done &#123;              panic(&quot;Fail in goroutine after &quot; + c.name + &quot; has completed&quot;)          &#125;          c.failed = true      &#125;        - Fail()方法会标记当前测试为失败，然后继续运行，并不会立即退出当前测试。如果是子测试，则除了标记当前测试结果外还通过c.parent.Fail()来标记父测试失败。    - common.FailNow()      func (c *common) FailNow() &#123;          c.Fail()          c.finished = true          runtime.Goexit()      &#125;        - FailNow()内部会调用Fail()标记测试失败，还会标记测试结束并退出当前测试协程。        - 可以简单的把一个测试理解为一个协程，FailNow()只会退出当前协程，并不会影响其他测试协程，但要保证在当前测试协程中调用FailNow()才有效，不可以在当前测试创建的协程中调用该方法。    - common.log()      func (c *common) log(s string) &#123;          c.mu.Lock()          defer c.mu.Unlock()          c.output = append(c.output, c.decorate(s)...)      &#125;        - common.log()为内部记录日志入口，日志会统一记录到common.output切片中，测试结束时再统一打印出来。        - 日志记录时会调用common.decorate()进行装饰，即加上文件名和行号，还会做一些其他格式化处理。        - 调用common.log()的方法，有Log()、Logf()、Error()、Errorf()、Fatal()、Fatalf()、Skip()、Skipf()等。        - 注意：单元测试中记录的日志只有在执行失败或指定了-v参数才会打印，否则不会打印。而在性能测试中则总是被打印出来，因为是否打印日志有可能影响性能测试结果。    - common.Log(args …interface&#123;&#125;)      func (c *common) Log(args ...interface&#123;&#125;) &#123;          c.log(fmt.Sprintln(args...))      &#125;        - common.Log()方法用于记录简单日志，通过fmt.Sprintln()方法生成日志字符串后记录。    - common.Logf(format string, args …interface&#123;&#125;)      func (c *common) Logf(format string, args ...interface&#123;&#125;) &#123;          c.log(fmt.Sprintf(format, args...))      &#125;        - common.Logf()方法用于格式化记录日志，通过fmt.Sprintf()生成字符串后记录。    - common.Error(args …interface&#123;&#125;)      // Error is equivalent to Log followed by Fail.      func (c *common) Error(args ...interface&#123;&#125;) &#123;          c.log(fmt.Sprintln(args...))          c.Fail()      &#125;        - common.Error()方法等同于common.Log()+common.Fail()，即记录日志并标记失败，但测试继续进行。    - common.Errorf(format string, args …interface&#123;&#125;)      // Errorf is equivalent to Logf followed by Fail.      func (c *common) Errorf(format string, args ...interface&#123;&#125;) &#123;          c.log(fmt.Sprintf(format, args...))          c.Fail()      &#125;        - common.Errorf()方法等同于common.Logf()+common.Fail()，即记录日志并标记失败，但测试继续进行。    - common.Fatal(args …interface&#123;&#125;)      // Fatal is equivalent to Log followed by FailNow.      func (c *common) Fatal(args ...interface&#123;&#125;) &#123;          c.log(fmt.Sprintln(args...))          c.FailNow()      &#125;        - common.Fatal()方法等同于common.Log()+common.FailNow()，即记录日志、标记失败并退出当前测试。    - common.Fatalf(format string, args …interface&#123;&#125;)      // Fatalf is equivalent to Logf followed by FailNow.      func (c *common) Fatalf(format string, args ...interface&#123;&#125;) &#123;          c.log(fmt.Sprintf(format, args...))          c.FailNow()      &#125;        - common.Fatalf()方法等同于common.Logf()+common.FailNow()，即记录日志、标记失败并退出当前测试。    - common.skip()      func (c *common) skip() &#123;          c.mu.Lock()          defer c.mu.Unlock()          c.skipped = true      &#125;        - common.skip()方法标记当前测试为已跳过状态，比如测试中检测到某种条件，不再继续测试。该函数仅标记测试跳过，与测试结果无关。测试结果仍然取决于common.failed。    - common.SkipNow()      func (c *common) SkipNow() &#123;          c.skip()          c.finished = true          runtime.Goexit()      &#125;        - common.SkipNow()方法标记测试跳过，并标记测试结束，最后退出当前测试。    - common.Skip(args …interface&#123;&#125;)      // Skip is equivalent to Log followed by SkipNow.      func (c *common) Skip(args ...interface&#123;&#125;) &#123;          c.log(fmt.Sprintln(args...))          c.SkipNow()      &#125;        - common.Skip()方法等同于common.Log()+common.SkipNow()。    - common.Skipf(format string, args …interface&#123;&#125;)      // Skipf is equivalent to Logf followed by SkipNow.      func (c *common) Skipf(format string, args ...interface&#123;&#125;) &#123;          c.log(fmt.Sprintf(format, args...))          c.SkipNow()      &#125;        - common.Skipf()方法等同于common.Logf() + common.SkipNow()。    - common.Helper()      // Helper marks the calling function as a test helper function.      // When printing file and line information, that function will be skipped.      // Helper may be called simultaneously from multiple goroutines.      func (c *common) Helper() &#123;          c.mu.Lock()          defer c.mu.Unlock()          if c.helpers == nil &#123;              c.helpers = make(map[string]struct&#123;&#125;)          &#125;          c.helpers[callerName(1)] = struct&#123;&#125;&#123;&#125;      &#125;        - common.Helper()方法标记当前函数为help函数，所谓help函数，即其中打印的日志，不记录help函数的函数名及行号，而是记录上一层函数的函数名和行号。</code></pre><ul><li><p>testing.TB接口</p><ul><li><ol><li><p>简介</p><ul><li>TB接口，顾名思义，是testing.T(单元测试)和testing.B(性能测试)共用的接口。</li><li>TB接口通过在接口中定义一个名为private(）的私有方法，保证了即使用户实现了类似的接口，也不会跟testing.TB接口冲突。</li><li>其实，这些接口在testing.T和testing.B公共成员testing.common中已经实现。</li></ul></li></ol></li><li><ol start="2"><li><p>接口定义</p><ul><li><p>在src/testing/testing.go中定义了testing.TB接口：</p><p>// TB is the interface common to T and B.<br>type TB interface {<br>   Error(args …interface{})<br>   Errorf(format string, args …interface{})<br>   Fail()<br>   FailNow()<br>   Failed() bool<br>   Fatal(args …interface{})<br>   Fatalf(format string, args …interface{})<br>   Log(args …interface{})<br>   Logf(format string, args …interface{})<br>   Name() string<br>   Skip(args …interface{})<br>   SkipNow()<br>   Skipf(format string, args …interface{})<br>   Skipped() bool<br>   Helper()</p><p>   // A private method to prevent users implementing the<br>   // interface and so future additions to it will not<br>   // violate Go 1 compatibility.<br>   private()<br>}</p></li></ul></li></ol></li></ul></li></ul><pre><code>    - 其中对外接口需要testing.T和testing.B实现，但由于testing.T和testing.B都继承了testing.common，而testing.common已经实现了这些接口，所以testing.T和testing.B天然实现了TB接口。    - 其中私有接口private()用于控制该接口的唯一性，即便用户代码中某个类型实现了这些方法，由于无法实现这个私有接口，也不能被认为是实现了TB接口，所以不会跟用户代码产生冲突。- 3. 接口分类    - 我们在testing.common部分介绍过每个接口的实现，我们接下来就从函数功能上对接口进行分类。    - 以单元测试为例，每个测试函数都需要接收一个testing.T类型的指针作为函数参数，该参数主要用于控制测试流程（如结束和跳过）和记录日志。- 4. 记录日志    - Log(args …interface&#123;&#125;)    - Logf(format string, args …interface&#123;&#125;)    - Log()和Logf()负责记录日志，其区别在于是否支持格式化参数；- 5. 标记失败+记录日志    - Error(args …interface&#123;&#125;)    - Errorf(format string, args …interface&#123;&#125;)    - Error()和Errorf()负责标记当前测试失败并记录日志。    - 只标记测试状态为失败，并不影响测试函数流程，不会结束当前测试，也不会退出当前测试。- 6. 标记失败+记录日志+结束测试    - Fatal(args …interface&#123;&#125;)    - Fatalf(format string, args …interface&#123;&#125;)    - Fatal()和Fatalf()负责标记当前测试失败、记录日志，并退出当前测试。- 7. 标记失败    - Fail()    - Fail()仅标记录前测试状态为失败。- 8. 标记失败并退出    - FailNow()    - FailNow()标记当前测试状态为失败并退出当前测试。- 9. 跳过测试+记录日志并退出    - Skip(args …interface&#123;&#125;)    - Skipf(format string, args …interface&#123;&#125;)    - Skip()和Skipf()标记当前测试状态为跳过并记录日志，最后退出当前测试。- 10. 跳过测试并退出    - SkipNow()    - SkipNow()标记测试状态为跳过，并退出当前测试。- 11. 私有接口避免冲突    - 接口定义中的private()方法是一个值得学习的用法。其目的是限定testing.TB接口的全局唯一性，即便用户的某个类型实现了除private()方法以外的其他方法，也不能说明实现了testing.TB接口，因为无法实现private()方法，private()方法属于testing包内部可见，外部不可见。</code></pre><ul><li>单元测试实现原理</li><li>性能测试实现原理</li><li>Main测试实现原理</li><li>go test工作机制</li></ul><h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><ul><li>测试参数</li><li>基准测试分析</li></ul><h3 id="Httptest"><a href="#Httptest" class="headerlink" title="Httptest"></a>Httptest</h3><p>前面介绍了go test用于单元测试、性能测试和示例测试，但Web应用程序中往往需要与其他系统进行交互，比如通过http访问其他系统，此时就需要有一种方法用于打桩来模拟Web服务器和客户端，httptest包即Go语言针对Web应用提供的解决方案。</p><p>httptest可以方便的模拟各种Web服务器和客户端，以达到测试目的。</p><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>定时器在Go语言应用中使用非常广泛，准确掌握其用法和实现原理至关重要。</p><p>Go提供了两种定时器，此处分为一次性定时器、周期性定时器。</p><p>一次性定时器：定时器只计时一次，结束便停止；<br>周期性定时器：定时器周期性进行计时，除非主动停止，否则将永久运行；<br>本章会快速介绍这两种定时器的基本用法，重点介绍其内部实现原理，最后再给出一个案例揭示使用定时器的风险。</p><h3 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h3><p>本小节，我们关注一次性定时器的使用方法及其使用原理。</p><ul><li><p>快速开始</p><ul><li><ol><li><p>简介</p><ul><li><p>Timer实际上是一种单一事件的定时器，即经过指定的时间后触发一个事件，这个事件通过其本身提供的channel进行通知。之所以叫单一事件，是因为Timer只执行一次就结束，这也是Timer与Ticker的最重要的区别之一。</p></li><li><p>通过timer.NewTimer(d Duration)可以创建一个timer，参数即等待的时间，时间到来后立即触发一个事件。</p></li><li><p>源码包src/time/sleep.go:Timer定义了Timer数据结构：</p><p>type Timer struct { // Timer代表一次定时，时间到来后仅发生一个事件。<br>   C &lt;-chan Time<br>   r runtimeTimer<br>}</p></li></ul></li></ol></li></ul></li></ul><pre><code>    - Timer对外仅暴露一个channel，指定的时间到来时就往该channel中写入系统时间，也即一个事件。    - 本节我们介绍Timer的几个使用场景，同时再介绍其对外呈现的方法。- 2. 使用场景    - 设定超时时间        - 有时我们希望从一个管道中读取数据，在管道中没有数据时，我们不想让程序永远阻塞在管道中，而是设定一个超时时间，在此时间段中如果管道中还是没有数据到来，则判定为超时。        - Go源码包中有大量类似的用法，比如从一个连接中等待数据，其简单的用法如下代码所示：          func WaitChannel(conn &lt;-chan string) bool &#123;              timer := time.NewTimer(1 * time.Second)              select &#123;              case &lt;- conn:                  timer.Stop()                  return true              case &lt;- timer.C: // 超时                  println(&quot;WaitChannel timeout!&quot;)                  return false              &#125;          &#125;        - WaitChannel作用就是检测指定的管道中是否有数据到来，通过select语句轮询conn和timer.C两个管道，timer会在1s后向timer.C写入数据，如果1s内conn还没有数据，则会判断为超时。    - 延迟执行某个方法        - 有时我们希望某个方法在今后的某个时刻执行，如下代码所示：          func DelayFunction() &#123;              timer := time.NewTimer(5 * time.Second)              select &#123;              case &lt;- timer.C:                  log.Println(&quot;Delayed 5s, start to do something.&quot;)              &#125;          &#125;        - DelayFunction()会一直等待timer的事件到来才会执行后面的方法(打印)。- 3. Timer对外接口    - 创建定时器        - 使用方法func NewTimer(d Duration) *Timer指定一个时间即可创建一个Timer，Timer一经创建便开始计时，不需要额外的启动命令。        - 实际上，创建Timer意味着把一个计时任务交给系统守护协程，该协程管理着所有的Timer，当Timer的时间到达后向Timer的管道中发送当前的时间作为事件。详细的实现原理我们后面会单独介绍。    - 停止定时器        - Timer创建后可以随时停止，停止计时器的方法是：        - func (t *Timer) Stop() bool        - 其返回值代表定时器有没有超时：        - true: 定时器超时前停止，后续不会再有事件发送；        - false: 定时器超时后停止；        - 实际上，停止计时器意味着通知系统守护协程移除该定时器。详细的实现原理我们后面单独介绍。    - 重置定时器        - 已过期的定时器或者已停止的定时器，可以通过重置动作重新激活，重置方法如下：        - func (t *Timer) Reset(d Duration) bool        - 重置的动作实质上是先停掉定时器，再启动。其返回值也即停掉计时器的返回值。        - 需要注意的是，重置定时器虽然可以用于修改还未超时的定时器，但正确的使用方式还是针对已过期的定时器或已被停止的定时器，同时其返回值也不可靠，返回值存在的价值仅仅是与前面版本兼容。        - 实际上，重置定时器意味着通知系统守护协程移除该定时器，重新设定时间后，再把定时器交给守护协程。详细的实现原理我们后面单独介绍。- 4. 简单接口  前面介绍了Timer的标准接口，time包同时还提供了一些简单的方法，在特定的场景下可以简化代码。    - After()        - 有时我们就是想等指定的时间，没有需求提前停止定时器，也没有需求复用该定时器，那么可以使用匿名的定时器。        - func After(d Duration) &lt;-chan Time方法创建一个定时器，并返回定时器的管道，如下代码所示：          func AfterDemo() &#123;              log.Println(time.Now())              &lt;- time.After(1 * time.Second)              log.Println(time.Now())          &#125;        - AfterDemo()两条打印时间间隔为1s，实际还是一个定时器，但代码变得更简洁。    - AfterFunc()        - 前面我们例子中讲到延迟一个方法的调用，实际上通过AfterFunc可以更简洁。AfterFunc的原型为：          func AfterFunc(d Duration, f func()) *Timer        - 该方法在指定时间到来后会执行函数f。例如：          func AfterFuncDemo() &#123;              log.Println(&quot;AfterFuncDemo start: &quot;, time.Now())              time.AfterFunc(1 * time.Second, func() &#123;                  log.Println(&quot;AfterFuncDemo end: &quot;, time.Now())              &#125;)              time.Sleep(2 * time.Second) // 等待协程退出          &#125;        - AfterFuncDemo()中先打印一个时间，然后使用AfterFunc启动一个定器，并指定定时器结束时执行一个方法打印结束时间。        - 与上面的例子所不同的是，time.AfterFunc()是异步执行的，所以需要在函数最后sleep等待指定的协程退出，否则可能函数结束时协程还未执行。- 5. 总结    - 本节简单介绍了Timer的常见使用场景和接口，后面的章节再介绍Ticker、以及二者的实际细节。    - Timer内容总结如下：        - time.NewTimer(d)创建一个Timer;        - timer.Stop()停掉当前Timer;        - timer.Reset(d)重置当前Timer;</code></pre><ul><li>实现原理</li></ul><h3 id="Ticker"><a href="#Ticker" class="headerlink" title="Ticker"></a>Ticker</h3><ul><li>快速开始</li><li>实现原理</li></ul><h3 id="Timer-1"><a href="#Timer-1" class="headerlink" title="Timer"></a>Timer</h3><ul><li>实现原理</li></ul><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><ul><li>开源库资源泄露</li></ul><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><p>名字由来</p><p>语法糖（Syntactic sugar）的概念是由英国计算机科学家Peter J. Landin提出的，<br>用于表示编程语言中的某种类型的语法，这些语法不会影响功能，但使用起来却很方便。</p><p>语法糖，也称糖语法，这些语法不仅不会影响功能，编译后的结果跟不使用语法糖也一样。</p><p>语法糖，有可能让代码编写变得简单，也有可能让代码可读性更高，也有可能让代码出问题。为了避免陷阱才是这个章节的重点。</p><p>Go语言语法糖</p><p>最常用的语法糖莫过于赋值符:=，其次，表示函数变参的…。</p><p>接下来，我们会介绍这两种语法糖的用法，更重要的是结合实际的经历跟大家分享其中的陷阱。</p><h3 id="简短变量声明"><a href="#简短变量声明" class="headerlink" title="简短变量声明"></a>简短变量声明</h3><ul><li>热身测验</li><li>使用规则</li></ul><h3 id="可变参函数"><a href="#可变参函数" class="headerlink" title="可变参函数"></a>可变参函数</h3><h2 id="GO语言版本管理"><a href="#GO语言版本管理" class="headerlink" title="GO语言版本管理"></a>GO语言版本管理</h2><p>GO语言的安装和卸载是个基本功，因为GO语言还在不断地演进，为了使用新版本你就需要先把旧版本删除再安装新版本。</p><p>另外，看起来非常简单的安装和卸载过程，如果你对GOROOT和GOPATH理解不到位，也会在使用过程中遇到麻烦。<br>再进一步，业界有许多GO语言的版本管理工具，我们借助这些工具可以实现同时安装多个GO语言版本，要理解这些工具的实现原理，<br>也需要了解GO语言运行机制，比如import搜索路径，而手动安装GO语言版本可以加深这些认识。</p><p>本章我们先介绍手动安装和卸载过程，再介绍一些基础概念，比如GOROOT、GOPATH等，最后我们会介绍常见的GO语言版本工具。</p><h3 id="GO语言安装"><a href="#GO语言安装" class="headerlink" title="GO语言安装"></a>GO语言安装</h3><ul><li><ol start="0"><li><p>前言</p><ul><li><p>与大多数开源软件一样，Go安装包也分为二进制包、源码包。二进制包为基于源码编译出各个组件，并把这些组件打包在一起供人下载和安装，源码包为 Golang语言源码，供人下载、编译后自行安装。</p></li><li><p>接下来我们以安装二进制包（go1.12.7.linux-amd64.tar.gz）为例进行说明安装过程。</p></li><li><p>linux下可以使用wget <a href="https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz%E5%91%BD%E4%BB%A4%E4%B8%8B%E8%BD%BD%E3%80%82">https://dl.google.com/go/go1.12.7.linux-amd64.tar.gz命令下载。</a></p></li><li><p>Go语言安装比较简单，大体上分为三个步骤：</p><ul><li>安装可执行命令</li><li>设置PATH环境变量</li><li>设置GOPATH环境变量</li></ul></li></ul></li></ol></li><li><ol><li><p>安装可执行命令</p><ul><li><p>二进制安装包中包含二进制、文档、标准库等内容，我们需要将该二进制完整的解压出来。</p></li><li><p>一般使用 /usr/local/go/ 来存放解压出来的文件，这个目录也就是 GOROOT，即GO的根目录。</p></li><li><p>下接使用tar命令将安装包解压到指定目录即可：</p><p>tar -C /usr/local -xzf go1.12.7.linux-amd64.tar.gz</p></li></ul></li></ol></li></ul><ul><li><ol start="2"><li><p>设置PATH环境变量</p><ul><li><p>Go的二进制可执行文件存在于$GOROOT/bin目录，需要将该目录加入到PATH环境变量中。</p></li><li><p>比如，把下面语句放入/etc/profile文件中。</p><p>export PATH=$PATH:/usr/local/go/bin</p></li></ul></li></ol></li></ul><ul><li><ol start="3"><li><p>设置GOPATH环境变量</p><ul><li><p>Linux下，自Go 1.8版本起，默认把$HOME/go作为GOPATH目录，可以根据需要设置自已的GOPATH目录。</p></li><li><p>如需要设置不同的GOPATH目录，可以将其放入~/.bash_profile中。</p><p>export GOPATH=$HOME/mygopath</p></li></ul></li></ol></li></ul><pre><code>- 即便使用GOPATH默认目录，推荐也把它加入到环境变量中，这可以让bash识别GOPATH变量。- 这里需要注意的是，GOPATH值不可以与GOROOT相同，因为如果用户的项目与标准库重名会导致编译时产生歧义。</code></pre><ul><li><ol start="4"><li><p>测试安装</p><ul><li><p>安装完成后，可以写个小程序验证一下，验证前建议重新登录，以便让环境变量生效。</p></li><li><p>创建$GOPATH/src/hello/hello.go文件：</p><p>package main</p><p>import “fmt”</p><p>func main() {<br>   fmt.Printf(“hello, world\n”)<br>}</p></li></ul></li></ol></li></ul><pre><code>- 接着进入$GOPATH/src/hello编译并执行：  # cd $GOPATH/src/hello  # go build  # hello  hello, world- 程序能正常输出hello, world就表示安装完成了。</code></pre><h3 id="GO语言卸载"><a href="#GO语言卸载" class="headerlink" title="GO语言卸载"></a>GO语言卸载</h3><ul><li><ol start="0"><li><p>前言</p><ul><li>当需要升级新的Go语言版本时，你需要先把旧版本删除。Go语言版本升级过程实际上是删除旧版本+安装新版本。</li><li>删除Go语言版本是安装新版本的逆过程，即把新版本安装时创建的目录、环境变量删除。</li></ul></li></ol></li><li><ol><li><p>删除Go安装目录</p><ul><li><p>通过go env命令查询安装目录，安装目录即GOROOT环境变量所指示的目录，如下所示：</p><h1 id="go-env"><a href="#go-env" class="headerlink" title="go env"></a>go env</h1><p>GOPATH=”/root/go”<br>GOROOT=”/usr/local/go”</p></li></ul></li></ol></li></ul><pre><code>- go env命令会输出很多Go语言相关的环境变量，上面只保留了最关键的两个GOROOT和GOPATH。- 接下来使用rm命令删除GOROOT指向的目录即可，比如# rm -rf /usr/local/go。</code></pre><ul><li><ol start="2"><li><p>删除残留的可执行文件</p><ul><li>Go程序在运行过程中会在GOPATH/bin目录下生成可执行文件，为了安全起见，也需要删除。</li><li>同样，使用rm 命令删除即可，比如# rm -rf /root/go/bin。</li><li>注：如果GOPATH包含多个目录，需要删除每个目录下的bin目录。</li></ul></li></ol></li><li><ol start="3"><li><p>删除环境变量</p><ul><li><p>将环境变量GOPATH删除，该环境变量一般是前一次安装Go时人为设置的。</p></li><li><p>环境变量一般存在于以下几个文件中：</p><ul><li>/etc/profile</li><li>/etc/bashrc</li><li>~/.bash_profile</li><li>~/.profile</li><li>~/.bashrc</li></ul></li><li><p>做完以上步骤，旧版本就被彻底的删除了。</p></li></ul></li></ol></li></ul><h2 id="GO依赖管理"><a href="#GO依赖管理" class="headerlink" title="GO依赖管理"></a>GO依赖管理</h2><p>Go语言依赖管理经历了三个重要的阶段：</p><p>GOPATH；<br>vendor；<br>Go Module；<br>早期Go语言单纯使用GOPATH管理依赖，但GOPATH不方便管理依赖的多个版本，后来增加了vendor，允许把项目依赖连同项目源码一同管理。<br>自从Go 1.11版本引入了全新的依赖管理工具Go module，直到Go 1.14版本 Go module才走向成熟。</p><p>Go官方依赖管理演进过程中还有为数众多的第三方管理工具，比如Glide、Govendor等等，但随着Go module的推出，<br>这些工具终将逐步退出历史舞台，本章节不再涵盖此部分内容。</p><p>从GOPATH到vendor，再到Go module是个不断演进的过程，了解每种依赖管理的痛点可以更好的理解下一代依赖管理的设计初衷。<br>本章先从基础的GOPATH讲起，接着介绍vendor，最后再介绍Go module。</p><h3 id="GOPATH"><a href="#GOPATH" class="headerlink" title="GOPATH"></a>GOPATH</h3><ul><li><ol start="0"><li><p>前言</p><ul><li><p>根据我个人的经验，那些对GOPATH感到困惑的同学，往往归属于下面两类：</p><ul><li>没有亲自安装过Go语言；</li><li>安装过，但没理解安装细节；</li></ul></li><li><p>其实，自己亲自动手安装一遍Go语言，然后运行一个Hello World程序，就基本上能理解GOPATH。</p></li><li><p>本节主要介绍GOPATH以及与其密切相关的GOROOT，关于安装相关的详细内容不再赘述。</p></li></ul></li></ol></li><li><ol><li><p>GOROOT 是什么</p><ul><li>通常我们说安装Go语言，实际上安装的是Go编译器和Go标准库，二者位于同一个安装包中。</li><li>假如你在Windows上使用Installer安装的话，它们将会被默认安装到c:\Go目录下，该目录即GOROOT目录，里面保存了开发GO程序所需要的所有组件，比如编译器、标准库和文档等等。</li><li>同时安装程序还会自动帮你设置GOROOT环境变量，如下图所示：</li><li>另外，安装程序还会把c:\Go\bin目录添加到系统的PATH环境变量中，如下图所示：</li><li>该目录主要是GO语言开发包中提供的二进程可执行程序。</li><li>所以，GOROOT实际上是指示GO语言安装目录的环境变量，属于GO语言顶级目录。</li></ul></li></ol></li><li><ol start="2"><li><p>GOPATH 是什么</p><ul><li><p>安装完Go语言，接下来就要写自己的Hello World项目了。实际上Go语言项目是由一个或多个package组成的，这些package按照来源分为以下几种：</p><ul><li>标准库</li><li>第三方库</li><li>项目私有库</li></ul></li><li><p>其中标准库的package全部位于GOROOT环境变量指示的目录中，而第三方库和项目私有库都位于GOPATH环境变量所指示的目录中。</p></li><li><p>实际上，安装GO语言时，安装程序会设置一个默认的GOPATH环境变量，如下所示：</p></li><li><p>与GOROOT不同的是，GOPATH环境变量位于用户域，因为每个用户都可以创建自己的工作空间而互不干扰。</p></li><li><p>用户的项目需要位于GOPATH下的src/目录中。</p></li><li><p>所以GOPATH指示用户工作空间目录的环境变量，它属于用户域范畴的。</p></li></ul></li></ol></li><li><ol start="3"><li><p>依赖查找</p><ul><li>当某个package需要引用其他包时，编译器就会依次从GOROOT/src/和GOPATH/src/中去查找，如果某个包从GOROOT下找到的话，就不再到GOPATH目录下查找，所以如果项目中开发的包名与标准库相同的话，将会被自动忽略。</li></ul></li></ol></li><li><ol start="4"><li><p>GOPATH的缺点</p><ul><li><p>GOPATH的优点是足够简单，但它不能很好的满足实际项目的工程需求。</p></li><li><p>比如，你有两个项目A和B，他们都引用某个第三方库T，但这两个项目使用了不同的T版本，即：</p><ul><li>项目A 使用T v1.0</li><li>项目B 使用T v2.0</li></ul></li><li><p>由于编译器依赖查找固定从GOPATH/src下查找GOPATH/src/T，所以，无法在同一个GOPATH目录下保存第三方库T的两个版本。所以项目A、B无法共享同一个GOPATH，需要各自维护一个，这给广大软件工程师带来了极大的困扰。</p></li><li><p>针对GOPATH的缺点，GO语言社区提供了Vendor机制，从此依赖管理进入第二个阶段：将项目的依赖包私有化。</p></li></ul></li></ol></li></ul><h3 id="Vendor"><a href="#Vendor" class="headerlink" title="Vendor"></a>Vendor</h3><ul><li><ol start="0"><li><p>前言</p><ul><li>前面我们介绍了使用GOPATH时的痛点：多项目无法共享同一个GOPATH。</li><li>其实本节介绍的vendor机制也没有彻底解决这个痛点，但是它提供了一个机制让项目的依赖隔离而不互相干扰。</li><li>自Go 1.6版本起，vendor机制正式启用，它允许把项目的依赖全部放到一个位于本项目的vendor目录中，这个vendor目录可以简单理解成私有的GOPATH目录。即编译时，优先从vendor中寻找依赖包，如果vendor中找不到再到GOPATH中寻找。</li></ul></li></ol></li><li><ol><li><p>vendor目录位置</p><ul><li><p>一个项目可以有多个vendor目录，分别位于不同的目录级别，但建议每个项目只在根目录放置一个vendor目录。</p></li><li><p>假如你有一个github.com/constabulary/example-gsftp项目，项目目录结构如下：</p><p>$GOPATH<br>|    src/<br>|    |    github.com/constabulary/example-gsftp/<br>|    |    |    cmd/<br>|    |    |    |    gsftp/<br>|    |    |    |    |    main.go</p></li></ul></li></ol></li></ul><pre><code>- 其中 main.go中依赖如下几个包：  import (      &quot;golang.org/x/crypto/ssh&quot;      &quot;github.com/pkg/sftp&quot;  )- 在没有使用vendor目录时，若想编译这个项目，那么GOPATH目录结构应该是如下所示：  $GOPATH  |    src/  |    |    github.com/constabulary/example-gsftp/  |    |    golang.org/x/crypto/ssh  |    |    github.com/pkg/sftp- 即，所有依赖的包，都位于$GOPATH/src下。- 为了把所使用到的golang.org/x/crypto/ssh 和 github.com/pkg/sftp版本固化下来，那么可以使用vendor机制。- 在项目github.com/constabulary/example-gsftp根目录下，创建一个vendor目录，并把golang.org/x/crypto/ssh 和 github.com/pkg/sftp存放到此处，让其成为项目的一部分。如下所示：  $GOPATH  |    src/  |    |    github.com/constabulary/example-gsftp/  |    |    |    cmd/  |    |    |    |    gsftp/  |    |    |    |    |    main.go  |    |    |    vendor/  |    |    |    |    github.com/pkg/sftp/  |    |    |    |    golang.org/x/crypto/ssh/- 使用vendor的好处是在项目github.com/constabulary/example-gsftp发布时，把其所依赖的软件一并发布，编译时不会受到GOPATH目录的影响，即便GOPATH下也有一个同名但不同版本的依赖包。</code></pre><ul><li><ol start="2"><li><p>搜索顺序</p><ul><li><p>上面的例子中，在编译main.go时，编译器搜索依赖包顺序为：</p><ul><li>从github.com/constabulary/example-gsftp/cmd/gsftp/下寻找vendor目录，没有找到，继续从上层查找；</li><li>从github.com/constabulary/example-gsftp/cmd/下寻找vendor目录，没有找到，继续从上层查找；</li><li>从github.com/constabulary/example-gsftp/下寻找vendor目录，从vendor目录中查找依赖包，结束；</li></ul></li><li><p>如果github.com/constabulary/example-gsftp/下的vendor目录中没有依赖包，则返回到GOPATH目录继续查找，这就是前面介绍的GOPATH机制了。</p></li><li><p>从上面的搜索顺序可以看出，实际上vendor目录可以存在于项目的任意目录的。但非常不推荐这么做，因为如果vendor目录过于分散，很可能会出现同一个依赖包，在项目的多个vendor中出现多次，这样依赖包会多次编译进二进制文件，从而造成二进制大小急剧变大。同时，也很可能出现一个项目中使用同一个依赖包的多个版本的情况，这种情况往往应该避免。</p></li></ul></li></ol></li><li><ol start="3"><li><p>vendor存在的问题</p><ul><li>vendor很好的解决了多项目间的隔离问题，但是位于vendor中的依赖包无法指定版本，某个依赖包，在把它放入vendor的那刻起，它就固定在当时版本，项目的使用者很难识别出你所使用的依赖版本。</li><li>比起这个，更严重的问题是上面提到的二进制急剧扩大问题，比如你依赖某个开源包A和B，但A中也有一个vendor目录，其中也放了B，那么你的项目中将会出现两个开源包B。再进一步，如果这两个开源包B版本不一致呢？如果二者不兼容，那后果将是灾难性的。</li><li>但是，不得不说，vendor能够解决绝大部分项目中的问题，如果你项目在使用vendor，也绝对没有问题。一直到Go 1.11版本，官方社区推出了Modules机制，从此Go的版本管理走进第三个时代。</li></ul></li></ol></li></ul><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>在开始学习module机制之前，我们有必要初步了解一下其涉及的基本概念，比如到底什么是module等。</p><ul><li><p>基础概念</p><ul><li><p>Module的定义</p><ul><li><p>首先，module是个新鲜又熟悉的概念。新鲜是指在以往GOPATH和vendor时代都没有提及，它是个新的词汇。</p></li><li><p>为什么说熟悉呢？因为它不是新的事物，事实上我们经常接触，这次只是官方给了一个统一的称呼而矣。</p></li><li><p>拿开源项目<a href="https://github.com/blang/semver%E4%B8%BE%E4%BE%8B%EF%BC%8C%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E6%98%AF%E4%B8%80%E4%B8%AA%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E5%A4%84%E7%90%86%E5%BA%93%EF%BC%8C%E5%BD%93%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E9%9C%80%E8%A6%81%E6%97%B6%E5%8F%AF%E4%BB%A5%E5%9C%A8%E4%BD%A0%E7%9A%84%E9%A1%B9%E7%9B%AE%E4%B8%ADimport%EF%BC%8C%E6%AF%94%E5%A6%82%EF%BC%9A">https://github.com/blang/semver举例，这个项目是一个语义化版本处理库，当你的项目需要时可以在你的项目中import，比如：</a></p><p>“github.com/blang/semver”</p></li></ul></li></ul></li></ul><pre><code>    - https://github.com/blang/semver项目中可以包含一个或多个package，不管有多少package，这些package都随项目一起发布，即当我们说github.com/blang/semver某个版本时，说的是整个项目，而不是具体的package。此时项目https://github.com/blang/semver就是一个module。    - 官方给module的定义是：A module is a collection of related Go packages that are versioned together as a single unit.，定义非常晰，一组package的集合，一起被标记版本，即是一个module。    - 通常而言，一个仓库包含一个module（虽然也可以包含多个，但不推荐），所以仓库、module和package的关系如下：        - 一个仓库包含一个或多个Go module；        - 每个Go module包含一个或多个Go package；        - 每个package包含一个或多个Go源文件；    - 此外，一个module的版本号规则必须遵循语义化规范（https://semver.org/），版本号必须使用格式`v(major).(minor).(patch)`，比如`v0.1.0`、`v1.2.3` 或v1.5.0-rc.1。- 语义化版本规范    - 语义化版本（Semantic Versioning）已成为事实上的标准，几乎知名的开源项目都遵循该规范，更详细的信息请前往https://semver.org/ 查看，在此只提炼一些要点，以便于后续的阅读。    - 版本格式v(major).(minor).(patch)中major指的是大版本，minor指小版本，patch指补丁版本。        - major: 当发生不兼容的改动时才可以增加major版本；比如v2.x.y与v1.x.y是不兼容的；        - minor: 当有新增特性时才可以增加该版本，比如v1.17.0是在v1.16.0基础上加了新的特性，同时兼容v1.16.0；        - patch: 当有bug修复时才可以 增加该版本，比如v1.17.1修复了v1.17.0上的bug，没有新特性增加；    - 语义化版本规范的好处是，用户通过版本号就能了解版本信息。    - 除了上面介绍的基础概念以外，还有描述依赖的go.mod和记录module的checksum的go.sum等内容，    - 这部分内容比较多且比较复杂，在后面的章节中我们通过实际的例子逐步展开介绍，否则提前暴露过多的细节容易造成困惑而徒生挫败感。</code></pre><ul><li><p>快速实践</p><p>本节我们根据实际的例子来演示go module的功能。在开始之前，我希望读者思考如下问题，并带着这些问题阅读下面的内容或者亲自动手实践以便加深认识。</p></li></ul><pre><code>- Go module到底是做什么的？    - 我们在前面的章节已介绍过，但还是想强调一下，Go module实际上只是精准的记录项目的依赖情况，包括每个依赖的精确版本号，仅此而矣。    - 那么，为什么需要记录这些依赖情况，或者记录这些依赖有什么好处呢？    - 试想一下，在编译某个项目时，第三方包的版本往往是可以替换的，如果不能精确的控制所使用的第三方包的版本，最终构建出的可执行文件从本质上是不同的，这会给问题诊断带来极大的困扰。    - 接下来，我们从一个Hello World项目开始，逐步介绍如何初始化module、如何记录依赖的版本信息。    - 项目托管在GitHub https://github.com/renhongcai/gomodule中，并使用版本号区别使用go module的阶段。        - v1.0.0 未引用任何第三方包，也未使用go module        - v1.1.0 未引用任何第三方包，已开始使用go module，但没有任何外部依赖        - v1.2.0 引用了第三方包，并更新了项目依赖    - 需要注意的是，下面的例子统一使用go 1.13版本，如果你使用go 1.11 或者go 1.12，运行效果可能略有不同。    - 本文最后部分我们尽量尝试记录一些版本间的差异，以供参考。- Hello World    - 在v1.0.0版本时，项目只包含一个main.go文件，只是一个简单的字符串打印：      package main      import &quot;fmt&quot;      func main() &#123;          fmt.Println(&quot;Hello World&quot;)      &#125;    - 此时，项目还没有引用任何第三方包，也未使用go module。- 初始化module    - 一个项目若要使用Go module，那么其本身需要先成为一个module，也即需要一个module名字。    - 在Go module机制下，项目的module名字以及其依赖信息记录在一个名为go.mod的文件中，该文件可以手动创建，也可以使用go mod init命令自动生成。推荐自动生成的方法，如下所示：      [root@ecs-d8b6 gomodule]# go mod init github.com/renhongcai/gomodule      go: creating new go.mod: module github.com/renhongcai/gomodule    - 完整的go mod init命令格式为go mod init [module]：其中[module]为module名字，如果不填，go mod init会尝试从版本控制系统或import的注释中猜测一个。这里推荐指定明确的module名字，因为猜测有时需要一些额外的条件，比如 Go 1.13版本，只有项目位于GOPATH中才可以正确运行，而 Go 1.11版本则没有此要求。    - 上面的命令会自动创建一个go.mod文件，其中包括module名字，以及我们所使用的Go 版本：      [root@ecs-d8b6 gomodule]# cat go.mod       module github.com/renhongcai/gomodule      go 1.13    - go.mod文件中的版本号go 1.13是在Go 1.12引入的，意思是开发此项目的Go语言版本，并不是编译该项目所限制的Go语言版本，但是如果项目中使用了Go 1.13的新特性，而你使用Go 1.11编译的话，编译失败时，编译器会提示你版本不匹配。    - 由于我们的项目还没有使用任何第三方包，所以go.mod中并没有记录依赖包的任何信息。我们把自动生成的go.mod提交，然后我们尝试引用一个第三方包。- 管理依赖    - 现在我们准备引用一个第三方包github.com/google/uuid来生成一个UUID，这样就会产生一个依赖，代码如下：      package main      import (          &quot;fmt&quot;          &quot;github.com/google/uuid&quot;      )      func main() &#123;          id := uuid.New().String()          fmt.Println(&quot;UUID: &quot;, id)      &#125;    - 在开始编译以前，我们先使用go get来分析依赖情况，并会自动下载依赖：      [root@ecs-d8b6 gomodule]# go get       go: finding github.com/google/uuid v1.1.1      go: downloading github.com/google/uuid v1.1.1      go: extracting github.com/google/uuid v1.1.1    - 从输出内容来看，go get帮我们定位到可以使用github.com/google/uuid的v1.1.1版本，并下载再解压它们。    - 注意：go get总是获取依赖的最新版本，如果github.com/google/uuid发布了新的版本，输出的版本信息会相应的变化。关于Go Module机制中版本选择我们将在后续的章节详细介绍。    - go get命令会自动修改go.mod文件：      [root@ecs-d8b6 gomodule]# cat go.mod       module github.com/renhongcai/gomodule      go 1.13      require github.com/google/uuid v1.1.1    - 可以看到，现在go.mod中增加了require github.com/google/uuid v1.1.1内容，表示当前项目依赖github.com/google/uuid的v1.1.1版本，这就是我们所说的go.mod记录的依赖信息。    - 由于这是当前项目第一次引用外部依赖，go get命令还会生成一个go.sum文件，记录依赖包的hash值：      [root@ecs-d8b6 gomodule]# cat go.sum       github.com/google/uuid v1.1.1 h1:Gkbcsh/GbpXz7lPftLA3P6TYMwjCLYm83jiFQZF/3gY=      github.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=    - 该文件通过记录每个依赖包的hash值，来确保依赖包没有被篡改。关于此部分内容我们在此暂不展开介绍，留待后面的章节详细介绍。    - 经go get修改的go.mod和创建的go.sum都需要提交到代码库，这样别人获取到项目代码，编译时就会使用项目所要求的依赖版本。    - 至此，项目已经有一个依赖包，并且可以编译执行了，每次运行都会生成一个独一无二的UUID：      [root@ecs-d8b6 gomodule]# go run main.go      UUID:  20047f5a-1a2a-4c00-bfcd-66af6c67bdfb    - 注：如果你没有使用go get在执行之前下载依赖，而是直接使用go build main.go运行项目的话，依赖包也会被自动下载。但是在v1.13.4中有个bug，即此时生成的go.mod中显示的依赖信息则会是require github.com/google/uuid v1.1.1 // indirect，注意行末的indirect表示间接依赖，这明显是错误的，因为我们直接import的。- 版本间差异    - 由于Go module在Go v1.11初次引入，历经Go v1.12、v1.13的发展，其实现细节上已有了一些变化，按照之前的规划Go module将会在v1.14定型，推荐尽可能使用最新版本，否则可能会产生一些困扰。    - 比如，在v1.11中使用go mod init初始化项目时，不填写module名称是没有问题，但在v1.13中，如果项目不在GOPATH目录中，则必须填写module名称。- 后记    - 本节，我们通过简单的示例介绍了如何初始化module以及如何添加新的依赖，还有更多的内容没有展开。比如go.mod文件中除了 module和require指令外还有replace和exclude指令，再比如go get下载的依赖包如何存储的，以及go.sum如何保证依赖包未被篡改的，这些内容我们留待后面的章节一一介绍。</code></pre><ul><li><p>replace指令</p><p>go.mod文件中通过指令声明module信息，用于控制命令行工具进行版本选择。一共有四个指令可供使用：</p><p>module： 声明module名称；<br>require： 声明依赖以及其版本号；<br>replace： 替换require中声明的依赖，使用另外的依赖及其版本号；<br>exclude： 禁用指定的依赖；<br>其中module和require我们前面已介绍过，module用于指定module的名字，如module github.com/renhongcai/gomodule，那么其他项目引用该module时其import路径需要指定github.com/renhongcai/gomodule。require用于指定依赖，如require github.com/google/uuid v1.1.1，该指令相当于告诉go build使用github.com/google/uuid的v1.1.1版本进行编译。</p><p>本节开始介绍replace的用法，包括其工作机制和常见的使用场景，下一节再对exclude展开介绍。</p></li></ul><pre><code>- replace 工作机制    - 顾名思义，replace指替换，它指示编译工具替换require指定中出现的包，比如，我们在require中指定的依赖如下：      module github.com/renhongcai/gomodule        go 1.13        require github.com/google/uuid v1.1.1    - 此时，我们可以使用go list -m all命令查看最终选定的版本：      [root@ecs-d8b6 gomodule]# go list -m all      github.com/renhongcai/gomodule      github.com/google/uuid v1.1.1    - 毫无意外，最终选定的uuid版本正是我们在require中指定的版本v1.1.1。    - 如果我们想使用uuid的v1.1.0版本进行构建，可以修改require指定，还可以使用replace来指定。    - 需要说明的是，正常情况下不需要使用replace来修改版本，最直接的办法是修改require即可，虽然replace也能够做到，但这不是replace的一般使用场景。    - 下面我们先通过一个简单的例子来说明replace的功能，随即介绍几种常见的使用场景。    - 比如，我们修改go.mod，添加replace指令：      [root@ecs-d8b6 gomodule]# cat go.mod       module github.com/renhongcai/gomodule      go 1.13      require github.com/google/uuid v1.1.1      replace github.com/google/uuid v1.1.1 =&gt; github.com/google/uuid v1.1.0    - replace github.com/google/uuid v1.1.1 =&gt; github.com/google/uuid v1.1.0指定表示替换uuid v1.1.1版本为 v1.1.0，此时再次使用go list -m all命令查看最终选定的版本：      [root@ecs-d8b6 gomodule]# go list -m all       github.com/renhongcai/gomodule      github.com/google/uuid v1.1.1 =&gt; github.com/google/uuid v1.1.0    - 可以看到其最终选择的uuid版本为 v1.1.0。如果你本地没有v1.1.0版本，你或许还会看到一条go: finding github.com/google/uuid v1.1.0信息，它表示在下载uuid v1.1.0包，也从侧面证明最终选择的版本为v1.1.0。    - 到此，我们可以看出replace的作用了，它用于替换require中出现的包，它正常工作还需要满足两个条件：    - 第一，replace仅在当前module为main module时有效，比如我们当前在编译github.com/renhongcai/gomodule，此时就是main module，如果其他项目引用了github.com/renhongcai/gomodule，那么其他项目编译时，replace就会被自动忽略。    - 第二，replace指定中=&gt;前面的包及其版本号必须出现在require中才有效，否则指令无效，也会被忽略。    - 比如，上面的例子中，我们指定replace github.com/google/uuid =&gt; github.com/google/uuid v1.1.0，或者指定replace github.com/google/uuid v1.0.9 =&gt; github.com/google/uuid v1.1.0，二者均都无效。- replace 使用场景  前面的例子中，我们使用replace替换require中的依赖，在实际项目中replace在项目中经常被使用，其中不乏一些精彩的用法。  但不管应用在哪种场景，其本质都一样，都是替换require中的依赖。    - 替换无法下载的包        - 由于中国大陆网络问题，有些包无法顺利下载，比如golang.org组织下的包，值得庆幸的是这些包在GitHub都有镜像，此时        - 就可以使用GitHub上的包来替换。        - 比如，项目中使用了golang.org/x/text包：          package main          import (              &quot;fmt&quot;              &quot;github.com/google/uuid&quot;              &quot;golang.org/x/text/language&quot;              &quot;golang.org/x/text/message&quot;          )          func main() &#123;              id := uuid.New().String()              fmt.Println(&quot;UUID: &quot;, id)              p := message.NewPrinter(language.BritishEnglish)              p.Printf(&quot;Number format: %v.\n&quot;, 1500)              p = message.NewPrinter(language.Greek)              p.Printf(&quot;Number format: %v.\n&quot;, 1500)          &#125;        - 上面的简单例子，使用两种语言language.BritishEnglish 和language.Greek分别打印数字1500，来查看不同语言对数字格式的处理，一个是1,500，另一个是1.500。此时就会分别引入&quot;golang.org/x/text/language&quot; 和&quot;golang.org/x/text/message&quot;。        - 执行go get 或go build命令时会就再次分析依赖情况，并更新go.mod文件。网络正常情况下，go.mod文件将会变成下面的内容：          module github.com/renhongcai/gomodule          go 1.13          require (              github.com/google/uuid v1.1.1              golang.org/x/text v0.3.2          )          replace github.com/google/uuid v1.1.1 =&gt; github.com/google/uuid v1.1.0        - 我们看到，依赖golang.org/x/text被添加到了require中。（多条require语句会自动使用()合并）。此外，我们没有刻意指定golang.org/x/text的版本号，Go命令行工具根据默认的版本计算规则使用了 v0.3.2版本，此处我们暂不关心具体的版本号。        - 没有合适的网络代理情况下，golang.org/x/text 很可能无法下载。那么此时，就可以使用replace来让我们的项目使用GitHub上相应的镜像包。我们可以添加一条新的replace条目，如下所示：          replace (              github.com/google/uuid v1.1.1 =&gt; github.com/google/uuid v1.1.0              golang.org/x/text v0.3.2 =&gt; github.com/golang/text v0.3.2          )        - 此时，项目编译时就会从GitHub下载包。我们源代码中import路径 golang.org/x/text/xxx不需要改变。        - 也许有读者会问，是否可以将import路径由golang.org/x/text/xxx改成github.com/golang/text/xxx？这样一来，就不需要使用replace来替换包了。        - 遗憾的是，不可以。因为github.com/golang/text只是镜像仓库，其go.mod文件中定义的module还是module golang.org/x/text，这个module名字直接决定了你的import的路径。    - 调试依赖包        - 有时我们需要调试依赖包，此时就可以使用replace来修改依赖，如下所示：          replace (          github.com/google/uuid v1.1.1 =&gt; ../uuid          golang.org/x/text v0.3.2 =&gt; github.com/golang/text v0.3.2          )        - )        - 语句github.com/google/uuid v1.1.1 =&gt; ../uuid使用本地的uuid来替换依赖包，此时，我们可以任意地修改../uuid目录的内容来进行调试。        - 除了使用相对路径，还可以使用绝对路径，甚至还可以使用自已的fork仓库。    - 使用fork仓库        - 有时在使用开源的依赖包时发现了bug，在开源版本还未修改或者没有新的版本发布时，你可以使用fork仓库，在fork仓库中进行bug fix。        - 你可以在fork仓库上发布新的版本，并相应的修改go.mod来使用fork仓库。        - 比如，我fork了开源包github.com/google/uuid，fork仓库地址为github.com/RainbowMango/uuid，那我们就可以在fork仓库里修改bug并发布新的版本v1.1.2，此时使用fork仓库的项目中go.mod中replace部分可以相应的做如下修改：          github.com/google/uuid v1.1.1 =&gt; github.com/RainbowMango/uuid v1.1.2        - 需要说明的是，使用fork仓库仅仅是临时的做法，一旦开源版本变得可用，需要尽快切换到开源版本。    - 禁止被依赖        - 另一种使用replace的场景是你的module不希望被直接引用，比如开源软件kubernetes，在它的go.mod中require部分有大量的v0.0.0依赖，比如：          module k8s.io/kubernetes          require (              ...              k8s.io/api v0.0.0              k8s.io/apiextensions-apiserver v0.0.0              k8s.io/apimachinery v0.0.0              k8s.io/apiserver v0.0.0              k8s.io/cli-runtime v0.0.0              k8s.io/client-go v0.0.0              k8s.io/cloud-provider v0.0.0              ...          )        - 由于上面的依赖都不存在v0.0.0版本，所以其他项目直接依赖k8s.io/kubernetes时会因无法找到版本而无法使用。        - 因为Kubernetes不希望作为module被直接使用，其他项目可以使用kubernetes其他子组件。        - kubernetes 对外隐藏了依赖版本号，其真实的依赖通过replace指定：          replace (              k8s.io/api =&gt; ./staging/src/k8s.io/api              k8s.io/apiextensions-apiserver =&gt; ./staging/src/k8s.io/apiextensions-apiserver              k8s.io/apimachinery =&gt; ./staging/src/k8s.io/apimachinery              k8s.io/apiserver =&gt; ./staging/src/k8s.io/apiserver              k8s.io/cli-runtime =&gt; ./staging/src/k8s.io/cli-runtime              k8s.io/client-go =&gt; ./staging/src/k8s.io/client-go              k8s.io/cloud-provider =&gt; ./staging/src/k8s.io/cloud-provider          )        - 前面我们说过，replace指令在当前模块不是main module时会被自动忽略的，Kubernetes正是利用了这一特性来实现对外隐藏依赖版本号来实现禁止直接引用的目的。</code></pre><ul><li><p>exclude指令</p><p> GO专家编程<br> 首页<br>目录<br>搜索</p><p>前言</p><p>常见数据结构实现原理</p><p>常见控制结构实现原理</p><p>协程</p><p>内存管理</p><p>并发控制</p><p>反射</p><p>测试</p><p>httptest</p><p>定时器</p><p>Timer</p><p>快速开始</p><p>实现原理</p><p>Ticker</p><p>timer</p><p>案例</p><p>语法糖</p><p>简短变量声明</p><p>可变参函数</p><p>GO语言版本管理</p><p>GO语言安装</p><p>GO语言卸载</p><p>GO依赖管理</p><p>GOPATH</p><p>vendor</p><p>module</p><p>基础概念</p><p>快速实践</p><p>replace指令</p><p>exclude指令</p><p>indirect含义</p><p>版本选择机制</p><p>incompatible</p><p>伪版本</p><p>依赖包存储</p><p>go.sum文件</p><p>编程陷阱</p><p>切片追加</p><p>循环变量绑定<br>本文档使用 topgoer 发布<br>go.mod文件中的exclude指令用于排除某个包的特定版本，其与replace类似，也仅在当前module为main module时有效，其他项目引用当前项目时，exclude指令会被忽略。</p><p>exclude指令在实际的项目中很少被使用，因为很少会显式地排除某个包的某个版本，除非我们知道某个版本有严重bug。<br>比如指令exclude github.com/google/uuid v1.1.0，表示不使用v1.1.0 版本。</p><p>下面我们还是使用github.com/renhongcai/gomodule来举例说明。</p></li></ul><pre><code>- 排除指定版本    - 在 github.com/renhongcai/gomodule的v1.3.0版本中，我们的go.mod文件如下：      module github.com/renhongcai/gomodule        go 1.13        require (          github.com/google/uuid v1.0.0          golang.org/x/text v0.3.2        )        replace golang.org/x/text v0.3.2 =&gt; github.com/golang/text v0.3.2    - github.com/google/uuid v1.0.0说明我们期望使用 uuid包的v1.0.0版本。    - 假如，当前uuid仅有v1.0.0 、v1.1.0和v1.1.1三个版本可用，而且我们假定v1.1.0版本有严重bug。    - 此时可以使用exclude指令将uuid的v1.1.0版本排除在外，即在go.mod文件添加如下内容：      exclude github.com/google/uuid v1.1.0    - 虽然我们暂时没有使用uuid的v1.1.0版本，但如果将来引用了其他包，正好其他包引用了uuid的v1.1.0版本的话，此时添加的exclude指令就会跳过v1.1.0版本。    - 下面我们创建github.com/renhongcai/exclude包来验证该问题。- 创建依赖包    - 为了进一步说明exclude用法，我们创建了一个仓库github.com/renhongcai/exclude，并在其中创建了一个modulegithub.com/renhongcai/exclude，其中go.mod文件（v1.0.0版本）如下：      module github.com/renhongcai/exclude      go 1.13      require github.com/google/uuid v1.1.0    - 可以看出其依赖github.com/google/uuid 的 v1.1.0 版本。创建github.com/renhongcai/exclude的目的是供github.com/renhongcai/gomodule使用的。- 使用依赖包    - 由于github.com/renhongcai/exclude也引用了uuid包且引用了更新版本的uuid，那么在github.com/renhongcai/gomodule引用github.com/renhongcai/exclude时，会被动的提升uuid的版本。    - 在没有添加exclude之前，编译时github.com/renhongcai/gomodule依赖的uuid版本会提升到v1.1.0，与github.com/renhongcai/exclude保持一致，相应的go.mod也会被自动修改，如下所示：      module github.com/renhongcai/gomodule      go 1.13      require (          github.com/google/uuid v1.1.0          github.com/renhongcai/exclude v1.0.0          golang.org/x/text v0.3.2      )      replace golang.org/x/text v0.3.2 =&gt; github.com/golang/text v0.3.2    - 但如果添加了exclude github.com/google/uuid v1.1.0 指令后，编译时github.com/renhongcai/gomodule依赖的uuid版本会自动跳过v1.1.0，即选择v1.1.1版本，相应的go.mod文件如下所示：      module github.com/renhongcai/gomodule      go 1.13      require (          github.com/google/uuid v1.1.1          github.com/renhongcai/exclude v1.0.0          golang.org/x/text v0.3.2      )      replace golang.org/x/text v0.3.2 =&gt; github.com/golang/text v0.3.2      exclude github.com/google/uuid v1.1.0    - 在本例中，在选择版本时，跳过uuid v1.1.0版本后还有v1.1.1版本可用，Go 命令行工具可以自动选择v1.1.1版本，但如果没有更新的版本时将会报错而无法编译。</code></pre><ul><li><p>indirect含义</p><p>在使用 Go module 过程中，随着引入的依赖增多，也许你会发现go.mod文件中部分依赖包后面会出现一个// indirect的标识。这个标识总是出现在require指令中，其中//与代码的行注释一样表示注释的开始，indirect表示间接的依赖。</p><p>比如开源软件 Kubernetes（v1.17.0版本）的 go.mod 文件中就有数十个依赖包被标记为indirect：</p><p>require (</p><pre><code>github.com/Rican7/retry v0.1.0 // indirectgithub.com/auth0/go-jwt-middleware v0.0.0-20170425171159-5493cabe49f7 // indirectgithub.com/boltdb/bolt v1.3.1 // indirectgithub.com/checkpoint-restore/go-criu v0.0.0-20190109184317-bdb7599cd87b // indirectgithub.com/codegangsta/negroni v1.0.0 // indirect...</code></pre><p>)<br>在执行命令go mod tidy时，Go module 会自动整理go.mod 文件，如果有必要会在部分依赖包的后面增加// indirect注释。一般而言，被添加注释的包肯定是间接依赖的包，而没有添加// indirect注释的包则是直接依赖的包，即明确的出现在某个import语句中。</p><p>然而，这里需要着重强调的是：并不是所有的间接依赖都会出现在 go.mod文件中。</p><p>间接依赖出现在go.mod文件的情况，可能符合下面所列场景的一种或多种：</p><p>直接依赖未启用 Go module<br>直接依赖go.mod 文件中缺失部分依赖</p></li></ul><pre><code>- 直接依赖未启用 Go module    - 如下图所示，Module A 依赖 B，但是 B 还未切换成 Module，也即没有go.mod文件，此时，当使用go mod tidy命令更新A的go.mod文件时，B的两个依赖B1和B2将会被添加到A的go.mod文件中（前提是A之前没有依赖B1和B2），并且B1 和B2还会被添加// indirect的注释。    - 此时Module A的go.mod文件中require部分将会变成：      require (          B vx.x.x          B1 vx.x.x // indirect          B2 vx.x.x // indirect      )    - 依赖B及B的依赖B1和B2都会出现在go.mod文件中。- 直接依赖 go.mod 文件不完整    - 如上面所述，如果依赖B没有go.mod文件，则Module A 将会把B的所有依赖记录到A 的go.mod文件中。即便B拥有go.mod，如果go.mod文件不完整的话，Module A依然会记录部分B的依赖到go.mod文件中。    - 如下图所示，Module B虽然提供了go.mod文件中，但go.mod文件中只添加了依赖B1，那么此时A在引用B时，则会在A的go.mod文件中添加B2作为间接依赖，B1则不会出现在A的go.mod文件中。    - 此时Module A的go.mod文件中require部分将会变成：      require (          B vx.x.x          B2 vx.x.x // indirect      )    - 由于B1已经包含进B的go.mod文件中，A的go.mod文件则不必再记录，只会记录缺失的B2。- 总结    - 为什么要记录间接依赖        - 在上面的例子中，如果某个依赖B 没有go.mod文件，在A 的go.mod文件中已经记录了依赖B及其版本号，为什么还要增加间接依赖呢？        - 我们知道Go module需要精确地记录软件的依赖情况，虽然此处记录了依赖B的版本号，但B的依赖情况没有记录下来，所以如果B的go.mod文件缺失了（或没有）这个信息，则需要在A的go.mod文件中记录下来。此时间接依赖的版本号将会根据Go module的版本选择机制确定一个最优版本。    - 如何处理间接依赖        - 综上所述间接依赖出现在go.mod中，可以一定程度上说明依赖有瑕疵，要么是其不支持Go module，要么是其go.mod文件不完整。        - 由于Go 语言从v1.11版本才推出module的特性，众多开源软件迁移到go module还需要一段时间，在过渡期必然会出现间接依赖，但随着时间的推进，在go.mod中出现// indirect的机率会越来越低。        - 出现间接依赖可能意味着你在使用过时的软件，如果有精力的话还是推荐尽快消除间接依赖。可以通过使用依赖的新版本或者替换依赖的方式消除间接依赖。    - 如何查找间接依赖来源        - Go module提供了go mod why 命令来解释为什么会依赖某个软件包，若要查看go.mod中某个间接依赖是被哪个依赖引入的，可以使用命令go mod why -m &lt;pkg&gt;来查看。        - 比如，我们有如下的go.mod文件片断：          require (              github.com/Rican7/retry v0.1.0 // indirect              github.com/google/uuid v1.0.0              github.com/renhongcai/indirect v1.0.0              github.com/spf13/pflag v1.0.5 // indirect              golang.org/x/text v0.3.2          )        - 我们希望确定间接依赖github.com/Rican7/retry v0.1.0 // indirect是被哪个依赖引入的，则可以使用命令go mod why来查看：          [root@ecs-d8b6 gomodule]# go mod why -m github.com/Rican7/retry          # github.com/Rican7/retry          github.com/renhongcai/gomodule          github.com/renhongcai/indirect          github.com/Rican7/retry    - 上面的打印信息中# github.com/Rican7/retry 表示当前正在分析的依赖，后面几行则表示依赖链。github.com/renhongcai/gomodule 依赖github.com/renhongcai/indirect，而github.com/renhongcai/indirect依赖github.com/Rican7/retry。由此我们就可以判断出间接依赖github.com/Rican7/retry是被github.com/renhongcai/indirect引入的。    - 另外，命令go mod why -m all则可以分析所有依赖的依赖链。</code></pre><ul><li><p>版本选择机制</p><p>在前面的章节中，我们使用过go get <pkg>来获取某个依赖，如果没有特别指定依赖的版本号，go get会自动选择一个最优版本，并且如果本地有go.mod文件的话，还会自动更新go.mod文件。</p><p>事实上除了go get，go build和go mod tidy也会自动帮我们选择依赖的版本。这些命令选择依赖版本时都遵循一些规则，本节我们就开始介绍Go module涉及到的版本选择机制。</p></li></ul><pre><code>- 依赖包版本约定  关于如何管理依赖包的版本，Go语言提供了一个规范，并且Go语言的演进过程中也一直遵循这个规范。  这个非强制性的规范主要围绕包的兼容性展开。对于如何处理依赖包的兼容性，根据是否支持Go module分别有不同的建议。    - Go module 之前版本兼容性        - 在Go v1.11（开始引入Go module的版本）之前，Go 语言建议依赖包需要保持向后兼容，这包括可导出的函数、变量、类型、常量等不可以随便删除。以函数为例，如果需要修改函数的入参，可以增加新的函数而不是直接修改原有的函数。        - 如果确实需要做一些打破兼容性的修改，建议创建新的包。        - 比如仓库github.com/RainbowMango/xxx中包含一个package A，此时该仓库只有一个package：          github.com/RainbowMango/xxx/A        - 那么其他项目引用该依赖时的import 路径为：          import &quot;github.com/RainbowMango/xxx/A&quot;        - 如果该依赖包需要引入一个不兼容的特性，可以在该仓库中增加一个新的package A1，此时该仓库包含两个包：          github.com/RainbowMango/xxx/A          github.com/RainbowMango/xxx/A1        - 那么其他项目在升级依赖包版本后不需要修改原有的代码可以继续使用package A，如果需要使用新的package A1，只需要将import 路径修改为import &quot;github.com/RainbowMango/xxx/A1&quot;并做相应的适配即可。    - Go module 之后版本兼容性        - 从Go v1.11版本开始，随着Go module特性的引入，依赖包的兼容性要求有了进一步的延伸，Go module开始关心依赖包版本管理系统（如Git）中的版本号。尽管如此，兼容性要求的核心内容没有改变：            - 如果新package 和旧的package拥有相同的import 路径，那么新package必须兼容旧的package;            - 如果新的package不能兼容旧的package，那么新的package需要更换import路径；        - 在前面的介绍中，我们知道Go module 的go.mod中记录的module名字决定了import路径。例如，要引用module module github.com/renhongcai/indirect中的内容时，其import路径需要为import github.com/renhongcai/indirect。        - 在Go module时代，module版本号要遵循语义化版本规范，即版本号格式为v&lt;major&gt;.&lt;minor&gt;.&lt;patch&gt;，如v1.2.3。当有不兼容的改变时，需要增加major版本号，如v2.1.0。        - Go module规定，如果major版本号大于1，则major版本号需要显式地标记在module名字中，如module github.com/my/mod/v2。这样做的好处是Go module 会把module github.com/my/mod/v2 和 module github.com/my/mod视做两个module，他们甚至可以被同时引用。        - 另外，如果module的版本为v0.x.x或v1.x.x则都不需要在module名字中体现版本号。- 版本选择机制  Go 的多个命令行工具都有自动选择依赖版本的能力，如go build 和go test，当在源代码中增加了新的import，这些命令将会自动选择一个最优的版本，并更新go.mod文件。  需要特别说明的是，如果go.mod文件中已标记了某个依赖包的版本号，则这些命令不会主动更新go.mod中的版本号。所谓自动更新版本号只在go.mod中缺失某些依赖或者依赖不匹配时才会发生。    - 最新版本选择        - 当在源代码中新增加了一个import，比如：        - import &quot;github.com/RainbowMango/M&quot;        - 如果go.mod的require指令中并没有包含github.com/RainbowMango/M这个依赖，那么go build 或go test命令则会去github.com/RainbowMango/M仓库寻找最新的符合语义化版本规范的版本，比如v1.2.3，并在go.mod文件中增加一条require依赖：        - require github.com/RainbowMango/M v1.2.3        - 这里，由于import路径里没有类似于v2或更高的版本号，所以版本选择时只会选择v1.x.x的版本，不会去选择v2.x.x或更高的版本。    - 最小版本选择        - 有时记录在go.mod文件中的依赖包版本会随着引入其他依赖包而发生变化。        - 如下图所示：        - Module A 依赖 Module M的v1.0.0版本，但之后 Module A 引入了 Module D，而Module D 依赖 Module M的v1.1.1版本，此时，由于依赖的传递，Module A也会选择v1.1.1版本。        - 需要注意的是，此时会自动选择最小可用的版本，而不是最新的tag版本。    - 总结        - 本节我们先是介绍了Go 语言针对依赖包版本管理的约定，这个不能算是强制性的要求，但如果不遵守该约定，后续该依赖包的使用者将会遇到各麻烦，最终有可能弃用这个不规范的依赖包。        - 接着介绍了Go module机制所采用的自动版本选择算法，除了自动版本选择以外，我们还可以显式地指定依赖包的版本。另外，除了在go.mod文件中指定依赖的tag 版本号以外，还可以使用假的版本号，这些内容我们将在后续的章节中分别展开介绍。</code></pre><ul><li><p>incompatible</p><p>在前面的章节中，我们介绍了Go module的版本选择机制，其中介绍了一个Module的版本号需要遵循v<major>.<minor>.<patch>的格式，此外，如果major版本号大于1时，其版本号还需要体现在Module名字中。</p><p>比如Module github.com/RainbowMango/m，如果其版本号增长到v2.x.x时，其Module名字也需要相应的改变为：<br>github.com/RainbowMango/m/v2。即，如果major版本号大于1时，需要在Module名字中体现版本。</p><p>那么如果Module的major版本号虽然变成了v2.x.x，但Module名字仍保持原样会怎么样呢？ 其他项目是否还可以引用呢？其他项目引用时有没有风险呢？这就是今天要讨论的内容。</p></li></ul><pre><code>- 能否引用不兼容的包    - 我们还是以Module github.com/RainbowMango/m 为例，假如其当前版本为v3.6.0，因为其Module名字未遵循Golang所推荐的风格，即Module名中附带版本信息，我们称这个Module为不规范的Module。    - 不规范的Module还是可以引用的，但跟引用规范的Module略有差别。    - 如果我们在项目A中引用了该module，使用命令go mod tidy，go 命令会自动查找Module m的最新版本，即v3.6.0。    - 由于Module为不规范的Module，为了加以区分，go 命令会在go.mod中增加+incompatible 标识。      require (          github.com/RainbowMango/m v3.6.0+incompatible      )    - 除了增加+incompatible（不兼容）标识外，在其使用上没有区别。- 如何处理incompatible    - go.mod文件中出现+incompatible，说明你引用了一个不规范的Module，正常情况下，只能说明这个Module版本未遵循版本化语义规范。但引用这个规范的Module还是有些困扰，可能还会有一定的风险。    - 比如，我们拿某开源Module github.com/blang/semver为例，编写本文时，该Module最新版本为v3.6.0，但其go.mod中记录的Module却是：      module github.com/blang/semver    - Module github.com/blang/semver 在另一个著名的开源软件Kubernetes（github.com/kubernetes/kubernetes）中被引用，那么Kubernetes的go.mod文件则会标记这个Module为+incompatible：      require (          ...          github.com/blang/semver v3.5.0+incompatible          ...      ）    - 站在Kubernetes的角度，此处的困扰在于，如果将来 github.com/blang/semver发布了新版本v4.0.0，但不幸的是Module名字仍然为github.com/blang/semver。那么，升级这个Module的版本将会变得困难。因为v3.6.0到v4.0.0跨越了大版本，按照语义化版本规范来解释说明发生了不兼容的改变，即然不兼容，项目维护者有必须对升级持谨慎态度，甚至放弃升级。    - 站在github.com/blang/semver的角度，如果迟迟不能将自身变得”规范”，那么其他项目有可能放弃本Module，转而使用其他更规范的Module来替代，开源项目如果没有使用者，也就走到了尽头。</code></pre><ul><li><p>伪版本</p><p>在go.mod中通常使用语义化版本来标记依赖，比如v1.2.3、v0.1.5等。因为go.mod文件通常是go命令自动生成并修改的，所以实际上是go命令习惯使用语义化版本。</p><p>诸如v1.2.3和v0.1.5这样的语义化版本，实际是某个commit ID的标记，真正的版本还是commit ID。比如github.com/renhongcai/gomodule项目的v1.5.0对应的真实版本为20e9757b072283e5f57be41405fe7aaf867db220。</p><p>由于语义化版本比commit ID更直观（方便交流与比较版本大小），所以一般情况下使用语义化版本。</p></li></ul><pre><code>- 什么是伪版本    - 在实际项目中，有时不得不直接使用一个commit ID，比如某项目发布了v1.5.0版本，但随即又修复了一个bug（引入一个新的commit ID），而且没有发布新的版本。此时，如果我们希望使用最新的版本，就需要直接引用最新的commit ID，而不是之前的语义化版本v1.5.0。    - 使用commit ID的版本在Go语言中称为pseudo-version，可译为”伪版本”。    - 伪版本的版本号通常会使用vx.y.z-yyyymmddhhmmss-abcdefabcdef格式，其中vx.y.z看上去像是一个真实的语义化版本，但通常并不存在该版本，所以称为伪版本。另外abcdefabcdef表示某个commit ID的前12位，而yyyymmddhhmmss则表示该commit的提交时间，方便做版本比较。    - 使用伪版本的go.mod举例如下：      ...      require (          go.etcd.io/etcd v0.0.0-20191023171146-3cf2f69b5738      )      ...- 伪版本风格    - 伪版本格式都为vx.y.z-yyyymmddhhmmss-abcdefabcdef，但vx.y.z部分在不同情况下略有区别，有时可能是vx.y.z-pre.0或者vx.y.z-0，甚至vx.y.z-dev.2.0等。    - vx.y.z的具体格式取决于所引用commit ID之前的版本号，如果所引用commit ID之前的最新的tag版本为v1.5.0，那么伪版本号则在其基础上增加一个标记，即v1.5.1-0，看上去像是下一个版本一样。    - 实际使用中go命令会帮我们自动生成伪版本，不需要手动计算，所以此处我们仅做基本说明。- 如何获取伪版本    - 我们使用具体的例子还演示如何使用伪版本。在仓库github.com/renhongcai/gomodule中存在v1.5.0 tag 版本，在v1.5.0之后又提交了一个commit，并没有发布新的版本。其版本示意图如下：    - 为了方便描述，我们把v1.5.0对应的commit 称为commit-A，而其随后的commit称为commit-B。    - 如果我们要使用commit-A，即v1.5.0，可使用go get github.com/renhongcai/gomodule@v1.5.0命令：      [root@ecs-d8b6 ~]# go get github.com/renhongcai/gomodule@v1.5.0      go: finding github.com/renhongcai/gomodule v1.5.0      go: downloading github.com/renhongcai/gomodule v1.5.0      go: extracting github.com/renhongcai/gomodule v1.5.0      go: finding github.com/renhongcai/indirect v1.0.1    - 此时，如果存在go.mod文件，github.com/renhongcai/gomodule体现在go.mod文件的版本为v1.5.0。    - 如果我们要使用commit-B，可使用go get github.com/renhongcai/gomodule@6eb27062747a458a27fb05fceff6e3175e5eca95命令（可以使用完整的commit id，也可以只使用前12位）：      [root@ecs-d8b6 ~]# go get github.com/renhongcai/gomodule@6eb27062747a458a27fb05fceff6e3175e5eca95      go: finding github.com 6eb27062747a458a27fb05fceff6e3175e5eca95      go: finding github.com/renhongcai/gomodule 6eb27062747a458a27fb05fceff6e3175e5eca95      go: finding github.com/renhongcai 6eb27062747a458a27fb05fceff6e3175e5eca95      go: downloading github.com/renhongcai/gomodule v1.5.1-0.20200203082525-6eb27062747a      go: extracting github.com/renhongcai/gomodule v1.5.1-0.20200203082525-6eb27062747a      go: finding github.com/renhongcai/indirect v1.0.2    - 此时，可以看到生成的伪版本号为v1.5.1-0.20200203082525-6eb27062747a，当前最新版本为v1.5.0，go命令生成伪版本号时自动增加了版本。此时，如果存在go.mod文件的话，github.com/renhongcai/gomodule体现在go.mod文件中的版本则为该伪版本号。</code></pre><ul><li><p>依赖包存储</p><p>在前面介绍GOPATH的章节中，我们提到GOPATH模式下不方便使用同一个依赖包的多个版本。在GOMODULE模式下这个问题得到了很好的解决。</p><p>GOPATH模式下，依赖包存储在$GOPATH/src，该目录下只保存特定依赖包的一个版本，而在GOMODULE模式下，依赖包存储在$GOPATH/pkg/mod，该目录中可以存储特定依赖包的多个版本。</p><p>需要注意的是$GOPATH/pkg/mod目录下有个cache目录，它用来存储依赖包的缓存，简单说，go命令每次下载新的依赖包都会在该cache目录中保存一份。关于该目录的工作机制我们留到GOPROXY章节时再详细介绍。</p><p>接下来，我们使用开源项目github.com/google/uuid为例分别说明GOPATH模式和GOMODULE模式下特定依赖包存储机制。在下面的操作中，我们会使用GO111MODULE环境变量控制具体的模式：</p><p>export GO111MODULE=off切换到GOPATH模式<br>export GO111MODULE=on切换到GOMODULE模式。</p></li></ul><pre><code>- GOPATH 依赖包存储    - 为了实验GOPATH模式下依赖包的存储方式，我们可以使用以下命令来获取github.com/google/uuid：      # export GO111MODULE=off      # go get -v github.com/google/uuid    - 在GOPATH模式下，go get命令会将依赖包下载到$GOPATH/src/google目录中。    - 该命令等同于在$GOPATH/src/google目录下执行git clone https://github.com/google/uuid.git，也就是$GOPATH/src/google/uuid目录中存储的是完整的仓库。- GOMODULE 依赖包存储    - 为了实验GOMODULE模式下依赖的存储方式，我们使用以下命令来获取github.com/google/uuid：      # export GO111MODULE=on      # go get -v github.com/google/uuid      # go get -v github.com/google/uuid@v1.0.0      # go get -v github.com/google/uuid@v1.1.0      # go get -v github.com/google/uuid@v1.1.1    - 在GOMODULE模式下，go get命令会将依赖包下载到$GOPATH/pkg/mod目录下，并且按照依赖包的版本分别存放。（注：go get命令不指定特定版本时，默认会下载最新版本，即v1.1.1，如软件包有新版本发布，实验结果将有所不同。）    - 此时$GOPATH/pkg/mod目录结构如下：      $&#123;GOPATH&#125;/pkg/mod/github.com/google      ├── uuid@v1.0.0      ├── uuid@v1.1.0      ├── uuid@v1.1.1    - 相较于GOPATH模式，GOMODULE有两处不同点：        - 一是依赖包的目录中包含了版本号，每个版本占用一个目录；        - 二是依赖包的特定版本目录中只包含依赖包文件，不包含.git目录；    - 由于依赖包的每个版本都有一个唯一的目录，所以在多项目场景中需要使用同一个依赖包的多版本时才不会产生冲突。另外，由于依赖包的每个版本都有唯一的目录，也表示该目录内容不会发生改变，也就不必再存储其位于版本管理系统(如git)中的信息。- 包名大小写敏感问题    - 有时我们使用的包名中会包含大写字母，比如github.com/Azure/azure-sdk-for-go，GOMODULE模式下，在存储时会将包名做大小写编码处理，即每个大写字母将变与!+相应的小写字母，比如github.com/Azure包在存储时将会被放置在$GOPATH/pkg/mod/github.com/!azure目录中。    - 需要注意的是，GOMODULE模式下，我们使用go get命令时，如果不小心将某个包名大小写搞错，比如github.com/google/uuid写成github.com/google/UUID时，在存储依赖包时会严格按照go get命令指示的包名进行存储。    - 如下所示，使用大写的UUID:      [root@ecs-d8b6 uuid]# go get -v github.com/google/UUID@v1.0.0      go: finding github.com v1.0.0      go: finding github.com/google v1.0.0      go: finding github.com/google/UUID v1.0.0      go: downloading github.com/google/UUID v1.0.0      go: extracting github.com/google/UUID v1.0.0      github.com/google/UUID    - 由于github.com/google/uuid域名不区分大小写，所以使用github.com/google/UUID下载包时仍然可以下载，但在存储时将会严格区分大小写，此时$GOPATH/pkg/mod/google/目录下将会多出一个d@v1.0.0&quot;&quot;&gt;`!u!u!i!d@v1.0.0`目录：      $&#123;GOPATH&#125;/pkg/mod/github.com/google      ├── uuid@v1.0.0      ├── uuid@v1.1.0      ├── uuid@v1.1.1      ├── !u!u!i!d@v1.0.0    - 在go get中使用错误的包名，除了会增加额外的不必要存储外，还可能会影响go命令解析依赖，还可能将错误的包名使用到import指令中，所以在实际使用时应该尽量避免。</code></pre><ul><li><p>go.sum文件</p><p>为了确保一致性构建，Go引入了go.mod文件来标记每个依赖包的版本，在构建过程中go命令会下载go.mod中的依赖包，下载的依赖包会缓存在本地，以便下次构建。<br>考虑到下载的依赖包有可能是被黑客恶意篡改的，以及缓存在本地的依赖包也有被篡改的可能，单单一个go.mod文件并不能保证一致性构建。</p><p>为了解决Go module的这一安全隐患，Go开发团队在引入go.mod的同时也引入了go.sum文件，用于记录每个依赖包的哈希值，在构建时，如果本地的依赖包hash值与go.sum文件中记录得不一致，则会拒绝构建。</p><p>本节暂不对模块校验细节展开介绍，只从日常应用层面介绍：</p><p>go.sum 文件记录含义<br>go.sum文件内容是如何生成的<br>go.sum是如何保证一致性构建的</p></li></ul><pre><code>- go.sum文件记录    - go.sum文件中每行记录由module名、版本和哈希组成，并由空格分开：      &lt;module&gt; &lt;version&gt;[/go.mod] &lt;hash&gt;    - 比如，某个go.sum文件中记录了github.com/google/uuid 这个依赖包的v1.1.1版本的哈希值：      github.com/google/uuid v1.1.1 h1:Gkbcsh/GbpXz7lPftLA3P6TYMwjCLYm83jiFQZF/3gY=        github.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=    - 在Go module机制下，我们需要同时使用依赖包的名称和版本才可以准确的描述一个依赖，为了方便叙述，下面我们使用依赖包版本来指代依赖包名称和版本。    - 正常情况下，每个依赖包版本会包含两条记录，第一条记录为该依赖包版本整体（所有文件）的哈希值，第二条记录仅表示该依赖包版本中go.mod文件的哈希值，如果该依赖包版本没有go.mod文件，则只有第一条记录。如上面的例子中，v1.1.1表示该依赖包版本整体，而v1.1.1/go.mod表示该依赖包版本中go.mod文件。    - 依赖包版本中任何一个文件（包括go.mod）改动，都会改变其整体哈希值，此处再额外记录依赖包版本的go.mod文件主要用于计算依赖树时不必下载完整的依赖包版本，只根据go.mod即可计算依赖树。    - 每条记录中的哈希值前均有一个表示哈希算法的h1:，表示后面的哈希值是由算法SHA-256计算出来的，自Go module从v1.11版本初次实验性引入，直至v1.14 ，只有这一个算法。    - 此外，细心的读者或许会发现go.sum文件中记录的依赖包版本数量往往比go.mod文件中要多，这是因为二者记录的粒度不同导致的。go.mod只需要记录直接依赖的依赖包版本，只在依赖包版本不包含go.mod文件时候才会记录间接依赖包版本，而go.sum则是要记录构建用到的所有依赖包版本。- 生成    - 假设我们在开发某个项目，当我们在GOMODULE模式下引入一个新的依赖时，通常会使用go get命令获取该依赖，比如：      go get github.com/google/uuid@v1.0.0    - go get命令首先会将该依赖包下载到本地缓存目录$GOPATH/pkg/mod/cache/download，该依赖包为一个后缀为.zip的压缩包，如v1.0.0.zip。go get下载完成后会对该.zip包做哈希运算，并将结果存放在后缀为.ziphash的文件中，如v1.0.0.ziphash。如果在项目的根目录中执行go get命令的话，go get会同步更新go.mod和go.sum文件，go.mod中记录的是依赖名及其版本，如：      require (          github.com/google/uuid v1.0.0      )    - go.sum文件中则会记录依赖包的哈希值（同时还有依赖包中go.mod的哈希值），如：      github.com/google/uuid v1.0.0 h1:b4Gk+7WdP/d3HZH8EJsZpvV7EtDOgaZLtnaNGIu1adA=      github.com/google/uuid v1.0.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=    - 值得一提的是，在更新go.sum之前，为了确保下载的依赖包是真实可靠的，go命令在下载完依赖包后还会查询GOSUMDB环境变量所指示的服务器，以得到一个权威的依赖包版本哈希值。如果go命令计算出的依赖包版本哈希值与GOSUMDB服务器给出的哈希值不一致，go命令将拒绝向下执行，也不会更新go.sum文件。    - go.sum存在的意义在于，我们希望别人或者在别的环境中构建当前项目时所使用依赖包跟go.sum中记录的是完全一致的，从而达到一致构建的目的。- 校验    - 假设我们拿到某项目的源代码并尝试在本地构建，go命令会从本地缓存中查找所有go.mod中记录的依赖包，并计算本地依赖包的哈希值，然后与go.sum中的记录进行对比，即检测本地缓存中使用的依赖包版本是否满足项目go.sum文件的期望。    - 如果校验失败，说明本地缓存目录中依赖包版本的哈希值和项目中go.sum中记录的哈希值不一致，go命令将拒绝构建。    - 这就是go.sum存在的意义，即如果不使用我期望的版本，就不能构建。    - 当校验失败时，有必要确认到底是本地缓存错了，还是go.sum记录错了。    - 需要说明的是，二者都可能出错，本地缓存目录中的依赖包版本有可能被有意或无意地修改过，项目中go.sum中记录的哈希值也可能被篡改过。    - 当校验失败时，go命令倾向于相信go.sum，因为一个新的依赖包版本在被添加到go.sum前是经过GOSUMDB（校验和数据库）验证过的。此时即便系统中配置了GOSUMDB（校验和数据库），go命令也不会查询该数据库。- 校验和数据库    - 环境变量GOSUMDB标识一个checksum database，即校验和数据库，实际上是一个web服务器，该服务器提供查询依赖包版本哈希值的服务。    - 该数据库中记录了很多依赖包版本的哈希值，比如Google官方的sum.golang.org则记录了所有的可公开获得的依赖包版本。除了使用官方的数据库，还可以指定自行搭建的数据库，甚至干脆禁用它（export GOSUMDB=off）。    - 如果系统配置了GOSUMDB，在依赖包版本被写入go.sum之前会向该数据库查询该依赖包版本的哈希值进行二次校验，校验无误后再写入go.sum。    - 如果系统禁用了GOSUMDB，在依赖包版本被写入go.sum之前则不会进行二次校验，go命令会相信所有下载到的依赖包，并把其哈希值记录到go.sum中。- 参考文档    - 命令行帮助文档（go 1.14）：$ go help module-auth    - Go 1.14 源码</code></pre><h2 id="编程陷阱"><a href="#编程陷阱" class="headerlink" title="编程陷阱"></a>编程陷阱</h2><p>本章介绍一些项目过程中可能会遇到的陷阱，大部分均来源于实际项目，比较具有代表性。</p><h3 id="切片追加"><a href="#切片追加" class="headerlink" title="切片追加"></a>切片追加</h3><p>Golang 内置方法append用于向切片中追加一个或多个元素，实际项目中比较常见。</p><p>其原型如下：</p><p>func append(slice []Type, elems …Type) []Type<br>本节不会对append的使用方式详细展开，而是重点介绍几个使用中常见的误区或者陷阱。</p><ul><li><p>热身</p><p>按照惯例，我们先拿几个小题目来检测一下对append的理解是否足够深刻。</p></li></ul><pre><code>- 题目一    - 函数Validation()用于一些合法性检查，每遇到一个错误，就生成一个新的error并追加到切片errs中，    - 最后返回包含所有错误信息的切片。    - 为了简单起见，假定函数发现了三个错误，如下所示：      func Validation() []error &#123;          var errs []error          append(errs, errors.New(&quot;error 1&quot;))          append(errs, errors.New(&quot;error 2&quot;))          append(errs, errors.New(&quot;error 3&quot;))          return errs      &#125;    - 请问函数Validation()有什么问题？- 题目二    - 函数ValidateName()用于检查某个名字是否合法，如果不为空则认为合法，否则返回一个error。    - 类似的，还可以有很多检查项，比如检查性别、年龄等，我们统称为子检查项。    - 函数Validations()用于收集所有子检查项的错误信息，将错误信息汇总到一个切片中返回。    - 请问函数Validations()有什么问题？      func ValidateName(name string) error &#123;          if name != &quot;&quot; &#123;              return nil          &#125;          return errors.New(&quot;empty name&quot;)      &#125;      func Validations(name string) []error &#123;          var errs []error          errs = append(errs, ValidateName(name))          return errs      &#125;</code></pre><ul><li><p>陷阱</p><p>前面的热身题目均来源于实际项目（已经做了最大程度的精简），分别代表一个本节将要介绍的陷阱。</p></li></ul><pre><code>- 陷阱一： append 会改变切片的地址    - append的本质是向切片中追加数据，而随着切片中元素逐渐增加，当切片底层的数组将满时，切片会发生扩容，    - 扩容会导致产生一个新的切片（拥有容量更大的底层数组），更多关于切片的信息，请查阅切片相关章节。    - append每个追加元素，都有可能触发切片扩容，也即有可能返回一个新的切片，这也是append函数声明中返回值为切片的原因。实际使用中应该总是接收该返回值。    - 上述题目一中，由于初始切片长度为0，所以实际上每次append都会产生一个新的切片并迅速抛弃（被gc回收）。    - 原始切片并没有任何改变。需要特别说明的是，不管初始切片长度为多少，不接收append返回都是有极大风险的。    - 另外，目前有很多的工具可以自动检查出类似的问题，比如GolandIDE就会给出很明显的提示。- 陷阱二： append 可以追加nil值    - 向切片中追加一个nil值是完全不会报错的，如下代码所示：      slice := append(slice, nil)    - 经过追加后，slice的长度递增1。    - 实际上nil是一个预定义的值，即空值，所以完全有理由向切片中追加。    - 上述题目二中，就是典型的向切片中追加nil（当名字为空时）的问题。单纯从技术上讲是没有问题，但在题目二场景中就有很大的问题。    - 题目中函数用于收集所有错误信息，没有错误就不应该追加到切片中。因后，后续极有可能会根据切片的长度来判断是否有错误发生，比如：      func foo() &#123;          errs := Validations(&quot;&quot;)          if len(errs) &gt; 0 &#123;              println(errs)              os.Exit(1)          &#125;      &#125;    - 如果向切片中追加一个nil元素，那么切片长度则不再为0，程序很可能因此而退出，更糟糕的是，这样的切片是没有内容会打印出来的，这无疑又增加了定位难度。</code></pre><h3 id="循环变量绑定"><a href="#循环变量绑定" class="headerlink" title="循环变量绑定"></a>循环变量绑定</h3><p>本节通过几个实例来介绍循环遍历时，尤其是使用循环变量时可能遇到的问题，希望通过本节内容的学习，<br>读者能够在实际项目中加以避免。</p><p>该类问题出现的频率超乎你的想像，不仅笔者本人参与的项目，甚至某些著名的开源项目中也普遍存在类似的问题。<br>所以，我希望在本文中对该类问题做一次总结性的分析。</p><ul><li><p>热身</p><p>按照惯例，我们还是从几个小题目开始，权当热身。</p></li></ul><pre><code>- 题目一    - 函数Process1()用于处理任务，每个任务均启动一个协程进行处理。      func Process1(tasks []string) &#123;          for _, task := range tasks &#123;              // 启动协程并发处理任务              go func() &#123;                  fmt.Printf(&quot;Worker start process task: %s\n&quot;, task)              &#125;()          &#125;      &#125;    - 请问函数是否有问题？- 题目二    - 函数Process2()用于处理任务，每个任务均启动一个协程进行处理。      func Process2(tasks []string) &#123;          for _, task := range tasks &#123;              // 启动协程并发处理任务              go func(t string) &#123;                  fmt.Printf(&quot;Worker start process task: %s\n&quot;, t)              &#125;(task)          &#125;      &#125;    - 协程匿名函数接收一个任务作为参数，并进行处理。    - 请问函数是否有问题？- 题目三    - 项目中经常需要编写单元测试，而单元测试最常见的是table-driven风格的测试，如下所示：      func Double(a int) int &#123;          return a * 2      &#125;    - 待测函数很简单，只是计算输入数值的2倍值。    - 测试函数如下：      func TestDouble(t *testing.T) &#123;          var tests = []struct &#123;              name         string              input        int              expectOutput int          &#125;&#123;              &#123;                  name:         &quot;double 1 should got 2&quot;,                  input:        1,                  expectOutput: 2,              &#125;,              &#123;                  name:         &quot;double 2 should got 4&quot;,                  input:        2,                  expectOutput: 4,              &#125;,          &#125;          for _, test := range tests &#123;              t.Run(test.name, func(t *testing.T) &#123;                  if test.expectOutput != Double(test.input) &#123;                      t.Fatalf(&quot;expect: %d, but got: %d&quot;, test.input, test.expectOutput)                  &#125;              &#125;)          &#125;      &#125;    - 上述测试函数也很简单，通过设计多个测试用例，标记输入输出，使用子测试进行验证。    - （注：如果不熟悉单元测试，请查阅相关章节）    - 请问，上述测试有没有问题？</code></pre><ul><li><p>原理剖析</p><p>上述三个问题，有个共同点就是都引用了循环变量。即在for index, value := range xxx语句中，<br>index和value便是循环变量。不同点是循环变量的使用方式，有的是直接在协程中引用（题目一），有的作为参数传递（题目二），而题目三则是兼而有之。</p><p>回答以上问题，记住以下两点即可。</p></li></ul><pre><code>- 循环变量是易变的    - 首先，循环变量实际上只是一个普通的变量。    - 语句for index, value := range xxx中，每次循环index和value都会被重新赋值（并非生成新的变量）。    - 如果循环体中会启动协程（并且协程会使用循环变量），就需要格外注意了，因为很可能循环结束后协程才开始执行，    - 此时，所有协程使用的循环变量有可能已被改写。（是否会改写取决于引用循环变量的方式）- 循环变量需要绑定    - 在题目一中，协程函数体中引用了循环变量task，协程从被创建到被调度执行期间循环变量极有可能被改写，    - 这种情况下，我们称之为变量没有绑定。    - 所以，题目一打印结果是混乱的。很有可能（随机）所有协程执行的task都是列表中的最后一个task。    - 在题目二中，协程函数体中并没有直接引用循环变量task，而是使用的参数。而在创建协程时，循环变量task    - 作为函数参数传递给了协程。参数传递的过程实际上也生成了新的变量，也即间接完成了绑定。    - 所以，题目二实际上是没有问题的。    - 在题目三中，测试用例名字test.name通过函数参数完成了绑定，而test.input 和 test.expectOutput则没有绑定。    - 然而题目三实际执行却不会有问题，因为t.Run(...)并不会启动新的协程，也就是循环体并没有并发。    - 此时，即便循环变量没有绑定也没有问题。    - 但是风险在于，如果t.Run(...)执行的测试体有可能并发（比如通过t.Parallel()），此时就极有可能引入问题。    - 对于题目三，建议显式地绑定，例如：        for _, test := range tests &#123;              tc := test // 显式绑定，每次循环都会生成一个新的tc变量              t.Run(tc.name, func(t *testing.T) &#123;                  if tc.expectOutput != Double(tc.input) &#123;                      t.Fatalf(&quot;expect: %d, but got: %d&quot;, tc.input, tc.expectOutput)                  &#125;              &#125;)          &#125;    - 通过tc := test显式地绑定，每次循环会生成一个新的变量。</code></pre><ul><li><p>总结</p><ul><li><p>简单点来说</p><ul><li><p>如果循环体没有并发出现，则引用循环变量一般不会出现问题；</p></li><li><p>如果循环体有并发，则根据引用循环变量的位置不同而有所区别</p><ul><li>通过参数完成绑定，则一般没有问题；</li><li>函数体中引用，则需要显式地绑定</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kvm安装虚拟机</title>
    <link href="/2021/01/21/linux/tmp/kvm%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <url>/2021/01/21/linux/tmp/kvm%E5%AE%89%E8%A3%85%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="kvm安装虚拟机"><a href="#kvm安装虚拟机" class="headerlink" title="kvm安装虚拟机"></a>kvm安装虚拟机</h1><h2 id="1-上传iso文件"><a href="#1-上传iso文件" class="headerlink" title="1. 上传iso文件"></a>1. 上传iso文件</h2><p>建议所有镜像文件统一存放。</p><h2 id="2-kvm启动虚拟机安装"><a href="#2-kvm启动虚拟机安装" class="headerlink" title="2.kvm启动虚拟机安装"></a>2.kvm启动虚拟机安装</h2><p>linux安装示例：</p><pre><code class="hljs bash">virt-install --connect  qemu:///system --virt-type kvm --name Centos8 --ram=4096  --disk path=/data/b/KVM/images/xxx.img,size=20,sparse --os-type=linux --accelerate -c /data/b/KVM/CentOS-8.2.iso  --network bridge=virbr0,model=virtio --vnc  --vncport=6991 --vnclisten=0.0.0.0 --force</code></pre><p>windows安装示例：</p><pre><code class="hljs bash">virt-install --name w16 --ram 32768 --vcpus 4 --os-type windows --os-variant win2k8 --network bridge=virbr0 --accelerate --disk path=/data/b/KVM/images/w16.img,format=qcow2,size=300 --cdrom=/data/b/KVM/win-ser-2016.iso --graphics vnc,listen=0.0.0.0,password=123,port=5910 --noautoconsole</code></pre><p>参数说明：</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>–name</td><td>虚拟机名称</td></tr><tr><td>–ram</td><td>虚拟机的内存大小</td></tr><tr><td>–vcpus</td><td>虚拟机的虚拟CPU数</td></tr><tr><td>–disk</td><td>虚拟机磁盘（磁盘位置，大小（G））</td></tr><tr><td>–os-type</td><td>针对操作系统类型优化虚拟机配置（iso是哪种类型就写哪种）</td></tr><tr><td>–accelerate</td><td>KVM内核加速（建议安装时加上这个选项）</td></tr><tr><td>–network</td><td>连接虚拟机到主机网络</td></tr><tr><td>–vnc</td><td>导出虚拟机服务</td></tr><tr><td>–vncport</td><td>vnc端口</td></tr><tr><td>–vnclisten</td><td>设置vnc ip(设置为0.0.0.0)，设置vnc连接密码（可选）</td></tr></tbody></table><h2 id="3-vnc安装操作系统"><a href="#3-vnc安装操作系统" class="headerlink" title="3. vnc安装操作系统"></a>3. vnc安装操作系统</h2><p>使用vnc连接客户端进行安装</p><h2 id="4-用vnc配置静态IP"><a href="#4-用vnc配置静态IP" class="headerlink" title="4.用vnc配置静态IP"></a>4.用vnc配置静态IP</h2><p><strong>注意：具体ip参数由实际情况决定</strong></p><h3 id="Ubuntu18配置静态IP"><a href="#Ubuntu18配置静态IP" class="headerlink" title="Ubuntu18配置静态IP"></a>Ubuntu18配置静态IP</h3><ol><li>切换为root用户执行（具体配置文件用tab自动补全）</li></ol><pre><code class="hljs shell">vi /etc/netplan/00***.yml</code></pre><ol start="2"><li>编辑配置文件内容如下所示，addresses处填入所要设置ip地址，dhcp4 no代表不适用dhcp协议获取ip，gateway代表网关地址。nameservers代表DNS域名解析服务器</li></ol><pre><code class="hljs bash">network:  ethernets:    ens3:      dhcp4: no      addresses: [192.168.122.70/24]      gateway4: 192.168.122.1      nameservers:             addresses: [114.114.114.114]  version: 2</code></pre><ol start="3"><li>执行以下命令是配置生效</li></ol><pre><code class="hljs shell">netplan apply</code></pre><ol start="4"><li>使用ifconfig查看配置是否成功</li><li>ping宿主机地址，ping 公网地址，查看是否能访问公网</li></ol><h3 id="Centos8配置静态IP"><a href="#Centos8配置静态IP" class="headerlink" title="Centos8配置静态IP"></a>Centos8配置静态IP</h3><ol><li><code>vi /etc/sysconfig/network-scripts/ifcfg-ens32</code></li></ol><pre><code class="hljs ini"><span class="hljs-attr">TYPE</span>=Ethernet<span class="hljs-attr">PROXY_METHOD</span>=none<span class="hljs-attr">BROWSER_ONLY</span>=<span class="hljs-literal">no</span><span class="hljs-attr">BOOTPROTO</span>=static<span class="hljs-attr">DEFROUTE</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><span class="hljs-attr">IPV6_ADDR_GEN_MODE</span>=stable-privacy<span class="hljs-attr">NAME</span>=ens32<span class="hljs-attr">UUID</span>=<span class="hljs-number">066</span>b4926-b40c-<span class="hljs-number">4</span>c28-a5b4-<span class="hljs-number">2310</span>d2b96613<span class="hljs-attr">DEVICE</span>=ens32<span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPADDR</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">1.200</span><span class="hljs-attr">NETMASK</span>=<span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><span class="hljs-attr">GATEWAY</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">1.254</span><span class="hljs-attr">DNS1</span>=<span class="hljs-number">223.5</span>.<span class="hljs-number">5.5</span><span class="hljs-attr">PREFIX</span>=<span class="hljs-number">24</span></code></pre><ol start="2"><li>使网络配置生效<code>nmcli c reload</code></li><li>查看配置是否生效<code>ifconfig ens32</code></li><li>ping宿主机地址，ping 公网地址，查看是否能访问公网</li></ol><h2 id="5-虚拟机端口转发"><a href="#5-虚拟机端口转发" class="headerlink" title="5.虚拟机端口转发"></a>5.虚拟机端口转发</h2><blockquote><p> 虚拟机能访问公网，操作系统安装基本结束。后续需要做虚拟机的端口转发、关闭安装系统时开放的vnc端口。<br> 下面分别介绍</p></blockquote><h3 id="使用iptables做端口转发"><a href="#使用iptables做端口转发" class="headerlink" title="使用iptables做端口转发"></a>使用iptables做端口转发</h3><ol><li>启用iptables</li><li>执行规则库，下面命令将虚拟机22端口转发到宿主机20022端口<pre><code class="hljs bash">iptables -t nat -A PREROUTING -p tcp --dport 20022 -j DNAT --to-destination 192.168.122.10:22iptables -t nat -A POSTROUTING -d 192.168.122.10 -p tcp --dport 20022 -j SNAT --to-source x.x.x.x</code></pre></li><li>保存iptables规则，设置开机启动iptables</li></ol><h3 id="使用HAProxy做端口转发"><a href="#使用HAProxy做端口转发" class="headerlink" title="使用HAProxy做端口转发"></a>使用HAProxy做端口转发</h3><p>端口转发配置文件服务器上/etc/haproxy/haproxy.cfg</p><p>启动方式</p><pre><code class="hljs bash">haproxy -f /etc/haproxy/haproxy.cfg</code></pre><p>可以直接查看/etc/haproxy/haproxy.cfg然后参照相关内容做相关配置。</p><p>配置文件示例如下：</p><pre><code class="hljs routeros">global    daemon    log 127.0.0.1 local3 info    maxconn 1000    ulimit-n 4000    uid 1001 [[普通用户的uid和gid]]    gid 1001    quiet    nbproc 1    pidfile /etc/haproxy/haproxy.pid #普通用户路径权限defaults    mode tcp #协议    timeout connect 5000ms    timeout<span class="hljs-built_in"> client </span>50000ms    timeout<span class="hljs-built_in"> server </span>50000ms<span class="hljs-comment">#规则一：</span>frontend tcp-in-unstable #名字    bind *:33891 #本地端口 ，注本地端口防火墙也要放开    default_backend tcpunstablebackend tcpunstable   <span class="hljs-built_in"> server </span>proxy00 192.168.122.27:3389 maxconn 1000<span class="hljs-comment">#规则二：</span>frontend tcp-in-unstable_33892    bind *:33892    default_backend tcpunstable_33892backend tcpunstable_33892   <span class="hljs-built_in"> server </span>proxy00 192.168.122.81:3389 maxconn 1000</code></pre><h2 id="6-关闭VNC连接"><a href="#6-关闭VNC连接" class="headerlink" title="6.关闭VNC连接"></a>6.关闭VNC连接</h2><p>出于安全角度，建议虚拟机安装配置完成后建议将VNC关闭</p><p>关闭VNC连接需要先关闭虚拟机 <code>virsh shutdown 虚拟机名称（--name参数定义的）</code>后修改虚拟机配置，配置文件为成功安装虚拟机后生成的文件，具体为该虚拟机各项参数详细信息。</p><p>下面介绍两种修改方式：</p><h3 id="virsh-edit"><a href="#virsh-edit" class="headerlink" title="virsh edit"></a>virsh edit</h3><p>virsh edit 虚拟机名称</p><p>后将vnc配置修改为</p><pre><code class="hljs pgsql">&lt;graphics <span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;vnc&#x27;</span> port=<span class="hljs-string">&#x27;-1&#x27;</span> autoport=<span class="hljs-string">&#x27;yes&#x27;</span> <span class="hljs-keyword">listen</span>=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>&gt;      &lt;<span class="hljs-keyword">listen</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&#x27;address&#x27;</span> address=<span class="hljs-string">&#x27;0.0.0.0&#x27;</span>/&gt;&lt;/graphics&gt;</code></pre><p>保存配置退出，重启虚拟机即可</p><h3 id="直接修改xml文件，重新定义虚拟机"><a href="#直接修改xml文件，重新定义虚拟机" class="headerlink" title="直接修改xml文件，重新定义虚拟机"></a>直接修改xml文件，重新定义虚拟机</h3><p>修改虚拟机生成后的xml配置文件，</p><p>默认服务器虚拟机配置文件在/etc/libvirt/qemu/下</p><ol><li>vim修改xml文件，如<code>vi /etc/libvirt/qemu/ubuntu2.xml</code>按照上述方式修改vnc配置，保存退出</li><li>先取消定义刚刚安装的虚拟机，<code>virsh undefine 虚拟机名称</code></li><li>定义新的虚拟机，如<code>virsh define /etc/libvirt/qemu/ubuntu2.xml</code></li><li>启动该虚拟机，<code>virsh start ubuntu2</code></li></ol><h2 id="7-设置虚拟机自启动"><a href="#7-设置虚拟机自启动" class="headerlink" title="7. 设置虚拟机自启动"></a>7. 设置虚拟机自启动</h2><p>xxx处修改为虚拟机名称<br><code>virsh autostart xxx</code></p><h2 id="8-virsh-常用命令"><a href="#8-virsh-常用命令" class="headerlink" title="8. virsh 常用命令"></a>8. virsh 常用命令</h2><p>下面简单介绍几条virsh常用命令：</p><h3 id="查看虚拟机状态"><a href="#查看虚拟机状态" class="headerlink" title="查看虚拟机状态"></a>查看虚拟机状态</h3><p><code>virsh list --all</code></p><h3 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h3><p><code>virsh start name</code></p><h3 id="关闭虚拟机"><a href="#关闭虚拟机" class="headerlink" title="关闭虚拟机"></a>关闭虚拟机</h3><p><code>virsh shutdown name</code></p><h3 id="强制关闭虚拟机"><a href="#强制关闭虚拟机" class="headerlink" title="强制关闭虚拟机"></a>强制关闭虚拟机</h3><p><strong>注意该名称非销毁虚拟机，只是强制关闭，undefine才是销毁虚拟机</strong></p><p><code>virsh destroy name</code></p><blockquote><p>后续可自行按需查找命令，如虚拟机快照，虚拟机扩容，虚拟机克隆复制等等</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>KVM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Go Programming Language（10-13）</title>
    <link href="/2020/11/24/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%8810-13%EF%BC%89/"/>
    <url>/2020/11/24/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%8810-13%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Go-Programming-Language（10-13）"><a href="#The-Go-Programming-Language（10-13）" class="headerlink" title="The Go Programming Language（10-13）"></a>The Go Programming Language（10-13）</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="本文为Go语言编程圣经中文版内容，本人在阅读时将其制作为思维导图及博客文章形式，仅供学习，若侵权请及时与我联系。"><a href="#本文为Go语言编程圣经中文版内容，本人在阅读时将其制作为思维导图及博客文章形式，仅供学习，若侵权请及时与我联系。" class="headerlink" title="本文为Go语言编程圣经中文版内容，本人在阅读时将其制作为思维导图及博客文章形式，仅供学习，若侵权请及时与我联系。"></a>本文为Go语言编程圣经中文版内容，本人在阅读时将其制作为思维导图及博客文章形式，仅供学习，若侵权请及时与我联系。</h3><h3 id="源码、PDF版、Markdown、xmind版下载链接"><a href="#源码、PDF版、Markdown、xmind版下载链接" class="headerlink" title="源码、PDF版、Markdown、xmind版下载链接"></a>源码、PDF版、Markdown、xmind版下载链接</h3><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://<span class="hljs-number">1</span>tnt<span class="hljs-number">1</span>.lanzous.com/b<span class="hljs-number">00</span>o<span class="hljs-number">36</span>ytc</code></pre><p>密码：</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span>ch0</code></pre><hr><h2 id="ch10-包和工具"><a href="#ch10-包和工具" class="headerlink" title="ch10  包和工具"></a>ch10  包和工具</h2><h3 id="ch10-0-简介"><a href="#ch10-0-简介" class="headerlink" title="ch10.0  简介"></a>ch10.0  简介</h3><ul><li>现在随便一个小程序的实现都可能包含超过10000个函数。然而作者一般只需要考虑其中很小的一部分和做很少的设计，因为绝大部分代码都是由他人编写的，它们通过类似包或模块的方式被重用。</li><li>Go语言有超过100个的标准包（译注：可以用<code>go list std | wc -l</code>命令查看标准包的具体数目），标准库为大多数的程序提供了必要的基础构件。在Go的社区，有很多成熟的包被设计、共享、重用和改进，目前互联网上已经发布了非常多的Go语言开源包，它们可以通过 <a href="http://godoc.org/">http://godoc.org</a> 检索。在本章，我们将演示如何使用已有的包和创建新的包。</li><li>Go还自带了工具箱，里面有很多用来简化工作区和包管理的小工具。在本书开始的时候，我们已经见识过如何使用工具箱自带的工具来下载、构建和运行我们的演示程序了。在本章，我们将看看这些工具的基本设计理论和尝试更多的功能，例如打印工作区中包的文档和查询相关的元数据等。在下一章，我们将探讨testing包的单元测试用法。</li></ul><h3 id="ch10-1-包简介"><a href="#ch10-1-包简介" class="headerlink" title="ch10.1  包简介"></a>ch10.1  包简介</h3><ul><li><p>任何包系统设计的目的都是为了简化大型程序的设计和维护工作，通过将一组相关的特性放进一个独立的单元以便于理解和更新，在每个单元更新的同时保持和程序中其它单元的相对独立性。这种模块化的特性允许每个包可以被其它的不同项目共享和重用，在项目范围内、甚至全球范围统一的分发和复用。</p></li><li><p>每个包一般都定义了一个不同的名字空间用于它内部的每个标识符的访问。每个名字空间关联到一个特定的包，让我们给类型、函数等选择简短明了的名字，这样可以在使用它们的时候减少和其它部分名字的冲突。</p></li><li><p>每个包还通过控制包内名字的可见性和是否导出来实现封装特性。通过限制包成员的可见性并隐藏包API的具体实现，将允许包的维护者在不影响外部包用户的前提下调整包的内部实现。通过限制包内变量的可见性，还可以强制用户通过某些特定函数来访问和更新内部变量，这样可以保证内部变量的一致性和并发时的互斥约束。</p></li><li><p>当我们修改了一个源文件，我们必须重新编译该源文件对应的包和所有依赖该包的其他包。即使是从头构建，Go语言编译器的编译速度也明显快于其它编译语言。Go语言的闪电般的编译速度主要得益于三个语言特性。</p><ul><li>第一点，所有导入的包必须在每个文件的开头显式声明，这样的话编译器就没有必要读取和分析整个源文件来判断包的依赖关系。</li><li>第二点，禁止包的环状依赖，因为没有循环依赖，包的依赖关系形成一个有向无环图，每个包可以被独立编译，而且很可能是被并发编译。</li><li>第三点，编译后包的目标文件不仅仅记录包本身的导出信息，目标文件同时还记录了包的依赖关系。</li><li>因此，在编译一个包的时候，编译器只需要读取每个直接导入包的目标文件，而不需要遍历所有依赖的的文件</li></ul></li></ul><h3 id="ch10-2-导入路径"><a href="#ch10-2-导入路径" class="headerlink" title="ch10.2  导入路径"></a>ch10.2  导入路径</h3><ul><li><p>每个包是由一个全局唯一的字符串所标识的导入路径定位。出现在import语句中的导入路径也是字符串。</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span>)</code></pre></li><li><p>就像我们在2.6.1节提到过的，Go语言的规范并没有指明包的导入路径字符串的具体含义，导入路径的具体含义是由构建工具来解释的。在本章，我们将深入讨论Go语言工具箱的功能，包括大家经常使用的构建测试等功能。当然，也有第三方扩展的工具箱存在。例如，Google公司内部的Go语言码农，他们就使用内部的多语言构建系统，用不同的规则来处理包名字和定位包，用不同的规则来处理单元测试等等，因为这样可以更紧密适配他们内部环境。</p><ul><li>译注：Google公司使用的是类似<a href="http://bazel.io/">Bazel</a>的构建系统，支持多种编程语言，目前该构件系统还不能完整支持Windows环境</li></ul></li><li><p>如果你计划分享或发布包，那么导入路径最好是全球唯一的。为了避免冲突，所有非标准库包的导入路径建议以所在组织的互联网域名为前缀；而且这样也有利于包的检索。例如，上面的import语句导入了Go团队维护的HTML解析器和一个流行的第三方维护的MySQL驱动。</p></li></ul><h3 id="ch10-3-包声明"><a href="#ch10-3-包声明" class="headerlink" title="ch10.3  包声明"></a>ch10.3  包声明</h3><ul><li><p>在每个Go语言源文件的开头都必须有包声明语句。包声明语句的主要目的是确定当前包被其它包导入时默认的标识符（也称为包名）。</p></li><li><p>例如，math/rand包的每个源文件的开头都包含<code>package rand</code>包声明语句，所以当你导入这个包，你就可以用rand.Int、rand.Float64类似的方式访问包的成员。</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;math/rand&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(rand.Int())&#125;</code></pre></li><li><p>通常来说，默认的包名就是包导入路径名的最后一段，因此即使两个包的导入路径不同，它们依然可能有一个相同的包名。例如，math/rand包和crypto/rand包的包名都是rand。稍后我们将看到如何同时导入两个有相同包名的包。</p></li><li><p>关于默认包名一般采用导入路径名的最后一段的约定也有三种例外情况。第一个例外，包对应一个可执行程序，也就是main包，这时候main包本身的导入路径是无关紧要的。名字为main的包是给go build（§10.7.3）构建命令一个信息，这个包编译完之后必须调用连接器生成一个可执行程序。</p></li><li><p>第二个例外，包所在的目录中可能有一些文件名是以<code>_test.go</code>为后缀的Go源文件（译注：前面必须有其它的字符，因为以<code>_</code>或<code>.</code>开头的源文件会被构建工具忽略），并且这些源文件声明的包名也是以<code>_test</code>为后缀名的。这种目录可以包含两种包：一种是普通包，另一种则是测试的外部扩展包。所有以<code>_test</code>为后缀包名的测试外部扩展包都由go test命令独立编译，普通包和测试的外部扩展包是相互独立的。测试的外部扩展包一般用来避免测试代码中的循环导入依赖，具体细节我们将在11.2.4节中介绍。</p></li><li><p>第三个例外，一些依赖版本号的管理工具会在导入路径后追加版本号信息，例如“gopkg.in/yaml.v2”。这种情况下包的名字并不包含版本号后缀，而是yaml。</p></li></ul><h3 id="ch10-4-导入声明"><a href="#ch10-4-导入声明" class="headerlink" title="ch10.4  导入声明"></a>ch10.4  导入声明</h3><ul><li><p>可以在一个Go语言源文件包声明语句之后，其它非导入声明语句之前，包含零到多个导入包声明语句。每个导入声明可以单独指定一个导入路径，也可以通过圆括号同时导入多个导入路径。下面两个导入形式是等价的，但是第二种形式更为常见。</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;os&quot;</span><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)</code></pre></li><li><p>导入的包之间可以通过添加空行来分组；通常将来自不同组织的包独自分组。包的导入顺序无关紧要，但是在每个分组中一般会根据字符串顺序排列。（gofmt和goimports工具都可以将不同分组导入的包独立排序。）</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;html/template&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span><span class="hljs-string">&quot;golang.org/x/net/ipv4&quot;</span>)</code></pre></li><li><p>如果我们想同时导入两个有着名字相同的包，例如math/rand包和crypto/rand包，那么导入声明必须至少为一个同名包指定一个新的包名以避免冲突。这叫做导入包的重命名。</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;crypto/rand&quot;</span>mrand <span class="hljs-string">&quot;math/rand&quot;</span> <span class="hljs-comment">// alternative name mrand avoids conflict</span>)</code></pre></li><li><p>导入包的重命名只影响当前的源文件。其它的源文件如果导入了相同的包，可以用导入包原本默认的名字或重命名为另一个完全不同的名字。</p></li><li><p>导入包重命名是一个有用的特性，它不仅仅只是为了解决名字冲突。如果导入的一个包名很笨重，特别是在一些自动生成的代码中，这时候用一个简短名称会更方便。选择用简短名称重命名导入包时候最好统一，以避免包名混乱。选择另一个包名称还可以帮助避免和本地普通变量名产生冲突。例如，如果文件中已经有了一个名为path的变量，那么我们可以将“path”标准包重命名为pathpkg。</p></li><li><p>每个导入声明语句都明确指定了当前包和被导入包之间的依赖关系。如果遇到包循环导入的情况，Go语言的构建工具将报告错误。</p></li></ul><h3 id="ch10-5-包的匿名导入"><a href="#ch10-5-包的匿名导入" class="headerlink" title="ch10.5  包的匿名导入"></a>ch10.5  包的匿名导入</h3><ul><li><p>如果只是导入一个包而并不使用导入的包将会导致一个编译错误。但是有时候我们只是想利用导入包而产生的副作用：它会计算包级变量的初始化表达式和执行导入包的init初始化函数（§2.6.2）。这时候我们需要抑制“unused import”编译错误，我们可以用下划线<code>_</code>来重命名导入的包。像往常一样，下划线<code>_</code>为空白标识符，并不能被访问。</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> _ <span class="hljs-string">&quot;image/png&quot;</span> <span class="hljs-comment">// register PNG decoder</span></code></pre></li><li><p>这个被称为包的匿名导入。它通常是用来实现一个编译时机制，然后通过在main主程序入口选择性地导入附加的包。首先，让我们看看如何使用该特性，然后再看看它是如何工作的。</p></li><li><p>标准库的image图像包包含了一个<code>Decode</code>函数，用于从<code>io.Reader</code>接口读取数据并解码图像，它调用底层注册的图像解码器来完成任务，然后返回image.Image类型的图像。使用<code>image.Decode</code>很容易编写一个图像格式的转换工具，读取一种格式的图像，然后编码为另一种图像格式：</p><p><u><i>gopl.io/ch10/jpeg</i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// The jpeg command reads a PNG image from the standard input</span><span class="hljs-comment">// and writes it as a JPEG image to the standard output.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;image&quot;</span><span class="hljs-string">&quot;image/jpeg&quot;</span>_ <span class="hljs-string">&quot;image/png&quot;</span> <span class="hljs-comment">// register PNG decoder</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> err := toJPEG(os.Stdin, os.Stdout); err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;jpeg: %v\n&quot;</span>, err)os.Exit(<span class="hljs-number">1</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">toJPEG</span><span class="hljs-params">(in io.Reader, out io.Writer)</span> <span class="hljs-title">error</span></span> &#123;img, kind, err := image.Decode(in)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;fmt.Fprintln(os.Stderr, <span class="hljs-string">&quot;Input format =&quot;</span>, kind)<span class="hljs-keyword">return</span> jpeg.Encode(out, img, &amp;jpeg.Options&#123;Quality: <span class="hljs-number">95</span>&#125;)&#125;</code></pre></li><li><p>如果我们将<code>gopl.io/ch3/mandelbrot</code>（§3.3）的输出导入到这个程序的标准输入，它将解码输入的PNG格式图像，然后转换为JPEG格式的图像输出（图3.3）。</p><pre><code class="hljs awk">$ go build gopl.io<span class="hljs-regexp">/ch3/m</span>andelbrot$ go build gopl.io<span class="hljs-regexp">/ch10/</span>jpeg$ .<span class="hljs-regexp">/mandelbrot | ./</span>jpeg &gt;mandelbrot.jpgInput format = png</code></pre></li><li><p>要注意image/png包的匿名导入语句。如果没有这一行语句，程序依然可以编译和运行，但是它将不能正确识别和解码PNG格式的图像：</p><pre><code class="hljs maxima">$ <span class="hljs-built_in">go</span> build gopl.io/ch10/jpeg$ ./<span class="hljs-built_in">mandelbrot</span> | ./jpeg &gt;<span class="hljs-built_in">mandelbrot</span>.jpgjpeg: <span class="hljs-built_in">image</span>: <span class="hljs-literal">unknown</span> format</code></pre></li><li><p>下面的代码演示了它的工作机制。标准库还提供了GIF、PNG和JPEG等格式图像的解码器，用户也可以提供自己的解码器，但是为了保持程序体积较小，很多解码器并没有被全部包含，除非是明确需要支持的格式。image.Decode函数在解码时会依次查询支持的格式列表。</p></li><li><p>每个格式驱动列表的每个入口指定了四件事情：格式的名称；一个用于描述这种图像数据开头部分模式的字符串，用于解码器检测识别；一个Decode函数用于完成解码图像工作；一个DecodeConfig函数用于解码图像的大小和颜色空间的信息。每个驱动入口是通过调用image.RegisterFormat函数注册，一般是在每个格式包的init初始化函数中调用，例如image/png包是这样注册的：</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> png <span class="hljs-comment">// image/png</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Decode</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(image.Image, error)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DecodeConfig</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(image.Config, error)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> pngHeader = <span class="hljs-string">&quot;\x89PNG\r\n\x1a\n&quot;</span>image.RegisterFormat(<span class="hljs-string">&quot;png&quot;</span>, pngHeader, Decode, DecodeConfig)&#125;</code></pre></li><li><p>最终的效果是，主程序只需要匿名导入特定图像驱动包就可以用image.Decode解码对应格式的图像了。</p></li><li><p>数据库包database/sql也是采用了类似的技术，让用户可以根据自己需要选择导入必要的数据库驱动。例如：</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;database/sql&quot;</span>_ <span class="hljs-string">&quot;github.com/lib/pq&quot;</span>              <span class="hljs-comment">// enable support for Postgres</span>_ <span class="hljs-string">&quot;github.com/go-sql-driver/mysql&quot;</span> <span class="hljs-comment">// enable support for MySQL</span>)db, err = sql.Open(<span class="hljs-string">&quot;postgres&quot;</span>, dbname) <span class="hljs-comment">// OK</span>db, err = sql.Open(<span class="hljs-string">&quot;mysql&quot;</span>, dbname)    <span class="hljs-comment">// OK</span>db, err = sql.Open(<span class="hljs-string">&quot;sqlite3&quot;</span>, dbname)  <span class="hljs-comment">// returns error: unknown driver &quot;sqlite3&quot;</span></code></pre></li></ul><h3 id="ch10-6-包和命名"><a href="#ch10-6-包和命名" class="headerlink" title="ch10.6  包和命名"></a>ch10.6  包和命名</h3><ul><li><p>在本节中，我们将提供一些关于Go语言独特的包和成员命名的约定。</p></li><li><p>当创建一个包，一般要用短小的包名，但也不能太短导致难以理解。标准库中最常用的包有bufio、bytes、flag、fmt、http、io、json、os、sort、sync和time等包。</p></li><li><p>尽可能让命名有描述性且无歧义。例如，类似imageutil或ioutilis的工具包命名已经足够简洁了，就无须再命名为util了。要尽量避免包名使用可能被经常用于局部变量的名字，这样可能导致用户重命名导入包，例如前面看到的path包。</p></li><li><p>包名一般采用单数的形式。标准库的bytes、errors和strings使用了复数形式，这是为了避免和预定义的类型冲突，同样还有go/types是为了避免和type关键字冲突。</p></li><li><p>要避免包名有其它的含义。例如，2.5节中我们的温度转换包最初使用了temp包名，虽然并没有持续多久。但这是一个糟糕的尝试，因为temp几乎是临时变量的同义词。然后我们有一段时间使用了temperature作为包名，显然名字并没有表达包的真实用途。最后我们改成了和strconv标准包类似的tempconv包名，这个名字比之前的就好多了。</p></li><li><p>现在让我们看看如何命名包的成员。由于是通过包的导入名字引入包里面的成员，例如fmt.Println，同时包含了包名和成员名信息。因此，我们一般并不需要关注Println的具体内容，因为fmt包名已经包含了这个信息。当设计一个包的时候，需要考虑包名和成员名两个部分如何很好地配合。下面有一些例子：</p><pre><code class="hljs css"><span class="hljs-selector-tag">bytes</span><span class="hljs-selector-class">.Equal</span>    <span class="hljs-selector-tag">flag</span><span class="hljs-selector-class">.Int</span>    <span class="hljs-selector-tag">http</span><span class="hljs-selector-class">.Get</span>    <span class="hljs-selector-tag">json</span><span class="hljs-selector-class">.Marshal</span></code></pre></li><li><p>我们可以看到一些常用的命名模式。strings包提供了和字符串相关的诸多操作：</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> strings<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Index</span><span class="hljs-params">(needle, haystack <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span><span class="hljs-keyword">type</span> Replacer <span class="hljs-keyword">struct</span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewReplacer</span><span class="hljs-params">(oldnew ...<span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">Replacer</span></span><span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">struct</span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewReader</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">Reader</span></span></code></pre></li><li><p>包名strings并没有出现在任何成员名字中。因为用户会这样引用这些成员strings.Index、strings.Replacer等。</p></li><li><p>其它一些包，可能只描述了单一的数据类型，例如html/template和math/rand等，只暴露一个主要的数据结构和与它相关的方法，还有一个以New命名的函数用于创建实例。</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> rand <span class="hljs-comment">// &quot;math/rand&quot;</span><span class="hljs-keyword">type</span> Rand <span class="hljs-keyword">struct</span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(source Source)</span> *<span class="hljs-title">Rand</span></span></code></pre></li><li><p>这可能导致一些名字重复，例如template.Template或rand.Rand，这就是为什么这些种类的包名往往特别短的原因之一。</p></li><li><p>在另一个极端，还有像net/http包那样含有非常多的名字和种类不多的数据类型，因为它们都是要执行一个复杂的复合任务。尽管有将近二十种类型和更多的函数，但是包中最重要的成员名字却是简单明了的：Get、Post、Handle、Error、Client、Server等。</p></li></ul><h3 id="ch10-7-工具"><a href="#ch10-7-工具" class="headerlink" title="ch10.7  工具"></a>ch10.7  工具</h3><ul><li><p>ch10.7.0 简介</p><ul><li><p>本章剩下的部分将讨论Go语言工具箱的具体功能，包括如何下载、格式化、构建、测试和安装Go语言编写的程序。</p></li><li><p>Go语言的工具箱集合了一系列功能的命令集。它可以看作是一个包管理器（类似于Linux中的apt和rpm工具），用于包的查询、计算包的依赖关系、从远程版本控制系统下载它们等任务。它也是一个构建系统，计算文件的依赖关系，然后调用编译器、汇编器和链接器构建程序，虽然它故意被设计成没有标准的make命令那么复杂。它也是一个单元测试和基准测试的驱动程序，我们将在第11章讨论测试话题。</p></li><li><p>Go语言工具箱的命令有着类似“瑞士军刀”的风格，带着一打的子命令，有一些我们经常用到，例如get、run、build和fmt等。你可以运行go或go help命令查看内置的帮助文档，为了查询方便，我们列出了最常用的命令：</p><pre><code class="hljs routeros">$ go<span class="hljs-built_in">..</span>.build            compile packages <span class="hljs-keyword">and</span> dependenciesclean            <span class="hljs-builtin-name">remove</span> object filesdoc              show documentation <span class="hljs-keyword">for</span> package <span class="hljs-keyword">or</span> symbolenv              <span class="hljs-builtin-name">print</span> Go environment informationfmt              <span class="hljs-builtin-name">run</span> gofmt on package sources<span class="hljs-builtin-name">get</span>              download <span class="hljs-keyword">and</span> install packages <span class="hljs-keyword">and</span> dependenciesinstall          compile <span class="hljs-keyword">and</span> install packages <span class="hljs-keyword">and</span> dependencieslist             list packages<span class="hljs-builtin-name">run</span>              compile <span class="hljs-keyword">and</span> <span class="hljs-builtin-name">run</span> Go programtest             test packagesversion          <span class="hljs-builtin-name">print</span> Go versionvet              <span class="hljs-builtin-name">run</span> go<span class="hljs-built_in"> tool </span>vet on packagesUse <span class="hljs-string">&quot;go help [command]&quot;</span> <span class="hljs-keyword">for</span> more information about a command.<span class="hljs-built_in">..</span>.</code></pre></li><li><p>为了达到零配置的设计目标，Go语言的工具箱很多地方都依赖各种约定。例如，根据给定的源文件的名称，Go语言的工具可以找到源文件对应的包，因为每个目录只包含了单一的包，并且包的导入路径和工作区的目录结构是对应的。给定一个包的导入路径，Go语言的工具可以找到与之对应的存储着实体文件的目录。它还可以根据导入路径找到存储代码的仓库的远程服务器URL。</p></li></ul></li><li><p>ch10.7.1 工作区结构</p><ul><li><p>对于大多数的Go语言用户，只需要配置一个名叫GOPATH的环境变量，用来指定当前工作目录即可。当需要切换到不同工作区的时候，只要更新GOPATH就可以了。例如，我们在编写本书时将GOPATH设置为<code>$HOME/gobook</code>：</p><pre><code class="hljs routeros">$ <span class="hljs-builtin-name">export</span> <span class="hljs-attribute">GOPATH</span>=<span class="hljs-variable">$HOME</span>/gobook$ go <span class="hljs-builtin-name">get</span> gopl.io/<span class="hljs-built_in">..</span>.</code></pre></li><li><p>当你用前面介绍的命令下载本书全部的例子源码之后，你的当前工作区的目录结构应该是这样的：</p><pre><code class="hljs jboss-cli">GOPATH/src/gopl.io/<span class="hljs-string">.git/</span>ch1/helloworld/main.godup/main.go<span class="hljs-string">...</span>golang.org/x/net/<span class="hljs-string">.git/</span>html/parse.gonode.go<span class="hljs-string">...</span>bin/helloworldduppkg/darwin_amd64/<span class="hljs-string">...</span></code></pre></li><li><p>GOPATH对应的工作区目录有三个子目录。其中src子目录用于存储源代码。每个包被保存在与$GOPATH/src的相对路径为包导入路径的子目录中，例如gopl.io/ch1/helloworld相对应的路径目录。我们看到，一个GOPATH工作区的src目录中可能有多个独立的版本控制系统，例如gopl.io和golang.org分别对应不同的Git仓库。其中pkg子目录用于保存编译后的包的目标文件，bin子目录用于保存编译后的可执行程序，例如helloworld可执行程序。</p></li><li><p>第二个环境变量GOROOT用来指定Go的安装目录，还有它自带的标准库包的位置。GOROOT的目录结构和GOPATH类似，因此存放fmt包的源代码对应目录应该为$GOROOT/src/fmt。用户一般不需要设置GOROOT，默认情况下Go语言安装工具会将其设置为安装的目录路径。</p></li><li><p>其中<code>go env</code>命令用于查看Go语言工具涉及的所有环境变量的值，包括未设置环境变量的默认值。GOOS环境变量用于指定目标操作系统（例如android、linux、darwin或windows），GOARCH环境变量用于指定处理器的类型，例如amd64、386或arm等。虽然GOPATH环境变量是唯一必须要设置的，但是其它环境变量也会偶尔用到。</p><pre><code class="hljs routeros">$ go env<span class="hljs-attribute">GOPATH</span>=<span class="hljs-string">&quot;/home/gopher/gobook&quot;</span><span class="hljs-attribute">GOROOT</span>=<span class="hljs-string">&quot;/usr/local/go&quot;</span><span class="hljs-attribute">GOARCH</span>=<span class="hljs-string">&quot;amd64&quot;</span><span class="hljs-attribute">GOOS</span>=<span class="hljs-string">&quot;darwin&quot;</span><span class="hljs-built_in">..</span>.</code></pre></li></ul></li><li><p>ch10.7.2 下载包</p><ul><li><p>使用Go语言工具箱的go命令，不仅可以根据包导入路径找到本地工作区的包，甚至可以从互联网上找到和更新包。</p></li><li><p>使用命令<code>go get</code>可以下载一个单一的包或者用<code>...</code>下载整个子目录里面的每个包。Go语言工具箱的go命令同时计算并下载所依赖的每个包，这也是前一个例子中golang.org/x/net/html自动出现在本地工作区目录的原因。</p></li><li><p>一旦<code>go get</code>命令下载了包，然后就是安装包或包对应的可执行的程序。我们将在下一节再关注它的细节，现在只是展示整个下载过程是如何的简单。第一个命令是获取golint工具，它用于检测Go源代码的编程风格是否有问题。第二个命令是用golint命令对2.6.2节的gopl.io/ch2/popcount包代码进行编码风格检查。它友好地报告了忘记了包的文档：</p><pre><code class="hljs awk">$ go get github.com<span class="hljs-regexp">/golang/</span>lint/golint$ <span class="hljs-variable">$GOPATH</span><span class="hljs-regexp">/bin/g</span>olint gopl.io<span class="hljs-regexp">/ch2/</span>popcountsrc<span class="hljs-regexp">/gopl.io/</span>ch2<span class="hljs-regexp">/popcount/m</span>ain.go:<span class="hljs-number">1</span>:<span class="hljs-number">1</span>:  package comment should be of the form <span class="hljs-string">&quot;Package popcount ...&quot;</span></code></pre></li><li><p><code>go get</code>命令支持当前流行的托管网站GitHub、Bitbucket和Launchpad，可以直接向它们的版本控制系统请求代码。对于其它的网站，你可能需要指定版本控制系统的具体路径和协议，例如 Git或Mercurial。运行<code>go help importpath</code>获取相关的信息。</p></li><li><p><code>go get</code>命令获取的代码是真实的本地存储仓库，而不仅仅只是复制源文件，因此你依然可以使用版本管理工具比较本地代码的变更或者切换到其它的版本。例如golang.org/x/net包目录对应一个Git仓库：</p><pre><code class="hljs awk">$ cd <span class="hljs-variable">$GOPATH</span><span class="hljs-regexp">/src/g</span>olang.org<span class="hljs-regexp">/x/</span>net$ git remote -vorigin  https:<span class="hljs-regexp">//g</span>o.googlesource.com/net (fetch)origin  https:<span class="hljs-regexp">//g</span>o.googlesource.com/net (push)</code></pre></li><li><p>需要注意的是导入路径含有的网站域名和本地Git仓库对应远程服务地址并不相同，真实的Git地址是go.googlesource.com。这其实是Go语言工具的一个特性，可以让包用一个自定义的导入路径，但是真实的代码却是由更通用的服务提供，例如googlesource.com或github.com。因为页面 <a href="https://golang.org/x/net/html">https://golang.org/x/net/html</a> 包含了如下的元数据，它告诉Go语言的工具当前包真实的Git仓库托管地址：</p><pre><code class="hljs gradle">$ go build gopl.io<span class="hljs-regexp">/ch1/</span>fetch$ .<span class="hljs-regexp">/fetch https:/</span><span class="hljs-regexp">/golang.org/</span>x<span class="hljs-regexp">/net/</span>html | <span class="hljs-keyword">grep</span> go-<span class="hljs-keyword">import</span>&lt;meta name=<span class="hljs-string">&quot;go-import&quot;</span>      content=<span class="hljs-string">&quot;golang.org/x/net git https://go.googlesource.com/net&quot;</span>&gt;</code></pre></li><li><p>如果指定<code>-u</code>命令行标志参数，<code>go get</code>命令将确保所有的包和依赖的包的版本都是最新的，然后重新编译和安装它们。如果不包含该标志参数的话，而且如果包已经在本地存在，那么代码将不会被自动更新。</p></li><li><p><code>go get -u</code>命令只是简单地保证每个包是最新版本，如果是第一次下载包则是比较方便的；但是对于发布程序则可能是不合适的，因为本地程序可能需要对依赖的包做精确的版本依赖管理。通常的解决方案是使用vendor的目录用于存储依赖包的固定版本的源代码，对本地依赖的包的版本更新也是谨慎和持续可控的。在Go1.5之前，一般需要修改包的导入路径，所以复制后golang.org/x/net/html导入路径可能会变为gopl.io/vendor/golang.org/x/net/html。最新的Go语言命令已经支持vendor特性，但限于篇幅这里并不讨论vendor的具体细节。不过可以通过<code>go help gopath</code>命令查看Vendor的帮助文档。</p></li></ul></li><li><p>ch10.7.3 构建包</p><ul><li><p><code>go build</code>命令编译命令行参数指定的每个包。如果包是一个库，则忽略输出结果；这可以用于检测包是可以正确编译的。如果包的名字是main，<code>go build</code>将调用链接器在当前目录创建一个可执行程序；以导入路径的最后一段作为可执行程序的名字。</p></li><li><p>由于每个目录只包含一个包，因此每个对应可执行程序或者叫Unix术语中的命令的包，会要求放到一个独立的目录中。这些目录有时候会放在名叫cmd目录的子目录下面，例如用于提供Go文档服务的golang.org/x/tools/cmd/godoc命令就是放在cmd子目录（§10.7.4）。</p></li><li><p>每个包可以由它们的导入路径指定，就像前面看到的那样，或者用一个相对目录的路径名指定，相对路径必须以<code>.</code>或<code>..</code>开头。如果没有指定参数，那么默认指定为当前目录对应的包。下面的命令用于构建同一个包，虽然它们的写法各不相同：</p><pre><code class="hljs awk">$ cd <span class="hljs-variable">$GOPATH</span><span class="hljs-regexp">/src/g</span>opl.io<span class="hljs-regexp">/ch1/</span>helloworld$ go build</code></pre><ul><li><p>或者：</p><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> anywhere<span class="hljs-variable">$</span> go build gopl.io/ch1/helloworld</code></pre></li><li><p>或者：</p><pre><code class="hljs awk">$ cd <span class="hljs-variable">$GOPATH</span>$ go build .<span class="hljs-regexp">/src/g</span>opl.io<span class="hljs-regexp">/ch1/</span>helloworld</code></pre></li><li><p>但不能这样：</p><pre><code class="hljs subunit">$ cd $GOPATH$ go build src/gopl.io/ch1/helloworld<span class="hljs-keyword">Error: </span>cannot find package &quot;src/gopl.io/ch1/helloworld&quot;.</code></pre></li></ul></li><li><p>也可以指定包的源文件列表，这一般只用于构建一些小程序或做一些临时性的实验。如果是main包，将会以第一个Go源文件的基础文件名作为最终的可执行程序的名字。</p><pre><code class="hljs go">$ cat quoteargs.<span class="hljs-keyword">go</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, os.Args[<span class="hljs-number">1</span>:])&#125;$ <span class="hljs-keyword">go</span> build quoteargs.<span class="hljs-keyword">go</span>$ ./quoteargs one <span class="hljs-string">&quot;two three&quot;</span> four\ five[<span class="hljs-string">&quot;one&quot;</span> <span class="hljs-string">&quot;two three&quot;</span> <span class="hljs-string">&quot;four five&quot;</span>]</code></pre></li><li><p>特别是对于这类一次性运行的程序，我们希望尽快的构建并运行它。<code>go run</code>命令实际上是结合了构建和运行的两个步骤：</p><pre><code class="hljs dockerfile">$ go <span class="hljs-keyword">run</span><span class="bash"> quoteargs.go one <span class="hljs-string">&quot;two three&quot;</span> four\ five</span>[<span class="hljs-string">&quot;one&quot;</span> <span class="hljs-string">&quot;two three&quot;</span> <span class="hljs-string">&quot;four five&quot;</span>]</code></pre><ul><li>译注：其实也可以偷懒，直接go run <code>*.go</code></li><li>第一行的参数列表中，第一个不是以<code>.go</code>结尾的将作为可执行程序的参数运行。</li></ul></li><li><p>默认情况下，<code>go build</code>命令构建指定的包和它依赖的包，然后丢弃除了最后的可执行文件之外所有的中间编译结果。依赖分析和编译过程虽然都是很快的，但是随着项目增加到几十个包和成千上万行代码，依赖关系分析和编译时间的消耗将变的可观，有时候可能需要几秒种，即使这些依赖项没有改变。</p></li><li><p><code>go install</code>命令和<code>go build</code>命令很相似，但是它会保存每个包的编译成果，而不是将它们都丢弃。被编译的包会被保存到$GOPATH/pkg目录下，目录路径和 src目录路径对应，可执行程序被保存到$GOPATH/bin目录。（很多用户会将$GOPATH/bin添加到可执行程序的搜索列表中。）还有，<code>go install</code>命令和<code>go build</code>命令都不会重新编译没有发生变化的包，这可以使后续构建更快捷。为了方便编译依赖的包，<code>go build -i</code>命令将安装每个目标所依赖的包。</p></li><li><p>因为编译对应不同的操作系统平台和CPU架构，<code>go install</code>命令会将编译结果安装到GOOS和GOARCH对应的目录。例如，在Mac系统，golang.org/x/net/html包将被安装到$GOPATH/pkg/darwin_amd64目录下的golang.org/x/net/html.a文件。</p></li><li><p>针对不同操作系统或CPU的交叉构建也是很简单的。只需要设置好目标对应的GOOS和GOARCH，然后运行构建命令即可。下面交叉编译的程序将输出它在编译时的操作系统和CPU类型：</p><p><u><i>gopl.io/ch10/cross</i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(runtime.GOOS, runtime.GOARCH)&#125;</code></pre><ul><li><p>下面以64位和32位环境分别编译和执行：</p><pre><code class="hljs awk">$ go build gopl.io<span class="hljs-regexp">/ch10/</span>cross$ ./crossdarwin amd64$ GOARCH=<span class="hljs-number">386</span> go build gopl.io<span class="hljs-regexp">/ch10/</span>cross$ ./crossdarwin <span class="hljs-number">386</span></code></pre></li></ul></li><li><p>有些包可能需要针对不同平台和处理器类型使用不同版本的代码文件，以便于处理底层的可移植性问题或为一些特定代码提供优化。如果一个文件名包含了一个操作系统或处理器类型名字，例如net_linux.go或asm_amd64.s，Go语言的构建工具将只在对应的平台编译这些文件。还有一个特别的构建注释参数可以提供更多的构建过程控制。例如，文件中可能包含下面的注释：</p><pre><code class="hljs Go"><span class="hljs-comment">// +build linux darwin</span></code></pre></li><li><p>在包声明和包注释的前面，该构建注释参数告诉<code>go build</code>只在编译程序对应的目标操作系统是Linux或Mac OS X时才编译这个文件。下面的构建注释则表示不编译这个文件：</p><pre><code class="hljs Go"><span class="hljs-comment">// +build ignore</span></code></pre></li><li><p>更多细节，可以参考go/build包的构建约束部分的文档。</p><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> doc <span class="hljs-keyword">go</span>/build</code></pre></li></ul></li><li><p>ch10.7.4 包文档</p><ul><li><p>Go语言的编码风格鼓励为每个包提供良好的文档。包中每个导出的成员和包声明前都应该包含目的和用法说明的注释。</p></li><li><p>Go语言中的文档注释一般是完整的句子，第一行通常是摘要说明，以被注释者的名字开头。注释中函数的参数或其它的标识符并不需要额外的引号或其它标记注明。例如，下面是fmt.Fprintf的文档注释。</p><pre><code class="hljs Go"><span class="hljs-comment">// Fprintf formats according to a format specifier and writes to w.</span><span class="hljs-comment">// It returns the number of bytes written and any write error encountered.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fprintf</span><span class="hljs-params">(w io.Writer, format <span class="hljs-keyword">string</span>, a ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span></code></pre></li><li><p>Fprintf函数格式化的细节在fmt包文档中描述。如果注释后紧跟着包声明语句，那注释对应整个包的文档。包文档对应的注释只能有一个（译注：其实可以有多个，它们会组合成一个包文档注释），包注释可以出现在任何一个源文件中。如果包的注释内容比较长，一般会放到一个独立的源文件中；fmt包注释就有300行之多。这个专门用于保存包文档的源文件通常叫doc.go。</p></li><li><p>好的文档并不需要面面俱到，文档本身应该是简洁但不可忽略的。事实上，Go语言的风格更喜欢简洁的文档，并且文档也是需要像代码一样维护的。对于一组声明语句，可以用一个精炼的句子描述，如果是显而易见的功能则并不需要注释。</p></li><li><p>在本书中，只要空间允许，我们之前很多包声明都包含了注释文档，但你可以从标准库中发现很多更好的例子。有两个工具可以帮到你。</p></li><li><p>首先是<code>go doc</code>命令，该命令打印其后所指定的实体的声明与文档注释，该实体可能是一个包：</p><pre><code class="hljs go">$ <span class="hljs-keyword">go</span> doc time<span class="hljs-keyword">package</span> time <span class="hljs-comment">// import &quot;time&quot;</span>Package time provides functionality <span class="hljs-keyword">for</span> measuring and displaying time.<span class="hljs-keyword">const</span> Nanosecond Duration = <span class="hljs-number">1</span> ...<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">After</span><span class="hljs-params">(d Duration)</span> &lt;-<span class="hljs-title">chan</span> <span class="hljs-title">Time</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sleep</span><span class="hljs-params">(d Duration)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Since</span><span class="hljs-params">(t Time)</span> <span class="hljs-title">Duration</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Now</span><span class="hljs-params">()</span> <span class="hljs-title">Time</span></span><span class="hljs-keyword">type</span> Duration <span class="hljs-keyword">int64</span><span class="hljs-keyword">type</span> Time <span class="hljs-keyword">struct</span> &#123; ... &#125;...many more...</code></pre><ul><li><p>或者是某个具体的包成员：</p><pre><code class="hljs pgsql">$ go doc <span class="hljs-type">time</span>.Sincefunc Since(t <span class="hljs-type">Time</span>) DurationSince <span class="hljs-keyword">returns</span> the <span class="hljs-type">time</span> elapsed since t.It <span class="hljs-keyword">is</span> shorthand <span class="hljs-keyword">for</span> <span class="hljs-type">time</span>.Now().Sub(t).</code></pre></li><li><p>或者是一个方法：</p><pre><code class="hljs livecodeserver">$ go doc <span class="hljs-built_in">time</span>.Duration.Secondsfunc (d Duration) Seconds() float64Seconds returns <span class="hljs-keyword">the</span> duration <span class="hljs-keyword">as</span> <span class="hljs-keyword">a</span> floating-point <span class="hljs-built_in">number</span> <span class="hljs-keyword">of</span> <span class="hljs-built_in">seconds</span>.</code></pre></li><li><p>该命令并不需要输入完整的包导入路径或正确的大小写。下面的命令将打印encoding/json包的<code>(*json.Decoder).Decode</code>方法的文档：</p><pre><code class="hljs pgsql">$ go doc <span class="hljs-type">json</span>.decodefunc (<span class="hljs-type">dec</span> *Decoder) Decode(v interface&#123;&#125;) errorDecode reads the next <span class="hljs-type">JSON</span>-encoded <span class="hljs-keyword">value</span> <span class="hljs-keyword">from</span> its <span class="hljs-keyword">input</span> <span class="hljs-keyword">and</span> storesit <span class="hljs-keyword">in</span> the <span class="hljs-keyword">value</span> pointed <span class="hljs-keyword">to</span> <span class="hljs-keyword">by</span> v.</code></pre></li></ul></li><li><p>第二个工具，名字也叫godoc，它提供可以相互交叉引用的HTML页面，但是包含和<code>go doc</code>命令相同以及更多的信息。图10.1演示了time包的文档，11.6节将看到godoc演示可以交互的示例程序。godoc的在线服务 <a href="https://godoc.org/">https://godoc.org</a> ，包含了成千上万的开源包的检索工具。</p><ul><li><p>你也可以在自己的工作区目录运行godoc服务。运行下面的命令，然后在浏览器查看 <a href="http://localhost:8000/pkg">http://localhost:8000/pkg</a> 页面：</p><pre><code class="hljs angelscript">$ godoc -http :<span class="hljs-number">8000</span></code></pre></li><li><p>其中<code>-analysis=type</code>和<code>-analysis=pointer</code>命令行标志参数用于打开文档和代码中关于静态分析的结果。</p></li></ul></li></ul></li><li><p>ch10.7.5 内部包</p><ul><li><p>在Go语言程序中，包是最重要的封装机制。没有导出的标识符只在同一个包内部可以访问，而导出的标识符则是面向全宇宙都是可见的。</p></li><li><p>有时候，一个中间的状态可能也是有用的，标识符对于一小部分信任的包是可见的，但并不是对所有调用者都可见。例如，当我们计划将一个大的包拆分为很多小的更容易维护的子包，但是我们并不想将内部的子包结构也完全暴露出去。同时，我们可能还希望在内部子包之间共享一些通用的处理包，或者我们只是想实验一个新包的还并不稳定的接口，暂时只暴露给一些受限制的用户使用。</p></li><li><p>为了满足这些需求，Go语言的构建工具对包含internal名字的路径段的包导入路径做了特殊处理。这种包叫internal包，一个internal包只能被和internal目录有同一个父目录的包所导入。例如，net/http/internal/chunked内部包只能被net/http/httputil或net/http包导入，但是不能被net/url包导入。不过net/url包却可以导入net/http/httputil包。</p><pre><code class="hljs awk">net/httpnet<span class="hljs-regexp">/http/i</span>nternal/chunkednet<span class="hljs-regexp">/http/</span>httputilnet/url</code></pre></li></ul></li><li><p>ch10.7.6 查询包</p><ul><li><p><code>go list</code>命令可以查询可用包的信息。其最简单的形式，可以测试包是否在工作区并打印它的导入路径：</p><pre><code class="hljs vim">$ <span class="hljs-keyword">go</span> <span class="hljs-keyword">list</span> github.<span class="hljs-keyword">com</span>/<span class="hljs-keyword">go</span>-sql-driver/mysqlgithub.<span class="hljs-keyword">com</span>/<span class="hljs-keyword">go</span>-sql-driver/mysql</code></pre></li><li><p><code>go list</code>命令的参数还可以用<code>&quot;...&quot;</code>表示匹配任意的包的导入路径。我们可以用它来列出工作区中的所有包：</p><pre><code class="hljs lasso">$ go <span class="hljs-built_in">list</span> <span class="hljs-params">...</span>archive/tararchive/zipbufio<span class="hljs-built_in">bytes</span>cmd/addr2linecmd/api<span class="hljs-params">...</span>many more<span class="hljs-params">...</span></code></pre></li><li><p>或者是特定子目录下的所有包：</p><pre><code class="hljs awk">$ go list gopl.io<span class="hljs-regexp">/ch3/</span>...gopl.io<span class="hljs-regexp">/ch3/</span>basename1gopl.io<span class="hljs-regexp">/ch3/</span>basename2gopl.io<span class="hljs-regexp">/ch3/</span>commagopl.io<span class="hljs-regexp">/ch3/m</span>andelbrotgopl.io<span class="hljs-regexp">/ch3/</span>netflaggopl.io<span class="hljs-regexp">/ch3/</span>printintsgopl.io<span class="hljs-regexp">/ch3/</span>surface</code></pre></li><li><p>或者是和某个主题相关的所有包:</p><pre><code class="hljs lasso">$ go <span class="hljs-built_in">list</span> <span class="hljs-params">...</span><span class="hljs-built_in">xml</span><span class="hljs-params">...</span>encoding/<span class="hljs-built_in">xml</span>gopl.io/ch7/xmlselect</code></pre></li><li><p><code>go list</code>命令还可以获取每个包完整的元信息，而不仅仅只是导入路径，这些元信息可以以不同格式提供给用户。其中<code>-json</code>命令行参数表示用JSON格式打印每个包的元信息。</p><pre><code class="hljs smalltalk"><span class="hljs-string">$ </span>go list -json hash&#123;<span class="hljs-comment">&quot;Dir&quot;</span>: <span class="hljs-comment">&quot;/home/gopher/go/src/hash&quot;</span>,<span class="hljs-comment">&quot;ImportPath&quot;</span>: <span class="hljs-comment">&quot;hash&quot;</span>,<span class="hljs-comment">&quot;Name&quot;</span>: <span class="hljs-comment">&quot;hash&quot;</span>,<span class="hljs-comment">&quot;Doc&quot;</span>: <span class="hljs-comment">&quot;Package hash provides interfaces for hash functions.&quot;</span>,<span class="hljs-comment">&quot;Target&quot;</span>: <span class="hljs-comment">&quot;/home/gopher/go/pkg/darwin_amd64/hash.a&quot;</span>,<span class="hljs-comment">&quot;Goroot&quot;</span>: <span class="hljs-keyword">true</span>,<span class="hljs-comment">&quot;Standard&quot;</span>: <span class="hljs-keyword">true</span>,<span class="hljs-comment">&quot;Root&quot;</span>: <span class="hljs-comment">&quot;/home/gopher/go&quot;</span>,<span class="hljs-comment">&quot;GoFiles&quot;</span>: [<span class="hljs-comment">&quot;hash.go&quot;</span>],<span class="hljs-comment">&quot;Imports&quot;</span>: [<span class="hljs-comment">&quot;io&quot;</span>],<span class="hljs-comment">&quot;Deps&quot;</span>: [<span class="hljs-comment">&quot;errors&quot;</span>,<span class="hljs-comment">&quot;io&quot;</span>,<span class="hljs-comment">&quot;runtime&quot;</span>,<span class="hljs-comment">&quot;sync&quot;</span>,<span class="hljs-comment">&quot;sync/atomic&quot;</span>,<span class="hljs-comment">&quot;unsafe&quot;</span>]&#125;</code></pre></li><li><p>命令行参数<code>-f</code>则允许用户使用text/template包（§4.6）的模板语言定义输出文本的格式。下面的命令将打印strconv包的依赖的包，然后用join模板函数将结果链接为一行，连接时每个结果之间用一个空格分隔：</p>    <pre><code class="hljs handlebars"><span class="xml">$ go list -f &#x27;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">join</span> .Deps <span class="hljs-string">&quot; &quot;</span>&#125;&#125;</span><span class="xml">&#x27; strconv</span><span class="xml">errors math runtime unicode/utf8 unsafe</span></code></pre>    <ul><li><p>上面的命令在Windows的命令行运行会遇到<code>template: main:1: unclosed action</code>的错误。产生这个错误的原因是因为命令行对命令中的<code>&quot; &quot;</code>参数进行了转义处理。可以按照下面的方法解决转义字符串的问题：</p>      <pre><code class="hljs handlebars"><span class="xml">$ go list -f &quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">join</span> .Deps \<span class="hljs-string">&quot; \&quot;&#125;&#125;&quot;</span> strconv</span></code></pre>      </li></ul></li><li><p>下面的命令打印compress子目录下所有包的导入包列表：</p>    <pre><code class="hljs livecodeserver">$ go list -f <span class="hljs-string">&#x27;&#123;&#123;.ImportPath&#125;&#125; -&gt; &#123;&#123;join .Imports &quot; &quot;&#125;&#125;&#x27;</span> <span class="hljs-built_in">compress</span>/...<span class="hljs-built_in">compress</span>/bzip2 -&gt; bufio io <span class="hljs-built_in">sort</span><span class="hljs-built_in">compress</span>/flate -&gt; bufio fmt io math <span class="hljs-built_in">sort</span> strconv<span class="hljs-built_in">compress</span>/gzip -&gt; bufio <span class="hljs-built_in">compress</span>/flate errors fmt hash hash/crc32 io <span class="hljs-built_in">time</span><span class="hljs-built_in">compress</span>/lzw -&gt; bufio errors fmt io<span class="hljs-built_in">compress</span>/zlib -&gt; bufio <span class="hljs-built_in">compress</span>/flate errors fmt hash hash/adler32 io</code></pre>    <ul><li><p>译注：Windows下有同样有问题，要避免转义字符串的干扰：</p>      <pre><code class="hljs handlebars"><span class="xml">$ go list -f &quot;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.ImportPath</span>&#125;&#125;</span><span class="xml"> -&gt; </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">join</span> .Imports \<span class="hljs-string">&quot; \&quot;&#125;&#125;&quot;</span> compress/...</span></code></pre>      </li></ul></li><li><p><code>go list</code>命令对于一次性的交互式查询或自动化构建或测试脚本都很有帮助。我们将在11.2.4节中再次使用它。每个子命令的更多信息，包括可设置的字段和意义，可以用<code>go help list</code>命令查看。</p></li><li><p>在本章，我们解释了Go语言工具中除了测试命令之外的所有重要的子命令。在下一章，我们将看到如何用<code>go test</code>命令去运行Go语言程序中的测试代码。</p></li></ul></li></ul><h2 id="ch11-测试"><a href="#ch11-测试" class="headerlink" title="ch11  测试"></a>ch11  测试</h2><h3 id="ch11-0-简介"><a href="#ch11-0-简介" class="headerlink" title="ch11.0  简介"></a>ch11.0  简介</h3><ul><li>Maurice Wilkes，第一个存储程序计算机EDSAC的设计者，1949年他在实验室爬楼梯时有一个顿悟。在《计算机先驱回忆录》（Memoirs of a Computer Pioneer）里，他回忆到：“忽然间有一种醍醐灌顶的感觉，我整个后半生的美好时光都将在寻找程序BUG中度过了”。肯定从那之后的大部分正常的码农都会同情Wilkes过分悲观的想法，虽然也许会有人困惑于他对软件开发的难度的天真看法。</li><li>现在的程序已经远比Wilkes时代的更大也更复杂，也有许多技术可以让软件的复杂性可得到控制。其中有两种技术在实践中证明是比较有效的。第一种是代码在被正式部署前需要进行代码评审。第二种则是测试，也就是本章的讨论主题。</li><li>我们说测试的时候一般是指自动化测试，也就是写一些小的程序用来检测被测试代码（产品代码）的行为和预期的一样，这些通常都是精心设计的执行某些特定的功能或者是通过随机性的输入待验证边界的处理。</li><li>软件测试是一个巨大的领域。测试的任务可能已经占据了一些程序员的部分时间和另一些程序员的全部时间。和软件测试技术相关的图书或博客文章有成千上万之多。对于每一种主流的编程语言，都会有一打的用于测试的软件包，同时也有大量的测试相关的理论，而且每种都吸引了大量技术先驱和追随者。这些都足以说服那些想要编写有效测试的程序员重新学习一套全新的技能。</li><li>Go语言的测试技术是相对低级的。它依赖一个go test测试命令和一组按照约定方式编写的测试函数，测试命令可以运行这些测试函数。编写相对轻量级的纯测试代码是有效的，而且它很容易延伸到基准测试和示例文档。</li><li>在实践中，编写测试代码和编写程序本身并没有多大区别。我们编写的每一个函数也是针对每个具体的任务。我们必须小心处理边界条件，思考合适的数据结构，推断合适的输入应该产生什么样的结果输出。编写测试代码和编写普通的Go代码过程是类似的；它并不需要学习新的符号、规则和工具。</li></ul><h3 id="ch11-1-go-test"><a href="#ch11-1-go-test" class="headerlink" title="ch11.1  go test"></a>ch11.1  go test</h3><ul><li><p>go test命令是一个按照一定的约定和组织来测试代码的程序。在包目录内，所有以<code>_test.go</code>为后缀名的源文件在执行go build时不会被构建成包的一部分，它们是go test测试的一部分。</p></li><li><p>在<code>*_test.go</code>文件中，有三种类型的函数：测试函数、基准测试（benchmark）函数、示例函数。</p><ul><li>一个测试函数是以Test为函数名前缀的函数，用于测试程序的一些逻辑行为是否正确；go test命令会调用这些测试函数并报告测试结果是PASS或FAIL。</li><li>基准测试函数是以Benchmark为函数名前缀的函数，它们用于衡量一些函数的性能；go test命令会多次运行基准测试函数以计算一个平均的执行时间。</li><li>示例函数是以Example为函数名前缀的函数，提供一个由编译器保证正确性的示例文档。</li></ul></li><li><p>我们将在11.2节讨论测试函数的所有细节，并在11.4节讨论基准测试函数的细节，然后在11.6节讨论示例函数的细节。</p></li><li><p>go test命令会遍历所有的<code>*_test.go</code>文件中符合上述命名规则的函数，生成一个临时的main包用于调用相应的测试函数，接着构建并运行、报告测试结果，最后清理测试中生成的临时文件。</p></li></ul><h3 id="ch11-2-测试函数"><a href="#ch11-2-测试函数" class="headerlink" title="ch11.2  测试函数"></a>ch11.2  测试函数</h3><ul><li><p>ch11.2.0 简介</p><ul><li><p>每个测试函数必须导入testing包。测试函数有如下的签名：</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestName</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-comment">// ...</span>&#125;</code></pre></li><li><p>测试函数的名字必须以Test开头，可选的后缀名必须以大写字母开头：</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSin</span><span class="hljs-params">(t *testing.T)</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCos</span><span class="hljs-params">(t *testing.T)</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestLog</span><span class="hljs-params">(t *testing.T)</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;</code></pre><ul><li>其中t参数用于报告测试失败和附加的日志信息。让我们定义一个实例包gopl.io/ch11/word1，其中只有一个函数IsPalindrome用于检查一个字符串是否从前向后和从后向前读都是一样的。</li></ul></li><li><p>下面这个实现对于一个字符串是否是回文字符串前后重复测试了两次；我们稍后会再讨论这个问题。</p><p><u><i>gopl.io/ch11/word1</i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// Package word provides utilities for word games.</span><span class="hljs-keyword">package</span> word<span class="hljs-comment">// IsPalindrome reports whether s reads the same forward and backward.</span><span class="hljs-comment">// (Our first attempt.)</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPalindrome</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> s &#123;<span class="hljs-keyword">if</span> s[i] != s[<span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>-i] &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></li><li><p>在相同的目录下，word_test.go测试文件中包含了TestPalindrome和TestNonPalindrome两个测试函数。每一个都是测试IsPalindrome是否给出正确的结果，并使用t.Error报告失败信息：</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> word<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestPalindrome</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">if</span> !IsPalindrome(<span class="hljs-string">&quot;detartrated&quot;</span>) &#123;t.Error(<span class="hljs-string">`IsPalindrome(&quot;detartrated&quot;) = false`</span>)&#125;<span class="hljs-keyword">if</span> !IsPalindrome(<span class="hljs-string">&quot;kayak&quot;</span>) &#123;t.Error(<span class="hljs-string">`IsPalindrome(&quot;kayak&quot;) = false`</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestNonPalindrome</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">if</span> IsPalindrome(<span class="hljs-string">&quot;palindrome&quot;</span>) &#123;t.Error(<span class="hljs-string">`IsPalindrome(&quot;palindrome&quot;) = true`</span>)&#125;&#125;</code></pre></li><li><p><code>go test</code>命令如果没有参数指定包那么将默认采用当前目录对应的包（和<code>go build</code>命令一样）。我们可以用下面的命令构建和运行测试。</p><pre><code class="hljs awk">$ cd <span class="hljs-variable">$GOPATH</span><span class="hljs-regexp">/src/g</span>opl.io<span class="hljs-regexp">/ch11/</span>word1$ go testok   gopl.io<span class="hljs-regexp">/ch11/</span>word1  <span class="hljs-number">0.008</span>s</code></pre></li><li><p>结果还比较满意，我们运行了这个程序，不过没有提前退出是因为还没有遇到BUG报告。不过一个法国名为“Noelle Eve Elleon”的用户会抱怨IsPalindrome函数不能识别“été”。另外一个来自美国中部用户的抱怨则是不能识别“A man, a plan, a canal: Panama.”。执行特殊和小的BUG报告为我们提供了新的更自然的测试用例。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFrenchPalindrome</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">if</span> !IsPalindrome(<span class="hljs-string">&quot;été&quot;</span>) &#123;t.Error(<span class="hljs-string">`IsPalindrome(&quot;été&quot;) = false`</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCanalPalindrome</span><span class="hljs-params">(t *testing.T)</span></span> &#123;input := <span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span><span class="hljs-keyword">if</span> !IsPalindrome(input) &#123;t.Errorf(<span class="hljs-string">`IsPalindrome(%q) = false`</span>, input)&#125;&#125;</code></pre></li><li><p>为了避免两次输入较长的字符串，我们使用了提供了有类似Printf格式化功能的 Errorf函数来汇报错误结果。</p></li><li><p>当添加了这两个测试用例之后，<code>go test</code>返回了测试失败的信息。</p><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">go</span> <span class="hljs-string">test</span><span class="hljs-string">---</span> <span class="hljs-attr">FAIL:</span> <span class="hljs-string">TestFrenchPalindrome</span> <span class="hljs-string">(0.00s)</span>    <span class="hljs-attr">word_test.go:28:</span> <span class="hljs-string">IsPalindrome(&quot;été&quot;)</span> <span class="hljs-string">=</span> <span class="hljs-literal">false</span><span class="hljs-string">---</span> <span class="hljs-attr">FAIL:</span> <span class="hljs-string">TestCanalPalindrome</span> <span class="hljs-string">(0.00s)</span>    <span class="hljs-attr">word_test.go:35:</span> <span class="hljs-string">IsPalindrome(&quot;A</span> <span class="hljs-string">man,</span> <span class="hljs-string">a</span> <span class="hljs-string">plan,</span> <span class="hljs-attr">a canal:</span> <span class="hljs-string">Panama&quot;)</span> <span class="hljs-string">=</span> <span class="hljs-literal">false</span><span class="hljs-string">FAIL</span><span class="hljs-string">FAIL</span>    <span class="hljs-string">gopl.io/ch11/word1</span>  <span class="hljs-number">0.</span><span class="hljs-string">014s</span></code></pre></li><li><p>先编写测试用例并观察到测试用例触发了和用户报告的错误相同的描述是一个好的测试习惯。只有这样，我们才能定位我们要真正解决的问题。</p></li><li><p>先写测试用例的另外的好处是，运行测试通常会比手工描述报告的处理更快，这让我们可以进行快速地迭代。如果测试集有很多运行缓慢的测试，我们可以通过只选择运行某些特定的测试来加快测试速度。</p><ul><li><p>参数<code>-v</code>可用于打印每个测试函数的名字和运行时间：</p><pre><code class="hljs asciidoc">$ go test -v<span class="hljs-section">=== RUN TestPalindrome</span><span class="hljs-bullet">--- </span>PASS: TestPalindrome (0.00s)<span class="hljs-section">=== RUN TestNonPalindrome</span><span class="hljs-bullet">--- </span>PASS: TestNonPalindrome (0.00s)<span class="hljs-section">=== RUN TestFrenchPalindrome</span><span class="hljs-bullet">--- </span>FAIL: TestFrenchPalindrome (0.00s)<span class="hljs-code">    word_test.go:28: IsPalindrome(&quot;été&quot;) = false</span><span class="hljs-section">=== RUN TestCanalPalindrome</span><span class="hljs-bullet">--- </span>FAIL: TestCanalPalindrome (0.00s)<span class="hljs-code">    word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) = false</span>FAILexit status 1FAIL    gopl.io/ch11/word1  0.017s</code></pre></li><li><p>参数<code>-run</code>对应一个正则表达式，只有测试函数名被它正确匹配的测试函数才会被<code>go test</code>测试命令运行：</p><pre><code class="hljs asciidoc">$ go test -v -run=&quot;French|Canal&quot;<span class="hljs-section">=== RUN TestFrenchPalindrome</span><span class="hljs-bullet">--- </span>FAIL: TestFrenchPalindrome (0.00s)<span class="hljs-code">    word_test.go:28: IsPalindrome(&quot;été&quot;) = false</span><span class="hljs-section">=== RUN TestCanalPalindrome</span><span class="hljs-bullet">--- </span>FAIL: TestCanalPalindrome (0.00s)<span class="hljs-code">    word_test.go:35: IsPalindrome(&quot;A man, a plan, a canal: Panama&quot;) = false</span>FAILexit status 1FAIL    gopl.io/ch11/word1  0.014s</code></pre></li></ul></li><li><p>当然，一旦我们已经修复了失败的测试用例，在我们提交代码更新之前，我们应该以不带参数的<code>go test</code>命令运行全部的测试用例，以确保修复失败测试的同时没有引入新的问题。</p></li><li><p>我们现在的任务就是修复这些错误。简要分析后发现第一个BUG的原因是我们采用了 byte而不是rune序列，所以像“été”中的é等非ASCII字符不能正确处理。第二个BUG是因为没有忽略空格和字母的大小写导致的。</p><ul><li><p>针对上述两个BUG，我们仔细重写了函数：</p><p><u><i>gopl.io/ch11/word2</i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// Package word provides utilities for word games.</span><span class="hljs-keyword">package</span> word<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unicode&quot;</span><span class="hljs-comment">// IsPalindrome reports whether s reads the same forward and backward.</span><span class="hljs-comment">// Letter case is ignored, as are non-letters.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPalindrome</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">var</span> letters []<span class="hljs-keyword">rune</span><span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> s &#123;<span class="hljs-keyword">if</span> unicode.IsLetter(r) &#123;letters = <span class="hljs-built_in">append</span>(letters, unicode.ToLower(r))&#125;&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> letters &#123;<span class="hljs-keyword">if</span> letters[i] != letters[<span class="hljs-built_in">len</span>(letters)<span class="hljs-number">-1</span>-i] &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></li><li><p>同时我们也将之前的所有测试数据合并到了一个测试中的表格中。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestIsPalindrome</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> tests = []<span class="hljs-keyword">struct</span> &#123;input <span class="hljs-keyword">string</span>want  <span class="hljs-keyword">bool</span>&#125;&#123;&#123;<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">true</span>&#125;,&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-literal">true</span>&#125;,&#123;<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-literal">true</span>&#125;,&#123;<span class="hljs-string">&quot;ab&quot;</span>, <span class="hljs-literal">false</span>&#125;,&#123;<span class="hljs-string">&quot;kayak&quot;</span>, <span class="hljs-literal">true</span>&#125;,&#123;<span class="hljs-string">&quot;detartrated&quot;</span>, <span class="hljs-literal">true</span>&#125;,&#123;<span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span>, <span class="hljs-literal">true</span>&#125;,&#123;<span class="hljs-string">&quot;Evil I did dwell; lewd did I live.&quot;</span>, <span class="hljs-literal">true</span>&#125;,&#123;<span class="hljs-string">&quot;Able was I ere I saw Elba&quot;</span>, <span class="hljs-literal">true</span>&#125;,&#123;<span class="hljs-string">&quot;été&quot;</span>, <span class="hljs-literal">true</span>&#125;,&#123;<span class="hljs-string">&quot;Et se resservir, ivresse reste.&quot;</span>, <span class="hljs-literal">true</span>&#125;,&#123;<span class="hljs-string">&quot;palindrome&quot;</span>, <span class="hljs-literal">false</span>&#125;, <span class="hljs-comment">// non-palindrome</span>&#123;<span class="hljs-string">&quot;desserts&quot;</span>, <span class="hljs-literal">false</span>&#125;,   <span class="hljs-comment">// semi-palindrome</span>&#125;<span class="hljs-keyword">for</span> _, test := <span class="hljs-keyword">range</span> tests &#123;<span class="hljs-keyword">if</span> got := IsPalindrome(test.input); got != test.want &#123;t.Errorf(<span class="hljs-string">&quot;IsPalindrome(%q) = %v&quot;</span>, test.input, got)&#125;&#125;&#125;</code></pre></li><li><p>现在我们的新测试都通过了：</p><pre><code class="hljs awk">$ go test gopl.io<span class="hljs-regexp">/ch11/</span>word2ok      gopl.io<span class="hljs-regexp">/ch11/</span>word2      <span class="hljs-number">0.015</span>s</code></pre></li></ul></li><li><p>这种表格驱动的测试在Go语言中很常见。我们可以很容易地向表格添加新的测试数据，并且后面的测试逻辑也没有冗余，这样我们可以有更多的精力去完善错误信息。</p></li><li><p>失败测试的输出并不包括调用t.Errorf时刻的堆栈调用信息。和其他编程语言或测试框架的assert断言不同，t.Errorf调用也没有引起panic异常或停止测试的执行。即使表格中前面的数据导致了测试的失败，表格后面的测试数据依然会运行测试，因此在一个测试中我们可能了解多个失败的信息。</p></li><li><p>如果我们真的需要停止测试，或许是因为初始化失败或可能是早先的错误导致了后续错误等原因，我们可以使用t.Fatal或t.Fatalf停止当前测试函数。它们必须在和测试函数同一个goroutine内调用。</p></li><li><p>测试失败的信息一般的形式是“f(x) = y, want z”，其中f(x)解释了失败的操作和对应的输入，y是实际的运行结果，z是期望的正确的结果。就像前面检查回文字符串的例子，实际的函数用于f(x)部分。显示x是表格驱动型测试中比较重要的部分，因为同一个断言可能对应不同的表格项执行多次。要避免无用和冗余的信息。在测试类似IsPalindrome返回布尔类型的函数时，可以忽略并没有额外信息的z部分。如果x、y或z是y的长度，输出一个相关部分的简明总结即可。测试的作者应该要努力帮助程序员诊断测试失败的原因。</p></li></ul></li><li><p>ch11.2.1 随机测试</p><ul><li><p>表格驱动的测试便于构造基于精心挑选的测试数据的测试用例。另一种测试思路是随机测试，也就是通过构造更广泛的随机输入来测试探索函数的行为。</p></li><li><p>那么对于一个随机的输入，我们如何能知道希望的输出结果呢？这里有两种处理策略。第一个是编写另一个对照函数，使用简单和清晰的算法，虽然效率较低但是行为和要测试的函数是一致的，然后针对相同的随机输入检查两者的输出结果。第二种是生成的随机输入的数据遵循特定的模式，这样我们就可以知道期望的输出的模式。</p></li><li><p>下面的例子使用的是第二种方法：randomPalindrome函数用于随机生成回文字符串。</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math/rand&quot;</span><span class="hljs-comment">// randomPalindrome returns a palindrome whose length and contents</span><span class="hljs-comment">// are derived from the pseudo-random number generator rng.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">randomPalindrome</span><span class="hljs-params">(rng *rand.Rand)</span> <span class="hljs-title">string</span></span> &#123;n := rng.Intn(<span class="hljs-number">25</span>) <span class="hljs-comment">// random length up to 24</span>runes := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">rune</span>, n)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; (n+<span class="hljs-number">1</span>)/<span class="hljs-number">2</span>; i++ &#123;r := <span class="hljs-keyword">rune</span>(rng.Intn(<span class="hljs-number">0x1000</span>)) <span class="hljs-comment">// random rune up to &#x27;\u0999&#x27;</span>runes[i] = rrunes[n<span class="hljs-number">-1</span>-i] = r&#125;<span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(runes)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestRandomPalindromes</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-comment">// Initialize a pseudo-random number generator.</span>seed := time.Now().UTC().UnixNano()t.Logf(<span class="hljs-string">&quot;Random seed: %d&quot;</span>, seed)rng := rand.New(rand.NewSource(seed))<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;p := randomPalindrome(rng)<span class="hljs-keyword">if</span> !IsPalindrome(p) &#123;t.Errorf(<span class="hljs-string">&quot;IsPalindrome(%q) = false&quot;</span>, p)&#125;&#125;&#125;</code></pre></li><li><p>虽然随机测试会有不确定因素，但是它也是至关重要的，我们可以从失败测试的日志获取足够的信息。在我们的例子中，输入IsPalindrome的p参数将告诉我们真实的数据，但是对于函数将接受更复杂的输入，不需要保存所有的输入，只要日志中简单地记录随机数种子即可（像上面的方式）。有了这些随机数初始化种子，我们可以很容易修改测试代码以重现失败的随机测试。</p></li><li><p>通过使用当前时间作为随机种子，在整个过程中的每次运行测试命令时都将探索新的随机数据。如果你使用的是定期运行的自动化测试集成系统，随机测试将特别有价值。</p></li></ul></li><li><p>ch11.2.2 测试一个命令</p><ul><li><p>对于测试包<code>go test</code>是一个有用的工具，但是稍加努力我们也可以用它来测试可执行程序。如果一个包的名字是 main，那么在构建时会生成一个可执行程序，不过main包可以作为一个包被测试器代码导入。</p></li><li><p>让我们为2.3.2节的echo程序编写一个测试。我们先将程序拆分为两个函数：echo函数完成真正的工作，main函数用于处理命令行输入参数和echo可能返回的错误。</p><p><u><i>gopl.io/ch11/echo</i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// Echo prints its command-line arguments.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;flag&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-keyword">var</span> (n = flag.Bool(<span class="hljs-string">&quot;n&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;omit trailing newline&quot;</span>)s = flag.String(<span class="hljs-string">&quot;s&quot;</span>, <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;separator&quot;</span>))<span class="hljs-keyword">var</span> out io.Writer = os.Stdout <span class="hljs-comment">// modified during testing</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;flag.Parse()<span class="hljs-keyword">if</span> err := echo(!*n, *s, flag.Args()); err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;echo: %v\n&quot;</span>, err)os.Exit(<span class="hljs-number">1</span>)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">echo</span><span class="hljs-params">(newline <span class="hljs-keyword">bool</span>, sep <span class="hljs-keyword">string</span>, args []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;fmt.Fprint(out, strings.Join(args, sep))<span class="hljs-keyword">if</span> newline &#123;fmt.Fprintln(out)&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></li><li><p>在测试中我们可以用各种参数和标志调用echo函数，然后检测它的输出是否正确，我们通过增加参数来减少echo函数对全局变量的依赖。我们还增加了一个全局名为out的变量来替代直接使用os.Stdout，这样测试代码可以根据需要将out修改为不同的对象以便于检查。下面就是echo_test.go文件中的测试代码：</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;bytes&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;testing&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestEcho</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> tests = []<span class="hljs-keyword">struct</span> &#123;newline <span class="hljs-keyword">bool</span>sep     <span class="hljs-keyword">string</span>args    []<span class="hljs-keyword">string</span>want    <span class="hljs-keyword">string</span>&#125;&#123;&#123;<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;&quot;</span>, []<span class="hljs-keyword">string</span>&#123;&#125;, <span class="hljs-string">&quot;\n&quot;</span>&#125;,&#123;<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;&quot;</span>, []<span class="hljs-keyword">string</span>&#123;&#125;, <span class="hljs-string">&quot;&quot;</span>&#125;,&#123;<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;\t&quot;</span>, []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;, <span class="hljs-string">&quot;one\ttwo\tthree\n&quot;</span>&#125;,&#123;<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;,&quot;</span>, []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;, <span class="hljs-string">&quot;a,b,c\n&quot;</span>&#125;,&#123;<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;:&quot;</span>, []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>&#125;, <span class="hljs-string">&quot;1:2:3&quot;</span>&#125;,&#125;<span class="hljs-keyword">for</span> _, test := <span class="hljs-keyword">range</span> tests &#123;descr := fmt.Sprintf(<span class="hljs-string">&quot;echo(%v, %q, %q)&quot;</span>,test.newline, test.sep, test.args)out = <span class="hljs-built_in">new</span>(bytes.Buffer) <span class="hljs-comment">// captured output</span><span class="hljs-keyword">if</span> err := echo(test.newline, test.sep, test.args); err != <span class="hljs-literal">nil</span> &#123;t.Errorf(<span class="hljs-string">&quot;%s failed: %v&quot;</span>, descr, err)<span class="hljs-keyword">continue</span>&#125;got := out.(*bytes.Buffer).String()<span class="hljs-keyword">if</span> got != test.want &#123;t.Errorf(<span class="hljs-string">&quot;%s = %q, want %q&quot;</span>, descr, got, test.want)&#125;&#125;&#125;</code></pre></li><li><p>要注意的是测试代码和产品代码在同一个包。虽然是main包，也有对应的main入口函数，但是在测试的时候main包只是TestEcho测试函数导入的一个普通包，里面main函数并没有被导出，而是被忽略的。</p></li><li><p>通过将测试放到表格中，我们很容易添加新的测试用例。让我通过增加下面的测试用例来看看失败的情况是怎么样的：</p><pre><code class="hljs Go">&#123;<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;,&quot;</span>, []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;, <span class="hljs-string">&quot;a b c\n&quot;</span>&#125;, <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> wrong expectation!</span></code></pre></li><li><p><code>go test</code>输出如下：</p><pre><code class="hljs bash">$ go <span class="hljs-built_in">test</span> gopl.io/ch11/<span class="hljs-built_in">echo</span>--- FAIL: TestEcho (0.00s)    echo_test.go:31: <span class="hljs-built_in">echo</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;,&quot;</span>, [<span class="hljs-string">&quot;a&quot;</span> <span class="hljs-string">&quot;b&quot;</span> <span class="hljs-string">&quot;c&quot;</span>]) = <span class="hljs-string">&quot;a,b,c&quot;</span>, want <span class="hljs-string">&quot;a b c\n&quot;</span>FAILFAIL        gopl.io/ch11/<span class="hljs-built_in">echo</span>         0.006s</code></pre></li><li><p>错误信息描述了尝试的操作（使用Go类似语法），实际的结果和期望的结果。通过这样的错误信息，你可以在检视代码之前就很容易定位错误的原因。</p></li><li><p>要注意的是在测试代码中并没有调用log.Fatal或os.Exit，因为调用这类函数会导致程序提前退出；调用这些函数的特权应该放在main函数中。如果真的有意外的事情导致函数发生panic异常，测试驱动应该尝试用recover捕获异常，然后将当前测试当作失败处理。如果是可预期的错误，例如非法的用户输入、找不到文件或配置文件不当等应该通过返回一个非空的error的方式处理。幸运的是（上面的意外只是一个插曲），我们的echo示例是比较简单的也没有需要返回非空error的情况。</p></li></ul></li><li><p>ch11.2.3 白盒测试</p><ul><li><p>一种测试分类的方法是基于测试者是否需要了解被测试对象的内部工作原理。黑盒测试只需要测试包公开的文档和API行为，内部实现对测试代码是透明的。相反，白盒测试有访问包内部函数和数据结构的权限，因此可以做到一些普通客户端无法实现的测试。例如，一个白盒测试可以在每个操作之后检测不变量的数据类型。</p><ul><li>白盒测试只是一个传统的名称，其实称为clear box测试会更准确。</li></ul></li><li><p>黑盒和白盒这两种测试方法是互补的。黑盒测试一般更健壮，随着软件实现的完善测试代码很少需要更新。它们可以帮助测试者了解真实客户的需求，也可以帮助发现API设计的一些不足之处。相反，白盒测试则可以对内部一些棘手的实现提供更多的测试覆盖。</p></li><li><p>我们已经看到两种测试的例子。TestIsPalindrome测试仅仅使用导出的IsPalindrome函数，因此这是一个黑盒测试。TestEcho测试则调用了内部的echo函数，并且更新了内部的out包级变量，这两个都是未导出的，因此这是白盒测试。</p></li><li><p>当我们准备TestEcho测试的时候，我们修改了echo函数使用包级的out变量作为输出对象，因此测试代码可以用另一个实现代替标准输出，这样可以方便对比echo输出的数据。使用类似的技术，我们可以将产品代码的其他部分也替换为一个容易测试的伪对象。使用伪对象的好处是我们可以方便配置，容易预测，更可靠，也更容易观察。同时也可以避免一些不良的副作用，例如更新生产数据库或信用卡消费行为。</p></li><li><p>下面的代码演示了为用户提供网络存储的web服务中的配额检测逻辑。当用户使用了超过90%的存储配额之后将发送提醒邮件。</p><p><u><i>gopl.io/ch11/storage1</i></u></p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> storage<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;net/smtp&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bytesInUse</span><span class="hljs-params">(username <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int64</span></span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-comment">// Email sender configuration.</span><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> never put passwords in source code!</span><span class="hljs-keyword">const</span> sender = <span class="hljs-string">&quot;notifications@example.com&quot;</span><span class="hljs-keyword">const</span> password = <span class="hljs-string">&quot;correcthorsebatterystaple&quot;</span><span class="hljs-keyword">const</span> hostname = <span class="hljs-string">&quot;smtp.example.com&quot;</span><span class="hljs-keyword">const</span> template = <span class="hljs-string">`Warning: you are using %d bytes of storage,</span><span class="hljs-string">%d%% of your quota.`</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckQuota</span><span class="hljs-params">(username <span class="hljs-keyword">string</span>)</span></span> &#123;used := bytesInUse(username)<span class="hljs-keyword">const</span> quota = <span class="hljs-number">1000000000</span> <span class="hljs-comment">// 1GB</span>percent := <span class="hljs-number">100</span> * used / quota<span class="hljs-keyword">if</span> percent &lt; <span class="hljs-number">90</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-comment">// OK</span>&#125;msg := fmt.Sprintf(template, used, percent)auth := smtp.PlainAuth(<span class="hljs-string">&quot;&quot;</span>, sender, password, hostname)err := smtp.SendMail(hostname+<span class="hljs-string">&quot;:587&quot;</span>, auth, sender,[]<span class="hljs-keyword">string</span>&#123;username&#125;, []<span class="hljs-keyword">byte</span>(msg))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Printf(<span class="hljs-string">&quot;smtp.SendMail(%s) failed: %s&quot;</span>, username, err)&#125;&#125;</code></pre><ul><li>译注：一般在实现业务机器监控，包括磁盘、cpu、网络等的时候，需要类似的到达阈值=&gt;触发报警的逻辑，所以是很实用的案例。</li></ul></li><li><p>我们想测试这段代码，但是我们并不希望发送真实的邮件。因此我们将邮件处理逻辑放到一个私有的notifyUser函数中。</p><p><u><i>gopl.io/ch11/storage2</i></u></p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> notifyUser = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(username, msg <span class="hljs-keyword">string</span>)</span></span> &#123;auth := smtp.PlainAuth(<span class="hljs-string">&quot;&quot;</span>, sender, password, hostname)err := smtp.SendMail(hostname+<span class="hljs-string">&quot;:587&quot;</span>, auth, sender,[]<span class="hljs-keyword">string</span>&#123;username&#125;, []<span class="hljs-keyword">byte</span>(msg))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Printf(<span class="hljs-string">&quot;smtp.SendEmail(%s) failed: %s&quot;</span>, username, err)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CheckQuota</span><span class="hljs-params">(username <span class="hljs-keyword">string</span>)</span></span> &#123;used := bytesInUse(username)<span class="hljs-keyword">const</span> quota = <span class="hljs-number">1000000000</span> <span class="hljs-comment">// 1GB</span>percent := <span class="hljs-number">100</span> * used / quota<span class="hljs-keyword">if</span> percent &lt; <span class="hljs-number">90</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-comment">// OK</span>&#125;msg := fmt.Sprintf(template, used, percent)notifyUser(username, msg)&#125;</code></pre></li><li><p>现在我们可以在测试中用伪邮件发送函数替代真实的邮件发送函数。它只是简单记录要通知的用户和邮件的内容。</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> storage<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;strings&quot;</span><span class="hljs-string">&quot;testing&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCheckQuotaNotifiesUser</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> notifiedUser, notifiedMsg <span class="hljs-keyword">string</span>notifyUser = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(user, msg <span class="hljs-keyword">string</span>)</span></span> &#123;notifiedUser, notifiedMsg = user, msg&#125;<span class="hljs-comment">// ...simulate a 980MB-used condition...</span><span class="hljs-keyword">const</span> user = <span class="hljs-string">&quot;joe@example.org&quot;</span>CheckQuota(user)<span class="hljs-keyword">if</span> notifiedUser == <span class="hljs-string">&quot;&quot;</span> &amp;&amp; notifiedMsg == <span class="hljs-string">&quot;&quot;</span> &#123;t.Fatalf(<span class="hljs-string">&quot;notifyUser not called&quot;</span>)&#125;<span class="hljs-keyword">if</span> notifiedUser != user &#123;t.Errorf(<span class="hljs-string">&quot;wrong user (%s) notified, want %s&quot;</span>,notifiedUser, user)&#125;<span class="hljs-keyword">const</span> wantSubstring = <span class="hljs-string">&quot;98% of your quota&quot;</span><span class="hljs-keyword">if</span> !strings.Contains(notifiedMsg, wantSubstring) &#123;t.Errorf(<span class="hljs-string">&quot;unexpected notification message &lt;&lt;%s&gt;&gt;, &quot;</span>+<span class="hljs-string">&quot;want substring %q&quot;</span>, notifiedMsg, wantSubstring)&#125;&#125;</code></pre></li><li><p>这里有一个问题：当测试函数返回后，CheckQuota将不能正常工作，因为notifyUsers依然使用的是测试函数的伪发送邮件函数（当更新全局对象的时候总会有这种风险）。 我们必须修改测试代码恢复notifyUsers原先的状态以便后续其他的测试没有影响，要确保所有的执行路径后都能恢复，包括测试失败或panic异常的情形。在这种情况下，我们建议使用defer语句来延后执行处理恢复的代码。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCheckQuotaNotifiesUser</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-comment">// Save and restore original notifyUser.</span>saved := notifyUser<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; notifyUser = saved &#125;()<span class="hljs-comment">// Install the test&#x27;s fake notifyUser.</span><span class="hljs-keyword">var</span> notifiedUser, notifiedMsg <span class="hljs-keyword">string</span>notifyUser = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(user, msg <span class="hljs-keyword">string</span>)</span></span> &#123;notifiedUser, notifiedMsg = user, msg&#125;<span class="hljs-comment">// ...rest of test...</span>&#125;</code></pre></li><li><p>这种处理模式可以用来暂时保存和恢复所有的全局变量，包括命令行标志参数、调试选项和优化参数；安装和移除导致生产代码产生一些调试信息的钩子函数；还有有些诱导生产代码进入某些重要状态的改变，比如超时、错误，甚至是一些刻意制造的并发行为等因素。</p></li><li><p>以这种方式使用全局变量是安全的，因为go test命令并不会同时并发地执行多个测试。</p></li></ul></li><li><p>ch11.2.4 外部测试包</p><ul><li><p>考虑下这两个包：net/url包，提供了URL解析的功能；net/http包，提供了web服务和HTTP客户端的功能。如我们所料，上层的net/http包依赖下层的net/url包。然后，net/url包中的一个测试是演示不同URL和HTTP客户端的交互行为。也就是说，一个下层包的测试代码导入了上层的包。</p></li><li><p>这样的行为在net/url包的测试代码中会导致包的循环依赖，正如图11.1中向上箭头所示，同时正如我们在10.1节所讲的，Go语言规范是禁止包的循环依赖的。</p></li><li><p>不过我们可以通过外部测试包的方式解决循环依赖的问题，也就是在net/url包所在的目录声明一个独立的url_test测试包。其中包名的<code>_test</code>后缀告诉go test工具它应该建立一个额外的包来运行测试。我们将这个外部测试包的导入路径视作是net/url_test会更容易理解，但实际上它并不能被其他任何包导入。</p></li><li><p>因为外部测试包是一个独立的包，所以能够导入那些<code>依赖待测代码本身</code>的其他辅助包；包内的测试代码就无法做到这点。在设计层面，外部测试包是在所有它依赖的包的上层，正如图11.2所示。</p></li><li><p>通过避免循环的导入依赖，外部测试包可以更灵活地编写测试，特别是集成测试（需要测试多个组件之间的交互），可以像普通应用程序那样自由地导入其他包。</p></li><li><p>我们可以用go list命令查看包对应目录中哪些Go源文件是产品代码，哪些是包内测试，还有哪些是外部测试包。我们以fmt包作为一个例子：GoFiles表示产品代码对应的Go源文件列表；也就是go build命令要编译的部分。</p>    <pre><code class="hljs vim">$ <span class="hljs-keyword">go</span> <span class="hljs-keyword">list</span> -<span class="hljs-keyword">f</span>=&#123;&#123;.GoFiles&#125;&#125; fmt[doc.<span class="hljs-keyword">go</span> format.<span class="hljs-keyword">go</span> <span class="hljs-keyword">print</span>.<span class="hljs-keyword">go</span> scan.<span class="hljs-keyword">go</span>]</code></pre>    </li><li><p>TestGoFiles表示的是fmt包内部测试代码，以_test.go为后缀文件名，不过只在测试时被构建：</p>    <pre><code class="hljs handlebars"><span class="xml">$ go list -f=</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">.TestGoFiles</span>&#125;&#125;</span><span class="xml"> fmt</span><span class="xml">[export_test.go]</span></code></pre>    </li><li><p>包的测试代码通常都在这些文件中，不过fmt包并非如此；稍后我们再解释export_test.go文件的作用。</p></li><li><p>XTestGoFiles表示的是属于外部测试包的测试代码，也就是fmt_test包，因此它们必须先导入fmt包。同样，这些文件也只是在测试时被构建运行：</p>    <pre><code class="hljs vim">$ <span class="hljs-keyword">go</span> <span class="hljs-keyword">list</span> -<span class="hljs-keyword">f</span>=&#123;&#123;.XTestGoFiles&#125;&#125; fmt[fmt_test.<span class="hljs-keyword">go</span> scan_test.<span class="hljs-keyword">go</span> stringer_test.<span class="hljs-keyword">go</span>]</code></pre>    </li><li><p>有时候外部测试包也需要访问被测试包内部的代码，例如在一个为了避免循环导入而被独立到外部测试包的白盒测试。在这种情况下，我们可以通过一些技巧解决：我们在包内的一个_test.go文件中导出一个内部的实现给外部测试包。因为这些代码只有在测试时才需要，因此一般会放在export_test.go文件中。</p></li><li><p>例如，fmt包的fmt.Scanf函数需要unicode.IsSpace函数提供的功能。但是为了避免太多的依赖，fmt包并没有导入包含巨大表格数据的unicode包；相反fmt包有一个叫isSpace内部的简易实现。</p></li><li><p>为了确保fmt.isSpace和unicode.IsSpace函数的行为保持一致，fmt包谨慎地包含了一个测试。一个在外部测试包内的白盒测试，是无法直接访问到isSpace内部函数的，因此fmt通过一个后门导出了isSpace函数。export_test.go文件就是专门用于外部测试包的后门。</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> fmt<span class="hljs-keyword">var</span> IsSpace = isSpace</code></pre></li><li><p>这个测试文件并没有定义测试代码；它只是通过fmt.IsSpace简单导出了内部的isSpace函数，提供给外部测试包使用。这个技巧可以广泛用于位于外部测试包的白盒测试。</p></li></ul></li><li><p>ch11.2.5 编写有效的测试</p><ul><li><p>许多Go语言新人会惊异于Go语言极简的测试框架。很多其它语言的测试框架都提供了识别测试函数的机制（通常使用反射或元数据），通过设置一些“setup”和“teardown”的钩子函数来执行测试用例运行的初始化和之后的清理操作，同时测试工具箱还提供了很多类似assert断言、值比较函数、格式化输出错误信息和停止一个失败的测试等辅助函数（通常使用异常机制）。虽然这些机制可以使得测试非常简洁，但是测试输出的日志却会像火星文一般难以理解。此外，虽然测试最终也会输出PASS或FAIL的报告，但是它们提供的信息格式却非常不利于代码维护者快速定位问题，因为失败信息的具体含义非常隐晦，比如“assert: 0 == 1”或成页的海量跟踪日志。</p></li><li><p>Go语言的测试风格则形成鲜明对比。它期望测试者自己完成大部分的工作，定义函数避免重复，就像普通编程那样。编写测试并不是一个机械的填空过程；一个测试也有自己的接口，尽管它的维护者也是测试仅有的一个用户。一个好的测试不应该引发其他无关的错误信息，它只要清晰简洁地描述问题的症状即可，有时候可能还需要一些上下文信息。在理想情况下，维护者可以在不看代码的情况下就能根据错误信息定位错误产生的原因。一个好的测试不应该在遇到一点小错误时就立刻退出测试，它应该尝试报告更多的相关的错误信息，因为我们可能从多个失败测试的模式中发现错误产生的规律。</p></li><li><p>下面的断言函数比较两个值，然后生成一个通用的错误信息，并停止程序。它很好用也确实有效，但是当测试失败的时候，打印的错误信息却几乎是没有价值的。它并没有为快速解决问题提供一个很好的入口。</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;strings&quot;</span><span class="hljs-string">&quot;testing&quot;</span>)<span class="hljs-comment">// A poor assertion function.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertEqual</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">if</span> x != y &#123;<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;%d != %d&quot;</span>, x, y))&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;words := strings.Split(<span class="hljs-string">&quot;a:b:c&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>)assertEqual(<span class="hljs-built_in">len</span>(words), <span class="hljs-number">3</span>)<span class="hljs-comment">// ...</span>&#125;</code></pre></li><li><p>从这个意义上说，断言函数犯了过早抽象的错误：仅仅测试两个整数是否相同，而没能根据上下文提供更有意义的错误信息。我们可以根据具体的错误打印一个更有价值的错误信息，就像下面例子那样。只有在测试中出现重复模式时才采用抽象。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;s, sep := <span class="hljs-string">&quot;a:b:c&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>words := strings.Split(s, sep)<span class="hljs-keyword">if</span> got, want := <span class="hljs-built_in">len</span>(words), <span class="hljs-number">3</span>; got != want &#123;t.Errorf(<span class="hljs-string">&quot;Split(%q, %q) returned %d words, want %d&quot;</span>,s, sep, got, want)&#125;<span class="hljs-comment">// ...</span>&#125;</code></pre></li><li><p>现在的测试不仅报告了调用的具体函数、它的输入和结果的意义；并且打印的真实返回的值和期望返回的值；并且即使断言失败依然会继续尝试运行更多的测试。一旦我们写了这样结构的测试，下一步自然不是用更多的if语句来扩展测试用例，我们可以用像IsPalindrome的表驱动测试那样来准备更多的s和sep测试用例。</p></li><li><p>前面的例子并不需要额外的辅助函数，如果有可以使测试代码更简单的方法我们也乐意接受。（我们将在13.3节看到一个类似reflect.DeepEqual辅助函数。）一个好的测试的关键是首先实现你期望的具体行为，然后才是考虑简化测试代码、避免重复。如果直接从抽象、通用的测试库着手，很难取得良好结果。</p></li></ul></li><li><p>ch11.2.6 避免脆弱的测试</p><ul><li>如果一个应用程序对于新出现的但有效的输入经常失败说明程序容易出bug（不够稳健）；同样，如果一个测试仅仅对程序做了微小变化就失败则称为脆弱。就像一个不够稳健的程序会挫败它的用户一样，一个脆弱的测试同样会激怒它的维护者。最脆弱的测试代码会在程序没有任何变化的时候产生不同的结果，时好时坏，处理它们会耗费大量的时间但是并不会得到任何好处。</li><li>当一个测试函数会产生一个复杂的输出如一个很长的字符串、一个精心设计的数据结构或一个文件时，人们很容易想预先写下一系列固定的用于对比的标杆数据。但是随着项目的发展，有些输出可能会发生变化，尽管很可能是一个改进的实现导致的。而且不仅仅是输出部分，函数复杂的输入部分可能也跟着变化了，因此测试使用的输入也就不再有效了。</li><li>避免脆弱测试代码的方法是只检测你真正关心的属性。保持测试代码的简洁和内部结构的稳定。特别是对断言部分要有所选择。不要对字符串进行全字匹配，而是针对那些在项目的发展中是比较稳定不变的子串。很多时候值得花力气来编写一个从复杂输出中提取用于断言的必要信息的函数，虽然这可能会带来很多前期的工作，但是它可以帮助迅速及时修复因为项目演化而导致的不合逻辑的失败测试。</li></ul></li></ul><h3 id="ch11-3-测试覆盖率"><a href="#ch11-3-测试覆盖率" class="headerlink" title="ch11.3  测试覆盖率"></a>ch11.3  测试覆盖率</h3><ul><li><p>就其性质而言，测试不可能是完整的。计算机科学家Edsger Dijkstra曾说过：“测试能证明缺陷存在，而无法证明没有缺陷。”再多的测试也不能证明一个程序没有BUG。在最好的情况下，测试可以增强我们的信心：代码在很多重要场景下是可以正常工作的。</p></li><li><p>对待测程序执行的测试的程度称为测试的覆盖率。测试覆盖率并不能量化——即使最简单的程序的动态也是难以精确测量的——但是有启发式方法来帮助我们编写有效的测试代码。</p></li><li><p>这些启发式方法中，语句的覆盖率是最简单和最广泛使用的。语句的覆盖率是指在测试中至少被运行一次的代码占总代码数的比例。在本节中，我们使用<code>go test</code>命令中集成的测试覆盖率工具，来度量下面代码的测试覆盖率，帮助我们识别测试和我们期望间的差距。</p></li><li><p>下面的代码是一个表格驱动的测试，用于测试第七章的表达式求值程序：</p><p><u><i>gopl.io/ch7/eval</i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestCoverage</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<span class="hljs-keyword">var</span> tests = []<span class="hljs-keyword">struct</span> &#123;input <span class="hljs-keyword">string</span>env   Envwant  <span class="hljs-keyword">string</span> <span class="hljs-comment">// expected error from Parse/Check or result from Eval</span>&#125;&#123;&#123;<span class="hljs-string">&quot;x % 2&quot;</span>, <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;unexpected &#x27;%&#x27;&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;!true&quot;</span>, <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;unexpected &#x27;!&#x27;&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;log(10)&quot;</span>, <span class="hljs-literal">nil</span>, <span class="hljs-string">`unknown function &quot;log&quot;`</span>&#125;,&#123;<span class="hljs-string">&quot;sqrt(1, 2)&quot;</span>, <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;call to sqrt has 2 args, want 1&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;sqrt(A / pi)&quot;</span>, Env&#123;<span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">87616</span>, <span class="hljs-string">&quot;pi&quot;</span>: math.Pi&#125;, <span class="hljs-string">&quot;167&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;pow(x, 3) + pow(y, 3)&quot;</span>, Env&#123;<span class="hljs-string">&quot;x&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-string">&quot;y&quot;</span>: <span class="hljs-number">10</span>&#125;, <span class="hljs-string">&quot;1729&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-number">-40</span>&#125;, <span class="hljs-string">&quot;-40&quot;</span>&#125;,&#125;<span class="hljs-keyword">for</span> _, test := <span class="hljs-keyword">range</span> tests &#123;expr, err := Parse(test.input)<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;err = expr.Check(<span class="hljs-keyword">map</span>[Var]<span class="hljs-keyword">bool</span>&#123;&#125;)&#125;<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> err.Error() != test.want &#123;t.Errorf(<span class="hljs-string">&quot;%s: got %q, want %q&quot;</span>, test.input, err, test.want)&#125;<span class="hljs-keyword">continue</span>&#125;got := fmt.Sprintf(<span class="hljs-string">&quot;%.6g&quot;</span>, expr.Eval(test.env))<span class="hljs-keyword">if</span> got != test.want &#123;t.Errorf(<span class="hljs-string">&quot;%s: %v =&gt; %s, want %s&quot;</span>,test.input, test.env, got, test.want)&#125;&#125;&#125;</code></pre><ul><li><p>首先，我们要确保所有的测试都正常通过：</p><pre><code class="hljs asciidoc">$ go test -v -run=Coverage gopl.io/ch7/eval<span class="hljs-section">=== RUN TestCoverage</span><span class="hljs-bullet">--- </span>PASS: TestCoverage (0.00s)PASSok      gopl.io/ch7/eval         0.011s</code></pre></li><li><p>下面这个命令可以显示测试覆盖率工具的使用用法：</p><pre><code class="hljs routeros">$ go<span class="hljs-built_in"> tool </span>coverUsage of <span class="hljs-string">&#x27;go tool cover&#x27;</span>:Given a coverage<span class="hljs-built_in"> profile </span>produced by <span class="hljs-string">&#x27;go test&#x27;</span>:    go test <span class="hljs-attribute">-coverprofile</span>=c.outOpen a web browser displaying annotated source code:    go<span class="hljs-built_in"> tool </span>cover <span class="hljs-attribute">-html</span>=c.out<span class="hljs-built_in">..</span>.</code></pre></li></ul></li><li><p>现在我们可以用<code>-coverprofile</code>标志参数重新运行测试：</p><pre><code class="hljs awk">$ go test -run=Coverage -coverprofile=c.out gopl.io<span class="hljs-regexp">/ch7/</span>evalok      gopl.io<span class="hljs-regexp">/ch7/</span>eval         <span class="hljs-number">0.032</span>s      coverage: <span class="hljs-number">68.5</span>% of statements</code></pre><ul><li>这个标志参数通过在测试代码中插入生成钩子来统计覆盖率数据。也就是说，在运行每个测试前，它将待测代码拷贝一份并做修改，在每个词法块都会设置一个布尔标志变量。当被修改后的被测试代码运行退出时，将统计日志数据写入c.out文件，并打印一部分执行的语句的一个总结。（如果你需要的是摘要，使用<code>go test -cover</code>。）</li><li>如果使用了<code>-covermode=count</code>标志参数，那么将在每个代码块插入一个计数器而不是布尔标志量。在统计结果中记录了每个块的执行次数，这可以用于衡量哪些是被频繁执行的热点代码。</li></ul></li><li><p>为了收集数据，我们运行了测试覆盖率工具，打印了测试日志，生成一个HTML报告，然后在浏览器中打开（图11.3）。</p><pre><code class="hljs routeros">$ go<span class="hljs-built_in"> tool </span>cover <span class="hljs-attribute">-html</span>=c.out</code></pre><ul><li><p>绿色的代码块被测试覆盖到了，红色的则表示没有被覆盖到。为了清晰起见，我们将背景红色文本的背景设置成了阴影效果。我们可以马上发现unary操作的Eval方法并没有被执行到。如果我们针对这部分未被覆盖的代码添加下面的测试用例，然后重新运行上面的命令，那么我们将会看到那个红色部分的代码也变成绿色了：</p><pre><code class="hljs clojure">&#123;<span class="hljs-string">&quot;-x * -x&quot;</span>, eval.Env&#123;<span class="hljs-string">&quot;x&quot;</span>: <span class="hljs-number">2</span>&#125;, <span class="hljs-string">&quot;4&quot;</span>&#125;</code></pre></li></ul></li><li><p>不过两个panic语句依然是红色的。这是没有问题的，因为这两个语句并不会被执行到。</p></li><li><p>实现100%的测试覆盖率听起来很美，但是在具体实践中通常是不可行的，也不是值得推荐的做法。因为那只能说明代码被执行过而已，并不意味着代码就是没有BUG的；因为对于逻辑复杂的语句需要针对不同的输入执行多次。有一些语句，例如上面的panic语句则永远都不会被执行到。</p></li><li><p>另外，还有一些隐晦的错误在现实中很少遇到也很难编写对应的测试代码。测试从本质上来说是一个比较务实的工作，编写测试代码和编写应用代码的成本对比是需要考虑的。测试覆盖率工具可以帮助我们快速识别测试薄弱的地方，但是设计好的测试用例和编写应用代码一样需要严密的思考。</p></li></ul><h3 id="ch11-4-基准测试"><a href="#ch11-4-基准测试" class="headerlink" title="ch11.4  基准测试"></a>ch11.4  基准测试</h3><ul><li><p>基准测试是测量一个程序在固定工作负载下的性能。在Go语言中，基准测试函数和普通测试函数写法类似，但是以Benchmark为前缀名，并且带有一个<code>*testing.B</code>类型的参数；<code>*testing.B</code>参数除了提供和<code>*testing.T</code>类似的方法，还有额外一些和性能测量相关的方法。它还提供了一个整数N，用于指定操作执行的循环次数。</p></li><li><p>下面是IsPalindrome函数的基准测试，其中循环将执行N次。</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;testing&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkIsPalindrome</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;IsPalindrome(<span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span>)&#125;&#125;</code></pre></li><li><p>我们用下面的命令运行基准测试。和普通测试不同的是，默认情况下不运行任何基准测试。我们需要通过<code>-bench</code>命令行标志参数手工指定要运行的基准测试函数。该参数是一个正则表达式，用于匹配要执行的基准测试函数的名字，默认值是空的。其中“.”模式将可以匹配所有基准测试函数，但因为这里只有一个基准测试函数，因此和<code>-bench=IsPalindrome</code>参数是等价的效果。</p><pre><code class="hljs awk">$ cd <span class="hljs-variable">$GOPATH</span><span class="hljs-regexp">/src/g</span>opl.io<span class="hljs-regexp">/ch11/</span>word2$ go test -bench=.PASSBenchmarkIsPalindrome-<span class="hljs-number">8</span> <span class="hljs-number">1000000</span>                <span class="hljs-number">1035</span> ns/opok      gopl.io<span class="hljs-regexp">/ch11/</span>word2      <span class="hljs-number">2.179</span>s</code></pre></li><li><p>结果中基准测试名的数字后缀部分，这里是8，表示运行时对应的GOMAXPROCS的值，这对于一些与并发相关的基准测试是重要的信息。</p></li><li><p>报告显示每次调用IsPalindrome函数花费1.035微秒，是执行1,000,000次的平均时间。因为基准测试驱动器开始时并不知道每个基准测试函数运行所花的时间，它会尝试在真正运行基准测试前先尝试用较小的N运行测试来估算基准测试函数所需要的时间，然后推断一个较大的时间保证稳定的测量结果。</p></li><li><p>循环在基准测试函数内实现，而不是放在基准测试框架内实现，这样可以让每个基准测试函数有机会在循环启动前执行初始化代码，这样并不会显著影响每次迭代的平均运行时间。如果还是担心初始化代码部分对测量时间带来干扰，那么可以通过testing.B参数提供的方法来临时关闭或重置计时器，不过这些一般很少会用到。</p></li><li><p>现在我们有了一个基准测试和普通测试，我们可以很容易测试改进程序运行速度的想法。也许最明显的优化是在IsPalindrome函数中第二个循环的停止检查，这样可以避免每个比较都做两次：</p><pre><code class="hljs Go">n := <span class="hljs-built_in">len</span>(letters)/<span class="hljs-number">2</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; n; i++ &#123;<span class="hljs-keyword">if</span> letters[i] != letters[<span class="hljs-built_in">len</span>(letters)<span class="hljs-number">-1</span>-i] &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span></code></pre><ul><li><p>不过很多情况下，一个显而易见的优化未必能带来预期的效果。这个改进在基准测试中只带来了4%的性能提升。</p><pre><code class="hljs angelscript">$ go test -bench=.PASSBenchmarkIsPalindrome<span class="hljs-number">-8</span> <span class="hljs-number">1000000</span>              <span class="hljs-number">992</span> ns/opok      gopl.io/ch11/word2      <span class="hljs-number">2.093</span>s</code></pre></li></ul></li><li><p>另一个改进想法是在开始为每个字符预先分配一个足够大的数组，这样就可以避免在append调用时可能会导致内存的多次重新分配。声明一个letters数组变量，并指定合适的大小，像下面这样，</p><pre><code class="hljs Go">letters := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">rune</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s))<span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> s &#123;<span class="hljs-keyword">if</span> unicode.IsLetter(r) &#123;letters = <span class="hljs-built_in">append</span>(letters, unicode.ToLower(r))&#125;&#125;</code></pre><ul><li><p>这个改进提升性能约35%，报告结果是基于2,000,000次迭代的平均运行时间统计。</p><pre><code class="hljs angelscript">$ go test -bench=.PASSBenchmarkIsPalindrome<span class="hljs-number">-8</span> <span class="hljs-number">2000000</span>                      <span class="hljs-number">697</span> ns/opok      gopl.io/ch11/word2      <span class="hljs-number">1.468</span>s</code></pre></li></ul></li><li><p>如这个例子所示，快的程序往往是伴随着较少的内存分配。<code>-benchmem</code>命令行标志参数将在报告中包含内存的分配数据统计。我们可以比较优化前后内存的分配情况：</p><pre><code class="hljs angelscript">$ go test -bench=. -benchmemPASSBenchmarkIsPalindrome    <span class="hljs-number">1000000</span>   <span class="hljs-number">1026</span> ns/op    <span class="hljs-number">304</span> B/op  <span class="hljs-number">4</span> allocs/op</code></pre><ul><li><p>这是优化之后的结果：</p><pre><code class="hljs angelscript">$ go test -bench=. -benchmemPASSBenchmarkIsPalindrome    <span class="hljs-number">2000000</span>    <span class="hljs-number">807</span> ns/op    <span class="hljs-number">128</span> B/op  <span class="hljs-number">1</span> allocs/op</code></pre></li><li><p>用一次内存分配代替多次的内存分配节省了75%的分配调用次数和减少近一半的内存需求。</p></li></ul></li><li><p>这个基准测试告诉了我们某个具体操作所需的绝对时间，但我们往往想知道的是两个不同的操作的时间对比。</p><ul><li>例如，如果一个函数需要1ms处理1,000个元素，那么处理10000或1百万将需要多少时间呢？这样的比较揭示了渐近增长函数的运行时间。</li><li>另一个例子：I/O缓存该设置为多大呢？基准测试可以帮助我们选择在性能达标情况下所需的最小内存。</li><li>第三个例子：对于一个确定的工作哪种算法更好？基准测试可以评估两种不同算法对于相同的输入在不同的场景和负载下的优缺点。</li></ul></li><li><p>比较型的基准测试就是普通程序代码。它们通常是单参数的函数，由几个不同数量级的基准测试函数调用，就像这样：</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">benchmark</span><span class="hljs-params">(b *testing.B, size <span class="hljs-keyword">int</span>)</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark10</span><span class="hljs-params">(b *testing.B)</span></span>         &#123; benchmark(b, <span class="hljs-number">10</span>) &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark100</span><span class="hljs-params">(b *testing.B)</span></span>        &#123; benchmark(b, <span class="hljs-number">100</span>) &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Benchmark1000</span><span class="hljs-params">(b *testing.B)</span></span>       &#123; benchmark(b, <span class="hljs-number">1000</span>) &#125;</code></pre><ul><li>通过函数参数来指定输入的大小，但是参数变量对于每个具体的基准测试都是固定的。要避免直接修改b.N来控制输入的大小。除非你将它作为一个固定大小的迭代计算输入，否则基准测试的结果将毫无意义。</li></ul></li><li><p>比较型的基准测试反映出的模式在程序设计阶段是很有帮助的，但是即使程序完工了也应当保留基准测试代码。因为随着项目的发展，或者是输入的增加，或者是部署到新的操作系统或不同的处理器，我们可以再次用基准测试来帮助我们改进设计。</p></li></ul><h3 id="ch11-5-剖析"><a href="#ch11-5-剖析" class="headerlink" title="ch11.5  剖析"></a>ch11.5  剖析</h3><ul><li><p>基准测试（Benchmark）对于衡量特定操作的性能是有帮助的，但是当我们试图让程序跑的更快的时候，我们通常并不知道从哪里开始优化。每个码农都应该知道Donald Knuth在1974年的“Structured Programming with go to Statements”上所说的格言。虽然经常被解读为不重视性能的意思，但是从原文我们可以看到不同的含义：</p><blockquote><p>毫无疑问，对效率的片面追求会导致各种滥用。程序员会浪费大量的时间在非关键程序的速度上，实际上这些尝试提升效率的行为反倒可能产生很大的负面影响，特别是当调试和维护的时候。我们不应该过度纠结于细节的优化，应该说约97%的场景：过早的优化是万恶之源。</p><p>当然我们也不应该放弃对那关键3%的优化。一个好的程序员不会因为这个比例小就裹足不前，他们会明智地观察和识别哪些是关键的代码；但是仅当关键代码已经被确认的前提下才会进行优化。对于很多程序员来说，判断哪部分是关键的性能瓶颈，是很容易犯经验上的错误的，因此一般应该借助测量工具来证明。</p></blockquote></li><li><p>当我们想仔细观察我们程序的运行速度的时候，最好的方法是性能剖析。剖析技术是基于程序执行期间一些自动抽样，然后在收尾时进行推断；最后产生的统计结果就称为剖析数据。</p></li><li><p>Go语言支持多种类型的剖析性能分析，每一种关注不同的方面，但它们都涉及到每个采样记录的感兴趣的一系列事件消息，每个事件都包含函数调用时函数调用堆栈的信息。内建的<code>go test</code>工具对几种分析方式都提供了支持。</p></li><li><p>CPU剖析数据标识了最耗CPU时间的函数。在每个CPU上运行的线程在每隔几毫秒都会遇到操作系统的中断事件，每次中断时都会记录一个剖析数据然后恢复正常的运行。</p></li><li><p>堆剖析则标识了最耗内存的语句。剖析库会记录调用内部内存分配的操作，平均每512KB的内存申请会触发一个剖析数据。</p></li><li><p>阻塞剖析则记录阻塞goroutine最久的操作，例如系统调用、管道发送和接收，还有获取锁等。每当goroutine被这些操作阻塞时，剖析库都会记录相应的事件。</p></li><li><p>只需要开启下面其中一个标志参数就可以生成各种分析文件。当同时使用多个标志参数时需要当心，因为一项分析操作可能会影响其他项的分析结果。</p><pre><code class="hljs x86asm">$ go <span class="hljs-keyword">test</span> -cpuprofile=<span class="hljs-meta">cpu</span><span class="hljs-number">.</span><span class="hljs-keyword">out</span>$ go <span class="hljs-keyword">test</span> -blockprofile=block<span class="hljs-number">.</span><span class="hljs-keyword">out</span>$ go <span class="hljs-keyword">test</span> -memprofile=mem<span class="hljs-number">.</span><span class="hljs-keyword">out</span></code></pre></li><li><p>对于一些非测试程序也很容易进行剖析，具体的实现方式，与程序是短时间运行的小工具还是长时间运行的服务会有很大不同。剖析对于长期运行的程序尤其有用，因此可以通过调用Go的runtime API来启用运行时剖析。</p></li><li><p>一旦我们已经收集到了用于分析的采样数据，我们就可以使用pprof来分析这些数据。这是Go工具箱自带的一个工具，但并不是一个日常工具，它对应<code>go tool pprof</code>命令。该命令有许多特性和选项，但是最基本的是两个参数：生成这个概要文件的可执行程序和对应的剖析数据。</p></li><li><p>为了提高分析效率和减少空间，分析日志本身并不包含函数的名字；它只包含函数对应的地址。也就是说pprof需要对应的可执行程序来解读剖析数据。虽然<code>go test</code>通常在测试完成后就丢弃临时用的测试程序，但是在启用分析的时候会将测试程序保存为foo.test文件，其中foo部分对应待测包的名字。</p></li><li><p>下面的命令演示了如何收集并展示一个CPU分析文件。我们选择<code>net/http</code>包的一个基准测试为例。通常最好是对业务关键代码的部分设计专门的基准测试。因为简单的基准测试几乎没法代表业务场景，因此我们用-run=NONE参数禁止那些简单测试。</p><pre><code class="hljs angelscript">$ go test -run=NONE -bench=ClientServerParallelTLS64 \    -cpuprofile=cpu.log net/http PASS BenchmarkClientServerParallelTLS64<span class="hljs-number">-8</span>  <span class="hljs-number">1000</span>    <span class="hljs-number">3141325</span> ns/op  <span class="hljs-number">143010</span> B/op  <span class="hljs-number">1747</span> allocs/opok       net/http       <span class="hljs-number">3.395</span>s$ go tool pprof -text -nodecount=<span class="hljs-number">10</span> ./http.test cpu.log<span class="hljs-number">2570</span>ms of <span class="hljs-number">3590</span>ms total (<span class="hljs-number">71.59</span>%)Dropped <span class="hljs-number">129</span> nodes (cum &lt;= <span class="hljs-number">17.95</span>ms)Showing top <span class="hljs-number">10</span> nodes <span class="hljs-keyword">out</span> of <span class="hljs-number">166</span> (cum &gt;= <span class="hljs-number">60</span>ms)    flat  flat%   sum%     cum   cum%  <span class="hljs-number">1730</span>ms <span class="hljs-number">48.19</span>% <span class="hljs-number">48.19</span>%  <span class="hljs-number">1750</span>ms <span class="hljs-number">48.75</span>%  crypto/elliptic.p256ReduceDegree   <span class="hljs-number">230</span>ms  <span class="hljs-number">6.41</span>% <span class="hljs-number">54.60</span>%   <span class="hljs-number">250</span>ms  <span class="hljs-number">6.96</span>%  crypto/elliptic.p256Diff   <span class="hljs-number">120</span>ms  <span class="hljs-number">3.34</span>% <span class="hljs-number">57.94</span>%   <span class="hljs-number">120</span>ms  <span class="hljs-number">3.34</span>%  math/big.addMulVVW   <span class="hljs-number">110</span>ms  <span class="hljs-number">3.06</span>% <span class="hljs-number">61.00</span>%   <span class="hljs-number">110</span>ms  <span class="hljs-number">3.06</span>%  syscall.Syscall    <span class="hljs-number">90</span>ms  <span class="hljs-number">2.51</span>% <span class="hljs-number">63.51</span>%  <span class="hljs-number">1130</span>ms <span class="hljs-number">31.48</span>%  crypto/elliptic.p256Square    <span class="hljs-number">70</span>ms  <span class="hljs-number">1.95</span>% <span class="hljs-number">65.46</span>%   <span class="hljs-number">120</span>ms  <span class="hljs-number">3.34</span>%  runtime.scanobject    <span class="hljs-number">60</span>ms  <span class="hljs-number">1.67</span>% <span class="hljs-number">67.13</span>%   <span class="hljs-number">830</span>ms <span class="hljs-number">23.12</span>%  crypto/elliptic.p256Mul    <span class="hljs-number">60</span>ms  <span class="hljs-number">1.67</span>% <span class="hljs-number">68.80</span>%   <span class="hljs-number">190</span>ms  <span class="hljs-number">5.29</span>%  math/big.nat.montgomery    <span class="hljs-number">50</span>ms  <span class="hljs-number">1.39</span>% <span class="hljs-number">70.19</span>%    <span class="hljs-number">50</span>ms  <span class="hljs-number">1.39</span>%  crypto/elliptic.p256ReduceCarry    <span class="hljs-number">50</span>ms  <span class="hljs-number">1.39</span>% <span class="hljs-number">71.59</span>%    <span class="hljs-number">60</span>ms  <span class="hljs-number">1.67</span>%  crypto/elliptic.p256Sum</code></pre><ul><li>参数<code>-text</code>用于指定输出格式，在这里每行是一个函数，根据使用CPU的时间长短来排序。其中<code>-nodecount=10</code>参数限制了只输出前10行的结果。对于严重的性能问题，这个文本格式基本可以帮助查明原因了。</li><li>这个概要文件告诉我们，HTTPS基准测试中<code>crypto/elliptic.p256ReduceDegree</code>函数占用了将近一半的CPU资源，对性能占很大比重。相比之下，如果一个概要文件中主要是runtime包的内存分配的函数，那么减少内存消耗可能是一个值得尝试的优化策略。</li></ul></li><li><p>对于一些更微妙的问题，你可能需要使用pprof的图形显示功能。这个需要安装GraphViz工具，可以从 <a href="http://www.graphviz.org/">http://www.graphviz.org</a> 下载。参数<code>-web</code>用于生成函数的有向图，标注有CPU的使用和最热点的函数等信息。</p></li><li><p>这一节我们只是简单看了下Go语言的数据分析工具。如果想了解更多，可以阅读Go官方博客的“Profiling Go Programs”一文。</p></li></ul><h3 id="ch11-6-示例函数"><a href="#ch11-6-示例函数" class="headerlink" title="ch11.6  示例函数"></a>ch11.6  示例函数</h3><ul><li><p>第三种被<code>go test</code>特别对待的函数是示例函数，以Example为函数名开头。示例函数没有函数参数和返回值。下面是IsPalindrome函数对应的示例函数：</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleIsPalindrome</span><span class="hljs-params">()</span></span> &#123;fmt.Println(IsPalindrome(<span class="hljs-string">&quot;A man, a plan, a canal: Panama&quot;</span>))fmt.Println(IsPalindrome(<span class="hljs-string">&quot;palindrome&quot;</span>))<span class="hljs-comment">// Output:</span><span class="hljs-comment">// true</span><span class="hljs-comment">// false</span>&#125;</code></pre></li><li><p>示例函数有三个用处。</p><ul><li><p>最主要的一个是作为文档：一个包的例子可以更简洁直观的方式来演示函数的用法，比文字描述更直接易懂，特别是作为一个提醒或快速参考时。一个示例函数也可以方便展示属于同一个接口的几种类型或函数之间的关系，所有的文档都必须关联到一个地方，就像一个类型或函数声明都统一到包一样。同时，示例函数和注释并不一样，示例函数是真实的Go代码，需要接受编译器的编译时检查，这样可以保证源代码更新时，示例代码不会脱节。</p><ul><li>根据示例函数的后缀名部分，godoc这个web文档服务器会将示例函数关联到某个具体函数或包本身，因此ExampleIsPalindrome示例函数将是IsPalindrome函数文档的一部分，Example示例函数将是包文档的一部分。</li></ul></li><li><p>示例函数的第二个用处是，在<code>go test</code>执行测试的时候也会运行示例函数测试。如果示例函数内含有类似上面例子中的<code>// Output:</code>格式的注释，那么测试工具会执行这个示例函数，然后检查示例函数的标准输出与注释是否匹配。</p></li><li><p>示例函数的第三个目的提供一个真实的演练场。 <a href="http://golang.org/">http://golang.org</a> 就是由godoc提供的文档服务，它使用了Go Playground让用户可以在浏览器中在线编辑和运行每个示例函数，就像图11.4所示的那样。这通常是学习函数使用或Go语言特性最快捷的方式。</p></li></ul></li><li><p>本书最后的两章是讨论reflect和unsafe包，一般的Go程序员很少使用它们，事实上也很少需要用到。因此，如果你还没有写过任何真实的Go程序的话，现在可以先去写些代码了。</p></li></ul><h2 id="ch12-反射"><a href="#ch12-反射" class="headerlink" title="ch12  反射"></a>ch12  反射</h2><h3 id="ch12-0-简介"><a href="#ch12-0-简介" class="headerlink" title="ch12.0  简介"></a>ch12.0  简介</h3><ul><li>Go语言提供了一种机制，能够在运行时更新变量和检查它们的值、调用它们的方法和它们支持的内在操作，而不需要在编译时就知道这些变量的具体类型。这种机制被称为反射。反射也可以让我们将类型本身作为第一类的值类型处理。</li><li>在本章，我们将探讨Go语言的反射特性，看看它可以给语言增加哪些表达力，以及在两个至关重要的API是如何使用反射机制的：一个是fmt包提供的字符串格式化功能，另一个是类似encoding/json和encoding/xml提供的针对特定协议的编解码功能。对于我们在4.6节中看到过的text/template和html/template包，它们的实现也是依赖反射技术的。然后，反射是一个复杂的内省技术，不应该随意使用，因此，尽管上面这些包内部都是用反射技术实现的，但是它们自己的API都没有公开反射相关的接口。</li></ul><h3 id="ch12-1-为何需要反射"><a href="#ch12-1-为何需要反射" class="headerlink" title="ch12.1  为何需要反射"></a>ch12.1  为何需要反射</h3><ul><li><p>有时候我们需要编写一个函数能够处理一类并不满足普通公共接口的类型的值，也可能是因为它们并没有确定的表示方式，或者是在我们设计该函数的时候这些类型可能还不存在。</p></li><li><p>个大家熟悉的例子是fmt.Fprintf函数提供的字符串格式化处理逻辑，它可以用来对任意类型的值格式化并打印，甚至支持用户自定义的类型。让我们也来尝试实现一个类似功能的函数。为了简单起见，我们的函数只接收一个参数，然后返回和fmt.Sprint类似的格式化后的字符串。我们实现的函数名也叫Sprint。</p></li><li><p>我们首先用switch类型分支来测试输入参数是否实现了String方法，如果是的话就调用该方法。然后继续增加类型测试分支，检查这个值的动态类型是否是string、int、bool等基础类型，并在每种情况下执行相应的格式化操作。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sprint</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">type</span> stringer <span class="hljs-keyword">interface</span> &#123;String() <span class="hljs-keyword">string</span>&#125;<span class="hljs-keyword">switch</span> x := x.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> stringer:<span class="hljs-keyword">return</span> x.String()<span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:<span class="hljs-keyword">return</span> x<span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>:<span class="hljs-keyword">return</span> strconv.Itoa(x)<span class="hljs-comment">// ...similar cases for int16, uint32, and so on...</span><span class="hljs-keyword">case</span> <span class="hljs-keyword">bool</span>:<span class="hljs-keyword">if</span> x &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;true&quot;</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;false&quot;</span><span class="hljs-keyword">default</span>:<span class="hljs-comment">// array, chan, func, map, pointer, slice, struct</span><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;???&quot;</span>&#125;&#125;</code></pre></li><li><p>但是我们如何处理其它类似[]float64、map[string][]string等类型呢？我们当然可以添加更多的测试分支，但是这些组合类型的数目基本是无穷的。还有如何处理类似url.Values这样的具名类型呢？即使类型分支可以识别出底层的基础类型是map[string][]string，但是它并不匹配url.Values类型，因为它们是两种不同的类型，而且switch类型分支也不可能包含每个类似url.Values的类型，这会导致对这些库的依赖。</p></li><li><p>没有办法来检查未知类型的表示方式，我们被卡住了。这就是我们为何需要反射的原因。</p></li></ul><h3 id="ch12-2-reflect-Type和reflect-Value"><a href="#ch12-2-reflect-Type和reflect-Value" class="headerlink" title="ch12.2  reflect.Type和reflect.Value"></a>ch12.2  reflect.Type和reflect.Value</h3><ul><li><p>反射是由 reflect 包提供的。它定义了两个重要的类型，Type 和 Value。一个 Type 表示一个Go类型。它是一个接口，有许多方法来区分类型以及检查它们的组成部分，例如一个结构体的成员或一个函数的参数等。唯一能反映 reflect.Type 实现的是接口的类型描述信息（§7.5），也正是这个实体标识了接口值的动态类型。</p></li><li><p>函数 reflect.TypeOf 接受任意的 interface{} 类型，并以 reflect.Type 形式返回其动态类型：</p><pre><code class="hljs Go">t := reflect.TypeOf(<span class="hljs-number">3</span>)  <span class="hljs-comment">// a reflect.Type</span>fmt.Println(t.String()) <span class="hljs-comment">// &quot;int&quot;</span>fmt.Println(t)          <span class="hljs-comment">// &quot;int&quot;</span></code></pre></li><li><p>其中 TypeOf(3) 调用将值 3 传给 interface{} 参数。回到 7.5节 的将一个具体的值转为接口类型会有一个隐式的接口转换操作，它会创建一个包含两个信息的接口值：操作数的动态类型（这里是 int）和它的动态的值（这里是 3）。</p></li><li><p>因为 reflect.TypeOf 返回的是一个动态类型的接口值，它总是返回具体的类型。因此，下面的代码将打印 “*os.File” 而不是 “io.Writer”。稍后，我们将看到能够表达接口类型的 reflect.Type。</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> w io.Writer = os.Stdoutfmt.Println(reflect.TypeOf(w)) <span class="hljs-comment">// &quot;*os.File&quot;</span></code></pre></li><li><p>要注意的是 reflect.Type 接口是满足 fmt.Stringer 接口的。因为打印一个接口的动态类型对于调试和日志是有帮助的， fmt.Printf 提供了一个缩写 %T 参数，内部使用 reflect.TypeOf 来输出：</p><pre><code class="hljs Go">fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// &quot;int&quot;</span></code></pre></li><li><p>reflect 包中另一个重要的类型是 Value。一个 reflect.Value 可以装载任意类型的值。函数 reflect.ValueOf 接受任意的 interface{} 类型，并返回一个装载着其动态值的 reflect.Value。和 reflect.TypeOf 类似，reflect.ValueOf 返回的结果也是具体的类型，但是 reflect.Value 也可以持有一个接口值。</p><pre><code class="hljs Go">v := reflect.ValueOf(<span class="hljs-number">3</span>) <span class="hljs-comment">// a reflect.Value</span>fmt.Println(v)          <span class="hljs-comment">// &quot;3&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, v)   <span class="hljs-comment">// &quot;3&quot;</span>fmt.Println(v.String()) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> &quot;&lt;int Value&gt;&quot;</span></code></pre></li><li><p>和 reflect.Type 类似，reflect.Value 也满足 fmt.Stringer 接口，但是除非 Value 持有的是字符串，否则 String 方法只返回其类型。而使用 fmt 包的 %v 标志参数会对 reflect.Values 特殊处理。</p></li><li><p>对 Value 调用 Type 方法将返回具体类型所对应的 reflect.Type：</p><pre><code class="hljs Go">t := v.Type()           <span class="hljs-comment">// a reflect.Type</span>fmt.Println(t.String()) <span class="hljs-comment">// &quot;int&quot;</span></code></pre></li><li><p>reflect.ValueOf 的逆操作是 reflect.Value.Interface 方法。它返回一个 interface{} 类型，装载着与 reflect.Value 相同的具体值：</p><pre><code class="hljs Go">v := reflect.ValueOf(<span class="hljs-number">3</span>) <span class="hljs-comment">// a reflect.Value</span>x := v.Interface()      <span class="hljs-comment">// an interface&#123;&#125;</span>i := x.(<span class="hljs-keyword">int</span>)            <span class="hljs-comment">// an int</span>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, i)   <span class="hljs-comment">// &quot;3&quot;</span></code></pre></li><li><p>reflect.Value 和 interface{} 都能装载任意的值。所不同的是，一个空的接口隐藏了值内部的表示方式和所有方法，因此只有我们知道具体的动态类型才能使用类型断言来访问内部的值（就像上面那样），内部值我们没法访问。相比之下，一个 Value 则有很多方法来检查其内容，无论它的具体类型是什么。让我们再次尝试实现我们的格式化函数 format.Any。</p></li><li><p>我们使用 reflect.Value 的 Kind 方法来替代之前的类型 switch。虽然还是有无穷多的类型，但是它们的 kinds 类型却是有限的：Bool、String 和 所有数字类型的基础类型；Array 和 Struct 对应的聚合类型；Chan、Func、Ptr、Slice 和 Map 对应的引用类型；interface 类型；还有表示空值的 Invalid 类型。（空的 reflect.Value 的 kind 即为 Invalid。）</p><p><u><i>gopl.io/ch12/format</i></u></p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> format<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;reflect&quot;</span><span class="hljs-string">&quot;strconv&quot;</span>)<span class="hljs-comment">// Any formats any value as a string.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Any</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> formatAtom(reflect.ValueOf(value))&#125;<span class="hljs-comment">// formatAtom formats a value without inspecting its internal structure.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">formatAtom</span><span class="hljs-params">(v reflect.Value)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">switch</span> v.Kind() &#123;<span class="hljs-keyword">case</span> reflect.Invalid:<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;invalid&quot;</span><span class="hljs-keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16,reflect.Int32, reflect.Int64:<span class="hljs-keyword">return</span> strconv.FormatInt(v.Int(), <span class="hljs-number">10</span>)<span class="hljs-keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16,reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="hljs-keyword">return</span> strconv.FormatUint(v.Uint(), <span class="hljs-number">10</span>)<span class="hljs-comment">// ...floating-point and complex cases omitted for brevity...</span><span class="hljs-keyword">case</span> reflect.Bool:<span class="hljs-keyword">return</span> strconv.FormatBool(v.Bool())<span class="hljs-keyword">case</span> reflect.String:<span class="hljs-keyword">return</span> strconv.Quote(v.String())<span class="hljs-keyword">case</span> reflect.Chan, reflect.Func, reflect.Ptr, reflect.Slice, reflect.Map:<span class="hljs-keyword">return</span> v.Type().String() + <span class="hljs-string">&quot; 0x&quot;</span> +strconv.FormatUint(<span class="hljs-keyword">uint64</span>(v.Pointer()), <span class="hljs-number">16</span>)<span class="hljs-keyword">default</span>: <span class="hljs-comment">// reflect.Array, reflect.Struct, reflect.Interface</span><span class="hljs-keyword">return</span> v.Type().String() + <span class="hljs-string">&quot; value&quot;</span>&#125;&#125;</code></pre></li><li><p>到目前为止，我们的函数将每个值视作一个不可分割没有内部结构的物品，因此它叫 formatAtom。对于聚合类型（结构体和数组）和接口，只是打印值的类型，对于引用类型（channels、functions、pointers、slices 和 maps），打印类型和十六进制的引用地址。虽然还不够理想，但是依然是一个重大的进步，并且 Kind 只关心底层表示，format.Any 也支持具名类型。例如：</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">int64</span> = <span class="hljs-number">1</span><span class="hljs-keyword">var</span> d time.Duration = <span class="hljs-number">1</span> * time.Nanosecondfmt.Println(format.Any(x))                  <span class="hljs-comment">// &quot;1&quot;</span>fmt.Println(format.Any(d))                  <span class="hljs-comment">// &quot;1&quot;</span>fmt.Println(format.Any([]<span class="hljs-keyword">int64</span>&#123;x&#125;))         <span class="hljs-comment">// &quot;[]int64 0x8202b87b0&quot;</span>fmt.Println(format.Any([]time.Duration&#123;d&#125;)) <span class="hljs-comment">// &quot;[]time.Duration 0x8202b87e0&quot;</span></code></pre></li></ul><h3 id="ch12-3-Display递归打印"><a href="#ch12-3-Display递归打印" class="headerlink" title="ch12.3  Display递归打印"></a>ch12.3  Display递归打印</h3><ul><li><p>接下来，让我们看看如何改善聚合数据类型的显示。我们并不想完全克隆一个fmt.Sprint函数，我们只是构建一个用于调试用的Display函数：给定任意一个复杂类型 x，打印这个值对应的完整结构，同时标记每个元素的发现路径。让我们从一个例子开始。</p><pre><code class="hljs Go">e, _ := eval.Parse(<span class="hljs-string">&quot;sqrt(A / pi)&quot;</span>)Display(<span class="hljs-string">&quot;e&quot;</span>, e)</code></pre></li><li><p>在上面的调用中，传入Display函数的参数是在7.9节一个表达式求值函数返回的语法树。Display函数的输出如下：</p><pre><code class="hljs Go">Display e (eval.call):e.fn = <span class="hljs-string">&quot;sqrt&quot;</span>e.args[<span class="hljs-number">0</span>].<span class="hljs-keyword">type</span> = eval.binarye.args[<span class="hljs-number">0</span>].value.op = <span class="hljs-number">47</span>e.args[<span class="hljs-number">0</span>].value.x.<span class="hljs-keyword">type</span> = eval.Vare.args[<span class="hljs-number">0</span>].value.x.value = <span class="hljs-string">&quot;A&quot;</span>e.args[<span class="hljs-number">0</span>].value.y.<span class="hljs-keyword">type</span> = eval.Vare.args[<span class="hljs-number">0</span>].value.y.value = <span class="hljs-string">&quot;pi&quot;</span></code></pre></li><li><p>你应该尽量避免在一个包的API中暴露涉及反射的接口。我们将定义一个未导出的display函数用于递归处理工作，导出的是Display函数，它只是display函数简单的包装以接受interface{}类型的参数：</p><p><u><i>gopl.io/ch12/display</i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Display</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;Display %s (%T):\n&quot;</span>, name, x)display(name, reflect.ValueOf(x))&#125;</code></pre></li><li><p>在display函数中，我们使用了前面定义的打印基础类型——基本类型、函数和chan等——元素值的formatAtom函数，但是我们会使用reflect.Value的方法来递归显示复杂类型的每一个成员。在递归下降过程中，path字符串，从最开始传入的起始值（这里是“e”），将逐步增长来表示是如何达到当前值（例如“e.args[0].value”）的。</p></li><li><p>因为我们不再模拟fmt.Sprint函数，我们将直接使用fmt包来简化我们的例子实现。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">display</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>, v reflect.Value)</span></span> &#123;<span class="hljs-keyword">switch</span> v.Kind() &#123;<span class="hljs-keyword">case</span> reflect.Invalid:fmt.Printf(<span class="hljs-string">&quot;%s = invalid\n&quot;</span>, path)<span class="hljs-keyword">case</span> reflect.Slice, reflect.Array:<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.Len(); i++ &#123;display(fmt.Sprintf(<span class="hljs-string">&quot;%s[%d]&quot;</span>, path, i), v.Index(i))&#125;<span class="hljs-keyword">case</span> reflect.Struct:<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumField(); i++ &#123;fieldPath := fmt.Sprintf(<span class="hljs-string">&quot;%s.%s&quot;</span>, path, v.Type().Field(i).Name)display(fieldPath, v.Field(i))&#125;<span class="hljs-keyword">case</span> reflect.Map:<span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> v.MapKeys() &#123;display(fmt.Sprintf(<span class="hljs-string">&quot;%s[%s]&quot;</span>, path,formatAtom(key)), v.MapIndex(key))&#125;<span class="hljs-keyword">case</span> reflect.Ptr:<span class="hljs-keyword">if</span> v.IsNil() &#123;fmt.Printf(<span class="hljs-string">&quot;%s = nil\n&quot;</span>, path)&#125; <span class="hljs-keyword">else</span> &#123;display(fmt.Sprintf(<span class="hljs-string">&quot;(*%s)&quot;</span>, path), v.Elem())&#125;<span class="hljs-keyword">case</span> reflect.Interface:<span class="hljs-keyword">if</span> v.IsNil() &#123;fmt.Printf(<span class="hljs-string">&quot;%s = nil\n&quot;</span>, path)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Printf(<span class="hljs-string">&quot;%s.type = %s\n&quot;</span>, path, v.Elem().Type())display(path+<span class="hljs-string">&quot;.value&quot;</span>, v.Elem())&#125;<span class="hljs-keyword">default</span>: <span class="hljs-comment">// basic types, channels, funcs</span>fmt.Printf(<span class="hljs-string">&quot;%s = %s\n&quot;</span>, path, formatAtom(v))&#125;&#125;</code></pre></li><li><p>让我们针对不同类型分别讨论。</p><ul><li><p><strong>Slice和数组：</strong> 两种的处理逻辑是一样的。Len方法返回slice或数组值中的元素个数，Index(i)获得索引i对应的元素，返回的也是一个reflect.Value；如果索引i超出范围的话将导致panic异常，这与数组或slice类型内建的len(a)和a[i]操作类似。display针对序列中的每个元素递归调用自身处理，我们通过在递归处理时向path附加“[i]”来表示访问路径。</p><ul><li>虽然reflect.Value类型带有很多方法，但是只有少数的方法能对任意值都安全调用。例如，Index方法只能对Slice、数组或字符串类型的值调用，如果对其它类型调用则会导致panic异常。</li></ul></li><li><p><strong>结构体：</strong> NumField方法报告结构体中成员的数量，Field(i)以reflect.Value类型返回第i个成员的值。成员列表也包括通过匿名字段提升上来的成员。为了在path添加“.f”来表示成员路径，我们必须获得结构体对应的reflect.Type类型信息，然后访问结构体第i个成员的名字。</p></li><li><p><strong>Maps:</strong> MapKeys方法返回一个reflect.Value类型的slice，每一个元素对应map的一个key。和往常一样，遍历map时顺序是随机的。MapIndex(key)返回map中key对应的value。我们向path添加“[key]”来表示访问路径。（我们这里有一个未完成的工作。其实map的key的类型并不局限于formatAtom能完美处理的类型；数组、结构体和接口都可以作为map的key。针对这种类型，完善key的显示信息是练习12.1的任务。）</p></li><li><p><strong>指针：</strong> Elem方法返回指针指向的变量，依然是reflect.Value类型。即使指针是nil，这个操作也是安全的，在这种情况下指针是Invalid类型，但是我们可以用IsNil方法来显式地测试一个空指针，这样我们可以打印更合适的信息。我们在path前面添加“*”，并用括弧包含以避免歧义。</p></li><li><p><strong>接口：</strong> 再一次，我们使用IsNil方法来测试接口是否是nil，如果不是，我们可以调用v.Elem()来获取接口对应的动态值，并且打印对应的类型和值。</p></li></ul></li><li><p>现在我们的Display函数总算完工了，让我们看看它的表现吧。下面的Movie类型是在4.5节的电影类型上演变来的：</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Movie <span class="hljs-keyword">struct</span> &#123;Title, Subtitle <span class="hljs-keyword">string</span>Year            <span class="hljs-keyword">int</span>Color           <span class="hljs-keyword">bool</span>Actor           <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>Oscars          []<span class="hljs-keyword">string</span>Sequel          *<span class="hljs-keyword">string</span>&#125;</code></pre><ul><li><p>让我们声明一个该类型的变量，然后看看Display函数如何显示它：</p><pre><code class="hljs Go">strangelove := Movie&#123;Title:    <span class="hljs-string">&quot;Dr. Strangelove&quot;</span>,Subtitle: <span class="hljs-string">&quot;How I Learned to Stop Worrying and Love the Bomb&quot;</span>,Year:     <span class="hljs-number">1964</span>,Color:    <span class="hljs-literal">false</span>,Actor: <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;Dr. Strangelove&quot;</span>:            <span class="hljs-string">&quot;Peter Sellers&quot;</span>,<span class="hljs-string">&quot;Grp. Capt. Lionel Mandrake&quot;</span>: <span class="hljs-string">&quot;Peter Sellers&quot;</span>,<span class="hljs-string">&quot;Pres. Merkin Muffley&quot;</span>:       <span class="hljs-string">&quot;Peter Sellers&quot;</span>,<span class="hljs-string">&quot;Gen. Buck Turgidson&quot;</span>:        <span class="hljs-string">&quot;George C. Scott&quot;</span>,<span class="hljs-string">&quot;Brig. Gen. Jack D. Ripper&quot;</span>:  <span class="hljs-string">&quot;Sterling Hayden&quot;</span>,<span class="hljs-string">`Maj. T.J. &quot;King&quot; Kong`</span>:      <span class="hljs-string">&quot;Slim Pickens&quot;</span>,&#125;,Oscars: []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;Best Actor (Nomin.)&quot;</span>,<span class="hljs-string">&quot;Best Adapted Screenplay (Nomin.)&quot;</span>,<span class="hljs-string">&quot;Best Director (Nomin.)&quot;</span>,<span class="hljs-string">&quot;Best Picture (Nomin.)&quot;</span>,&#125;,&#125;</code></pre></li><li><p>Display(“strangelove”, strangelove)调用将显示（strangelove电影对应的中文名是《奇爱博士》）：</p><pre><code class="hljs Go">Display strangelove (display.Movie):strangelove.Title = <span class="hljs-string">&quot;Dr. Strangelove&quot;</span>strangelove.Subtitle = <span class="hljs-string">&quot;How I Learned to Stop Worrying and Love the Bomb&quot;</span>strangelove.Year = <span class="hljs-number">1964</span>strangelove.Color = <span class="hljs-literal">false</span>strangelove.Actor[<span class="hljs-string">&quot;Gen. Buck Turgidson&quot;</span>] = <span class="hljs-string">&quot;George C. Scott&quot;</span>strangelove.Actor[<span class="hljs-string">&quot;Brig. Gen. Jack D. Ripper&quot;</span>] = <span class="hljs-string">&quot;Sterling Hayden&quot;</span>strangelove.Actor[<span class="hljs-string">&quot;Maj. T.J. \&quot;King\&quot; Kong&quot;</span>] = <span class="hljs-string">&quot;Slim Pickens&quot;</span>strangelove.Actor[<span class="hljs-string">&quot;Dr. Strangelove&quot;</span>] = <span class="hljs-string">&quot;Peter Sellers&quot;</span>strangelove.Actor[<span class="hljs-string">&quot;Grp. Capt. Lionel Mandrake&quot;</span>] = <span class="hljs-string">&quot;Peter Sellers&quot;</span>strangelove.Actor[<span class="hljs-string">&quot;Pres. Merkin Muffley&quot;</span>] = <span class="hljs-string">&quot;Peter Sellers&quot;</span>strangelove.Oscars[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;Best Actor (Nomin.)&quot;</span>strangelove.Oscars[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;Best Adapted Screenplay (Nomin.)&quot;</span>strangelove.Oscars[<span class="hljs-number">2</span>] = <span class="hljs-string">&quot;Best Director (Nomin.)&quot;</span>strangelove.Oscars[<span class="hljs-number">3</span>] = <span class="hljs-string">&quot;Best Picture (Nomin.)&quot;</span>strangelove.Sequel = <span class="hljs-literal">nil</span></code></pre></li><li><p>我们也可以使用Display函数来显示标准库中类型的内部结构，例如<code>*os.File</code>类型：</p><pre><code class="hljs Go">Display(<span class="hljs-string">&quot;os.Stderr&quot;</span>, os.Stderr)<span class="hljs-comment">// Output:</span><span class="hljs-comment">// Display os.Stderr (*os.File):</span><span class="hljs-comment">// (*(*os.Stderr).file).fd = 2</span><span class="hljs-comment">// (*(*os.Stderr).file).name = &quot;/dev/stderr&quot;</span><span class="hljs-comment">// (*(*os.Stderr).file).nepipe = 0</span></code></pre></li></ul></li><li><p>可以看出，反射能够访问到结构体中未导出的成员。需要当心的是这个例子的输出在不同操作系统上可能是不同的，并且随着标准库的发展也可能导致结果不同。（这也是将这些成员定义为私有成员的原因之一！）我们甚至可以用Display函数来显示reflect.Value 的内部构造（在这里设置为<code>*os.File</code>的类型描述体）。<code>Display(&quot;rV&quot;, reflect.ValueOf(os.Stderr))</code>调用的输出如下，当然不同环境得到的结果可能有差异：</p><pre><code class="hljs Go">Display rV (reflect.Value):(*rV.typ).size = <span class="hljs-number">8</span>(*rV.typ).hash = <span class="hljs-number">871609668</span>(*rV.typ).align = <span class="hljs-number">8</span>(*rV.typ).fieldAlign = <span class="hljs-number">8</span>(*rV.typ).kind = <span class="hljs-number">22</span>(*(*rV.typ).<span class="hljs-keyword">string</span>) = <span class="hljs-string">&quot;*os.File&quot;</span>(*(*(*rV.typ).uncommonType).methods[<span class="hljs-number">0</span>].name) = <span class="hljs-string">&quot;Chdir&quot;</span>(*(*(*(*rV.typ).uncommonType).methods[<span class="hljs-number">0</span>].mtyp).<span class="hljs-keyword">string</span>) = <span class="hljs-string">&quot;func() error&quot;</span>(*(*(*(*rV.typ).uncommonType).methods[<span class="hljs-number">0</span>].typ).<span class="hljs-keyword">string</span>) = <span class="hljs-string">&quot;func(*os.File) error&quot;</span>...</code></pre></li><li><p>观察下面两个例子的区别：</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">3</span>Display(<span class="hljs-string">&quot;i&quot;</span>, i)<span class="hljs-comment">// Output:</span><span class="hljs-comment">// Display i (int):</span><span class="hljs-comment">// i = 3</span>Display(<span class="hljs-string">&quot;&amp;i&quot;</span>, &amp;i)<span class="hljs-comment">// Output:</span><span class="hljs-comment">// Display &amp;i (*interface &#123;&#125;):</span><span class="hljs-comment">// (*&amp;i).type = int</span><span class="hljs-comment">// (*&amp;i).value = 3</span></code></pre><ul><li><p>在第一个例子中，Display函数调用reflect.ValueOf(i)，它返回一个Int类型的值。正如我们在12.2节中提到的，reflect.ValueOf总是返回一个具体类型的 Value，因为它是从一个接口值提取的内容。</p></li><li><p>在第二个例子中，Display函数调用的是reflect.ValueOf(&amp;i)，它返回一个指向i的指针，对应Ptr类型。在switch的Ptr分支中，对这个值调用 Elem 方法，返回一个Value来表示变量 i 本身，对应Interface类型。像这样一个间接获得的Value，可能代表任意类型的值，包括接口类型。display函数递归调用自身，这次它分别打印了这个接口的动态类型和值。</p></li><li><p>对于目前的实现，如果遇到对象图中含有回环，Display将会陷入死循环，例如下面这个首尾相连的链表：</p><pre><code class="hljs Go"><span class="hljs-comment">// a struct that points to itself</span><span class="hljs-keyword">type</span> Cycle <span class="hljs-keyword">struct</span>&#123; Value <span class="hljs-keyword">int</span>; Tail *Cycle &#125;<span class="hljs-keyword">var</span> c Cyclec = Cycle&#123;<span class="hljs-number">42</span>, &amp;c&#125;Display(<span class="hljs-string">&quot;c&quot;</span>, c)</code></pre></li><li><p>Display会永远不停地进行深度递归打印：</p><pre><code class="hljs Go">Display c (display.Cycle):c.Value = <span class="hljs-number">42</span>(*c.Tail).Value = <span class="hljs-number">42</span>(*(*c.Tail).Tail).Value = <span class="hljs-number">42</span>(*(*(*c.Tail).Tail).Tail).Value = <span class="hljs-number">42</span>...ad infinitum...</code></pre></li></ul></li><li><p>许多Go语言程序都包含了一些循环的数据。让Display支持这类带环的数据结构需要些技巧，需要额外记录迄今访问的路径；相应会带来成本。通用的解决方案是采用 unsafe 的语言特性，我们将在13.3节看到具体的解决方案。</p></li><li><p>带环的数据结构很少会对fmt.Sprint函数造成问题，因为它很少尝试打印完整的数据结构。例如，当它遇到一个指针的时候，它只是简单地打印指针的数字值。在打印包含自身的slice或map时可能卡住，但是这种情况很罕见，不值得付出为了处理回环所需的开销。</p></li></ul><h3 id="ch12-4-示例：编码S表达式"><a href="#ch12-4-示例：编码S表达式" class="headerlink" title="ch12.4  示例：编码S表达式"></a>ch12.4  示例：编码S表达式</h3><ul><li><p>Display是一个用于显示结构化数据的调试工具，但是它并不能将任意的Go语言对象编码为通用消息然后用于进程间通信。</p></li><li><p>正如我们在4.5节中中看到的，Go语言的标准库支持了包括JSON、XML和ASN.1等多种编码格式。还有另一种依然被广泛使用的格式是S表达式格式，采用Lisp语言的语法。但是和其他编码格式不同的是，Go语言自带的标准库并不支持S表达式，主要是因为它没有一个公认的标准规范。</p></li><li><p>在本节中，我们将定义一个包用于将任意的Go语言对象编码为S表达式格式，它支持以下结构：</p><pre><code class="hljs lsl"><span class="hljs-number">42</span>          <span class="hljs-type">integer</span><span class="hljs-string">&quot;hello&quot;</span>     <span class="hljs-type">string</span>（带有Go风格的引号）foo         symbol（未用引号括起来的名字）(<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>)     <span class="hljs-type">list</span>  （括号包起来的<span class="hljs-number">0</span>个或多个元素）</code></pre></li><li><p>布尔型习惯上使用t符号表示true，空列表或nil符号表示false，但是为了简单起见，我们暂时忽略布尔类型。同时忽略的还有chan管道和函数，因为通过反射并无法知道它们的确切状态。我们忽略的还有浮点数、复数和interface。支持它们是练习12.3的任务。</p></li><li><p>我们将Go语言的类型编码为S表达式的方法如下。整数和字符串以显而易见的方式编码。空值编码为nil符号。数组和slice被编码为列表。</p></li><li><p>构体被编码为成员对象的列表，每个成员对象对应一个有两个元素的子列表，子列表的第一个元素是成员的名字，第二个元素是成员的值。Map被编码为键值对的列表。传统上，S表达式使用点状符号列表(key . value)结构来表示key/value对，而不是用一个含双元素的列表，不过为了简单我们忽略了点状符号列表。</p></li><li><p>编码是由一个encode递归函数完成，如下所示。它的结构本质上和前面的Display函数类似：</p><p><u><i>gopl.io/ch12/sexpr</i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">encode</span><span class="hljs-params">(buf *bytes.Buffer, v reflect.Value)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">switch</span> v.Kind() &#123;<span class="hljs-keyword">case</span> reflect.Invalid:buf.WriteString(<span class="hljs-string">&quot;nil&quot;</span>)<span class="hljs-keyword">case</span> reflect.Int, reflect.Int8, reflect.Int16,reflect.Int32, reflect.Int64:fmt.Fprintf(buf, <span class="hljs-string">&quot;%d&quot;</span>, v.Int())<span class="hljs-keyword">case</span> reflect.Uint, reflect.Uint8, reflect.Uint16,reflect.Uint32, reflect.Uint64, reflect.Uintptr:fmt.Fprintf(buf, <span class="hljs-string">&quot;%d&quot;</span>, v.Uint())<span class="hljs-keyword">case</span> reflect.String:fmt.Fprintf(buf, <span class="hljs-string">&quot;%q&quot;</span>, v.String())<span class="hljs-keyword">case</span> reflect.Ptr:<span class="hljs-keyword">return</span> encode(buf, v.Elem())<span class="hljs-keyword">case</span> reflect.Array, reflect.Slice: <span class="hljs-comment">// (value ...)</span>buf.WriteByte(<span class="hljs-string">&#x27;(&#x27;</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.Len(); i++ &#123;<span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;buf.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)&#125;<span class="hljs-keyword">if</span> err := encode(buf, v.Index(i)); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;&#125;buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<span class="hljs-keyword">case</span> reflect.Struct: <span class="hljs-comment">// ((name value) ...)</span>buf.WriteByte(<span class="hljs-string">&#x27;(&#x27;</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumField(); i++ &#123;<span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;buf.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)&#125;fmt.Fprintf(buf, <span class="hljs-string">&quot;(%s &quot;</span>, v.Type().Field(i).Name)<span class="hljs-keyword">if</span> err := encode(buf, v.Field(i)); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)&#125;buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<span class="hljs-keyword">case</span> reflect.Map: <span class="hljs-comment">// ((key value) ...)</span>buf.WriteByte(<span class="hljs-string">&#x27;(&#x27;</span>)<span class="hljs-keyword">for</span> i, key := <span class="hljs-keyword">range</span> v.MapKeys() &#123;<span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;buf.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)&#125;buf.WriteByte(<span class="hljs-string">&#x27;(&#x27;</span>)<span class="hljs-keyword">if</span> err := encode(buf, key); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;buf.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)<span class="hljs-keyword">if</span> err := encode(buf, v.MapIndex(key)); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)&#125;buf.WriteByte(<span class="hljs-string">&#x27;)&#x27;</span>)<span class="hljs-keyword">default</span>: <span class="hljs-comment">// float, complex, bool, chan, func, interface</span><span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unsupported type: %s&quot;</span>, v.Type())&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><ul><li><p>Marshal函数是对encode的包装，以保持和encoding/…下其它包有着相似的API：</p><pre><code class="hljs Go"><span class="hljs-comment">// Marshal encodes a Go value in S-expression form.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Marshal</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<span class="hljs-keyword">var</span> buf bytes.Buffer<span class="hljs-keyword">if</span> err := encode(&amp;buf, reflect.ValueOf(v)); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;<span class="hljs-keyword">return</span> buf.Bytes(), <span class="hljs-literal">nil</span>&#125;</code></pre></li><li><p>下面是Marshal对12.3节的strangelove变量编码后的结果：</p><pre><code class="hljs clojure">((<span class="hljs-name">Title</span> <span class="hljs-string">&quot;Dr. Strangelove&quot;</span>) (<span class="hljs-name">Subtitle</span> <span class="hljs-string">&quot;How I Learned to Stop Worrying and Lo</span><span class="hljs-string">ve the Bomb&quot;</span>) (<span class="hljs-name">Year</span> <span class="hljs-number">1964</span>) (<span class="hljs-name">Actor</span> ((<span class="hljs-string">&quot;Grp. Capt. Lionel Mandrake&quot;</span> <span class="hljs-string">&quot;Peter Sell</span><span class="hljs-string">ers&quot;</span>) (<span class="hljs-string">&quot;Pres. Merkin Muffley&quot;</span> <span class="hljs-string">&quot;Peter Sellers&quot;</span>) (<span class="hljs-string">&quot;Gen. Buck Turgidson&quot;</span> <span class="hljs-string">&quot;Geor</span><span class="hljs-string">ge C. Scott&quot;</span>) (<span class="hljs-string">&quot;Brig. Gen. Jack D. Ripper&quot;</span> <span class="hljs-string">&quot;Sterling Hayden&quot;</span>) (<span class="hljs-string">&quot;Maj. T.J. \</span><span class="hljs-string">&quot;</span>King\<span class="hljs-string">&quot; Kong&quot;</span> <span class="hljs-string">&quot;Slim Pickens&quot;</span>) (<span class="hljs-string">&quot;Dr. Strangelove&quot;</span> <span class="hljs-string">&quot;Peter Sellers&quot;</span>))) (<span class="hljs-name">Oscars</span>(<span class="hljs-string">&quot;Best Actor (Nomin.)&quot;</span> <span class="hljs-string">&quot;Best Adapted Screenplay (Nomin.)&quot;</span> <span class="hljs-string">&quot;Best Director (N</span><span class="hljs-string">omin.)&quot;</span> <span class="hljs-string">&quot;Best Picture (Nomin.)&quot;</span>)) (<span class="hljs-name">Sequel</span> <span class="hljs-literal">nil</span>))</code></pre></li><li><p>整个输出编码为一行中以减少输出的大小，但是也很难阅读。下面是对S表达式手动格式化的结果。编写一个S表达式的美化格式化函数将作为一个具有挑战性的练习任务；不过 <a href="http://gopl.io/">http://gopl.io</a> 也提供了一个简单的版本。</p><pre><code class="hljs clojure">((<span class="hljs-name">Title</span> <span class="hljs-string">&quot;Dr. Strangelove&quot;</span>) (<span class="hljs-name">Subtitle</span> <span class="hljs-string">&quot;How I Learned to Stop Worrying and Love the Bomb&quot;</span>) (<span class="hljs-name">Year</span> <span class="hljs-number">1964</span>) (<span class="hljs-name">Actor</span> ((<span class="hljs-string">&quot;Grp. Capt. Lionel Mandrake&quot;</span> <span class="hljs-string">&quot;Peter Sellers&quot;</span>)         (<span class="hljs-string">&quot;Pres. Merkin Muffley&quot;</span> <span class="hljs-string">&quot;Peter Sellers&quot;</span>)         (<span class="hljs-string">&quot;Gen. Buck Turgidson&quot;</span> <span class="hljs-string">&quot;George C. Scott&quot;</span>)         (<span class="hljs-string">&quot;Brig. Gen. Jack D. Ripper&quot;</span> <span class="hljs-string">&quot;Sterling Hayden&quot;</span>)         (<span class="hljs-string">&quot;Maj. T.J. \&quot;King\&quot; Kong&quot;</span> <span class="hljs-string">&quot;Slim Pickens&quot;</span>)         (<span class="hljs-string">&quot;Dr. Strangelove&quot;</span> <span class="hljs-string">&quot;Peter Sellers&quot;</span>))) (<span class="hljs-name">Oscars</span> (<span class="hljs-string">&quot;Best Actor (Nomin.)&quot;</span>          <span class="hljs-string">&quot;Best Adapted Screenplay (Nomin.)&quot;</span>          <span class="hljs-string">&quot;Best Director (Nomin.)&quot;</span>          <span class="hljs-string">&quot;Best Picture (Nomin.)&quot;</span>)) (<span class="hljs-name">Sequel</span> <span class="hljs-literal">nil</span>))</code></pre></li><li><p>和fmt.Print、json.Marshal、Display函数类似，sexpr.Marshal函数处理带环的数据结构也会陷入死循环。</p></li></ul></li></ul><h3 id="ch12-5-通过reflect-Value修改值"><a href="#ch12-5-通过reflect-Value修改值" class="headerlink" title="ch12.5  通过reflect.Value修改值"></a>ch12.5  通过reflect.Value修改值</h3><ul><li><p>目前为止，反射还只是程序中变量的另一种读取方式。然而，在本节中我们将重点讨论如何通过反射机制来修改变量。</p></li><li><p>回想一下，Go语言中类似x、x.f[1]和*p形式的表达式都可以表示变量，但是其它如x + 1和f(2)则不是变量。一个变量就是一个可寻址的内存空间，里面存储了一个值，并且存储的值可以通过内存地址来更新。</p></li><li><p>对于reflect.Values也有类似的区别。有一些reflect.Values是可取地址的；其它一些则不可以。考虑以下的声明语句：</p><pre><code class="hljs Go">x := <span class="hljs-number">2</span>                   <span class="hljs-comment">// value   type    variable?</span>a := reflect.ValueOf(<span class="hljs-number">2</span>)  <span class="hljs-comment">// 2       int     no</span>b := reflect.ValueOf(x)  <span class="hljs-comment">// 2       int     no</span>c := reflect.ValueOf(&amp;x) <span class="hljs-comment">// &amp;x      *int    no</span>d := c.Elem()            <span class="hljs-comment">// 2       int     yes (x)</span></code></pre></li><li><p>其中a对应的变量不可取地址。因为a中的值仅仅是整数2的拷贝副本。b中的值也同样不可取地址。c中的值还是不可取地址，它只是一个指针<code>&amp;x</code>的拷贝。实际上，所有通过reflect.ValueOf(x)返回的reflect.Value都是不可取地址的。但是对于d，它是c的解引用方式生成的，指向另一个变量，因此是可取地址的。我们可以通过调用reflect.ValueOf(&amp;x).Elem()，来获取任意变量x对应的可取地址的Value。</p></li><li><p>我们可以通过调用reflect.Value的CanAddr方法来判断其是否可以被取地址：</p><pre><code class="hljs Go">fmt.Println(a.CanAddr()) <span class="hljs-comment">// &quot;false&quot;</span>fmt.Println(b.CanAddr()) <span class="hljs-comment">// &quot;false&quot;</span>fmt.Println(c.CanAddr()) <span class="hljs-comment">// &quot;false&quot;</span>fmt.Println(d.CanAddr()) <span class="hljs-comment">// &quot;true&quot;</span></code></pre></li><li><p>每当我们通过指针间接地获取的reflect.Value都是可取地址的，即使开始的是一个不可取地址的Value。在反射机制中，所有关于是否支持取地址的规则都是类似的。例如，slice的索引表达式e[i]将隐式地包含一个指针，它就是可取地址的，即使开始的e表达式不支持也没有关系。以此类推，reflect.ValueOf(e).Index(i)对应的值也是可取地址的，即使原始的reflect.ValueOf(e)不支持也没有关系。</p></li><li><p>要从变量对应的可取地址的reflect.Value来访问变量需要三个步骤。第一步是调用Addr()方法，它返回一个Value，里面保存了指向变量的指针。然后是在Value上调用Interface()方法，也就是返回一个interface{}，里面包含指向变量的指针。最后，如果我们知道变量的类型，我们可以使用类型的断言机制将得到的interface{}类型的接口强制转为普通的类型指针。这样我们就可以通过这个普通指针来更新变量了：</p><pre><code class="hljs Go">x := <span class="hljs-number">2</span>d := reflect.ValueOf(&amp;x).Elem()   <span class="hljs-comment">// d refers to the variable x</span>px := d.Addr().Interface().(*<span class="hljs-keyword">int</span>) <span class="hljs-comment">// px := &amp;x</span>*px = <span class="hljs-number">3</span>                           <span class="hljs-comment">// x = 3</span>fmt.Println(x)                    <span class="hljs-comment">// &quot;3&quot;</span></code></pre><ul><li><p>或者，不使用指针，而是通过调用可取地址的reflect.Value的reflect.Value.Set方法来更新对应的值：</p><pre><code class="hljs Go">d.Set(reflect.ValueOf(<span class="hljs-number">4</span>))fmt.Println(x) <span class="hljs-comment">// &quot;4&quot;</span></code></pre></li><li><p>Set方法将在运行时执行和编译时进行类似的可赋值性约束的检查。以上代码，变量和值都是int类型，但是如果变量是int64类型，那么程序将抛出一个panic异常，所以关键问题是要确保改类型的变量可以接受对应的值：</p><pre><code class="hljs Go">d.Set(reflect.ValueOf(<span class="hljs-keyword">int64</span>(<span class="hljs-number">5</span>))) <span class="hljs-comment">// panic: int64 is not assignable to int</span></code></pre></li><li><p>同样，对一个不可取地址的reflect.Value调用Set方法也会导致panic异常：</p><pre><code class="hljs Go">x := <span class="hljs-number">2</span>b := reflect.ValueOf(x)b.Set(reflect.ValueOf(<span class="hljs-number">3</span>)) <span class="hljs-comment">// panic: Set using unaddressable value</span></code></pre></li><li><p>这里有很多用于基本数据类型的Set方法：SetInt、SetUint、SetString和SetFloat等。</p><pre><code class="hljs Go">d := reflect.ValueOf(&amp;x).Elem()d.SetInt(<span class="hljs-number">3</span>)fmt.Println(x) <span class="hljs-comment">// &quot;3&quot;</span></code></pre></li></ul></li><li><p>从某种程度上说，这些Set方法总是尽可能地完成任务。以SetInt为例，只要变量是某种类型的有符号整数就可以工作，即使是一些命名的类型、甚至只要底层数据类型是有符号整数就可以，而且如果对于变量类型值太大的话会被自动截断。但需要谨慎的是：对于一个引用interface{}类型的reflect.Value调用SetInt会导致panic异常，即使那个interface{}变量对于整数类型也不行。</p><pre><code class="hljs Go">x := <span class="hljs-number">1</span>rx := reflect.ValueOf(&amp;x).Elem()rx.SetInt(<span class="hljs-number">2</span>)                     <span class="hljs-comment">// OK, x = 2</span>rx.Set(reflect.ValueOf(<span class="hljs-number">3</span>))       <span class="hljs-comment">// OK, x = 3</span>rx.SetString(<span class="hljs-string">&quot;hello&quot;</span>)            <span class="hljs-comment">// panic: string is not assignable to int</span>rx.Set(reflect.ValueOf(<span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">// panic: string is not assignable to int</span><span class="hljs-keyword">var</span> y <span class="hljs-keyword">interface</span>&#123;&#125;ry := reflect.ValueOf(&amp;y).Elem()ry.SetInt(<span class="hljs-number">2</span>)                     <span class="hljs-comment">// panic: SetInt called on interface Value</span>ry.Set(reflect.ValueOf(<span class="hljs-number">3</span>))       <span class="hljs-comment">// OK, y = int(3)</span>ry.SetString(<span class="hljs-string">&quot;hello&quot;</span>)            <span class="hljs-comment">// panic: SetString called on interface Value</span>ry.Set(reflect.ValueOf(<span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">// OK, y = &quot;hello&quot;</span></code></pre></li><li><p>当我们用Display显示os.Stdout结构时，我们发现反射可以越过Go语言的导出规则的限制读取结构体中未导出的成员，比如在类Unix系统上os.File结构体中的fd int成员。然而，利用反射机制并不能修改这些未导出的成员：</p><pre><code class="hljs Go">stdout := reflect.ValueOf(os.Stdout).Elem() <span class="hljs-comment">// *os.Stdout, an os.File var</span>fmt.Println(stdout.Type())                  <span class="hljs-comment">// &quot;os.File&quot;</span>fd := stdout.FieldByName(<span class="hljs-string">&quot;fd&quot;</span>)fmt.Println(fd.Int()) <span class="hljs-comment">// &quot;1&quot;</span>fd.SetInt(<span class="hljs-number">2</span>)          <span class="hljs-comment">// panic: unexported field</span></code></pre></li><li><p>一个可取地址的reflect.Value会记录一个结构体成员是否是未导出成员，如果是的话则拒绝修改操作。因此，CanAddr方法并不能正确反映一个变量是否是可以被修改的。另一个相关的方法CanSet是用于检查对应的reflect.Value是否是可取地址并可被修改的：</p><pre><code class="hljs Go">fmt.Println(fd.CanAddr(), fd.CanSet()) <span class="hljs-comment">// &quot;true false&quot;</span></code></pre></li></ul><h3 id="ch12-6-示例：编码S表达式"><a href="#ch12-6-示例：编码S表达式" class="headerlink" title="ch12.6  示例：编码S表达式"></a>ch12.6  示例：编码S表达式</h3><ul><li><p>标准库中encoding/…下每个包中提供的Marshal编码函数都有一个对应的Unmarshal函数用于解码。例如，我们在4.5节中看到的，要将包含JSON编码格式的字节slice数据解码为我们自己的Movie类型（§12.3），我们可以这样做：</p><pre><code class="hljs Go">data := []<span class="hljs-keyword">byte</span>&#123;<span class="hljs-comment">/* ... */</span>&#125;<span class="hljs-keyword">var</span> movie Movieerr := json.Unmarshal(data, &amp;movie)</code></pre></li><li><p>Unmarshal函数使用了反射机制类修改movie变量的每个成员，根据输入的内容为Movie成员创建对应的map、结构体和slice。</p></li><li><p>现在让我们为S表达式编码实现一个简易的Unmarshal，类似于前面的json.Unmarshal标准库函数，对应我们之前实现的sexpr.Marshal函数的逆操作。我们必须提醒一下，一个健壮的和通用的实现通常需要比例子更多的代码，为了便于演示我们采用了精简的实现。我们只支持S表达式有限的子集，同时处理错误的方式也比较粗暴，代码的目的是为了演示反射的用法，而不是构造一个实用的S表达式的解码器。</p></li><li><p>词法分析器lexer使用了标准库中的text/scanner包将输入流的字节数据解析为一个个类似注释、标识符、字符串面值和数字面值之类的标记。输入扫描器scanner的Scan方法将提前扫描和返回下一个记号，对于rune类型。大多数记号，比如“(”，对应一个单一rune可表示的Unicode字符，但是text/scanner也可以用小的负数表示记号标识符、字符串等由多个字符组成的记号。调用Scan方法将返回这些记号的类型，接着调用TokenText方法将返回记号对应的文本内容。</p></li><li><p>因为每个解析器可能需要多次使用当前的记号，但是Scan会一直向前扫描，所以我们包装了一个lexer扫描器辅助类型，用于跟踪最近由Scan方法返回的记号。</p><p><u><i>gopl.io/ch12/sexpr</i></u></p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> lexer <span class="hljs-keyword">struct</span> &#123;scan  scanner.Scannertoken <span class="hljs-keyword">rune</span> <span class="hljs-comment">// the current token</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span> <span class="hljs-title">next</span><span class="hljs-params">()</span></span>        &#123; lex.token = lex.scan.Scan() &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span> <span class="hljs-title">text</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123; <span class="hljs-keyword">return</span> lex.scan.TokenText() &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(lex *lexer)</span> <span class="hljs-title">consume</span><span class="hljs-params">(want <span class="hljs-keyword">rune</span>)</span></span> &#123;<span class="hljs-keyword">if</span> lex.token != want &#123; <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> Not an example of good error handling.</span><span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;got %q, want %q&quot;</span>, lex.text(), want))&#125;lex.next()&#125;</code></pre></li><li><p>现在让我们转到语法解析器。它主要包含两个功能。第一个是read函数，用于读取S表达式的当前标记，然后根据S表达式的当前标记更新可取地址的reflect.Value对应的变量v。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">(lex *lexer, v reflect.Value)</span></span> &#123;<span class="hljs-keyword">switch</span> lex.token &#123;<span class="hljs-keyword">case</span> scanner.Ident:<span class="hljs-comment">// The only valid identifiers are</span><span class="hljs-comment">// &quot;nil&quot; and struct field names.</span><span class="hljs-keyword">if</span> lex.text() == <span class="hljs-string">&quot;nil&quot;</span> &#123;v.Set(reflect.Zero(v.Type()))lex.next()<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">case</span> scanner.String:s, _ := strconv.Unquote(lex.text()) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring errors</span>v.SetString(s)lex.next()<span class="hljs-keyword">return</span><span class="hljs-keyword">case</span> scanner.Int:i, _ := strconv.Atoi(lex.text()) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring errors</span>v.SetInt(<span class="hljs-keyword">int64</span>(i))lex.next()<span class="hljs-keyword">return</span><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;(&#x27;</span>:lex.next()readList(lex, v)lex.next() <span class="hljs-comment">// consume &#x27;)&#x27;</span><span class="hljs-keyword">return</span>&#125;<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected token %q&quot;</span>, lex.text()))&#125;</code></pre></li><li><p>我们的S表达式使用标识符区分两个不同类型，结构体成员名和nil值的指针。read函数值处理nil类型的标识符。当遇到scanner.Ident为“nil”是，使用reflect.Zero函数将变量v设置为零值。而其它任何类型的标识符，我们都作为错误处理。后面的readList函数将处理结构体的成员名。</p></li><li><p>一个“(”标记对应一个列表的开始。第二个函数readList，将一个列表解码到一个聚合类型中（map、结构体、slice或数组），具体类型依然于传入待填充变量的类型。每次遇到这种情况，循环继续解析每个元素直到遇到于开始标记匹配的结束标记“)”，endList函数用于检测结束标记。</p></li><li><p>最有趣的部分是递归。最简单的是对数组类型的处理。直到遇到“)”结束标记，我们使用Index函数来获取数组每个元素的地址，然后递归调用read函数处理。和其它错误类似，如果输入数据导致解码器的引用超出了数组的范围，解码器将抛出panic异常。slice也采用类似方法解析，不同的是我们将为每个元素创建新的变量，然后将元素添加到slice的末尾。</p></li><li><p>在循环处理结构体和map每个元素时必须解码一个(key value)格式的对应子列表。对于结构体，key部分对于成员的名字。和数组类似，我们使用FieldByName找到结构体对应成员的变量，然后递归调用read函数处理。对于map，key可能是任意类型，对元素的处理方式和slice类似，我们创建一个新的变量，然后递归填充它，最后将新解析到的key/value对添加到map。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readList</span><span class="hljs-params">(lex *lexer, v reflect.Value)</span></span> &#123;<span class="hljs-keyword">switch</span> v.Kind() &#123;<span class="hljs-keyword">case</span> reflect.Array: <span class="hljs-comment">// (item ...)</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; !endList(lex); i++ &#123;read(lex, v.Index(i))&#125;<span class="hljs-keyword">case</span> reflect.Slice: <span class="hljs-comment">// (item ...)</span><span class="hljs-keyword">for</span> !endList(lex) &#123;item := reflect.New(v.Type().Elem()).Elem()read(lex, item)v.Set(reflect.Append(v, item))&#125;<span class="hljs-keyword">case</span> reflect.Struct: <span class="hljs-comment">// ((name value) ...)</span><span class="hljs-keyword">for</span> !endList(lex) &#123;lex.consume(<span class="hljs-string">&#x27;(&#x27;</span>)<span class="hljs-keyword">if</span> lex.token != scanner.Ident &#123;<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;got token %q, want field name&quot;</span>, lex.text()))&#125;name := lex.text()lex.next()read(lex, v.FieldByName(name))lex.consume(<span class="hljs-string">&#x27;)&#x27;</span>)&#125;<span class="hljs-keyword">case</span> reflect.Map: <span class="hljs-comment">// ((key value) ...)</span>v.Set(reflect.MakeMap(v.Type()))<span class="hljs-keyword">for</span> !endList(lex) &#123;lex.consume(<span class="hljs-string">&#x27;(&#x27;</span>)key := reflect.New(v.Type().Key()).Elem()read(lex, key)value := reflect.New(v.Type().Elem()).Elem()read(lex, value)v.SetMapIndex(key, value)lex.consume(<span class="hljs-string">&#x27;)&#x27;</span>)&#125;<span class="hljs-keyword">default</span>:<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;cannot decode list into %v&quot;</span>, v.Type()))&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">endList</span><span class="hljs-params">(lex *lexer)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">switch</span> lex.token &#123;<span class="hljs-keyword">case</span> scanner.EOF:<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;end of file&quot;</span>)<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;)&#x27;</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre></li><li><p>最后，我们将解析器包装为导出的Unmarshal解码函数，隐藏了一些初始化和清理等边缘处理。内部解析器以panic的方式抛出错误，但是Unmarshal函数通过在defer语句调用recover函数来捕获内部panic（§5.10），然后返回一个对panic对应的错误信息。</p><pre><code class="hljs Go"><span class="hljs-comment">// Unmarshal parses S-expression data and populates the variable</span><span class="hljs-comment">// whose address is in the non-nil pointer out.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unmarshal</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>, out <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(err error)</span></span> &#123;lex := &amp;lexer&#123;scan: scanner.Scanner&#123;Mode: scanner.GoTokens&#125;&#125;lex.scan.Init(bytes.NewReader(data))lex.next() <span class="hljs-comment">// get the first token</span><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> this is not an example of ideal error handling.</span><span class="hljs-keyword">if</span> x := <span class="hljs-built_in">recover</span>(); x != <span class="hljs-literal">nil</span> &#123;err = fmt.Errorf(<span class="hljs-string">&quot;error at %s: %v&quot;</span>, lex.scan.Position, x)&#125;&#125;()read(lex, reflect.ValueOf(out).Elem())<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></li><li><p>生产实现不应该对任何输入问题都用panic形式报告，而且应该报告一些错误相关的信息，例如出现错误输入的行号和位置等。尽管如此，我们希望通过这个例子来展示类似encoding/json等包底层代码的实现思路，以及如何使用反射机制来填充数据结构。</p></li></ul><h3 id="ch12-7-获取结构体字段标识"><a href="#ch12-7-获取结构体字段标识" class="headerlink" title="ch12.7  获取结构体字段标识"></a>ch12.7  获取结构体字段标识</h3><ul><li><p>在4.5节我们使用构体成员标签用于设置对应JSON对应的名字。其中json成员标签让我们可以选择成员的名字和抑制零值成员的输出。在本节，我们将看到如何通过反射机制类获取成员标签。</p></li><li><p>对于一个web服务，大部分HTTP处理函数要做的第一件事情就是展开请求中的参数到本地变量中。我们定义了一个工具函数，叫params.Unpack，通过使用结构体成员标签机制来让HTTP处理函数解析请求参数更方便。</p></li><li><p>首先，我们看看如何使用它。下面的search函数是一个HTTP请求处理函数。它定义了一个匿名结构体类型的变量，用结构体的每个成员表示HTTP请求的参数。其中结构体成员标签指明了对于请求参数的名字，为了减少URL的长度这些参数名通常都是神秘的缩略词。Unpack将请求参数填充到合适的结构体成员中，这样我们可以方便地通过合适的类型类来访问这些参数。</p><p><u><i>gopl.io/ch12/search</i></u></p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;gopl.io/ch12/params&quot;</span><span class="hljs-comment">// search implements the /search URL endpoint.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">search</span><span class="hljs-params">(resp http.ResponseWriter, req *http.Request)</span></span> &#123;<span class="hljs-keyword">var</span> data <span class="hljs-keyword">struct</span> &#123;Labels     []<span class="hljs-keyword">string</span> <span class="hljs-string">`http:&quot;l&quot;`</span>MaxResults <span class="hljs-keyword">int</span>      <span class="hljs-string">`http:&quot;max&quot;`</span>Exact      <span class="hljs-keyword">bool</span>     <span class="hljs-string">`http:&quot;x&quot;`</span>&#125;data.MaxResults = <span class="hljs-number">10</span> <span class="hljs-comment">// set default</span><span class="hljs-keyword">if</span> err := params.Unpack(req, &amp;data); err != <span class="hljs-literal">nil</span> &#123;http.Error(resp, err.Error(), http.StatusBadRequest) <span class="hljs-comment">// 400</span><span class="hljs-keyword">return</span>&#125;<span class="hljs-comment">// ...rest of handler...</span>fmt.Fprintf(resp, <span class="hljs-string">&quot;Search: %+v\n&quot;</span>, data)&#125;</code></pre></li><li><p>下面的Unpack函数主要完成三件事情。第一，它调用req.ParseForm()来解析HTTP请求。然后，req.Form将包含所有的请求参数，不管HTTP客户端使用的是GET还是POST请求方法。</p></li><li><p>下一步，Unpack函数将构建每个结构体成员有效参数名字到成员变量的映射。如果结构体成员有成员标签的话，有效参数名字可能和实际的成员名字不相同。reflect.Type的Field方法将返回一个reflect.StructField，里面含有每个成员的名字、类型和可选的成员标签等信息。其中成员标签信息对应reflect.StructTag类型的字符串，并且提供了Get方法用于解析和根据特定key提取的子串，例如这里的http:”…”形式的子串。</p><p><u><i>gopl.io/ch12/params</i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// Unpack populates the fields of the struct pointed to by ptr</span><span class="hljs-comment">// from the HTTP request parameters in req.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unpack</span><span class="hljs-params">(req *http.Request, ptr <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> err := req.ParseForm(); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-comment">// Build map of fields keyed by effective name.</span>fields := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]reflect.Value)v := reflect.ValueOf(ptr).Elem() <span class="hljs-comment">// the struct variable</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumField(); i++ &#123;fieldInfo := v.Type().Field(i) <span class="hljs-comment">// a reflect.StructField</span>tag := fieldInfo.Tag           <span class="hljs-comment">// a reflect.StructTag</span>name := tag.Get(<span class="hljs-string">&quot;http&quot;</span>)<span class="hljs-keyword">if</span> name == <span class="hljs-string">&quot;&quot;</span> &#123;name = strings.ToLower(fieldInfo.Name)&#125;fields[name] = v.Field(i)&#125;<span class="hljs-comment">// Update struct field for each parameter in the request.</span><span class="hljs-keyword">for</span> name, values := <span class="hljs-keyword">range</span> req.Form &#123;f := fields[name]<span class="hljs-keyword">if</span> !f.IsValid() &#123;<span class="hljs-keyword">continue</span> <span class="hljs-comment">// ignore unrecognized HTTP parameters</span>&#125;<span class="hljs-keyword">for</span> _, value := <span class="hljs-keyword">range</span> values &#123;<span class="hljs-keyword">if</span> f.Kind() == reflect.Slice &#123;elem := reflect.New(f.Type().Elem()).Elem()<span class="hljs-keyword">if</span> err := populate(elem, value); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s: %v&quot;</span>, name, err)&#125;f.Set(reflect.Append(f, elem))&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-keyword">if</span> err := populate(f, value); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s: %v&quot;</span>, name, err)&#125;&#125;&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></li><li><p>最后，Unpack遍历HTTP请求的name/valu参数键值对，并且根据更新相应的结构体成员。回想一下，同一个名字的参数可能出现多次。如果发生这种情况，并且对应的结构体成员是一个slice，那么就将所有的参数添加到slice中。其它情况，对应的成员值将被覆盖，只有最后一次出现的参数值才是起作用的。</p></li><li><p>populate函数小心用请求的字符串类型参数值来填充单一的成员v（或者是slice类型成员中的单一的元素）。目前，它仅支持字符串、有符号整数和布尔型。其中其它的类型将留做练习任务。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">populate</span><span class="hljs-params">(v reflect.Value, value <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">switch</span> v.Kind() &#123;<span class="hljs-keyword">case</span> reflect.String:v.SetString(value)<span class="hljs-keyword">case</span> reflect.Int:i, err := strconv.ParseInt(value, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;v.SetInt(i)<span class="hljs-keyword">case</span> reflect.Bool:b, err := strconv.ParseBool(value)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;v.SetBool(b)<span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unsupported kind %s&quot;</span>, v.Type())&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></li><li><p>如果我们上上面的处理程序添加到一个web服务器，则可以产生以下的会话：</p><pre><code class="hljs vim">$ <span class="hljs-keyword">go</span> build gopl.io/ch12/<span class="hljs-built_in">search</span>$ ./<span class="hljs-built_in">search</span> &amp;$ ./fetch <span class="hljs-string">&#x27;http://localhost:12345/search&#x27;</span>Search: &#123;Label<span class="hljs-variable">s:</span>[] MaxResult<span class="hljs-variable">s:10</span> Exac<span class="hljs-variable">t:false</span>&#125;$ ./fetch <span class="hljs-string">&#x27;http://localhost:12345/search?l=golang&amp;l=programming&#x27;</span>Search: &#123;Label<span class="hljs-variable">s:</span>[golang programming] MaxResult<span class="hljs-variable">s:10</span> Exac<span class="hljs-variable">t:false</span>&#125;$ ./fetch <span class="hljs-string">&#x27;http://localhost:12345/search?l=golang&amp;l=programming&amp;max=100&#x27;</span>Search: &#123;Label<span class="hljs-variable">s:</span>[golang programming] MaxResult<span class="hljs-variable">s:100</span> Exac<span class="hljs-variable">t:false</span>&#125;$ ./fetch <span class="hljs-string">&#x27;http://localhost:12345/search?x=true&amp;l=golang&amp;l=programming&#x27;</span>Search: &#123;Label<span class="hljs-variable">s:</span>[golang programming] MaxResult<span class="hljs-variable">s:10</span> Exac<span class="hljs-variable">t:true</span>&#125;$ ./fetch <span class="hljs-string">&#x27;http://localhost:12345/search?q=hello&amp;x=123&#x27;</span><span class="hljs-keyword">x</span>: strconv.ParseBoo<span class="hljs-variable">l:</span> parsing <span class="hljs-string">&quot;123&quot;</span>: invalid <span class="hljs-keyword">syntax</span>$ ./fetch <span class="hljs-string">&#x27;http://localhost:12345/search?q=hello&amp;max=lots&#x27;</span><span class="hljs-built_in">max</span>: strconv.ParseIn<span class="hljs-variable">t:</span> parsing <span class="hljs-string">&quot;lots&quot;</span>: invalid <span class="hljs-keyword">syntax</span></code></pre></li></ul><h3 id="ch12-8-显示一个类型的方法集"><a href="#ch12-8-显示一个类型的方法集" class="headerlink" title="ch12.8  显示一个类型的方法集"></a>ch12.8  显示一个类型的方法集</h3><ul><li><p>我们的最后一个例子是使用reflect.Type来打印任意值的类型和枚举它的方法：</p><p><u><i>gopl.io/ch12/methods</i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// Print prints the method set of the value x.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Print</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;v := reflect.ValueOf(x)t := v.Type()fmt.Printf(<span class="hljs-string">&quot;type %s\n&quot;</span>, t)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumMethod(); i++ &#123;methType := v.Method(i).Type()fmt.Printf(<span class="hljs-string">&quot;func (%s) %s%s\n&quot;</span>, t, t.Method(i).Name,strings.TrimPrefix(methType.String(), <span class="hljs-string">&quot;func&quot;</span>))&#125;&#125;</code></pre></li><li><p>reflect.Type和reflect.Value都提供了一个Method方法。每次t.Method(i)调用将一个reflect.Method的实例，对应一个用于描述一个方法的名称和类型的结构体。每次v.Method(i)方法调用都返回一个reflect.Value以表示对应的值（§6.4），也就是一个方法是帮到它的接收者的。使用reflect.Value.Call方法（我们这里没有演示），将可以调用一个Func类型的Value，但是这个例子中只用到了它的类型。</p></li><li><p>这是属于time.Duration和<code>*strings.Replacer</code>两个类型的方法：</p><pre><code class="hljs Go">methods.Print(time.Hour)<span class="hljs-comment">// Output:</span><span class="hljs-comment">// type time.Duration</span><span class="hljs-comment">// func (time.Duration) Hours() float64</span><span class="hljs-comment">// func (time.Duration) Minutes() float64</span><span class="hljs-comment">// func (time.Duration) Nanoseconds() int64</span><span class="hljs-comment">// func (time.Duration) Seconds() float64</span><span class="hljs-comment">// func (time.Duration) String() string</span>methods.Print(<span class="hljs-built_in">new</span>(strings.Replacer))<span class="hljs-comment">// Output:</span><span class="hljs-comment">// type *strings.Replacer</span><span class="hljs-comment">// func (*strings.Replacer) Replace(string) string</span><span class="hljs-comment">// func (*strings.Replacer) WriteString(io.Writer, string) (int, error)</span></code></pre></li></ul><h3 id="ch12-9-几点忠告"><a href="#ch12-9-几点忠告" class="headerlink" title="ch12.9  几点忠告"></a>ch12.9  几点忠告</h3><ul><li><p>虽然反射提供的API远多于我们讲到的，我们前面的例子主要是给出了一个方向，通过反射可以实现哪些功能。反射是一个强大并富有表达力的工具，但是它应该被小心地使用，原因有三。</p></li><li><p>第一个原因是，基于反射的代码是比较脆弱的。对于每一个会导致编译器报告类型错误的问题，在反射中都有与之相对应的误用问题，不同的是编译器会在构建时马上报告错误，而反射则是在真正运行到的时候才会抛出panic异常，可能是写完代码很久之后了，而且程序也可能运行了很长的时间。</p></li><li><p>以前面的readList函数（§12.6）为例，为了从输入读取字符串并填充int类型的变量而调用的reflect.Value.SetString方法可能导致panic异常。绝大多数使用反射的程序都有类似的风险，需要非常小心地检查每个reflect.Value的对应值的类型、是否可取地址，还有是否可以被修改等。</p></li><li><p>避免这种因反射而导致的脆弱性的问题的最好方法，是将所有的反射相关的使用控制在包的内部，如果可能的话避免在包的API中直接暴露reflect.Value类型，这样可以限制一些非法输入。如果无法做到这一点，在每个有风险的操作前指向额外的类型检查。以标准库中的代码为例，当fmt.Printf收到一个非法的操作数时，它并不会抛出panic异常，而是打印相关的错误信息。程序虽然还有BUG，但是会更加容易诊断。</p><pre><code class="hljs Go">fmt.Printf(<span class="hljs-string">&quot;%d %s\n&quot;</span>, <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">42</span>) <span class="hljs-comment">// &quot;%!d(string=hello) %!s(int=42)&quot;</span></code></pre></li><li><p>反射同样降低了程序的安全性，还影响了自动化重构和分析工具的准确性，因为它们无法识别运行时才能确认的类型信息。</p></li><li><p>避免使用反射的第二个原因是，即使对应类型提供了相同文档，但是反射的操作不能做静态类型检查，而且大量反射的代码通常难以理解。总是需要小心翼翼地为每个导出的类型和其它接受interface{}或reflect.Value类型参数的函数维护说明文档。</p></li><li><p>第三个原因，基于反射的代码通常比正常的代码运行速度慢一到两个数量级。对于一个典型的项目，大部分函数的性能和程序的整体性能关系不大，所以当反射能使程序更加清晰的时候可以考虑使用。测试是一个特别适合使用反射的场景，因为每个测试的数据集都很小。但是对于性能关键路径的函数，最好避免使用反射。</p></li></ul><h2 id="ch13-底层编程"><a href="#ch13-底层编程" class="headerlink" title="ch13  底层编程"></a>ch13  底层编程</h2><h3 id="ch13-0-简介"><a href="#ch13-0-简介" class="headerlink" title="ch13.0  简介"></a>ch13.0  简介</h3><ul><li>Go语言的设计包含了诸多安全策略，限制了可能导致程序运行出错的用法。编译时类型检查可以发现大多数类型不匹配的操作，例如两个字符串做减法的错误。字符串、map、slice和chan等所有的内置类型，都有严格的类型转换规则。</li><li>对于无法静态检测到的错误，例如数组访问越界或使用空指针，运行时动态检测可以保证程序在遇到问题的时候立即终止并打印相关的错误信息。自动内存管理（垃圾内存自动回收）可以消除大部分野指针和内存泄漏相关的问题。</li><li>Go语言的实现刻意隐藏了很多底层细节。我们无法知道一个结构体真实的内存布局，也无法获取一个运行时函数对应的机器码，也无法知道当前的goroutine是运行在哪个操作系统线程之上。事实上，Go语言的调度器会自己决定是否需要将某个goroutine从一个操作系统线程转移到另一个操作系统线程。一个指向变量的指针也并没有展示变量真实的地址。因为垃圾回收器可能会根据需要移动变量的内存位置，当然变量对应的地址也会被自动更新。</li><li>总的来说，Go语言的这些特性使得Go程序相比较低级的C语言来说更容易预测和理解，程序也不容易崩溃。通过隐藏底层的实现细节，也使得Go语言编写的程序具有高度的可移植性，因为语言的语义在很大程度上是独立于任何编译器实现、操作系统和CPU系统结构的（当然也不是完全绝对独立：例如int等类型就依赖于CPU机器字的大小，某些表达式求值的具体顺序，还有编译器实现的一些额外的限制等）。</li><li>有时候我们可能会放弃使用部分语言特性而优先选择具有更好性能的方法，例如需要与其他语言编写的库进行互操作，或者用纯Go语言无法实现的某些函数。</li><li>在本章，我们将展示如何使用unsafe包来摆脱Go语言规则带来的限制，讲述如何创建C语言函数库的绑定，以及如何进行系统调用。</li><li>本章提供的方法不应该轻易使用（译注：属于黑魔法，虽然功能很强大，但是也容易误伤到自己）。如果没有处理好细节，它们可能导致各种不可预测的并且隐晦的错误，甚至连有经验的C语言程序员也无法理解这些错误。使用unsafe包的同时也放弃了Go语言保证与未来版本的兼容性的承诺，因为它必然会有意无意中使用很多非公开的实现细节，而这些实现的细节在未来的Go语言中很可能会被改变。</li><li>要注意的是，unsafe包是一个采用特殊方式实现的包。虽然它可以和普通包一样的导入和使用，但它实际上是由编译器实现的。它提供了一些访问语言内部特性的方法，特别是内存布局相关的细节。将这些特性封装到一个独立的包中，是为在极少数情况下需要使用的时候，同时引起人们的注意（译注：因为看包的名字就知道使用unsafe包是不安全的）。此外，有一些环境因为安全的因素可能限制这个包的使用。</li><li>不过unsafe包被广泛地用于比较低级的包，例如runtime、os、syscall还有net包等，因为它们需要和操作系统密切配合，但是对于普通的程序一般是不需要使用unsafe包的。</li></ul><h3 id="ch13-1-unsafe-Sizeof-Alignof-和-Offsetof"><a href="#ch13-1-unsafe-Sizeof-Alignof-和-Offsetof" class="headerlink" title="ch13.1  unsafe.Sizeof, Alignof 和 Offsetof"></a>ch13.1  unsafe.Sizeof, Alignof 和 Offsetof</h3><ul><li><p>unsafe.Sizeof函数返回操作数在内存中的字节大小，参数可以是任意类型的表达式，但是它并不会对表达式进行求值。一个Sizeof函数调用是一个对应uintptr类型的常量表达式，因此返回的结果可以用作数组类型的长度大小，或者用作计算其他的常量。</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unsafe&quot;</span>fmt.Println(unsafe.Sizeof(<span class="hljs-keyword">float64</span>(<span class="hljs-number">0</span>))) <span class="hljs-comment">// &quot;8&quot;</span></code></pre></li><li><p>Sizeof函数返回的大小只包括数据结构中固定的部分，例如字符串对应结构体中的指针和字符串长度部分，但是并不包含指针指向的字符串的内容。Go语言中非聚合类型通常有一个固定的大小，尽管在不同工具链下生成的实际大小可能会有所不同。考虑到可移植性，引用类型或包含引用类型的大小在32位平台上是4个字节，在64位平台上是8个字节。</p></li><li><p>计算机在加载和保存数据时，如果内存地址合理地对齐的将会更有效率。例如2字节大小的int16类型的变量地址应该是偶数，一个4字节大小的rune类型变量的地址应该是4的倍数，一个8字节大小的float64、uint64或64-bit指针类型变量的地址应该是8字节对齐的。但是对于再大的地址对齐倍数则是不需要的，即使是complex128等较大的数据类型最多也只是8字节对齐。</p></li><li><p>由于地址对齐这个因素，一个聚合类型（结构体或数组）的大小至少是所有字段或元素大小的总和，或者更大因为可能存在内存空洞。内存空洞是编译器自动添加的没有被使用的内存空间，用于保证后面每个字段或元素的地址相对于结构或数组的开始地址能够合理地对齐（译注：内存空洞可能会存在一些随机数据，可能会对用unsafe包直接操作内存的处理产生影响）。</p><table><thead><tr><th>类型</th><th>大小</th></tr></thead><tbody><tr><td><code>bool</code></td><td>1个字节</td></tr><tr><td><code>intN, uintN, floatN, complexN</code></td><td>N/8个字节（例如float64是8个字节）</td></tr><tr><td><code>int, uint, uintptr</code></td><td>1个机器字</td></tr><tr><td><code>*T</code></td><td>1个机器字</td></tr><tr><td><code>string</code></td><td>2个机器字（data、len）</td></tr><tr><td><code>[]T</code></td><td>3个机器字（data、len、cap）</td></tr><tr><td><code>map</code></td><td>1个机器字</td></tr><tr><td><code>func</code></td><td>1个机器字</td></tr><tr><td><code>chan</code></td><td>1个机器字</td></tr><tr><td><code>interface</code></td><td>2个机器字（type、value）</td></tr></tbody></table></li><li><p>Go语言的规范并没有要求一个字段的声明顺序和内存中的顺序是一致的，所以理论上一个编译器可以随意地重新排列每个字段的内存位置，虽然在写作本书的时候编译器还没有这么做。下面的三个结构体虽然有着相同的字段，但是第一种写法比另外的两个需要多50%的内存。</p><pre><code class="hljs Go">                               <span class="hljs-comment">// 64-bit  32-bit</span><span class="hljs-keyword">struct</span>&#123; <span class="hljs-keyword">bool</span>; <span class="hljs-keyword">float64</span>; <span class="hljs-keyword">int16</span> &#125; <span class="hljs-comment">// 3 words 4words</span><span class="hljs-keyword">struct</span>&#123; <span class="hljs-keyword">float64</span>; <span class="hljs-keyword">int16</span>; <span class="hljs-keyword">bool</span> &#125; <span class="hljs-comment">// 2 words 3words</span><span class="hljs-keyword">struct</span>&#123; <span class="hljs-keyword">bool</span>; <span class="hljs-keyword">int16</span>; <span class="hljs-keyword">float64</span> &#125; <span class="hljs-comment">// 2 words 3words</span></code></pre></li><li><p>关于内存地址对齐算法的细节超出了本书的范围，也不是每一个结构体都需要担心这个问题，不过有效的包装可以使数据结构更加紧凑（译注：未来的Go语言编译器应该会默认优化结构体的顺序，当然应该也能够指定具体的内存布局，相同讨论请参考 <a href="https://github.com/golang/go/issues/10014">Issue10014</a> ），内存使用率和性能都可能会受益。</p></li><li><p><code>unsafe.Alignof</code> 函数返回对应参数的类型需要对齐的倍数。和 Sizeof 类似， Alignof 也是返回一个常量表达式，对应一个常量。通常情况下布尔和数字类型需要对齐到它们本身的大小（最多8个字节），其它的类型对齐到机器字大小。</p></li><li><p><code>unsafe.Offsetof</code> 函数的参数必须是一个字段 <code>x.f</code>，然后返回 <code>f</code> 字段相对于 <code>x</code> 起始地址的偏移量，包括可能的空洞。</p></li><li><p>图 13.1 显示了一个结构体变量 x 以及其在32位和64位机器上的典型的内存。灰色区域是空洞。</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">struct</span> &#123;a <span class="hljs-keyword">bool</span>b <span class="hljs-keyword">int16</span>c []<span class="hljs-keyword">int</span>&#125;</code></pre><ul><li><p>32位系统：</p><pre><code class="hljs reasonml"><span class="hljs-constructor">Sizeof(<span class="hljs-params">x</span>)</span>   = <span class="hljs-number">16</span>  <span class="hljs-constructor">Alignof(<span class="hljs-params">x</span>)</span>   = <span class="hljs-number">4</span><span class="hljs-constructor">Sizeof(<span class="hljs-params">x</span>.<span class="hljs-params">a</span>)</span> = <span class="hljs-number">1</span>   <span class="hljs-constructor">Alignof(<span class="hljs-params">x</span>.<span class="hljs-params">a</span>)</span> = <span class="hljs-number">1</span> <span class="hljs-constructor">Offsetof(<span class="hljs-params">x</span>.<span class="hljs-params">a</span>)</span> = <span class="hljs-number">0</span><span class="hljs-constructor">Sizeof(<span class="hljs-params">x</span>.<span class="hljs-params">b</span>)</span> = <span class="hljs-number">2</span>   <span class="hljs-constructor">Alignof(<span class="hljs-params">x</span>.<span class="hljs-params">b</span>)</span> = <span class="hljs-number">2</span> <span class="hljs-constructor">Offsetof(<span class="hljs-params">x</span>.<span class="hljs-params">b</span>)</span> = <span class="hljs-number">2</span><span class="hljs-constructor">Sizeof(<span class="hljs-params">x</span>.<span class="hljs-params">c</span>)</span> = <span class="hljs-number">12</span>  <span class="hljs-constructor">Alignof(<span class="hljs-params">x</span>.<span class="hljs-params">c</span>)</span> = <span class="hljs-number">4</span> <span class="hljs-constructor">Offsetof(<span class="hljs-params">x</span>.<span class="hljs-params">c</span>)</span> = <span class="hljs-number">4</span></code></pre></li><li><p>64位系统：</p><pre><code class="hljs reasonml"><span class="hljs-constructor">Sizeof(<span class="hljs-params">x</span>)</span>   = <span class="hljs-number">32</span>  <span class="hljs-constructor">Alignof(<span class="hljs-params">x</span>)</span>   = <span class="hljs-number">8</span><span class="hljs-constructor">Sizeof(<span class="hljs-params">x</span>.<span class="hljs-params">a</span>)</span> = <span class="hljs-number">1</span>   <span class="hljs-constructor">Alignof(<span class="hljs-params">x</span>.<span class="hljs-params">a</span>)</span> = <span class="hljs-number">1</span> <span class="hljs-constructor">Offsetof(<span class="hljs-params">x</span>.<span class="hljs-params">a</span>)</span> = <span class="hljs-number">0</span><span class="hljs-constructor">Sizeof(<span class="hljs-params">x</span>.<span class="hljs-params">b</span>)</span> = <span class="hljs-number">2</span>   <span class="hljs-constructor">Alignof(<span class="hljs-params">x</span>.<span class="hljs-params">b</span>)</span> = <span class="hljs-number">2</span> <span class="hljs-constructor">Offsetof(<span class="hljs-params">x</span>.<span class="hljs-params">b</span>)</span> = <span class="hljs-number">2</span><span class="hljs-constructor">Sizeof(<span class="hljs-params">x</span>.<span class="hljs-params">c</span>)</span> = <span class="hljs-number">24</span>  <span class="hljs-constructor">Alignof(<span class="hljs-params">x</span>.<span class="hljs-params">c</span>)</span> = <span class="hljs-number">8</span> <span class="hljs-constructor">Offsetof(<span class="hljs-params">x</span>.<span class="hljs-params">c</span>)</span> = <span class="hljs-number">8</span></code></pre></li></ul></li><li><p>虽然这几个函数在不安全的unsafe包，但是这几个函数调用并不是真的不安全，特别在需要优化内存空间时它们返回的结果对于理解原生的内存布局很有帮助。</p></li></ul><h3 id="ch13-2-unsafe-Pointer"><a href="#ch13-2-unsafe-Pointer" class="headerlink" title="ch13.2  unsafe.Pointer"></a>ch13.2  unsafe.Pointer</h3><ul><li><p>大多数指针类型会写成<code>*T</code>，表示是“一个指向T类型变量的指针”。unsafe.Pointer是特别定义的一种指针类型（译注：类似C语言中的<code>void*</code>类型的指针），它可以包含任意类型变量的地址。当然，我们不可以直接通过<code>*p</code>来获取unsafe.Pointer指针指向的真实变量的值，因为我们并不知道变量的具体类型。和普通指针一样，unsafe.Pointer指针也是可以比较的，并且支持和nil常量比较判断是否为空指针。</p></li><li><p>一个普通的<code>*T</code>类型指针可以被转化为unsafe.Pointer类型指针，并且一个unsafe.Pointer类型指针也可以被转回普通的指针，被转回普通的指针类型并不需要和原始的<code>*T</code>类型相同。通过将<code>*float64</code>类型指针转化为<code>*uint64</code>类型指针，我们可以查看一个浮点数变量的位模式。</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> math<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Float64bits</span><span class="hljs-params">(f <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">uint64</span></span> &#123; <span class="hljs-keyword">return</span> *(*<span class="hljs-keyword">uint64</span>)(unsafe.Pointer(&amp;f)) &#125;fmt.Printf(<span class="hljs-string">&quot;%[[016x]]\n&quot;</span>, Float64bits(<span class="hljs-number">1.0</span>)) <span class="hljs-comment">// &quot;0x3ff0000000000000&quot;</span></code></pre></li><li><p>通过转为新类型指针，我们可以更新浮点数的位模式。通过位模式操作浮点数是可以的，但是更重要的意义是指针转换语法让我们可以在不破坏类型系统的前提下向内存写入任意的值。</p></li><li><p>一个unsafe.Pointer指针也可以被转化为uintptr类型，然后保存到指针型数值变量中（译注：这只是和当前指针相同的一个数字值，并不是一个指针），然后用以做必要的指针数值运算。（第三章内容，uintptr是一个无符号的整型数，足以保存一个地址）这种转换虽然也是可逆的，但是将uintptr转为unsafe.Pointer指针可能会破坏类型系统，因为并不是所有的数字都是有效的内存地址。</p></li><li><p>许多将unsafe.Pointer指针转为原生数字，然后再转回为unsafe.Pointer类型指针的操作也是不安全的。比如下面的例子需要将变量x的地址加上b字段地址偏移量转化为<code>*int16</code>类型指针，然后通过该指针更新x.b：</p><p><u><i>gopl.io/ch13/unsafeptr</i></u></p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">struct</span> &#123;a <span class="hljs-keyword">bool</span>b <span class="hljs-keyword">int16</span>c []<span class="hljs-keyword">int</span>&#125;<span class="hljs-comment">// 和 pb := &amp;x.b 等价</span>pb := (*<span class="hljs-keyword">int16</span>)(unsafe.Pointer(<span class="hljs-keyword">uintptr</span>(unsafe.Pointer(&amp;x)) + unsafe.Offsetof(x.b)))*pb = <span class="hljs-number">42</span>fmt.Println(x.b) <span class="hljs-comment">// &quot;42&quot;</span></code></pre></li><li><p>上面的写法尽管很繁琐，但在这里并不是一件坏事，因为这些功能应该很谨慎地使用。不要试图引入一个uintptr类型的临时变量，因为它可能会破坏代码的安全性（译注：这是真正可以体会unsafe包为何不安全的例子）。下面段代码是错误的：</p><pre><code class="hljs Go"><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> subtly incorrect!</span>tmp := <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(&amp;x)) + unsafe.Offsetof(x.b)pb := (*<span class="hljs-keyword">int16</span>)(unsafe.Pointer(tmp))*pb = <span class="hljs-number">42</span></code></pre></li><li><p>产生错误的原因很微妙。有时候垃圾回收器会移动一些变量以降低内存碎片等问题。这类垃圾回收器被称为移动GC。当一个变量被移动，所有的保存该变量旧地址的指针必须同时被更新为变量移动后的新地址。从垃圾收集器的视角来看，一个unsafe.Pointer是一个指向变量的指针，因此当变量被移动时对应的指针也必须被更新；但是uintptr类型的临时变量只是一个普通的数字，所以其值不应该被改变。上面错误的代码因为引入一个非指针的临时变量tmp，导致垃圾收集器无法正确识别这个是一个指向变量x的指针。当第二个语句执行时，变量x可能已经被转移，这时候临时变量tmp也就不再是现在的<code>&amp;x.b</code>地址。第三个向之前无效地址空间的赋值语句将彻底摧毁整个程序！</p></li><li><p>还有很多类似原因导致的错误。例如这条语句：</p><pre><code class="hljs Go">pT := <span class="hljs-keyword">uintptr</span>(unsafe.Pointer(<span class="hljs-built_in">new</span>(T))) <span class="hljs-comment">// 提示: 错误!</span></code></pre></li><li><p>这里并没有指针引用<code>new</code>新创建的变量，因此该语句执行完成之后，垃圾收集器有权马上回收其内存空间，所以返回的pT将是无效的地址。</p></li><li><p>虽然目前的Go语言实现还没有使用移动GC（译注：未来可能实现），但这不该是编写错误代码侥幸的理由：当前的Go语言实现已经有移动变量的场景。在5.2节我们提到goroutine的栈是根据需要动态增长的。当发生栈动态增长的时候，原来栈中的所有变量可能需要被移动到新的更大的栈中，所以我们并不能确保变量的地址在整个使用周期内是不变的。</p></li><li><p>在编写本文时，还没有清晰的原则来指引Go程序员，什么样的unsafe.Pointer和uintptr的转换是不安全的（参考 <a href="https://github.com/golang/go/issues/7192">Issue7192</a> ）. 译注: 该问题已经关闭），因此我们强烈建议按照最坏的方式处理。将所有包含变量地址的uintptr类型变量当作BUG处理，同时减少不必要的unsafe.Pointer类型到uintptr类型的转换。在第一个例子中，有三个转换——字段偏移量到uintptr的转换和转回unsafe.Pointer类型的操作——所有的转换全在一个表达式完成。</p></li><li><p>当调用一个库函数，并且返回的是uintptr类型地址时（译注：普通方法实现的函数尽量不要返回该类型。下面例子是reflect包的函数，reflect包和unsafe包一样都是采用特殊技术实现的，编译器可能给它们开了后门），比如下面反射包中的相关函数，返回的结果应该立即转换为unsafe.Pointer以确保指针指向的是相同的变量。</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> reflect<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Value)</span> <span class="hljs-title">Pointer</span><span class="hljs-params">()</span> <span class="hljs-title">uintptr</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Value)</span> <span class="hljs-title">UnsafeAddr</span><span class="hljs-params">()</span> <span class="hljs-title">uintptr</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(Value)</span> <span class="hljs-title">InterfaceData</span><span class="hljs-params">()</span> [2]<span class="hljs-title">uintptr</span> // <span class="hljs-params">(index 1)</span></span></code></pre></li></ul><h3 id="ch13-3-示例：深度相等判断"><a href="#ch13-3-示例：深度相等判断" class="headerlink" title="ch13.3  示例：深度相等判断"></a>ch13.3  示例：深度相等判断</h3><ul><li><p>来自reflect包的DeepEqual函数可以对两个值进行深度相等判断。DeepEqual函数使用内建的==比较操作符对基础类型进行相等判断，对于复合类型则递归该变量的每个基础类型然后做类似的比较判断。因为它可以工作在任意的类型上，甚至对于一些不支持==操作运算符的类型也可以工作，因此在一些测试代码中广泛地使用该函数。比如下面的代码是用DeepEqual函数比较两个字符串slice是否相等。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSplit</span><span class="hljs-params">(t *testing.T)</span></span> &#123;got := strings.Split(<span class="hljs-string">&quot;a:b:c&quot;</span>, <span class="hljs-string">&quot;:&quot;</span>)want := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<span class="hljs-keyword">if</span> !reflect.DeepEqual(got, want) &#123; <span class="hljs-comment">/* ... */</span> &#125;&#125;</code></pre></li><li><p>尽管DeepEqual函数很方便，而且可以支持任意的数据类型，但是它也有不足之处。例如，它将一个nil值的map和非nil值但是空的map视作不相等，同样nil值的slice 和非nil但是空的slice也视作不相等。</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> a, b []<span class="hljs-keyword">string</span> = <span class="hljs-literal">nil</span>, []<span class="hljs-keyword">string</span>&#123;&#125;fmt.Println(reflect.DeepEqual(a, b)) <span class="hljs-comment">// &quot;false&quot;</span><span class="hljs-keyword">var</span> c, d <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span> = <span class="hljs-literal">nil</span>, <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)fmt.Println(reflect.DeepEqual(c, d)) <span class="hljs-comment">// &quot;false&quot;</span></code></pre></li><li><p>我们希望在这里实现一个自己的Equal函数，用于比较类型的值。和DeepEqual函数类似的地方是它也是基于slice和map的每个元素进行递归比较，不同之处是它将nil值的slice（map类似）和非nil值但是空的slice视作相等的值。基础部分的比较可以基于reflect包完成，和12.3章的Display函数的实现方法类似。同样，我们也定义了一个内部函数equal，用于内部的递归比较。读者目前不用关心seen参数的具体含义。对于每一对需要比较的x和y，equal函数首先检测它们是否都有效（或都无效），然后检测它们是否是相同的类型。剩下的部分是一个巨大的switch分支，用于相同基础类型的元素比较。因为页面空间的限制，我们省略了一些相似的分支。</p><p><u><i>gopl.io/ch13/equal</i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">equal</span><span class="hljs-params">(x, y reflect.Value, seen <span class="hljs-keyword">map</span>[comparison]<span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> !x.IsValid() || !y.IsValid() &#123;<span class="hljs-keyword">return</span> x.IsValid() == y.IsValid()&#125;<span class="hljs-keyword">if</span> x.Type() != y.Type() &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-comment">// ...cycle check omitted (shown later)...</span><span class="hljs-keyword">switch</span> x.Kind() &#123;<span class="hljs-keyword">case</span> reflect.Bool:<span class="hljs-keyword">return</span> x.Bool() == y.Bool()<span class="hljs-keyword">case</span> reflect.String:<span class="hljs-keyword">return</span> x.String() == y.String()<span class="hljs-comment">// ...numeric cases omitted for brevity...</span><span class="hljs-keyword">case</span> reflect.Chan, reflect.UnsafePointer, reflect.Func:<span class="hljs-keyword">return</span> x.Pointer() == y.Pointer()<span class="hljs-keyword">case</span> reflect.Ptr, reflect.Interface:<span class="hljs-keyword">return</span> equal(x.Elem(), y.Elem(), seen)<span class="hljs-keyword">case</span> reflect.Array, reflect.Slice:<span class="hljs-keyword">if</span> x.Len() != y.Len() &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; x.Len(); i++ &#123;<span class="hljs-keyword">if</span> !equal(x.Index(i), y.Index(i), seen) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-comment">// ...struct and map cases omitted for brevity...</span>&#125;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;unreachable&quot;</span>)&#125;</code></pre></li><li><p>和前面的建议一样，我们并不公开reflect包相关的接口，所以导出的函数需要在内部自己将变量转为reflect.Value类型。</p><pre><code class="hljs Go"><span class="hljs-comment">// Equal reports whether x and y are deeply equal.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Equal</span><span class="hljs-params">(x, y <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span> &#123;seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[comparison]<span class="hljs-keyword">bool</span>)<span class="hljs-keyword">return</span> equal(reflect.ValueOf(x), reflect.ValueOf(y), seen)&#125;<span class="hljs-keyword">type</span> comparison <span class="hljs-keyword">struct</span> &#123;x, y unsafe.Pointertreflect.Type&#125;</code></pre></li><li><p>为了确保算法对于有环的数据结构也能正常退出，我们必须记录每次已经比较的变量，从而避免进入第二次的比较。Equal函数分配了一组用于比较的结构体，包含每对比较对象的地址（unsafe.Pointer形式保存）和类型。我们要记录类型的原因是，有些不同的变量可能对应相同的地址。例如，如果x和y都是数组类型，那么x和x[0]将对应相同的地址，y和y[0]也是对应相同的地址，这可以用于区分x与y之间的比较或x[0]与y[0]之间的比较是否进行过了。</p><pre><code class="hljs Go"><span class="hljs-comment">// cycle check</span><span class="hljs-keyword">if</span> x.CanAddr() &amp;&amp; y.CanAddr() &#123;xptr := unsafe.Pointer(x.UnsafeAddr())yptr := unsafe.Pointer(y.UnsafeAddr())<span class="hljs-keyword">if</span> xptr == yptr &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// identical references</span>&#125;c := comparison&#123;xptr, yptr, x.Type()&#125;<span class="hljs-keyword">if</span> seen[c] &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span> <span class="hljs-comment">// already seen</span>&#125;seen[c] = <span class="hljs-literal">true</span>&#125;</code></pre></li><li><p>这是Equal函数用法的例子:</p><pre><code class="hljs Go">fmt.Println(Equal([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;))        <span class="hljs-comment">// &quot;true&quot;</span>fmt.Println(Equal([]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;foo&quot;</span>&#125;, []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;bar&quot;</span>&#125;))      <span class="hljs-comment">// &quot;false&quot;</span>fmt.Println(Equal([]<span class="hljs-keyword">string</span>(<span class="hljs-literal">nil</span>), []<span class="hljs-keyword">string</span>&#123;&#125;))             <span class="hljs-comment">// &quot;true&quot;</span>fmt.Println(Equal(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>(<span class="hljs-literal">nil</span>), <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;&#125;)) <span class="hljs-comment">// &quot;true&quot;</span></code></pre></li><li><p>Equal函数甚至可以处理类似12.3章中导致Display陷入死循环的带有环的数据。</p><pre><code class="hljs Go"><span class="hljs-comment">// Circular linked lists a -&gt; b -&gt; a and c -&gt; c.</span><span class="hljs-keyword">type</span> link <span class="hljs-keyword">struct</span> &#123;value <span class="hljs-keyword">string</span>tail *link&#125;a, b, c := &amp;link&#123;value: <span class="hljs-string">&quot;a&quot;</span>&#125;, &amp;link&#123;value: <span class="hljs-string">&quot;b&quot;</span>&#125;, &amp;link&#123;value: <span class="hljs-string">&quot;c&quot;</span>&#125;a.tail, b.tail, c.tail = b, a, cfmt.Println(Equal(a, a)) <span class="hljs-comment">// &quot;true&quot;</span>fmt.Println(Equal(b, b)) <span class="hljs-comment">// &quot;true&quot;</span>fmt.Println(Equal(c, c)) <span class="hljs-comment">// &quot;true&quot;</span>fmt.Println(Equal(a, b)) <span class="hljs-comment">// &quot;false&quot;</span>fmt.Println(Equal(a, c)) <span class="hljs-comment">// &quot;false&quot;</span></code></pre></li></ul><h3 id="ch13-4-通过cgo调用C代码"><a href="#ch13-4-通过cgo调用C代码" class="headerlink" title="ch13.4  通过cgo调用C代码"></a>ch13.4  通过cgo调用C代码</h3><ul><li><p>Go程序可能会遇到要访问C语言的某些硬件驱动函数的场景，或者是从一个C++语言实现的嵌入式数据库查询记录的场景，或者是使用Fortran语言实现的一些线性代数库的场景。C语言作为一个通用语言，很多库会选择提供一个C兼容的API，然后用其他不同的编程语言实现（译者：Go语言需要也应该拥抱这些巨大的代码遗产）。</p></li><li><p>在本节中，我们将构建一个简易的数据压缩程序，使用了一个Go语言自带的叫cgo的用于支援C语言函数调用的工具。这类工具一般被称为 <em>foreign-function interfaces</em> （简称ffi），并且在类似工具中cgo也不是唯一的。SWIG（<a href="http://swig.org/">http://swig.org</a>）是另一个类似的且被广泛使用的工具，SWIG提供了很多复杂特性以支援C++的特性，但SWIG并不是我们要讨论的主题。</p></li><li><p>在标准库的<code>compress/...</code>子包有很多流行的压缩算法的编码和解码实现，包括流行的LZW压缩算法（Unix的compress命令用的算法）和DEFLATE压缩算法（GNU gzip命令用的算法）。这些包的API的细节虽然有些差异，但是它们都提供了针对 io.Writer类型输出的压缩接口和提供了针对io.Reader类型输入的解压缩接口。例如：</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> gzip <span class="hljs-comment">// compress/gzip</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewWriter</span><span class="hljs-params">(w io.Writer)</span> <span class="hljs-title">io</span>.<span class="hljs-title">WriteCloser</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewReader</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(io.ReadCloser, error)</span></span></code></pre></li><li><p>bzip2压缩算法，是基于优雅的Burrows-Wheeler变换算法，运行速度比gzip要慢，但是可以提供更高的压缩比。标准库的compress/bzip2包目前还没有提供bzip2压缩算法的实现。完全从头开始实现一个压缩算法是一件繁琐的工作，而且 <a href="http://bzip.org/">http://bzip.org</a> 已经有现成的libbzip2的开源实现，不仅文档齐全而且性能又好。</p></li><li><p>如果是比较小的C语言库，我们完全可以用纯Go语言重新实现一遍。如果我们对性能也没有特殊要求的话，我们还可以用os/exec包的方法将C编写的应用程序作为一个子进程运行。只有当你需要使用复杂而且性能更高的底层C接口时，就是使用cgo的场景了（译注：用os/exec包调用子进程的方法会导致程序运行时依赖那个应用程序）。下面我们将通过一个例子讲述cgo的具体用法。</p></li><li><p>译注：本章采用的代码都是最新的。因为之前已经出版的书中包含的代码只能在Go1.5之前使用。从Go1.6开始，Go语言已经明确规定了哪些Go语言指针可以直接传入C语言函数。新代码重点是增加了bz2alloc和bz2free的两个函数，用于bz_stream对象空间的申请和释放操作。下面是新代码中增加的注释，说明这个问题：</p><pre><code class="hljs Go"><span class="hljs-comment">// The version of this program that appeared in the first and second</span><span class="hljs-comment">// printings did not comply with the proposed rules for passing</span><span class="hljs-comment">// pointers between Go and C, described here:</span><span class="hljs-comment">// https://github.com/golang/proposal/blob/master/design/12416-cgo-pointers.md</span><span class="hljs-comment">//</span><span class="hljs-comment">// The rules forbid a C function like bz2compress from storing &#x27;in&#x27;</span><span class="hljs-comment">// and &#x27;out&#x27; (pointers to variables allocated by Go) into the Go</span><span class="hljs-comment">// variable &#x27;s&#x27;, even temporarily.</span><span class="hljs-comment">//</span><span class="hljs-comment">// The version below, which appears in the third printing, has been</span><span class="hljs-comment">// corrected.  To comply with the rules, the bz_stream variable must</span><span class="hljs-comment">// be allocated by C code.  We have introduced two C functions,</span><span class="hljs-comment">// bz2alloc and bz2free, to allocate and free instances of the</span><span class="hljs-comment">// bz_stream type.  Also, we have changed bz2compress so that before</span><span class="hljs-comment">// it returns, it clears the fields of the bz_stream that contain</span><span class="hljs-comment">// pointers to Go variables.</span></code></pre></li><li><p>要使用libbzip2，我们需要先构建一个bz_stream结构体，用于保持输入和输出缓存。然后有三个函数：BZ2_bzCompressInit用于初始化缓存，BZ2_bzCompress用于将输入缓存的数据压缩到输出缓存，BZ2_bzCompressEnd用于释放不需要的缓存。（目前不要担心包的具体结构，这个例子的目的就是演示各个部分如何组合在一起的。）</p></li><li><p>我们可以在Go代码中直接调用BZ2_bzCompressInit和BZ2_bzCompressEnd，但是对于BZ2_bzCompress，我们将定义一个C语言的包装函数，用它完成真正的工作。下面是C代码，对应一个独立的文件。</p><p><u><i>gopl.io/ch13/bzip</i></u></p><pre><code class="hljs C"><span class="hljs-comment">/* This file is gopl.io/ch13/bzip/bzip2.c,         */</span><span class="hljs-comment">/* a simple wrapper for libbzip2 suitable for cgo. */</span>[[include]] &lt;bzlib.h&gt;<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">bz2compress</span><span class="hljs-params">(bz_stream *s, <span class="hljs-keyword">int</span> action,</span></span><span class="hljs-function"><span class="hljs-params">                <span class="hljs-keyword">char</span> *in, <span class="hljs-keyword">unsigned</span> *inlen, <span class="hljs-keyword">char</span> *out, <span class="hljs-keyword">unsigned</span> *outlen)</span> </span>&#123;s-&gt;next_in = in;s-&gt;avail_in = *inlen;s-&gt;next_out = out;s-&gt;avail_out = *outlen;<span class="hljs-keyword">int</span> r = BZ2_bzCompress(s, action);*inlen -= s-&gt;avail_in;*outlen -= s-&gt;avail_out;s-&gt;next_in = s-&gt;next_out = <span class="hljs-literal">NULL</span>;<span class="hljs-keyword">return</span> r;&#125;</code></pre></li><li><p>现在让我们转到Go语言部分，第一部分如下所示。其中<code>import &quot;C&quot;</code>的语句是比较特别的。其实并没有一个叫C的包，但是这行语句会让Go编译程序在编译之前先运行cgo工具。</p><pre><code class="hljs Go"><span class="hljs-comment">// Package bzip provides a writer that uses bzip2 compression (bzip.org).</span><span class="hljs-keyword">package</span> bzip<span class="hljs-comment">/*</span><span class="hljs-comment">[[cgo]] CFLAGS: -I/usr/include</span><span class="hljs-comment">[[cgo]] LDFLAGS: -L/usr/lib -lbz2</span><span class="hljs-comment">[[include]] &lt;bzlib.h&gt;</span><span class="hljs-comment">[[include]] &lt;stdlib.h&gt;</span><span class="hljs-comment">bz_stream* bz2alloc() &#123; return calloc(1, sizeof(bz_stream)); &#125;</span><span class="hljs-comment">int bz2compress(bz_stream *s, int action,</span><span class="hljs-comment">                char *in, unsigned *inlen, char *out, unsigned *outlen);</span><span class="hljs-comment">void bz2free(bz_stream* s) &#123; free(s); &#125;</span><span class="hljs-comment">*/</span><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;C&quot;</span><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;unsafe&quot;</span>)<span class="hljs-keyword">type</span> writer <span class="hljs-keyword">struct</span> &#123;w      io.Writer <span class="hljs-comment">// underlying output stream</span>stream *C.bz_streamoutbuf [<span class="hljs-number">64</span> * <span class="hljs-number">1024</span>]<span class="hljs-keyword">byte</span>&#125;<span class="hljs-comment">// NewWriter returns a writer for bzip2-compressed streams.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewWriter</span><span class="hljs-params">(out io.Writer)</span> <span class="hljs-title">io</span>.<span class="hljs-title">WriteCloser</span></span> &#123;<span class="hljs-keyword">const</span> blockSize = <span class="hljs-number">9</span><span class="hljs-keyword">const</span> verbosity = <span class="hljs-number">0</span><span class="hljs-keyword">const</span> workFactor = <span class="hljs-number">30</span>w := &amp;writer&#123;w: out, stream: C.bz2alloc()&#125;C.BZ2_bzCompressInit(w.stream, blockSize, verbosity, workFactor)<span class="hljs-keyword">return</span> w&#125;</code></pre></li><li><p>在预处理过程中，cgo工具生成一个临时包用于包含所有在Go语言中访问的C语言的函数或类型。例如C.bz_stream和C.BZ2_bzCompressInit。cgo工具通过以某种特殊的方式调用本地的C编译器来发现在Go源文件导入声明前的注释中包含的C头文件中的内容（译注：<code>import &quot;C&quot;</code>语句前紧挨着的注释是对应cgo的特殊语法，对应必要的构建参数选项和C语言代码）。</p></li><li><p>在cgo注释中还可以包含[[cgo指令，用于给C语言工具链指定特殊的参数。例如CFLAGS和LDFLAGS分别对应传给C语言编译器的编译参数和链接器参数，使它们可以从特定目录找到bzlib]].h头文件和libbz2.a库文件。这个例子假设你已经在/usr目录成功安装了bzip2库。如果bzip2库是安装在不同的位置，你需要更新这些参数（译注：这里有一个从纯C代码生成的cgo绑定，不依赖bzip2静态库和操作系统的具体环境，具体请访问 <a href="https://github.com/chai2010/bzip2">https://github.com/chai2010/bzip2</a> ）。</p></li><li><p>NewWriter函数通过调用C语言的BZ2_bzCompressInit函数来初始化stream中的缓存。在writer结构中还包括了另一个buffer，用于输出缓存。</p></li><li><p>下面是Write方法的实现，返回成功压缩数据的大小，主体是一个循环中调用C语言的bz2compress函数实现的。从代码可以看到，Go程序可以访问C语言的bz_stream、char和uint类型，还可以访问bz2compress等函数，甚至可以访问C语言中像BZ_RUN那样的宏定义，全部都是以C.x语法访问。其中C.uint类型和Go语言的uint类型并不相同，即使它们具有相同的大小也是不同的类型。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *writer)</span> <span class="hljs-title">Write</span><span class="hljs-params">(data []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<span class="hljs-keyword">if</span> w.stream == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;closed&quot;</span>)&#125;<span class="hljs-keyword">var</span> total <span class="hljs-keyword">int</span> <span class="hljs-comment">// uncompressed bytes written</span><span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(data) &gt; <span class="hljs-number">0</span> &#123;inlen, outlen := C.<span class="hljs-keyword">uint</span>(<span class="hljs-built_in">len</span>(data)), C.<span class="hljs-keyword">uint</span>(<span class="hljs-built_in">cap</span>(w.outbuf))C.bz2compress(w.stream, C.BZ_RUN,(*C.char)(unsafe.Pointer(&amp;data[<span class="hljs-number">0</span>])), &amp;inlen,(*C.char)(unsafe.Pointer(&amp;w.outbuf)), &amp;outlen)total += <span class="hljs-keyword">int</span>(inlen)data = data[inlen:]<span class="hljs-keyword">if</span> _, err := w.w.Write(w.outbuf[:outlen]); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> total, err&#125;&#125;<span class="hljs-keyword">return</span> total, <span class="hljs-literal">nil</span>&#125;</code></pre></li><li><p>在循环的每次迭代中，向bz2compress传入数据的地址和剩余部分的长度，还有输出缓存w.outbuf的地址和容量。这两个长度信息通过它们的地址传入而不是值传入，因为bz2compress函数可能会根据已经压缩的数据和压缩后数据的大小来更新这两个值。每个块压缩后的数据被写入到底层的io.Writer。</p></li><li><p>Close方法和Write方法有着类似的结构，通过一个循环将剩余的压缩数据刷新到输出缓存。</p><pre><code class="hljs Go"><span class="hljs-comment">// Close flushes the compressed data and closes the stream.</span><span class="hljs-comment">// It does not close the underlying io.Writer.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(w *writer)</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> w.stream == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;closed&quot;</span>)&#125;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;C.BZ2_bzCompressEnd(w.stream)C.bz2free(w.stream)w.stream = <span class="hljs-literal">nil</span>&#125;()<span class="hljs-keyword">for</span> &#123;inlen, outlen := C.<span class="hljs-keyword">uint</span>(<span class="hljs-number">0</span>), C.<span class="hljs-keyword">uint</span>(<span class="hljs-built_in">cap</span>(w.outbuf))r := C.bz2compress(w.stream, C.BZ_FINISH, <span class="hljs-literal">nil</span>, &amp;inlen,(*C.char)(unsafe.Pointer(&amp;w.outbuf)), &amp;outlen)<span class="hljs-keyword">if</span> _, err := w.w.Write(w.outbuf[:outlen]); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">if</span> r == C.BZ_STREAM_END &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;&#125;&#125;</code></pre></li><li><p>压缩完成后，Close方法用了defer函数确保函数退出前调用C.BZ2_bzCompressEnd和C.bz2free释放相关的C语言运行时资源。此刻w.stream指针将不再有效，我们将它设置为nil以保证安全，然后在每个方法中增加了nil检测，以防止用户在关闭后依然错误使用相关方法。</p></li><li><p>上面的实现中，不仅仅写是非并发安全的，甚至并发调用Close和Write方法也可能导致程序的的崩溃。修复这个问题是练习13.3的内容。</p></li><li><p>下面的bzipper程序，使用我们自己包实现的bzip2压缩命令。它的行为和许多Unix系统的bzip2命令类似。</p><p><u><i>gopl.io/ch13/bzipper</i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// Bzipper reads input, bzip2-compresses it, and writes it out.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;gopl.io/ch13/bzip&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;w := bzip.NewWriter(os.Stdout)<span class="hljs-keyword">if</span> _, err := io.Copy(w, os.Stdin); err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;bzipper: %v\n&quot;</span>, err)&#125;<span class="hljs-keyword">if</span> err := w.Close(); err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;bzipper: close: %v\n&quot;</span>, err)&#125;&#125;</code></pre></li><li><p>在上面的场景中，我们使用bzipper压缩了/usr/share/dict/words系统自带的词典，从938,848字节压缩到335,405字节。大约是原始数据大小的三分之一。然后使用系统自带的bunzip2命令进行解压。压缩前后文件的SHA256哈希码是相同了，这也说明了我们的压缩工具是正确的。（如果你的系统没有sha256sum命令，那么请先按照练习4.2实现一个类似的工具）</p><pre><code class="hljs awk">$ go build gopl.io<span class="hljs-regexp">/ch13/</span>bzipper$ wc -c &lt; <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/dict/</span>words<span class="hljs-number">938848</span>$ sha256sum &lt; <span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/dict/</span>words<span class="hljs-number">126</span>a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed -$ .<span class="hljs-regexp">/bzipper &lt; /u</span>sr<span class="hljs-regexp">/share/</span>dict/words | wc -c<span class="hljs-number">335405</span>$ .<span class="hljs-regexp">/bzipper &lt; /u</span>sr<span class="hljs-regexp">/share/</span>dict/words | bunzip2 | sha256sum<span class="hljs-number">126</span>a4ef38493313edc50b86f90dfdaf7c59ec6c948451eac228f2f3a8ab1a6ed -</code></pre></li><li><p>我们演示了如何将一个C语言库链接到Go语言程序。相反，将Go编译为静态库然后链接到C程序，或者将Go程序编译为动态库然后在C程序中动态加载也都是可行的（译注：在Go1.5中，Windows系统的Go语言实现并不支持生成C语言动态库或静态库的特性。不过好消息是，目前已经有人在尝试解决这个问题，具体请访问 <a href="https://github.com/golang/go/issues/11058">Issue11058</a> ）。这里我们只展示的cgo很小的一些方面，更多的关于内存管理、指针、回调函数、中断信号处理、字符串、errno处理、终结器，以及goroutines和系统线程的关系等，有很多细节可以讨论。特别是如何将Go语言的指针传入C函数的规则也是异常复杂的（译注：简单来说，要传入C函数的Go指针指向的数据本身不能包含指针或其他引用类型；并且C函数在返回后不能继续持有Go指针；并且在C函数返回之前，Go指针是被锁定的，不能导致对应指针数据被移动或栈的调整），部分的原因在13.2节有讨论到，但是在Go1.5中还没有被明确（译注：Go1.6将会明确cgo中的指针使用规则）。如果要进一步阅读，可以从 <a href="https://golang.org/cmd/cgo">https://golang.org/cmd/cgo</a> 开始。</p></li></ul><h3 id="ch13-5-几点忠告"><a href="#ch13-5-几点忠告" class="headerlink" title="ch13.5  几点忠告"></a>ch13.5  几点忠告</h3><ul><li>我们在前一章结尾的时候，我们警告要谨慎使用reflect包。那些警告同样适用于本章的unsafe包。</li><li>高级语言使得程序员不用再关心真正运行程序的指令细节，同时也不再需要关注许多如内存布局之类的实现细节。因为高级语言这个绝缘的抽象层，我们可以编写安全健壮的，并且可以运行在不同操作系统上的具有高度可移植性的程序。</li><li>但是unsafe包，它让程序员可以透过这个绝缘的抽象层直接使用一些必要的功能，虽然可能是为了获得更好的性能。但是代价就是牺牲了可移植性和程序安全，因此使用unsafe包是一个危险的行为。我们对何时以及如何使用unsafe包的建议和我们在11.5节提到的Knuth对过早优化的建议类似。大多数Go程序员可能永远不会需要直接使用unsafe包。当然，也永远都会有一些需要使用unsafe包实现会更简单的场景。如果确实认为使用unsafe包是最理想的方式，那么应该尽可能将它限制在较小的范围，这样其它代码就可以忽略unsafe的影响。</li><li>现在，赶紧将最后两章抛入脑后吧。编写一些实实在在的应用是真理。请远离reflect和unsafe包，除非你确实需要它们。</li><li>最后，用Go快乐地编程。我们希望你能像我们一样喜欢Go语言。</li></ul><p><em>XMind: ZEN - Trial Version</em></p>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Go Programming Language（9）</title>
    <link href="/2020/11/23/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%889%EF%BC%89/"/>
    <url>/2020/11/23/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%889%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="The-Go-Programming-Language（9"><a href="#The-Go-Programming-Language（9" class="headerlink" title="The Go Programming Language（9)"></a>The Go Programming Language（9)</h1><h3 id="源码、PDF版、Markdown、xmind版下载链接"><a href="#源码、PDF版、Markdown、xmind版下载链接" class="headerlink" title="源码、PDF版、Markdown、xmind版下载链接"></a>源码、PDF版、Markdown、xmind版下载链接</h3><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://<span class="hljs-number">1</span>tnt<span class="hljs-number">1</span>.lanzous.com/b<span class="hljs-number">00</span>o<span class="hljs-number">36</span>ytc</code></pre><p>密码：</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span>ch0</code></pre><hr><h2 id="ch9-基于共享变量的并发"><a href="#ch9-基于共享变量的并发" class="headerlink" title="ch9  基于共享变量的并发"></a>ch9  基于共享变量的并发</h2><h3 id="ch9-0-简介"><a href="#ch9-0-简介" class="headerlink" title="ch9.0   简介"></a>ch9.0   简介</h3><ul><li>前一章我们介绍了一些使用goroutine和channel这样直接而自然的方式来实现并发的方法。然而这样做我们实际上回避了在写并发代码时必须处理的一些重要而且细微的问题。</li><li>在本章中，我们会细致地了解并发机制。尤其是在多goroutine之间的共享变量，并发问题的分析手段，以及解决这些问题的基本模式。最后我们会解释goroutine和操作系统线程之间的技术上的一些区别。</li></ul><h3 id="ch9-1-竞争条件"><a href="#ch9-1-竞争条件" class="headerlink" title="ch9.1   竞争条件"></a>ch9.1   竞争条件</h3><ul><li><p>数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生。</p></li><li><p>在一个线性（就是说只有一个goroutine的）的程序中，程序的执行顺序只由程序的逻辑来决定。</p><ul><li>例如，我们有一段语句序列，第一个在第二个之前，以此类推。在有两个或更多goroutine的程序中，每一个goroutine内的语句也是按照既定的顺序去执行的，但是一般情况下我们没法去知道分别位于两个goroutine的事件x和y的执行顺序，x是在y之前还是之后还是同时发生是没法判断的。当我们没有办法自信地确认一个事件是在另一个事件的前面或者后面发生的话，就说明x和y这两个事件是并发的。</li></ul></li><li><p>考虑一下，一个函数在线性程序中可以正确地工作。如果在并发的情况下，这个函数依然可以正确地工作的话，那么我们就说这个函数是并发安全的，并发安全的函数不需要额外的同步工作。我们可以把这个概念概括为一个特定类型的一些方法和操作函数，对于某个类型来说，如果其所有可访问的方法和操作都是并发安全的话，那么该类型便是并发安全的。</p></li><li><p>在一个程序中有非并发安全的类型的情况下，我们依然可以使这个程序并发安全。确实，并发安全的类型是例外，而不是规则，所以只有当文档中明确地说明了其是并发安全的情况下，你才可以并发地去访问它。</p></li><li><p>我们会避免并发访问大多数的类型，无论是将变量局限在单一的一个goroutine内，还是用互斥条件维持更高级别的不变性，都是为了这个目的。我们会在本章中说明这些术语。</p></li><li><p>相反，包级别的导出函数一般情况下都是并发安全的。由于package级的变量没法被限制在单一的gorouine，所以修改这些变量“必须”使用互斥条件。</p></li><li><p>一个函数在并发调用时没法工作的原因太多了，比如死锁（deadlock）、活锁（livelock）和饿死（resource starvation）。我们没有空去讨论所有的问题，这里我们只聚焦在竞争条件上。</p></li><li><p>竞争条件指的是程序在多个goroutine交叉执行操作时，没有给出正确的结果。竞争条件是很恶劣的一种场景，因为这种问题会一直潜伏在你的程序里，然后在非常少见的时候蹦出来，或许只是会在很大的负载时才会发生，又或许是会在使用了某一个编译器、某一种平台或者某一种架构的时候才会出现。这些使得竞争条件带来的问题非常难以复现而且难以分析诊断。</p></li><li><p>传统上经常用经济损失来为竞争条件做比喻，所以我们来看一个简单的银行账户程序。</p><pre><code class="hljs go"><span class="hljs-comment">// Package bank implements a bank with only one account.</span><span class="hljs-keyword">package</span> bank<span class="hljs-keyword">var</span> balance <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123; balance = balance + amount &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> balance &#125;</code></pre></li><li><p>当然我们也可以把Deposit存款函数写成balance += amount，这种形式也是等价的，不过长一些的形式解释起来更方便一些。</p></li><li><p>对于这个简单的程序而言，我们一眼就能看出，以任意顺序调用函数Deposit和Balance都会得到正确的结果。也就是说，Balance函数会给出之前的所有存入的额度之和。然而，当我们并发地而不是顺序地调用这些函数的话，Balance就再也没办法保证结果正确了。考虑一下下面的两个goroutine，其代表了一个银行联合账户的两笔交易：</p><pre><code class="hljs go"><span class="hljs-comment">// Alice:</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;bank.Deposit(<span class="hljs-number">200</span>)                <span class="hljs-comment">// A1</span>fmt.Println(<span class="hljs-string">&quot;=&quot;</span>, bank.Balance()) <span class="hljs-comment">// A2</span>&#125;()<span class="hljs-comment">// Bob:</span><span class="hljs-keyword">go</span> bank.Deposit(<span class="hljs-number">100</span>)                 <span class="hljs-comment">// B</span></code></pre><ul><li><p>Alice存了$200，然后检查她的余额，同时Bob存了$100。因为A1和A2是和B并发执行的，我们没法预测他们发生的先后顺序。直观地来看的话，我们会认为其执行顺序只有三种可能性：“Alice先”，“Bob先”以及“Alice/Bob/Alice”交错执行。下面的表格会展示经过每一步骤后balance变量的值。引号里的字符串表示余额单。</p><pre><code class="hljs apache"><span class="hljs-attribute">Alice</span> first        Bob first        Alice/Bob/Alice          <span class="hljs-attribute">0</span>                <span class="hljs-number">0</span>                      <span class="hljs-number">0</span>  <span class="hljs-attribute">A1</span>    <span class="hljs-number">200</span>        B     <span class="hljs-number">100</span>             A<span class="hljs-number">1</span>     <span class="hljs-number">200</span>  <span class="hljs-attribute">A2</span> <span class="hljs-string">&quot;= 200&quot;</span>       A<span class="hljs-number">1</span>    <span class="hljs-number">300</span>             B      <span class="hljs-number">300</span>  <span class="hljs-attribute">B</span>     <span class="hljs-number">300</span>        A<span class="hljs-number">2</span> <span class="hljs-string">&quot;= 300&quot;</span>            A<span class="hljs-number">2</span>  <span class="hljs-string">&quot;= 300&quot;</span></code></pre></li><li><p>所有情况下最终的余额都是$300。唯一的变数是Alice的余额单是否包含了Bob交易，不过无论怎么着客户都不会在意。</p></li><li><p>但是事实是上面的直觉推断是错误的。第四种可能的结果是事实存在的，这种情况下Bob的存款会在Alice存款操作中间，在余额被读到（balance + amount）之后，在余额被更新之前（balance = …），这样会导致Bob的交易丢失。而这是因为Alice的存款操作A1实际上是两个操作的一个序列，读取然后写；可以称之为A1r和A1w。下面是交叉时产生的问题：</p><pre><code class="hljs lsl">Data race<span class="hljs-number">0</span>A1r      <span class="hljs-number">0</span>     ... = balance + amountB      <span class="hljs-number">100</span>A1w    <span class="hljs-number">200</span>     balance = ...A2  <span class="hljs-string">&quot;= 200&quot;</span></code></pre><ul><li><p>在A1r之后，balance + amount会被计算为200，所以这是A1w会写入的值，并不受其它存款操作的干预。最终的余额是$200。银行的账户上的资产比Bob实际的资产多了$100。</p><ul><li>译注：因为丢失了Bob的存款操作，所以其实是说Bob的钱丢了。</li></ul></li></ul></li></ul></li><li><p>这个程序包含了一个特定的竞争条件，叫作数据竞争。无论任何时候，只要有两个goroutine并发访问同一变量，且至少其中的一个是写操作的时候就会发生数据竞争。</p></li><li><p>如果数据竞争的对象是一个比一个机器字（译注：32位机器上一个字=4个字节）更大的类型时，事情就变得更麻烦了，比如interface，string或者slice类型都是如此。下面的代码会并发地更新两个不同长度的slice：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> x []<span class="hljs-keyword">int</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; x = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>) &#125;()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; x = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">1000000</span>) &#125;()x[<span class="hljs-number">999999</span>] = <span class="hljs-number">1</span> <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> undefined behavior; memory corruption possible!</span></code></pre><ul><li>最后一个语句中的x的值是未定义的；其可能是nil，或者也可能是一个长度为10的slice，也可能是一个长度为1,000,000的slice。</li><li>但是回忆一下slice的三个组成部分：指针（pointer）、长度（length）和容量（capacity）。如果指针是从第一个make调用来，而长度从第二个make来，x就变成了一个混合体，一个自称长度为1,000,000但实际上内部只有10个元素的slice。这样导致的结果是存储999,999元素的位置会碰撞一个遥远的内存位置，这种情况下难以对值进行预测，而且debug也会变成噩梦。</li><li>这种语义雷区被称为未定义行为，对C程序员来说应该很熟悉；幸运的是在Go语言里造成的麻烦要比C里小得多。</li></ul></li><li><p>尽管并发程序的概念让我们知道并发并不是简单的语句交叉执行。我们将会在9.4节中看到，数据竞争可能会有奇怪的结果。许多程序员，甚至一些非常聪明的人也还是会偶尔提出一些理由来允许数据竞争，比如：“互斥条件代价太高”，“这个逻辑只是用来做logging”，“我不介意丢失一些消息”等等。因为在他们的编译器或者平台上很少遇到问题，可能给了他们错误的信心。一个好的经验法则是根本就没有什么所谓的良性数据竞争。所以我们一定要避免数据竞争，那么在我们的程序中要如何做到呢？</p></li><li><p>我们来重复一下数据竞争的定义，因为实在太重要了：数据竞争会在两个以上的goroutine并发访问相同的变量且至少其中一个为写操作时发生。根据上述定义，有三种方式可以避免数据竞争：</p><ul><li><p>第一种方法是不要去写变量。考虑一下下面的map，会被“懒”填充，也就是说在每个key被第一次请求到的时候才会去填值。如果Icon是被顺序调用的话，这个程序会工作很正常，但如果Icon被并发调用，那么对于这个map来说就会存在数据竞争。</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> icons = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]image.Image)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadIcon</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">image</span>.<span class="hljs-title">Image</span></span><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> not concurrency-safe!</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Icon</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">image</span>.<span class="hljs-title">Image</span></span> &#123;icon, ok := icons[name]<span class="hljs-keyword">if</span> !ok &#123;icon = loadIcon(name)icons[name] = icon&#125;<span class="hljs-keyword">return</span> icon&#125;</code></pre><ul><li><p>反之，如果我们在创建goroutine之前的初始化阶段，就初始化了map中的所有条目并且再也不去修改它们，那么任意数量的goroutine并发访问Icon都是安全的，因为每一个goroutine都只是去读取而已。</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> icons = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]image.Image&#123;<span class="hljs-string">&quot;spades.png&quot;</span>:   loadIcon(<span class="hljs-string">&quot;spades.png&quot;</span>),<span class="hljs-string">&quot;hearts.png&quot;</span>:   loadIcon(<span class="hljs-string">&quot;hearts.png&quot;</span>),<span class="hljs-string">&quot;diamonds.png&quot;</span>: loadIcon(<span class="hljs-string">&quot;diamonds.png&quot;</span>),<span class="hljs-string">&quot;clubs.png&quot;</span>:    loadIcon(<span class="hljs-string">&quot;clubs.png&quot;</span>),&#125;<span class="hljs-comment">// Concurrency-safe.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Icon</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">image</span>.<span class="hljs-title">Image</span></span> &#123; <span class="hljs-keyword">return</span> icons[name] &#125;</code></pre></li><li><p>上面的例子里icons变量在包初始化阶段就已经被赋值了，包的初始化是在程序main函数开始执行之前就完成了的。只要初始化完成了，icons就再也不会被修改。数据结构如果从不被修改或是不变量则是并发安全的，无需进行同步。不过显然，如果update操作是必要的，我们就没法用这种方法，比如说银行账户。</p></li></ul></li><li><p>第二种避免数据竞争的方法是，避免从多个goroutine访问变量。这也是前一章中大多数程序所采用的方法。例如前面的并发web爬虫（§8.6）的main goroutine是唯一一个能够访问seen map的goroutine，而聊天服务器（§8.10）中的broadcaster goroutine是唯一一个能够访问clients map的goroutine。这些变量都被限定在了一个单独的goroutine中。</p><ul><li><p>由于其它的goroutine不能够直接访问变量，它们只能使用一个channel来发送请求给指定的goroutine来查询更新变量。这也就是Go的口头禅“不要使用共享数据来通信；使用通信来共享数据”。一个提供对一个指定的变量通过channel来请求的goroutine叫做这个变量的monitor（监控）goroutine。例如broadcaster goroutine会监控clients map的全部访问。</p></li><li><p>下面是一个重写了的银行的例子，这个例子中balance变量被限制在了monitor goroutine中，名为teller：</p><p><u><i>gopl.io/ch9/bank1</i></u></p><pre><code class="hljs go"><span class="hljs-comment">// Package bank provides a concurrency-safe bank with one account.</span><span class="hljs-keyword">package</span> bank<span class="hljs-keyword">var</span> deposits = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>) <span class="hljs-comment">// send amount to deposit</span><span class="hljs-keyword">var</span> balances = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>) <span class="hljs-comment">// receive balance</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123; deposits &lt;- amount &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span>       &#123; <span class="hljs-keyword">return</span> &lt;-balances &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">teller</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> balance <span class="hljs-keyword">int</span> <span class="hljs-comment">// balance is confined to teller goroutine</span><span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> amount := &lt;-deposits:balance += amount<span class="hljs-keyword">case</span> balances &lt;- balance:&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">go</span> teller() <span class="hljs-comment">// start the monitor goroutine</span>&#125;</code></pre></li><li><p>即使当一个变量无法在其整个生命周期内被绑定到一个独立的goroutine，绑定依然是并发问题的一个解决方案。</p></li><li><p>例如在一条流水线上的goroutine之间共享变量是很普遍的行为，在这两者间会通过channel来传输地址信息。如果流水线的每一个阶段都能够避免在将变量传送到下一阶段后再去访问它，那么对这个变量的所有访问就是线性的。其效果是变量会被绑定到流水线的一个阶段，传送完之后被绑定到下一个，以此类推。这种规则有时被称为串行绑定。</p></li><li><p>下面的例子中，Cakes会被严格地顺序访问，先是baker gorouine，然后是icer gorouine：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Cake <span class="hljs-keyword">struct</span>&#123; state <span class="hljs-keyword">string</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">baker</span><span class="hljs-params">(cooked <span class="hljs-keyword">chan</span>&lt;- *Cake)</span></span> &#123;<span class="hljs-keyword">for</span> &#123;cake := <span class="hljs-built_in">new</span>(Cake)cake.state = <span class="hljs-string">&quot;cooked&quot;</span>cooked &lt;- cake <span class="hljs-comment">// baker never touches this cake again</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">icer</span><span class="hljs-params">(iced <span class="hljs-keyword">chan</span>&lt;- *Cake, cooked &lt;-<span class="hljs-keyword">chan</span> *Cake)</span></span> &#123;<span class="hljs-keyword">for</span> cake := <span class="hljs-keyword">range</span> cooked &#123;cake.state = <span class="hljs-string">&quot;iced&quot;</span>iced &lt;- cake <span class="hljs-comment">// icer never touches this cake again</span>&#125;&#125;</code></pre></li></ul></li><li><p>第三种避免数据竞争的方法是允许很多goroutine去访问变量，但是在同一个时刻最多只有一个goroutine在访问。这种方式被称为“互斥”，在下一节来讨论这个主题。</p></li></ul></li></ul><h3 id="ch9-2-sync-Mutex互斥锁"><a href="#ch9-2-sync-Mutex互斥锁" class="headerlink" title="ch9.2   sync.Mutex互斥锁"></a>ch9.2   sync.Mutex互斥锁</h3><ul><li><p>在8.6节中，我们使用了一个buffered channel作为一个计数信号量，来保证最多只有20个goroutine会同时执行HTTP请求。同理，我们可以用一个容量只有1的channel来保证最多只有一个goroutine在同一时刻访问一个共享变量。一个只能为1和0的信号量叫做二元信号量（binary semaphore）。</p><p><u><i>gopl.io/ch9/bank2</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">var</span> (sema    = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">1</span>) <span class="hljs-comment">// a binary semaphore guarding balance</span>balance <span class="hljs-keyword">int</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123;sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// acquire token</span>balance = balance + amount&lt;-sema <span class="hljs-comment">// release token</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// acquire token</span>b := balance&lt;-sema <span class="hljs-comment">// release token</span><span class="hljs-keyword">return</span> b&#125;</code></pre></li><li><p>这种互斥很实用，而且被sync包里的Mutex类型直接支持。它的Lock方法能够获取到token(这里叫锁)，并且Unlock方法会释放这个token：</p><p><u><i>gopl.io/ch9/bank3</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sync&quot;</span><span class="hljs-keyword">var</span> (mu      sync.Mutex <span class="hljs-comment">// guards balance</span>balance <span class="hljs-keyword">int</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123;mu.Lock()balance = balance + amountmu.Unlock()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;mu.Lock()b := balancemu.Unlock()<span class="hljs-keyword">return</span> b&#125;</code></pre><ul><li>每次一个goroutine访问bank变量时（这里只有balance余额变量），它都会调用mutex的Lock方法来获取一个互斥锁。如果其它的goroutine已经获得了这个锁的话，这个操作会被阻塞直到其它goroutine调用了Unlock使该锁变回可用状态。mutex会保护共享变量。惯例来说，被mutex所保护的变量是在mutex变量声明之后立刻声明的。如果你的做法和惯例不符，确保在文档里对你的做法进行说明。</li><li>在Lock和Unlock之间的代码段中的内容goroutine可以随便读取或者修改，这个代码段叫做临界区。锁的持有者在其他goroutine获取该锁之前需要调用Unlock。goroutine在结束后释放锁是必要的，无论以哪条路径通过函数都需要释放，即使是在错误路径中，也要记得释放。</li></ul></li><li><p>上面的bank程序例证了一种通用的并发模式。一系列的导出函数封装了一个或多个变量，那么访问这些变量唯一的方式就是通过这些函数来做</p></li><li><p>每一个函数在一开始就获取互斥锁并在最后释放锁，从而保证共享变量不会被并发访问。这种函数、互斥锁和变量的编排叫作监控monitor。</p><ul><li>（这种老式单词的monitor是受“monitor goroutine”的术语启发而来的。两种用法都是一个代理人保证变量被顺序访问）</li></ul></li><li><p>由于在存款和查询余额函数中的临界区代码这么短——只有一行，没有分支调用——在代码最后去调用Unlock就显得更为直截了当。在更复杂的临界区的应用中，尤其是必须要尽早处理错误并返回的情况下，就很难去（靠人）判断对Lock和Unlock的调用是在所有路径中都能够严格配对的了。Go语言里的defer简直就是这种情况下的救星：我们用defer来调用Unlock，临界区会隐式地延伸到函数作用域的最后，这样我们就从“总要记得在函数返回之后或者发生错误返回时要记得调用一次Unlock”这种状态中获得了解放。Go会自动帮我们完成这些事情。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;mu.Lock()<span class="hljs-keyword">defer</span> mu.Unlock()<span class="hljs-keyword">return</span> balance&#125;</code></pre><ul><li>上面的例子里Unlock会在return语句读取完balance的值之后执行，所以Balance函数是并发安全的。这带来的另一点好处是，我们再也不需要一个本地变量b了。</li></ul></li><li><p>此外，一个deferred Unlock即使在临界区发生panic时依然会执行，这对于用recover（§5.10）来恢复的程序来说是很重要的。defer调用只会比显式地调用Unlock成本高那么一点点，不过却在很大程度上保证了代码的整洁性。大多数情况下对于并发程序来说，代码的整洁性比过度的优化更重要。如果可能的话尽量使用defer来将临界区扩展到函数的结束。</p></li><li><p>考虑一下下面的Withdraw函数。成功的时候，它会正确地减掉余额并返回true。但如果银行记录资金对交易来说不足，那么取款就会恢复余额，并返回false。</p><pre><code class="hljs go"><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> not atomic!</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;Deposit(-amount)<span class="hljs-keyword">if</span> Balance() &lt; <span class="hljs-number">0</span> &#123;Deposit(amount)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// insufficient funds</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></li><li><p>函数终于给出了正确的结果，但是还有一点讨厌的副作用。当过多的取款操作同时执行时，balance可能会瞬时被减到0以下。这可能会引起一个并发的取款被不合逻辑地拒绝。所以如果Bob尝试买一辆sports car时，Alice可能就没办法为她的早咖啡付款了。这里的问题是取款不是一个原子操作：它包含了三个步骤，每一步都需要去获取并释放互斥锁，但任何一次锁都不会锁上整个取款流程。</p></li><li><p>理想情况下，取款应该只在整个操作中获得一次互斥锁。下面这样的尝试是错误的：</p><pre><code class="hljs go"><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;mu.Lock()<span class="hljs-keyword">defer</span> mu.Unlock()Deposit(-amount)<span class="hljs-keyword">if</span> Balance() &lt; <span class="hljs-number">0</span> &#123;Deposit(amount)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// insufficient funds</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre><ul><li>上面这个例子中，Deposit会调用mu.Lock()第二次去获取互斥锁，但因为mutex已经锁上了，而无法被重入（译注：go里没有重入锁，关于重入锁的概念，请参考java）——也就是说没法对一个已经锁上的mutex来再次上锁——这会导致程序死锁，没法继续执行下去，Withdraw会永远阻塞下去。</li></ul></li><li><p>关于Go的mutex不能重入这一点我们有很充分的理由。mutex的目的是确保共享变量在程序执行时的关键点上能够保证不变性。不变性的一层含义是“没有goroutine访问共享变量”，但实际上这里对于mutex保护的变量来说，不变性还包含更深层含义：当一个goroutine获得了一个互斥锁时，它能断定被互斥锁保护的变量正处于不变状态（译注：即没有其他代码块正在读写共享变量），在其获取并保持锁期间，可能会去更新共享变量，这样不变性只是短暂地被破坏，然而当其释放锁之后，锁必须保证共享变量重获不变性并且多个goroutine按顺序访问共享变量。尽管一个可以重入的mutex也可以保证没有其它的goroutine在访问共享变量，但它不具备不变性更深层含义。（译注：<a href="https://stackoverflow.com/questions/14670979/recursive-locking-in-go/14671462#14671462">更详细的解释</a>，Russ Cox认为可重入锁是bug的温床，是一个失败的设计）</p></li><li><p>一个通用的解决方案是将一个函数分离为多个函数，比如我们把Deposit分离成两个：一个不导出的函数deposit，这个函数假设锁总是会被保持并去做实际的操作，另一个是导出的函数Deposit，这个函数会调用deposit，但在调用前会先去获取锁。同理我们可以将Withdraw也表示成这种形式：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Withdraw</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;mu.Lock()<span class="hljs-keyword">defer</span> mu.Unlock()deposit(-amount)<span class="hljs-keyword">if</span> balance &lt; <span class="hljs-number">0</span> &#123;deposit(amount)<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment">// insufficient funds</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123;mu.Lock()<span class="hljs-keyword">defer</span> mu.Unlock()deposit(amount)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;mu.Lock()<span class="hljs-keyword">defer</span> mu.Unlock()<span class="hljs-keyword">return</span> balance&#125;<span class="hljs-comment">// This function requires that the lock be held.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">deposit</span><span class="hljs-params">(amount <span class="hljs-keyword">int</span>)</span></span> &#123; balance += amount &#125;</code></pre><ul><li>当然，这里的存款deposit函数很小，实际上取款Withdraw函数不需要理会对它的调用，尽管如此，这里的表达还是表明了规则。</li></ul></li><li><p>封装（§6.6），用限制一个程序中的意外交互的方式，可以使我们获得数据结构的不变性。因为某种原因，封装还帮我们获得了并发的不变性。当你使用mutex时，确保mutex和其保护的变量没有被导出（在go里也就是小写，且不要被大写字母开头的函数访问啦），无论这些变量是包级的变量还是一个struct的字段。</p></li></ul><h3 id="ch9-3-sync-RWMutex读写锁"><a href="#ch9-3-sync-RWMutex读写锁" class="headerlink" title="ch9.3   sync.RWMutex读写锁"></a>ch9.3   sync.RWMutex读写锁</h3><ul><li><p>在100刀的存款消失时不做记录多少还是会让我们有一些恐慌，Bob写了一个程序，每秒运行几百次来检查他的银行余额。他会在家，在工作中，甚至会在他的手机上来运行这个程序。银行注意到这些陡增的流量使得存款和取款有了延时，因为所有的余额查询请求是顺序执行的，这样会互斥地获得锁，并且会暂时阻止其它的goroutine运行。</p></li><li><p>由于Balance函数只需要读取变量的状态，所以我们同时让多个Balance调用并发运行事实上是安全的，只要在运行的时候没有存款或者取款操作就行。在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥。这种锁叫作“多读单写”锁（multiple readers, single writer lock），Go语言提供的这样的锁是sync.RWMutex：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.RWMutex<span class="hljs-keyword">var</span> balance <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Balance</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;mu.RLock() <span class="hljs-comment">// readers lock</span><span class="hljs-keyword">defer</span> mu.RUnlock()<span class="hljs-keyword">return</span> balance&#125;</code></pre><ul><li>Balance函数现在调用了RLock和RUnlock方法来获取和释放一个读取或者共享锁。Deposit函数没有变化，会调用mu.Lock和mu.Unlock方法来获取和释放一个写或互斥锁。</li><li>在这次修改后，Bob的余额查询请求就可以彼此并行地执行并且会很快地完成了。锁在更多的时间范围可用，并且存款请求也能够及时地被响应了。</li></ul></li><li><p>RLock只能在临界区共享变量没有任何写入操作时可用。一般来说，我们不应该假设逻辑上的只读函数/方法也不会去更新某一些变量。比如一个方法功能是访问一个变量，但它也有可能会同时去给一个内部的计数器+1（译注：可能是记录这个方法的访问次数啥的），或者去更新缓存——使即时的调用能够更快。如果有疑惑的话，请使用互斥锁。</p></li><li><p>RWMutex只有当获得锁的大部分goroutine都是读操作，而锁在竞争条件下，也就是说，goroutine们必须等待才能获取到锁的时候，RWMutex才是最能带来好处的。RWMutex需要更复杂的内部记录，所以会让它比一般的无竞争锁的mutex慢一些。</p></li></ul><h3 id="ch9-4-内存同步"><a href="#ch9-4-内存同步" class="headerlink" title="ch9.4   内存同步"></a>ch9.4   内存同步</h3><ul><li><p>你可能比较纠结为什么Balance方法需要用到互斥条件，无论是基于channel还是基于互斥量。毕竟和存款不一样，它只由一个简单的操作组成，所以不会碰到其它goroutine在其执行“期间”执行其它逻辑的风险。这里使用mutex有两方面考虑。第一Balance不会在其它操作比如Withdraw“中间”执行。第二（更重要的）是“同步”不仅仅是一堆goroutine执行顺序的问题，同样也会涉及到内存的问题。</p></li><li><p>在现代计算机中可能会有一堆处理器，每一个都会有其本地缓存（local cache）。为了效率，对内存的写入一般会在每一个处理器中缓冲，并在必要时一起flush到主存。这种情况下这些数据可能会以与当初goroutine写入顺序不同的顺序被提交到主存。像channel通信或者互斥量操作这样的原语会使处理器将其聚集的写入flush并commit，这样goroutine在某个时间点上的执行结果才能被其它处理器上运行的goroutine得到。</p></li><li><p>考虑一下下面代码片段的可能输出：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> x, y <span class="hljs-keyword">int</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;x = <span class="hljs-number">1</span> <span class="hljs-comment">// A1</span>fmt.Print(<span class="hljs-string">&quot;y:&quot;</span>, y, <span class="hljs-string">&quot; &quot;</span>) <span class="hljs-comment">// A2</span>&#125;()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;y = <span class="hljs-number">1</span>                   <span class="hljs-comment">// B1</span>fmt.Print(<span class="hljs-string">&quot;x:&quot;</span>, x, <span class="hljs-string">&quot; &quot;</span>) <span class="hljs-comment">// B2</span>&#125;()</code></pre><ul><li><p>因为两个goroutine是并发执行，并且访问共享变量时也没有互斥，会有数据竞争，所以程序的运行结果没法预测的话也请不要惊讶。我们可能希望它能够打印出下面这四种结果中的一种，相当于几种不同的交错执行时的情况：</p><pre><code class="hljs angelscript">y:<span class="hljs-number">0</span> x:<span class="hljs-number">1</span>x:<span class="hljs-number">0</span> y:<span class="hljs-number">1</span>x:<span class="hljs-number">1</span> y:<span class="hljs-number">1</span>y:<span class="hljs-number">1</span> x:<span class="hljs-number">1</span></code></pre></li><li><p>第四行可以被解释为执行顺序A1,B1,A2,B2或者B1,A1,A2,B2的执行结果。然而实际运行时还是有些情况让我们有点惊讶：</p><pre><code class="hljs angelscript">x:<span class="hljs-number">0</span> y:<span class="hljs-number">0</span>y:<span class="hljs-number">0</span> x:<span class="hljs-number">0</span></code></pre></li></ul></li><li><p>根据所使用的编译器，CPU，或者其它很多影响因子，这两种情况也是有可能发生的。那么这两种情况要怎么解释呢？</p></li><li><p>在一个独立的goroutine中，每一个语句的执行顺序是可以被保证的，也就是说goroutine内顺序是连贯的。但是在不使用channel且不使用mutex这样的显式同步操作时，我们就没法保证事件在不同的goroutine中看到的执行顺序是一致的了。尽管goroutine A中一定需要观察到x=1执行成功之后才会去读取y，但它没法确保自己观察得到goroutine B中对y的写入，所以A还可能会打印出y的一个旧版的值。</p></li><li><p>尽管去理解并发的一种尝试是去将其运行理解为不同goroutine语句的交错执行，但看看上面的例子，这已经不是现代的编译器和cpu的工作方式了。因为赋值和打印指向不同的变量，编译器可能会断定两条语句的顺序不会影响执行结果，并且会交换两个语句的执行顺序。如果两个goroutine在不同的CPU上执行，每一个核心有自己的缓存，这样一个goroutine的写入对于其它goroutine的Print，在主存同步之前就是不可见的了。</p></li><li><p>所有并发的问题都可以用一致的、简单的既定的模式来规避。所以可能的话，将变量限定在goroutine内部；如果是多个goroutine都需要访问的变量，使用互斥条件来访问。</p></li></ul><h3 id="ch9-5-sync-Once初始化"><a href="#ch9-5-sync-Once初始化" class="headerlink" title="ch9.5   sync.Once初始化"></a>ch9.5   sync.Once初始化</h3><ul><li><p>如果初始化成本比较大的话，那么将初始化延迟到需要的时候再去做就是一个比较好的选择。如果在程序启动的时候就去做这类初始化的话，会增加程序的启动时间，并且因为执行的时候可能也并不需要这些变量，所以实际上有一些浪费。让我们来看在本章早一些时候的icons变量：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> icons <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]image.Image</code></pre></li><li><p>这个版本的Icon用到了懒初始化（lazy initialization）。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadIcons</span><span class="hljs-params">()</span></span> &#123;icons = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]image.Image&#123;<span class="hljs-string">&quot;spades.png&quot;</span>:   loadIcon(<span class="hljs-string">&quot;spades.png&quot;</span>),<span class="hljs-string">&quot;hearts.png&quot;</span>:   loadIcon(<span class="hljs-string">&quot;hearts.png&quot;</span>),<span class="hljs-string">&quot;diamonds.png&quot;</span>: loadIcon(<span class="hljs-string">&quot;diamonds.png&quot;</span>),<span class="hljs-string">&quot;clubs.png&quot;</span>:loadIcon(<span class="hljs-string">&quot;clubs.png&quot;</span>),&#125;&#125;<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> not concurrency-safe!</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Icon</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">image</span>.<span class="hljs-title">Image</span></span> &#123;<span class="hljs-keyword">if</span> icons == <span class="hljs-literal">nil</span> &#123;loadIcons() <span class="hljs-comment">// one-time initialization</span>&#125;<span class="hljs-keyword">return</span> icons[name]&#125;</code></pre></li><li><p>如果一个变量只被一个单独的goroutine所访问的话，我们可以使用上面的这种模板，但这种模板在Icon被并发调用时并不安全。就像前面银行的那个Deposit(存款)函数一样，Icon函数也是由多个步骤组成的：首先测试icons是否为空，然后load这些icons，之后将icons更新为一个非空的值。直觉会告诉我们最差的情况是loadIcons函数被多次访问会带来数据竞争。当第一个goroutine在忙着loading这些icons的时候，另一个goroutine进入了Icon函数，发现变量是nil，然后也会调用loadIcons函数。</p></li><li><p>不过这种直觉是错误的。（我们希望你从现在开始能够构建自己对并发的直觉，也就是说对并发的直觉总是不能被信任的！），回忆一下9.4节。因为缺少显式的同步，编译器和CPU是可以随意地去更改访问内存的指令顺序，以任意方式，只要保证每一个goroutine自己的执行顺序一致。其中一种可能loadIcons的语句重排是下面这样。它会在填写icons变量的值之前先用一个空map来初始化icons变量。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">loadIcons</span><span class="hljs-params">()</span></span> &#123;icons = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]image.Image)icons[<span class="hljs-string">&quot;spades.png&quot;</span>] = loadIcon(<span class="hljs-string">&quot;spades.png&quot;</span>)icons[<span class="hljs-string">&quot;hearts.png&quot;</span>] = loadIcon(<span class="hljs-string">&quot;hearts.png&quot;</span>)icons[<span class="hljs-string">&quot;diamonds.png&quot;</span>] = loadIcon(<span class="hljs-string">&quot;diamonds.png&quot;</span>)icons[<span class="hljs-string">&quot;clubs.png&quot;</span>] = loadIcon(<span class="hljs-string">&quot;clubs.png&quot;</span>)&#125;</code></pre></li><li><p>因此，一个goroutine在检查icons是非空时，也并不能就假设这个变量的初始化流程已经走完了（译注：可能只是塞了个空map，里面的值还没填完，也就是说填值的语句都没执行完呢）。</p></li><li><p>最简单且正确的保证所有goroutine能够观察到loadIcons效果的方式，是用一个mutex来同步检查。</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.Mutex <span class="hljs-comment">// guards icons</span><span class="hljs-keyword">var</span> icons <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]image.Image<span class="hljs-comment">// Concurrency-safe.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Icon</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">image</span>.<span class="hljs-title">Image</span></span> &#123;mu.Lock()<span class="hljs-keyword">defer</span> mu.Unlock()<span class="hljs-keyword">if</span> icons == <span class="hljs-literal">nil</span> &#123;loadIcons()&#125;<span class="hljs-keyword">return</span> icons[name]&#125;</code></pre></li><li><p>然而使用互斥访问icons的代价就是没有办法对该变量进行并发访问，即使变量已经被初始化完毕且再也不会进行变动。这里我们可以引入一个允许多读的锁：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> mu sync.RWMutex <span class="hljs-comment">// guards icons</span><span class="hljs-keyword">var</span> icons <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]image.Image<span class="hljs-comment">// Concurrency-safe.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Icon</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">image</span>.<span class="hljs-title">Image</span></span> &#123;mu.RLock()<span class="hljs-keyword">if</span> icons != <span class="hljs-literal">nil</span> &#123;icon := icons[name]mu.RUnlock()<span class="hljs-keyword">return</span> icon&#125;mu.RUnlock()<span class="hljs-comment">// acquire an exclusive lock</span>mu.Lock()<span class="hljs-keyword">if</span> icons == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> must recheck for nil</span>loadIcons()&#125;icon := icons[name]mu.Unlock()<span class="hljs-keyword">return</span> icon&#125;</code></pre></li><li><p>上面的代码有两个临界区。goroutine首先会获取一个读锁，查询map，然后释放锁。如果条目被找到了（一般情况下），那么会直接返回。如果没有找到，那goroutine会获取一个写锁。不释放共享锁的话，也没有任何办法来将一个共享锁升级为一个互斥锁，所以我们必须重新检查icons变量是否为nil，以防止在执行这一段代码的时候，icons变量已经被其它gorouine初始化过了。</p></li><li><p>上面的模板使我们的程序能够更好的并发，但是有一点太复杂且容易出错。幸运的是，sync包为我们提供了一个专门的方案来解决这种一次性初始化的问题：sync.Once。概念上来讲，一次性的初始化需要一个互斥量mutex和一个boolean变量来记录初始化是不是已经完成了；互斥量用来保护boolean变量和客户端数据结构。Do这个唯一的方法需要接收初始化函数作为其参数。让我们用sync.Once来简化前面的Icon函数吧：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> loadIconsOnce sync.Once<span class="hljs-keyword">var</span> icons <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]image.Image<span class="hljs-comment">// Concurrency-safe.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Icon</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">image</span>.<span class="hljs-title">Image</span></span> &#123;loadIconsOnce.Do(loadIcons)<span class="hljs-keyword">return</span> icons[name]&#125;</code></pre></li><li><p>每一次对Do(loadIcons)的调用都会锁定mutex，并会检查boolean变量（译注：Go1.9中会先判断boolean变量是否为1(true)，只有不为1才锁定mutex，不再需要每次都锁定mutex）。在第一次调用时，boolean变量的值是false，Do会调用loadIcons并会将boolean变量设置为true。随后的调用什么都不会做，但是mutex同步会保证loadIcons对内存（这里其实就是指icons变量啦）产生的效果能够对所有goroutine可见。用这种方式来使用sync.Once的话，我们能够避免在变量被构建完成之前和其它goroutine共享该变量。</p></li></ul><h3 id="ch9-6-竞争条件检测"><a href="#ch9-6-竞争条件检测" class="headerlink" title="ch9.6   竞争条件检测"></a>ch9.6   竞争条件检测</h3><ul><li>即使我们小心到不能再小心，但在并发程序中犯错还是太容易了。幸运的是，Go的runtime和工具链为我们装备了一个复杂但好用的动态分析工具，竞争检查器（the race detector）。</li><li>只要在go build，go run或者go test命令后面加上-race的flag，就会使编译器创建一个你的应用的“修改”版或者一个附带了能够记录所有运行期对共享变量访问工具的test，并且会记录下每一个读或者写共享变量的goroutine的身份信息。另外，修改版的程序会记录下所有的同步事件，比如go语句，channel操作，以及对<code>(*sync.Mutex).Lock</code>，<code>(*sync.WaitGroup).Wait</code>等等的调用。（完整的同步事件集合是在The Go Memory Model文档中有说明，该文档是和语言文档放在一起的。译注：<a href="https://golang.org/ref/mem">https://golang.org/ref/mem</a> ）</li><li>竞争检查器会检查这些事件，会寻找在哪一个goroutine中出现了这样的case，例如其读或者写了一个共享变量，这个共享变量是被另一个goroutine在没有进行干预同步操作便直接写入的。这种情况也就表明了是对一个共享变量的并发访问，即数据竞争。这个工具会打印一份报告，内容包含变量身份，读取和写入的goroutine中活跃的函数的调用栈。这些信息在定位问题时通常很有用。9.7节中会有一个竞争检查器的实战样例。</li><li>竞争检查器会检查这些事件，会寻找在哪一个goroutine中出现了这样的case，例如其读或者写了一个共享变量，这个共享变量是被另一个goroutine在没有进行干预同步操作便直接写入的。这种情况也就表明了是对一个共享变量的并发访问，即数据竞争。这个工具会打印一份报告，内容包含变量身份，读取和写入的goroutine中活跃的函数的调用栈。这些信息在定位问题时通常很有用。9.7节中会有一个竞争检查器的实战样例。</li><li>竞争检查器会报告所有的已经发生的数据竞争。然而，它只能检测到运行时的竞争条件；并不能证明之后不会发生数据竞争。所以为了使结果尽量正确，请保证你的测试并发地覆盖到了你的包。</li><li>由于需要额外的记录，因此构建时加了竞争检测的程序跑起来会慢一些，且需要更大的内存，即使是这样，这些代价对于很多生产环境的工作来说还是可以接受的。对于一些偶发的竞争条件来说，让竞争检查器来干活可以节省无数日夜的debugging。（译注：多少服务端C和C++程序员为此竞折腰。）</li></ul><h3 id="ch9-7-示例：并发的非阻塞缓存"><a href="#ch9-7-示例：并发的非阻塞缓存" class="headerlink" title="ch9.7   示例：并发的非阻塞缓存"></a>ch9.7   示例：并发的非阻塞缓存</h3><ul><li><p>本节中我们会做一个无阻塞的缓存，这种工具可以帮助我们来解决现实世界中并发程序出现但没有现成的库可以解决的问题。这个问题叫作缓存（memoizing）函数</p><ul><li>译注：Memoization的定义： memoization 一词是Donald Michie 根据拉丁语memorandum杜撰的一个词。相应的动词、过去分词、ing形式有memoiz、memoized、memoizing</li></ul></li><li><p>也就是说，我们需要缓存函数的返回结果，这样在对函数进行调用的时候，我们就只需要一次计算，之后只要返回计算的结果就可以了。我们的解决方案会是并发安全且会避免对整个缓存加锁而导致所有操作都去争一个锁的设计。</p></li><li><p>我们将使用下面的httpGetBody函数作为我们需要缓存的函数的一个样例。这个函数会去进行HTTP GET请求并且获取http响应body。对这个函数的调用本身开销是比较大的，所以我们尽量避免在不必要的时候反复调用。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">httpGetBody</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;resp, err := http.Get(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;<span class="hljs-keyword">defer</span> resp.Body.Close()<span class="hljs-keyword">return</span> ioutil.ReadAll(resp.Body)&#125;</code></pre><ul><li>最后一行稍微隐藏了一些细节。ReadAll会返回两个结果，一个[]byte数组和一个错误，不过这两个对象可以被赋值给httpGetBody的返回声明里的interface{}和error类型，所以我们也就可以这样返回结果并且不需要额外的工作了。我们在httpGetBody中选用这种返回类型是为了使其可以与缓存匹配。</li></ul></li><li><p>下面是我们要设计的cache的第一个“草稿”：</p><p><u><i>gopl.io/ch9/memo1</i></u></p><pre><code class="hljs go"><span class="hljs-comment">// Package memo provides a concurrency-unsafe</span><span class="hljs-comment">// memoization of a function of type Func.</span><span class="hljs-keyword">package</span> memo<span class="hljs-comment">// A Memo caches the results of calling a Func.</span><span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span> &#123;f     Funccache <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]result&#125;<span class="hljs-comment">// Func is the type of the function to memoize.</span><span class="hljs-keyword">type</span> Func <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;value <span class="hljs-keyword">interface</span>&#123;&#125;err   error&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(f Func)</span> *<span class="hljs-title">Memo</span></span> &#123;<span class="hljs-keyword">return</span> &amp;Memo&#123;f: f, cache: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]result)&#125;&#125;<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> not concurrency-safe!</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;res, ok := memo.cache[key]<span class="hljs-keyword">if</span> !ok &#123;res.value, res.err = memo.f(key)memo.cache[key] = res&#125;<span class="hljs-keyword">return</span> res.value, res.err&#125;</code></pre><ul><li>Memo实例会记录需要缓存的函数f（类型为Func），以及缓存内容（里面是一个string到result映射的map）。每一个result都是简单的函数返回的值对儿——一个值和一个错误值。继续下去我们会展示一些Memo的变种，不过所有的例子都会遵循上面的这些方面。</li></ul></li><li><p>下面是一个使用Memo的例子。对于流入的URL的每一个元素我们都会调用Get，并打印调用延时以及其返回的数据大小的log：</p><pre><code class="hljs go">m := memo.New(httpGetBody)<span class="hljs-keyword">for</span> url := <span class="hljs-keyword">range</span> incomingURLs() &#123;start := time.Now()value, err := m.Get(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Print(err)&#125;fmt.Printf(<span class="hljs-string">&quot;%s, %s, %d bytes\n&quot;</span>,url, time.Since(start), <span class="hljs-built_in">len</span>(value.([]<span class="hljs-keyword">byte</span>)))&#125;</code></pre></li><li><p>我们可以使用测试包（第11章的主题）来系统地鉴定缓存的效果。从下面的测试输出，我们可以看到URL流包含了一些重复的情况，尽管我们第一次对每一个URL的<code>(*Memo).Get</code>的调用都会花上几百毫秒，但第二次就只需要花1毫秒就可以返回完整的数据了。</p><pre><code class="hljs awk">$ go test -v gopl.io<span class="hljs-regexp">/ch9/m</span>emo1=== RUN   Testhttps:<span class="hljs-regexp">//g</span>olang.org, <span class="hljs-number">175.026418</span>ms, <span class="hljs-number">7537</span> byteshttps:<span class="hljs-regexp">//g</span>odoc.org, <span class="hljs-number">172.686825</span>ms, <span class="hljs-number">6878</span> byteshttps:<span class="hljs-regexp">//</span>play.golang.org, <span class="hljs-number">115.762377</span>ms, <span class="hljs-number">5767</span> byteshttp:<span class="hljs-regexp">//g</span>opl.io, <span class="hljs-number">749.887242</span>ms, <span class="hljs-number">2856</span> byteshttps:<span class="hljs-regexp">//g</span>olang.org, <span class="hljs-number">721</span>ns, <span class="hljs-number">7537</span> byteshttps:<span class="hljs-regexp">//g</span>odoc.org, <span class="hljs-number">152</span>ns, <span class="hljs-number">6878</span> byteshttps:<span class="hljs-regexp">//</span>play.golang.org, <span class="hljs-number">205</span>ns, <span class="hljs-number">5767</span> byteshttp:<span class="hljs-regexp">//g</span>opl.io, <span class="hljs-number">326</span>ns, <span class="hljs-number">2856</span> bytes--- PASS: Test (<span class="hljs-number">1.21</span>s)PASSok  gopl.io<span class="hljs-regexp">/ch9/m</span>emo1   <span class="hljs-number">1.257</span>s</code></pre><ul><li>这个测试是顺序地去做所有的调用的。</li></ul></li><li><p>由于这种彼此独立的HTTP请求可以很好地并发，我们可以把这个测试改成并发形式。可以使用sync.WaitGroup来等待所有的请求都完成之后再返回。</p><pre><code class="hljs go">m := memo.New(httpGetBody)<span class="hljs-keyword">var</span> n sync.WaitGroup<span class="hljs-keyword">for</span> url := <span class="hljs-keyword">range</span> incomingURLs() &#123;n.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span></span> &#123;start := time.Now()value, err := m.Get(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Print(err)&#125;fmt.Printf(<span class="hljs-string">&quot;%s, %s, %d bytes\n&quot;</span>,url, time.Since(start), <span class="hljs-built_in">len</span>(value.([]<span class="hljs-keyword">byte</span>)))n.Done()&#125;(url)&#125;n.Wait()</code></pre><ul><li>这次测试跑起来更快了，然而不幸的是貌似这个测试不是每次都能够正常工作。我们注意到有一些意料之外的cache miss（缓存未命中），或者命中了缓存但却返回了错误的值，或者甚至会直接崩溃。</li></ul></li><li><p>但更糟糕的是，有时候这个程序还是能正确的运行（译：也就是最让人崩溃的偶发bug），所以我们甚至可能都不会意识到这个程序有bug。但是我们可以使用-race这个flag来运行程序，竞争检测器（§9.6）会打印像下面这样的报告：</p><pre><code class="hljs gradle">$ go test -run=TestConcurrent -race -v gopl.io<span class="hljs-regexp">/ch9/m</span>emo1=== RUN   TestConcurrent...WARNING: DATA RACE<span class="hljs-keyword">Write</span> by goroutine <span class="hljs-number">36</span>:  <span class="hljs-keyword">runtime</span>.mapassign1()      ~<span class="hljs-regexp">/go/</span>src<span class="hljs-regexp">/runtime/</span>hashmap.go:<span class="hljs-number">411</span> +<span class="hljs-number">0</span>x0  gopl.io<span class="hljs-regexp">/ch9/m</span>emo1.(*Memo).Get()      ~<span class="hljs-regexp">/gobook2/</span>src<span class="hljs-regexp">/gopl.io/</span>ch9<span class="hljs-regexp">/memo1/m</span>emo.go:<span class="hljs-number">32</span> +<span class="hljs-number">0</span>x205  ...<span class="hljs-keyword">Previous</span> <span class="hljs-keyword">write</span> by goroutine <span class="hljs-number">35</span>:  <span class="hljs-keyword">runtime</span>.mapassign1()      ~<span class="hljs-regexp">/go/</span>src<span class="hljs-regexp">/runtime/</span>hashmap.go:<span class="hljs-number">411</span> +<span class="hljs-number">0</span>x0  gopl.io<span class="hljs-regexp">/ch9/m</span>emo1.(*Memo).Get()      ~<span class="hljs-regexp">/gobook2/</span>src<span class="hljs-regexp">/gopl.io/</span>ch9<span class="hljs-regexp">/memo1/m</span>emo.go:<span class="hljs-number">32</span> +<span class="hljs-number">0</span>x205...Found <span class="hljs-number">1</span> data race(s)FAIL    gopl.io<span class="hljs-regexp">/ch9/m</span>emo1   <span class="hljs-number">2.393</span>s</code></pre><ul><li>memo.go的32行出现了两次，说明有两个goroutine在没有同步干预的情况下更新了cache map。这表明Get不是并发安全的，存在数据竞争。</li></ul></li><li><p>最简单的使cache并发安全的方式是使用基于监控的同步。只要给Memo加上一个mutex，在Get的一开始获取互斥锁，return的时候释放锁，就可以让cache的操作发生在临界区内了：</p><p><u><i>gopl.io/ch9/memo2</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span> &#123;f     Funcmu    sync.Mutex <span class="hljs-comment">// guards cache</span>cache <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]result&#125;<span class="hljs-comment">// Get is concurrency-safe.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;memo.mu.Lock()res, ok := memo.cache[key]    <span class="hljs-keyword">if</span> !ok &#123;res.value, res.err = memo.f(key)memo.cache[key] = res&#125;memo.mu.Unlock()<span class="hljs-keyword">return</span> res.value, res.err&#125;</code></pre><ul><li>测试依然并发进行，但这回竞争检查器“沉默”了。不幸的是对于Memo的这一点改变使我们完全丧失了并发的性能优点。每次对f的调用期间都会持有锁，Get将本来可以并行运行的I/O操作串行化了。我们本章的目的是完成一个无锁缓存，而不是现在这样的将所有请求串行化的函数的缓存。</li></ul></li><li><p>下一个Get的实现，调用Get的goroutine会两次获取锁：查找阶段获取一次，如果查找没有返回任何内容，那么进入更新阶段会再次获取。在这两次获取锁的中间阶段，其它goroutine可以随意使用cache。</p><p><u><i>gopl.io/ch9/memo3</i></u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;memo.mu.Lock()res, ok := memo.cache[key]memo.mu.Unlock()<span class="hljs-keyword">if</span> !ok &#123;res.value, res.err = memo.f(key)<span class="hljs-comment">// Between the two critical sections, several goroutines</span><span class="hljs-comment">// may race to compute f(key) and update the map.</span>memo.mu.Lock()memo.cache[key] = resmemo.mu.Unlock()&#125;<span class="hljs-keyword">return</span> res.value, res.err&#125;</code></pre><ul><li>这些修改使性能再次得到了提升，但有一些URL被获取了两次。这种情况在两个以上的goroutine同一时刻调用Get来请求同样的URL时会发生。多个goroutine一起查询cache，发现没有值，然后一起调用f这个慢不拉叽的函数。在得到结果后，也都会去更新map。其中一个获得的结果会覆盖掉另一个的结果。</li></ul></li><li><p>理想情况下是应该避免掉多余的工作的。而这种“避免”工作一般被称为duplicate suppression（重复抑制/避免）。下面版本的Memo每一个map元素都是指向一个条目的指针。每一个条目包含对函数f调用结果的内容缓存。与之前不同的是这次entry还包含了一个叫ready的channel。在条目的结果被设置之后，这个channel就会被关闭，以向其它goroutine广播（§8.9）去读取该条目内的结果是安全的了。</p><p><u><i>gopl.io/ch9/memo4</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;res   resultready <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// closed when res is ready</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(f Func)</span> *<span class="hljs-title">Memo</span></span> &#123;<span class="hljs-keyword">return</span> &amp;Memo&#123;f: f, cache: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*entry)&#125;&#125;<span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span> &#123;f     Funcmu    sync.Mutex <span class="hljs-comment">// guards cache</span>cache <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*entry&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;, err error)</span></span> &#123;memo.mu.Lock()e := memo.cache[key]<span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// This is the first request for this key.</span><span class="hljs-comment">// This goroutine becomes responsible for computing</span><span class="hljs-comment">// the value and broadcasting the ready condition.</span>e = &amp;entry&#123;ready: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)&#125;memo.cache[key] = ememo.mu.Unlock()e.res.value, e.res.err = memo.f(key)<span class="hljs-built_in">close</span>(e.ready) <span class="hljs-comment">// broadcast ready condition</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// This is a repeat request for this key.</span>memo.mu.Unlock()&lt;-e.ready <span class="hljs-comment">// wait for ready condition</span>&#125;<span class="hljs-keyword">return</span> e.res.value, e.res.err&#125;</code></pre><ul><li>现在Get函数包括下面这些步骤了：获取互斥锁来保护共享变量cache map，查询map中是否存在指定条目，如果没有找到那么分配空间插入一个新条目，释放互斥锁。如果存在条目的话且其值没有写入完成（也就是有其它的goroutine在调用f这个慢函数）时，goroutine必须等待值ready之后才能读到条目的结果。而想知道是否ready的话，可以直接从ready channel中读取，由于这个读取操作在channel关闭之前一直是阻塞。</li><li>如果没有条目的话，需要向map中插入一个没有准备好的条目，当前正在调用的goroutine就需要负责调用慢函数、更新条目以及向其它所有goroutine广播条目已经ready可读的消息了。</li><li>条目中的e.res.value和e.res.err变量是在多个goroutine之间共享的。创建条目的goroutine同时也会设置条目的值，其它goroutine在收到”ready”的广播消息之后立刻会去读取条目的值。尽管会被多个goroutine同时访问，但却并不需要互斥锁。ready channel的关闭一定会发生在其它goroutine接收到广播事件之前，因此第一个goroutine对这些变量的写操作是一定发生在这些读操作之前的。不会发生数据竞争。</li></ul></li><li><p>这样并发、不重复、无阻塞的cache就完成了。</p></li><li><p>上面这样Memo的实现使用了一个互斥量来保护多个goroutine调用Get时的共享map变量。不妨把这种设计和前面提到的把map变量限制在一个单独的monitor goroutine的方案做一些对比，后者在调用Get时需要发消息。</p></li><li><p>Func、result和entry的声明和之前保持一致：</p><pre><code class="hljs go"><span class="hljs-comment">// Func is the type of the function to memoize.</span><span class="hljs-keyword">type</span> Func <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span><span class="hljs-comment">// A result is the result of calling a Func.</span><span class="hljs-keyword">type</span> result <span class="hljs-keyword">struct</span> &#123;value <span class="hljs-keyword">interface</span>&#123;&#125;err   error&#125;<span class="hljs-keyword">type</span> entry <span class="hljs-keyword">struct</span> &#123;res   resultready <span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125; <span class="hljs-comment">// closed when res is ready</span>&#125;</code></pre></li><li><p>然而Memo类型现在包含了一个叫做requests的channel，Get的调用方用这个channel来和monitor goroutine来通信。requests channel中的元素类型是request。Get的调用方会把这个结构中的两组key都填充好，实际上用这两个变量来对函数进行缓存的。另一个叫response的channel会被拿来发送响应结果。这个channel只会传回一个单独的值。</p><p><u><i>gopl.io/ch9/memo5</i></u></p><pre><code class="hljs go"><span class="hljs-comment">// A request is a message requesting that the Func be applied to key.</span><span class="hljs-keyword">type</span> request <span class="hljs-keyword">struct</span> &#123;key      <span class="hljs-keyword">string</span>response <span class="hljs-keyword">chan</span>&lt;- result <span class="hljs-comment">// the client wants a single result</span>&#125;<span class="hljs-keyword">type</span> Memo <span class="hljs-keyword">struct</span>&#123; requests <span class="hljs-keyword">chan</span> request &#125;<span class="hljs-comment">// New returns a memoization of f.  Clients must subsequently call Close.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(f Func)</span> *<span class="hljs-title">Memo</span></span> &#123;memo := &amp;Memo&#123;requests: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> request)&#125;<span class="hljs-keyword">go</span> memo.server(f)<span class="hljs-keyword">return</span> memo&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">interface</span>&#123;&#125;, error)</span></span> &#123;response := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> result)memo.requests &lt;- request&#123;key, response&#125;res := &lt;-response<span class="hljs-keyword">return</span> res.value, res.err&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-built_in">close</span>(memo.requests) &#125;</code></pre><ul><li>上面的Get方法，会创建一个response channel，把它放进request结构中，然后发送给monitor goroutine，然后马上又会接收它。</li></ul></li><li><p>cache变量被限制在了monitor goroutine ``(*Memo).server`中，下面会看到。monitor会在循环中一直读取请求，直到request channel被Close方法关闭。每一个请求都会去查询cache，如果没有找到条目的话，那么就会创建/插入一个新的条目。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(memo *Memo)</span> <span class="hljs-title">server</span><span class="hljs-params">(f Func)</span></span> &#123;cache := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]*entry)<span class="hljs-keyword">for</span> req := <span class="hljs-keyword">range</span> memo.requests &#123;e := cache[req.key]<span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;<span class="hljs-comment">// This is the first request for this key.</span>e = &amp;entry&#123;ready: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)&#125;cache[req.key] = e<span class="hljs-keyword">go</span> e.call(f, req.key) <span class="hljs-comment">// call f(key)</span>&#125;<span class="hljs-keyword">go</span> e.deliver(req.response)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *entry)</span> <span class="hljs-title">call</span><span class="hljs-params">(f Func, key <span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-comment">// Evaluate the function.</span>e.res.value, e.res.err = f(key)<span class="hljs-comment">// Broadcast the ready condition.</span><span class="hljs-built_in">close</span>(e.ready)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *entry)</span> <span class="hljs-title">deliver</span><span class="hljs-params">(response <span class="hljs-keyword">chan</span>&lt;- result)</span></span> &#123;<span class="hljs-comment">// Wait for the ready condition.</span>&lt;-e.ready<span class="hljs-comment">// Send the result to the client.</span>response &lt;- e.res&#125;</code></pre></li><li><p>和基于互斥量的版本类似，第一个对某个key的请求需要负责去调用函数f并传入这个key，将结果存在条目里，并关闭ready channel来广播条目的ready消息。使用<code>(*entry).call</code>来完成上述工作。</p></li><li><p>紧接着对同一个key的请求会发现map中已经有了存在的条目，然后会等待结果变为ready，并将结果从response发送给客户端的goroutien。上述工作是用<code>(*entry).deliver</code>来完成的。对call和deliver方法的调用必须让它们在自己的goroutine中进行以确保monitor goroutines不会因此而被阻塞住而没法处理新的请求。</p></li><li><p>这个例子说明我们无论用上锁，还是通信来建立并发程序都是可行的。</p></li><li><p>上面的两种方案并不好说特定情境下哪种更好，不过了解他们还是有价值的。有时候从一种方式切换到另一种可以使你的代码更为简洁。（译注：不是说好的golang推崇通信并发么。）</p></li></ul><h3 id="ch9-8-Goroutines和线程"><a href="#ch9-8-Goroutines和线程" class="headerlink" title="ch9.8   Goroutines和线程"></a>ch9.8   Goroutines和线程</h3><ul><li><p>ch9.8.0 简介</p><ul><li>在上一章中我们说goroutine和操作系统的线程区别可以先忽略。尽管两者的区别实际上只是一个量的区别，但量变会引起质变的道理同样适用于goroutine和线程。现在正是我们来区分开两者的最佳时机。</li></ul></li><li><p>ch9.8.1 动态栈</p><ul><li>每一个OS线程都有一个固定大小的内存块（一般会是2MB）来做栈，这个栈会用来存储当前正在被调用或挂起（指在调用其它函数时）的函数的内部变量。这个固定大小的栈同时很大又很小。因为2MB的栈对于一个小小的goroutine来说是很大的内存浪费，比如对于我们用到的，一个只是用来WaitGroup之后关闭channel的goroutine来说。</li><li>而对于go程序来说，同时创建成百上千个goroutine是非常普遍的，如果每一个goroutine都需要这么大的栈的话，那这么多的goroutine就不太可能了。除去大小的问题之外，固定大小的栈对于更复杂或者更深层次的递归函数调用来说显然是不够的。修改固定的大小可以提升空间的利用率，允许创建更多的线程，并且可以允许更深的递归调用，不过这两者是没法同时兼备的。</li><li>相反，一个goroutine会以一个很小的栈开始其生命周期，一般只需要2KB。一个goroutine的栈，和操作系统线程一样，会保存其活跃或挂起的函数调用的本地变量，但是和OS线程不太一样的是，一个goroutine的栈大小并不是固定的；栈的大小会根据需要动态地伸缩。而goroutine的栈的最大值有1GB，比传统的固定大小的线程栈要大得多，尽管一般情况下，大多goroutine都不需要这么大的栈。</li></ul></li><li><p>ch9.8.2 Goroutine调度</p><ul><li>OS线程会被操作系统内核调度。每几毫秒，一个硬件计时器会中断处理器，这会调用一个叫作scheduler的内核函数。这个函数会挂起当前执行的线程并将它的寄存器内容保存到内存中，检查线程列表并决定下一次哪个线程可以被运行，并从内存中恢复该线程的寄存器信息，然后恢复执行该线程的现场并开始执行线程。</li><li>因为操作系统线程是被内核所调度，所以从一个线程向另一个“移动”需要完整的上下文切换，也就是说，保存一个用户线程的状态到内存，恢复另一个线程的到寄存器，然后更新调度器的数据结构。这几步操作很慢，因为其局部性很差需要几次内存访问，并且会增加运行的cpu周期。</li><li>Go的运行时包含了其自己的调度器，这个调度器使用了一些技术手段，比如m:n调度，因为其会在n个操作系统线程上多工（调度）m个goroutine。Go调度器的工作和内核的调度是相似的，但是这个调度器只关注单独的Go程序中的goroutine（译注：按程序独立）。</li><li>和操作系统的线程调度不同的是，Go调度器并不是用一个硬件定时器，而是被Go语言“建筑”本身进行调度的。例如当一个goroutine调用了time.Sleep，或者被channel调用或者mutex操作阻塞时，调度器会使其进入休眠并开始执行另一个goroutine，直到时机到了再去唤醒第一个goroutine。因为这种调度方式不需要进入内核的上下文，所以重新调度一个goroutine比调度一个线程代价要低得多。</li></ul></li><li><p>ch9.8.3 GOMAXPROCS</p><ul><li><p>Go的调度器使用了一个叫做GOMAXPROCS的变量来决定会有多少个操作系统的线程同时执行Go的代码。其默认的值是运行机器上的CPU的核心数，所以在一个有8个核心的机器上时，调度器一次会在8个OS线程上去调度GO代码。（GOMAXPROCS是前面说的m:n调度中的n）。</p></li><li><p>在休眠中的或者在通信中被阻塞的goroutine是不需要一个对应的线程来做调度的。在I/O中或系统调用中或调用非Go语言函数时，是需要一个对应的操作系统线程的，但是GOMAXPROCS并不需要将这几种情况计算在内。</p></li><li><p>你可以用GOMAXPROCS的环境变量来显式地控制这个参数，或者也可以在运行时用runtime.GOMAXPROCS函数来修改它。我们在下面的小程序中会看到GOMAXPROCS的效果，这个程序会无限打印0和1。</p><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">go</span> fmt.Print(<span class="hljs-number">0</span>)fmt.Print(<span class="hljs-number">1</span>)&#125;$ GOMAXPROCS=<span class="hljs-number">1</span> <span class="hljs-keyword">go</span> run hacker-cliché.<span class="hljs-keyword">go</span><span class="hljs-number">111111111111111111110000000000000000000011111.</span>..$ GOMAXPROCS=<span class="hljs-number">2</span> <span class="hljs-keyword">go</span> run hacker-cliché.<span class="hljs-keyword">go</span><span class="hljs-number">010101010101010101011001100101011010010100110.</span>..</code></pre><ul><li>在第一次执行时，最多同时只能有一个goroutine被执行。初始情况下只有main goroutine被执行，所以会打印很多1。过了一段时间后，GO调度器会将其置为休眠，并唤醒另一个goroutine，这时候就开始打印很多0了，在打印的时候，goroutine是被调度到操作系统线程上的。</li><li>在第二次执行时，我们使用了两个操作系统线程，所以两个goroutine可以一起被执行，以同样的频率交替打印0和1。我们必须强调的是goroutine的调度是受很多因子影响的，而runtime也是在不断地发展演进的，所以这里的你实际得到的结果可能会因为版本的不同而与我们运行的结果有所不同。</li></ul></li></ul></li><li><p>ch9.8.4 Goroutine没有ID号</p><ul><li><p>在大多数支持多线程的操作系统和程序语言中，当前的线程都有一个独特的身份（id），并且这个身份信息可以以一个普通值的形式被很容易地获取到，典型的可以是一个integer或者指针值。</p></li><li><p>这种情况下我们做一个抽象化的thread-local storage（线程本地存储，多线程编程中不希望其它线程访问的内容）就很容易，只需要以线程的id作为key的一个map就可以解决问题，每一个线程以其id就能从中获取到值，且和其它线程互不冲突。</p></li><li><p>oroutine没有可以被程序员获取到的身份（id）的概念。这一点是设计上故意而为之，由于thread-local storage总是会被滥用。</p><ul><li>比如说，一个web server是用一种支持tls的语言实现的，而非常普遍的是很多函数会去寻找HTTP请求的信息，这代表它们就是去其存储层（这个存储层有可能是tls）查找的。</li><li>这就像是那些过分依赖全局变量的程序一样，会导致一种非健康的“距离外行为”，在这种行为下，一个函数的行为可能并不仅由自己的参数所决定，而是由其所运行在的线程所决定。</li><li>因此，如果线程本身的身份会改变——比如一些worker线程之类的——那么函数的行为就会变得神秘莫测。</li></ul></li><li><p>Go鼓励更为简单的模式，这种模式下参数对函数的影响都是显式的。这样不仅使程序变得更易读，而且会让我们自由地向一些给定的函数分配子任务时不用担心其身份信息影响行为。</p><ul><li>译注：外部显式参数和内部显式参数。tls 中的内容算是”外部”隐式参数</li></ul></li><li><p>你现在应该已经明白了写一个Go程序所需要的所有语言特性信息。在后面两章节中，我们会回顾一些之前的实例和工具，支持我们写出更大规模的程序：如何将一个工程组织成一系列的包，如何获取，构建，测试，性能测试，剖析，写文档，并且将这些包分享出去。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Go Programming Language（8）- channel</title>
    <link href="/2020/11/22/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%888%EF%BC%89-%20channel/"/>
    <url>/2020/11/22/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%888%EF%BC%89-%20channel/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="The-Go-Programming-Language（8"><a href="#The-Go-Programming-Language（8" class="headerlink" title="The Go Programming Language（8)"></a>The Go Programming Language（8)</h1><h3 id="源码、PDF版、Markdown、xmind版下载链接"><a href="#源码、PDF版、Markdown、xmind版下载链接" class="headerlink" title="源码、PDF版、Markdown、xmind版下载链接"></a>源码、PDF版、Markdown、xmind版下载链接</h3><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://<span class="hljs-number">1</span>tnt<span class="hljs-number">1</span>.lanzous.com/b<span class="hljs-number">00</span>o<span class="hljs-number">36</span>ytc</code></pre><p>密码：</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span>ch0</code></pre><hr><h2 id="ch8-Goroutines和Channels"><a href="#ch8-Goroutines和Channels" class="headerlink" title="ch8  Goroutines和Channels"></a>ch8  Goroutines和Channels</h2><h3 id="ch8-4-Channels"><a href="#ch8-4-Channels" class="headerlink" title="ch8.4   Channels"></a>ch8.4   Channels</h3><ul><li><p>ch8.4.0   简介</p><ul><li><p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为chan int。</p></li><li><p>使用内置的make函数，我们可以创建一个channel：</p><pre><code class="hljs Go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>) <span class="hljs-comment">// ch has type &#x27;chan int&#x27;</span></code></pre></li><li><p>和map类似，channel也对应一个make创建的底层数据结构的引用。当我们复制一个channel或用于函数参数传递时，我们只是拷贝了一个channel引用，因此调用者和被调用者将引用同一个channel对象。和其它的引用类型一样，channel的零值也是nil。</p></li><li><p>两个相同类型的channel可以使用==运算符比较。如果两个channel引用的是相同的对象，那么比较的结果为真。一个channel也可以和nil进行比较。</p></li><li><p>一个channel有发送和接受两个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都使用<code>&lt;-</code>运算符。在发送语句中，<code>&lt;-</code>运算符分割channel和要发送的值。在接收语句中，<code>&lt;-</code>运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。</p><pre><code class="hljs Go">ch &lt;- x  <span class="hljs-comment">// a send statement</span>x = &lt;-ch <span class="hljs-comment">// a receive expression in an assignment statement</span>&lt;-ch     <span class="hljs-comment">// a receive statement; result is discarded</span></code></pre></li><li><p>Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。</p><ul><li><p>使用内置的close函数就可以关闭一个channel：</p><pre><code class="hljs Go"><span class="hljs-built_in">close</span>(ch)</code></pre></li></ul></li><li><p>以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。</p><pre><code class="hljs Go">ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)    <span class="hljs-comment">// unbuffered channel</span>ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>) <span class="hljs-comment">// unbuffered channel</span>ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">// buffered channel with capacity 3</span></code></pre></li><li><p>我们将先讨论无缓存的channel，然后在8.4.4节讨论带缓存的channel。</p></li></ul></li><li><p>ch8.4.1 不带缓存的Channels</p><ul><li><p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。</p></li><li><p>基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作。因为这个原因，无缓存Channels有时候也被称为同步Channels。当通过一个无缓存Channels发送数据时，接收者收到数据发生在再次唤醒唤醒发送者goroutine之前</p><ul><li><em>happens before</em>，这是Go语言并发内存模型的一个关键术语！</li></ul></li><li><p>在讨论并发编程时，当我们说x事件在y事件之前发生（<em>happens before</em>），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。</p></li><li><p>当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。在下一章中我们将看到，当两个goroutine并发访问了相同的变量时，我们有必要保证某些事件的执行顺序，以避免出现某些并发问题。</p></li><li><p>在8.3节的客户端程序，它在主goroutine中（译注：就是执行main函数的goroutine）将标准输入复制到server，因此当客户端程序关闭标准输入时，后台goroutine可能依然在工作。我们需要让主goroutine等待后台goroutine完成工作后再退出，我们使用了一个channel来同步两个goroutine：</p><p><u><i>gopl.io/ch8/netcat3</i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;done := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;io.Copy(os.Stdout, conn) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring errors</span>log.Println(<span class="hljs-string">&quot;done&quot;</span>)done &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// signal the main goroutine</span>&#125;()mustCopy(conn, os.Stdin)conn.Close()&lt;-done <span class="hljs-comment">// wait for background goroutine to finish</span>&#125;</code></pre></li><li><p>当用户关闭了标准输入，主goroutine中的mustCopy函数调用将返回，然后调用conn.Close()关闭读和写方向的网络连接。关闭网络连接中的写方向的连接将导致server程序收到一个文件（end-of-file）结束的信号。关闭网络连接中读方向的连接将导致后台goroutine的io.Copy函数调用返回一个“read from closed connection”（“从关闭的连接读”）类似的错误，因此我们临时移除了错误日志语句；在练习8.3将会提供一个更好的解决方案。（需要注意的是go语句调用了一个函数字面量，这是Go语言中启动goroutine常用的形式。）</p></li><li><p>在后台goroutine返回之前，它先打印一个日志信息，然后向done对应的channel发送一个值。主goroutine在退出前先等待从done对应的channel接收一个值。因此，总是可以在程序退出前正确输出“done”消息。</p></li><li><p>基于channels发送消息有两个重要方面。首先每个消息都有一个值，但是有时候通讯的事实和发生的时刻也同样重要。当我们更希望强调通讯发生的时刻时，我们将它称为<strong>消息事件</strong>。有些消息事件并不携带额外的信息，它仅仅是用作两个goroutine之间的同步，这时候我们可以用<code>struct&#123;&#125;</code>空结构体作为channels元素的类型，虽然也可以使用bool或int类型实现同样的功能，<code>done &lt;- 1</code>语句也比<code>done &lt;- struct&#123;&#125;&#123;&#125;</code>更短。</p></li></ul></li><li><p>ch8.4.2 串联的Channels（Pipeline）</p><ul><li><p>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline）。下面的程序用两个channels将三个goroutine串联起来</p><ul><li>第一个goroutine是一个计数器，用于生成0、1、2、……形式的整数序列，然后通过channel将该整数序列发送给第二个goroutine；</li><li>第二个goroutine是一个求平方的程序，对收到的每个整数求平方,然后将平方后的结果通过第二个channel发送给第三个goroutine</li><li>第三个goroutine是一个打印程序，打印收到的每个整数。</li></ul></li><li><p>为了保持例子清晰，我们有意选择了非常简单的函数，当然三个goroutine的计算很简单，在现实中确实没有必要为如此简单的运算构建三个goroutine。</p><p><u><i>gopl.io/ch8/pipeline1</i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;naturals := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)squares := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<span class="hljs-comment">// Counter</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; ; x++ &#123;naturals &lt;- x&#125;&#125;()<span class="hljs-comment">// Squarer</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;x := &lt;-naturalssquares &lt;- x * x&#125;&#125;()<span class="hljs-comment">// Printer (in main goroutine)</span><span class="hljs-keyword">for</span> &#123;fmt.Println(&lt;-squares)&#125;&#125;</code></pre></li><li><p>如您所料，上面的程序将生成0、1、4、9、……形式的无穷数列。像这样的串联Channels的管道（Pipelines）可以用在需要长时间运行的服务中，每个长时间运行的goroutine可能会包含一个死循环，在不同goroutine的死循环内部使用串联的Channels来通信。但是，如果我们希望通过Channels只发送有限的数列该如何处理呢？</p></li><li><p>如果发送者知道，没有更多的值需要发送到channel的话，那么让接收者也能及时知道没有多余的值可接收将是有用的，因为接收者可以停止不必要的接收等待。这可以通过内置的close函数来关闭channel实现：</p><pre><code class="hljs Go"><span class="hljs-built_in">close</span>(naturals)</code></pre></li><li><p>当一个channel被关闭后，再向该channel发送数据将导致panic异常。当一个被关闭的channel中已经发送的数据都被成功接收后，后续的接收操作将不再阻塞，它们会立即返回一个零值。关闭上面例子中的naturals变量对应的channel并不能终止循环，它依然会收到一个永无休止的零值序列，然后将它们发送给打印者goroutine。</p></li><li><p>没有办法直接测试一个channel是否被关闭，但是接收操作有一个变体形式：它多接收一个结果，多接收的第二个结果是一个布尔值ok，ture表示成功从channels接收到值，false表示channels已经被关闭并且里面没有值可接收。使用这个特性，我们可以修改squarer函数中的循环代码，当naturals对应的channel被关闭并没有值可接收时跳出循环，并且也关闭squares对应的channel.</p><pre><code class="hljs Go"><span class="hljs-comment">// Squarer</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> &#123;x, ok := &lt;-naturals<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">break</span> <span class="hljs-comment">// channel was closed and drained</span>&#125;squares &lt;- x * x&#125;<span class="hljs-built_in">close</span>(squares)&#125;()</code></pre></li><li><p>因为上面的语法是笨拙的，而且这种处理模式很常见，因此Go语言的range循环可直接在channels上面迭代。使用range循环是上面处理模式的简洁语法，它依次从channel接收数据，当channel被关闭并且没有值可接收时跳出循环。</p></li><li><p>在下面的改进中，我们的计数器goroutine只生成100个含数字的序列，然后关闭naturals对应的channel，这将导致计算平方数的squarer对应的goroutine可以正常终止循环并关闭squares对应的channel。（在一个更复杂的程序中，可以通过defer语句关闭对应的channel。）最后，主goroutine也可以正常终止循环并退出程序。</p><p><u><i>gopl.io/ch8/pipeline2</i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;naturals := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)squares := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<span class="hljs-comment">// Counter</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">100</span>; x++ &#123;naturals &lt;- x&#125;<span class="hljs-built_in">close</span>(naturals)&#125;()<span class="hljs-comment">// Squarer</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> x := <span class="hljs-keyword">range</span> naturals &#123;squares &lt;- x * x&#125;<span class="hljs-built_in">close</span>(squares)&#125;()<span class="hljs-comment">// Printer (in main goroutine)</span><span class="hljs-keyword">for</span> x := <span class="hljs-keyword">range</span> squares &#123;fmt.Println(x)&#125;&#125;</code></pre><ul><li>其实你并不需要关闭每一个channel。只有当需要告诉接收者goroutine，所有的数据已经全部发送时才需要关闭channel。不管一个channel是否被关闭，当它没有被引用时将会被Go语言的垃圾自动回收器回收。</li><li>不要将关闭一个打开文件的操作和关闭一个channel操作混淆。对于每个打开的文件，都需要在不使用的时候调用对应的Close方法来关闭文件。</li></ul></li><li><p>试图重复关闭一个channel将导致panic异常，试图关闭一个nil值的channel也将导致panic异常。关闭一个channels还会触发一个广播机制，我们将在8.9节讨论。</p></li></ul></li><li><p>ch8.4.3 单方向的Channel</p><ul><li><p>随着程序的增长，人们习惯于将大的函数拆分为小的函数。我们前面的例子中使用了三个goroutine，然后用两个channels来连接它们，它们都是main函数的局部变量。将三个goroutine拆分为以下三个函数是自然的想法：</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squarer</span><span class="hljs-params">(out, in <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printer</span><span class="hljs-params">(in <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span></code></pre><ul><li><p>其中计算平方的squarer函数在两个串联Channels的中间，因此拥有两个channel类型的参数，一个用于输入一个用于输出。两个channel都拥有相同的类型，但是它们的使用方式相反：一个只用于接收，另一个只用于发送。参数的名字in和out已经明确表示了这个意图，但是并无法保证squarer函数向一个in参数对应的channel发送数据或者从一个out参数对应的channel接收数据。</p><ul><li>箭头<code>&lt;-</code>和关键字chan的相对位置表明了channel的方向。</li><li>这种限制将在编译期检测。</li></ul></li></ul></li><li><p>这种场景是典型的。当一个channel作为一个函数参数时，它一般总是被专门用于只发送或者只接收。</p></li><li><p>因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，因此对一个只接收的channel调用close将是一个编译错误。</p></li><li><p>这是改进的版本，这一次参数使用了单方向channel类型：</p><p><u><i>gopl.io/ch8/pipeline3</i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>)</span></span> &#123; <span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">100</span>; x++ &#123; out &lt;- x &#125; <span class="hljs-built_in">close</span>(out)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squarer</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>, in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123; <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> in &#123; out &lt;- v * v &#125; <span class="hljs-built_in">close</span>(out)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printer</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123; <span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> in &#123; fmt.Println(v) &#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123; naturals := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>) squares := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>) <span class="hljs-keyword">go</span> counter(naturals) <span class="hljs-keyword">go</span> squarer(squares, naturals) printer(squares)&#125;</code></pre></li><li><p>调用counter（naturals）时，naturals的类型将隐式地从chan int转换成chan&lt;- int。调用printer(squares)也会导致相似的隐式转换，这一次是转换为<code>&lt;-chan int</code>类型只接收型的channel。任何双向channel向单向channel变量的赋值操作都将导致该隐式转换。这里并没有反向转换的语法：也就是不能将一个类似<code>chan&lt;- int</code>类型的单向型的channel转换为<code>chan int</code>类型的双向型的channel。</p></li></ul></li><li><p>ch8.4.4 带缓存的Channels</p><ul><li><p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。下面的语句创建了一个可以持有三个字符串元素的带缓存Channel。图8.2是ch变量对应的channel的图形表示形式。</p><pre><code class="hljs Go">ch = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">3</span>)</code></pre></li><li><p>向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</p></li><li><p>我们可以在无阻塞的情况下连续向新创建的channel发送三个值：</p><pre><code class="hljs Go">ch &lt;- <span class="hljs-string">&quot;A&quot;</span>ch &lt;- <span class="hljs-string">&quot;B&quot;</span>ch &lt;- <span class="hljs-string">&quot;C&quot;</span></code></pre><ul><li><p>此刻，channel的内部缓存队列将是满的（图8.3），如果有第四个发送操作将发生阻塞。</p></li><li><p>如果我们接收一个值，</p><pre><code class="hljs Go">fmt.Println(&lt;-ch) <span class="hljs-comment">// &quot;A&quot;</span></code></pre></li><li><p>那么channel的缓存队列将不是满的也不是空的（图8.4），因此对该channel执行的发送或接收操作都不会发生阻塞。通过这种方式，channel的缓存队列解耦了接收和发送的goroutine。</p></li><li><p>在某些特殊情况下，程序可能需要知道channel内部缓存的容量，可以用内置的cap函数获取：</p><pre><code class="hljs Go">fmt.Println(<span class="hljs-built_in">cap</span>(ch)) <span class="hljs-comment">// &quot;3&quot;</span></code></pre></li><li><p>同样，对于内置的len函数，如果传入的是channel，那么将返回channel内部缓存队列中有效元素的个数。因为在并发程序中该信息会随着接收操作而失效，但是它对某些故障诊断和性能优化会有帮助。</p><pre><code class="hljs Go">fmt.Println(<span class="hljs-built_in">len</span>(ch)) <span class="hljs-comment">// &quot;2&quot;</span></code></pre></li><li><p>在继续执行两次接收操作后channel内部的缓存队列将又成为空的，如果有第四个接收操作将发生阻塞：</p><pre><code class="hljs Go">fmt.Println(&lt;-ch) <span class="hljs-comment">// &quot;B&quot;</span>fmt.Println(&lt;-ch) <span class="hljs-comment">// &quot;C&quot;</span></code></pre></li><li><p>在这个例子中，发送和接收操作都发生在同一个goroutine中，但是在真实的程序中它们一般由不同的goroutine执行。Go语言新手有时候会将一个带缓存的channel当作同一个goroutine中的队列使用，虽然语法看似简单，但实际上这是一个错误。Channel和goroutine的调度器机制是紧密相连的，如果没有其他goroutine从channel接收，发送者——或许是整个程序——将会面临永远阻塞的风险。如果你只是需要一个简单的队列，使用slice就可以了。</p></li></ul></li><li><p>下面的例子展示了一个使用了带缓存channel的应用。它并发地向三个镜像站点发出请求，三个镜像站点分散在不同的地理位置。它们分别将收到的响应发送到带缓存channel，最后接收者只接收第一个收到的响应，也就是最快的那个响应。因此mirroredQuery函数可能在另外两个响应慢的镜像站点响应之前就返回了结果。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mirroredQuery</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;responses := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>, <span class="hljs-number">3</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; responses &lt;- request(<span class="hljs-string">&quot;asia.gopl.io&quot;</span>) &#125;()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; responses &lt;- request(<span class="hljs-string">&quot;europe.gopl.io&quot;</span>) &#125;()<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; responses &lt;- request(<span class="hljs-string">&quot;americas.gopl.io&quot;</span>) &#125;()<span class="hljs-keyword">return</span> &lt;-responses <span class="hljs-comment">// return the quickest response</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">request</span><span class="hljs-params">(hostname <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(response <span class="hljs-keyword">string</span>)</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;</code></pre><ul><li>多个goroutines并发地向同一个channel发送数据，或从同一个channel接收数据都是常见的用法。</li></ul></li><li><p>如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住。这种情况，称为goroutines泄漏，这将是一个BUG。和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。</p></li><li><p>关于无缓存或带缓存channels之间的选择，或者是带缓存channels的容量大小的选择，都可能影响程序的正确性。无缓存channel更强地保证了每个发送操作与相应的同步接收操作；但是对于带缓存channel，这些操作是解耦的。同样，即使我们知道将要发送到一个channel的信息的数量上限，创建一个对应容量大小的带缓存channel也是不现实的，因为这要求在执行任何接收操作之前缓存所有已经发送的值。如果未能分配足够的缓存将导致程序死锁。</p></li><li><p>Channel的缓存也可能影响程序的性能。想象一家蛋糕店有三个厨师，一个烘焙，一个上糖衣，还有一个将每个蛋糕传递到它下一个厨师的生产线。在狭小的厨房空间环境，每个厨师在完成蛋糕后必须等待下一个厨师已经准备好接受它；这类似于在一个无缓存的channel上进行沟通。</p></li><li><p>如果在每个厨师之间有一个放置一个蛋糕的额外空间，那么每个厨师就可以将一个完成的蛋糕临时放在那里而马上进入下一个蛋糕的制作中；这类似于将channel的缓存队列的容量设置为1。只要每个厨师的平均工作效率相近，那么其中大部分的传输工作将是迅速的，个体之间细小的效率差异将在交接过程中弥补。如果厨师之间有更大的额外空间——也是就更大容量的缓存队列——将可以在不停止生产线的前提下消除更大的效率波动，例如一个厨师可以短暂地休息，然后再加快赶上进度而不影响其他人。</p></li><li><p>另一方面，如果生产线的前期阶段一直快于后续阶段，那么它们之间的缓存在大部分时间都将是满的。相反，如果后续阶段比前期阶段更快，那么它们之间的缓存在大部分时间都将是空的。对于这类场景，额外的缓存并没有带来任何好处。</p></li><li><p>生产线的隐喻对于理解channels和goroutines的工作机制是很有帮助的。例如，如果第二阶段是需要精心制作的复杂操作，一个厨师可能无法跟上第一个厨师的进度，或者是无法满足第三阶段厨师的需求。要解决这个问题，我们可以再雇佣另一个厨师来帮助完成第二阶段的工作，他执行相同的任务但是独立工作。这类似于基于相同的channels创建另一个独立的goroutine。</p></li><li><p>我们没有太多的空间展示全部细节，但是gopl.io/ch8/cake包模拟了这个蛋糕店，可以通过不同的参数调整。它还对上面提到的几种场景提供对应的基准测试（§11.4） 。</p></li></ul></li></ul><h3 id="ch8-5-并发的循环"><a href="#ch8-5-并发的循环" class="headerlink" title="ch8.5   并发的循环"></a>ch8.5   并发的循环</h3><ul><li><p>本节中，我们会探索一些用来在并行时循环迭代的常见并发模型。我们会探究从全尺寸图片生成一些缩略图的问题。gopl.io/ch8/thumbnail包提供了ImageFile函数来帮我们拉伸图片。我们不会说明这个函数的实现，只需要从gopl.io下载它。</p><p><u><i>gopl.io/ch8/thumbnail</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> thumbnail<span class="hljs-comment">// ImageFile reads an image from infile and writes</span><span class="hljs-comment">// a thumbnail-size version of it in the same directory.</span><span class="hljs-comment">// It returns the generated file name, e.g., &quot;foo.thumb.jpg&quot;.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ImageFile</span><span class="hljs-params">(infile <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span></code></pre></li><li><p>下面的程序会循环迭代一些图片文件名，并为每一张图片生成一个缩略图：</p><p><u><i>gopl.io/ch8/thumbnail</i></u></p><pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails makes thumbnails of the specified files.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails</span><span class="hljs-params">(filenames []<span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<span class="hljs-keyword">if</span> _, err := thumbnail.ImageFile(f); err != <span class="hljs-literal">nil</span> &#123;log.Println(err)&#125;&#125;&#125;</code></pre></li><li><p>显然我们处理文件的顺序无关紧要，因为每一个图片的拉伸操作和其它图片的处理操作都是彼此独立的。像这种子问题都是完全彼此独立的问题被叫做易并行embarrassingly parallel问题，易并行问题是最容易被实现成并行的一类问题，并且最能够享受到并发带来的好处，能够随着并行的规模线性地扩展。</p></li><li><p>下面让我们并行地执行这些操作，从而将文件IO的延迟隐藏掉，并用上多核cpu的计算能力来拉伸图像。我们的第一个并发程序只是使用了一个go关键字。这里我们先忽略掉错误，之后再进行处理。</p><pre><code class="hljs go"><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails2</span><span class="hljs-params">(filenames []<span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<span class="hljs-keyword">go</span> thumbnail.ImageFile(f) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring errors</span>&#125;&#125;</code></pre><ul><li>这个版本运行的实在有点太快，实际上，由于它比最早的版本使用的时间要短得多，即使当文件名的slice中只包含有一个元素。这就有点奇怪了，如果程序没有并发执行的话，那为什么一个并发的版本还是要快呢？</li><li>答案其实是makeThumbnails在它还没有完成工作之前就已经返回了。它启动了所有的goroutine，每一个文件名对应一个，但没有等待它们一直到执行完毕。</li></ul></li><li><p>没有什么直接的办法能够等待goroutine完成，但是我们可以改变goroutine里的代码让其能够将完成情况报告给外部的goroutine知晓，使用的方式是向一个共享的channel中发送事件。因为我们已经确切地知道有len(filenames)个内部goroutine，所以外部的goroutine只需要在返回之前对这些事件计数。</p><pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails3 makes thumbnails of the specified files in parallel.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails3</span><span class="hljs-params">(filenames []<span class="hljs-keyword">string</span>)</span></span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-keyword">string</span>)</span></span> &#123;thumbnail.ImageFile(f) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring errors</span>ch &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;&#125;(f)&#125;<span class="hljs-comment">// Wait for goroutines to complete.</span><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> filenames &#123;&lt;-ch&#125;&#125;</code></pre><ul><li><p>注意我们将f的值作为一个显式的变量传给了函数，而不是在循环的闭包中声明：</p><pre><code class="hljs go"><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;thumbnail.ImageFile(f) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect!</span><span class="hljs-comment">// ...</span>&#125;()&#125;</code></pre></li></ul></li><li><p>回忆一下之前在5.6.1节中，匿名函数中的循环变量快照问题。上面这个单独的变量f是被所有的匿名函数值所共享，且会被连续的循环迭代所更新的。当新的goroutine开始执行字面函数时，for循环可能已经更新了f并且开始了另一轮的迭代或者（更有可能的）已经结束了整个循环，所以当这些goroutine开始读取f的值时，它们所看到的值已经是slice的最后一个元素了。显式地添加这个参数，我们能够确保使用的f是当go语句执行时的“当前”那个f。</p></li><li><p>如果我们想要从每一个worker goroutine往主goroutine中返回值时该怎么办呢？当我们调用thumbnail.ImageFile创建文件失败的时候，它会返回一个错误。下一个版本的makeThumbnails会返回其在做拉伸操作时接收到的第一个错误：</p><pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails4 makes thumbnails for the specified files in parallel.</span><span class="hljs-comment">// It returns an error if any step failed.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails4</span><span class="hljs-params">(filenames []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;errors := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> error)<span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-keyword">string</span>)</span></span> &#123;_, err := thumbnail.ImageFile(f)errors &lt;- err&#125;(f)&#125;<span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> filenames &#123;<span class="hljs-keyword">if</span> err := &lt;-errors; err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> incorrect: goroutine leak!</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><ul><li>这个程序有一个微妙的bug。当它遇到第一个非nil的error时会直接将error返回到调用方，使得没有一个goroutine去排空errors channel。这样剩下的worker goroutine在向这个channel中发送值时，都会永远地阻塞下去，并且永远都不会退出。这种情况叫做goroutine泄露（§8.4.4），可能会导致整个程序卡住或者跑出out of memory的错误。</li><li>最简单的解决办法就是用一个具有合适大小的buffered channel，这样这些worker goroutine向channel中发送错误时就不会被阻塞。（一个可选的解决办法是创建一个另外的goroutine，当main goroutine返回第一个错误的同时去排空channel。）</li></ul></li><li><p>下一个版本的makeThumbnails使用了一个buffered channel来返回生成的图片文件的名字，附带生成时的错误。</p><pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails5 makes thumbnails for the specified files in parallel.</span><span class="hljs-comment">// It returns the generated file names in an arbitrary order,</span><span class="hljs-comment">// or an error if any step failed.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails5</span><span class="hljs-params">(filenames []<span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(thumbfiles []<span class="hljs-keyword">string</span>, err error)</span></span> &#123;<span class="hljs-keyword">type</span> item <span class="hljs-keyword">struct</span> &#123;thumbfile <span class="hljs-keyword">string</span>err       error&#125;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> item, <span class="hljs-built_in">len</span>(filenames))<span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> filenames &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">var</span> it itemit.thumbfile, it.err = thumbnail.ImageFile(f)ch &lt;- it&#125;(f)&#125;<span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> filenames &#123;it := &lt;-ch<span class="hljs-keyword">if</span> it.err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, it.err&#125;thumbfiles = <span class="hljs-built_in">append</span>(thumbfiles, it.thumbfile)&#125;<span class="hljs-keyword">return</span> thumbfiles, <span class="hljs-literal">nil</span>&#125;</code></pre><ul><li>我们最后一个版本的makeThumbnails返回了新文件们的大小总计数（bytes）。和前面的版本都不一样的一点是我们在这个版本里没有把文件名放在slice里，而是通过一个string的channel传过来，所以我们无法对循环的次数进行预测。</li></ul></li><li><p>为了知道最后一个goroutine什么时候结束（最后一个结束并不一定是最后一个开始），我们需要一个递增的计数器，在每一个goroutine启动时加一，在goroutine退出时减一。这需要一种特殊的计数器，这个计数器需要在多个goroutine操作时做到安全并且提供在其减为零之前一直等待的一种方法。这种计数类型被称为sync.WaitGroup，下面的代码就用到了这种方法：</p><pre><code class="hljs go"><span class="hljs-comment">// makeThumbnails6 makes thumbnails for each file received from the channel.</span><span class="hljs-comment">// It returns the number of bytes occupied by the files it creates.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeThumbnails6</span><span class="hljs-params">(filenames &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int64</span></span> &#123;sizes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int64</span>)<span class="hljs-keyword">var</span> wg sync.WaitGroup <span class="hljs-comment">// number of working goroutines</span><span class="hljs-keyword">for</span> f := <span class="hljs-keyword">range</span> filenames &#123;wg.Add(<span class="hljs-number">1</span>)<span class="hljs-comment">// worker</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(f <span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> wg.Done()thumb, err := thumbnail.ImageFile(f)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Println(err)<span class="hljs-keyword">return</span>&#125;info, _ := os.Stat(thumb) <span class="hljs-comment">// OK to ignore error</span>sizes &lt;- info.Size()&#125;(f)&#125;<span class="hljs-comment">// closer</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;wg.Wait()<span class="hljs-built_in">close</span>(sizes)&#125;()<span class="hljs-keyword">var</span> total <span class="hljs-keyword">int64</span><span class="hljs-keyword">for</span> size := <span class="hljs-keyword">range</span> sizes &#123;total += size&#125;<span class="hljs-keyword">return</span> total&#125;</code></pre><ul><li>注意Add和Done方法的不对称。Add是为计数器加一，必须在worker goroutine开始之前调用，而不是在goroutine中；否则的话我们没办法确定Add是在”closer” goroutine调用Wait之前被调用。并且Add还有一个参数，但Done却没有任何参数；其实它和Add(-1)是等价的。我们使用defer来确保计数器即使是在出错的情况下依然能够正确地被减掉。上面的程序代码结构是当我们使用并发循环，但又不知道迭代次数时很通常而且很地道的写法。</li><li>sizes channel携带了每一个文件的大小到main goroutine，在main goroutine中使用了range loop来计算总和。观察一下我们是怎样创建一个closer goroutine，并让其在所有worker goroutine们结束之后再关闭sizes channel的。两步操作：wait和close，必须是基于sizes的循环的并发。考虑一下另一种方案：如果等待操作被放在了main goroutine中，在循环之前，这样的话就永远都不会结束了，如果在循环之后，那么又变成了不可达的部分，因为没有任何东西去关闭这个channel，这个循环就永远都不会终止。</li></ul></li></ul><h3 id="ch8-6-示例：并发的Web爬虫"><a href="#ch8-6-示例：并发的Web爬虫" class="headerlink" title="ch8.6   示例：并发的Web爬虫"></a>ch8.6   示例：并发的Web爬虫</h3><ul><li><p>在5.6节中，我们做了一个简单的web爬虫，用bfs(广度优先)算法来抓取整个网站。在本节中，我们会让这个爬虫并行化，这样每一个彼此独立的抓取命令可以并行进行IO，最大化利用网络资源。crawl函数和gopl.io/ch5/findlinks3中的是一样的。</p><p><u><i>gopl.io/ch8/crawl1</i></u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawl</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;fmt.Println(url)list, err := links.Extract(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Print(err)&#125;<span class="hljs-keyword">return</span> list&#125;</code></pre></li><li><p>主函数和5.6节中的breadthFirst(广度优先)类似。像之前一样，一个worklist是一个记录了需要处理的元素的队列，每一个元素都是一个需要抓取的URL列表，不过这一次我们用channel代替slice来做这个队列。每一个对crawl的调用都会在他们自己的goroutine中进行并且会把他们抓到的链接发送回worklist。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;worklist := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">string</span>)<span class="hljs-comment">// Start with the command-line arguments.</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- os.Args[<span class="hljs-number">1</span>:] &#125;()<span class="hljs-comment">// Crawl the web concurrently.</span>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)<span class="hljs-keyword">for</span> list := <span class="hljs-keyword">range</span> worklist &#123;<span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> list &#123;<span class="hljs-keyword">if</span> !seen[link] &#123;seen[link] = <span class="hljs-literal">true</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(link <span class="hljs-keyword">string</span>)</span></span> &#123;worklist &lt;- crawl(link)&#125;(link)&#125;&#125;&#125;&#125;</code></pre></li><li><p>注意这里的crawl所在的goroutine会将link作为一个显式的参数传入，来避免“循环变量快照”的问题（在5.6.1中有讲解）。另外注意这里将命令行参数传入worklist也是在一个另外的goroutine中进行的，这是为了避免channel两端的main goroutine与crawler goroutine都尝试向对方发送内容，却没有一端接收内容时发生死锁。当然，这里我们也可以用buffered channel来解决问题，这里不再赘述。</p></li><li><p>现在爬虫可以高并发地运行起来，并且可以产生一大堆的URL了，不过还是会有俩问题。一个问题是在运行一段时间后可能会出现在log的错误信息里的：</p><pre><code class="hljs awk">$ go build gopl.io<span class="hljs-regexp">/ch8/</span>crawl1$ .<span class="hljs-regexp">/crawl1 http:/</span><span class="hljs-regexp">/gopl.io/</span>http:<span class="hljs-regexp">//g</span>opl.io/https:<span class="hljs-regexp">//g</span>olang.org<span class="hljs-regexp">/help/</span>https:<span class="hljs-regexp">//g</span>olang.org<span class="hljs-regexp">/doc/</span>https:<span class="hljs-regexp">//g</span>olang.org<span class="hljs-regexp">/blog/</span>...<span class="hljs-number">2015</span><span class="hljs-regexp">/07/</span><span class="hljs-number">15</span> <span class="hljs-number">18</span>:<span class="hljs-number">22</span>:<span class="hljs-number">12</span> Get ...: dial tcp: lookup blog.golang.org: no such host<span class="hljs-number">2015</span><span class="hljs-regexp">/07/</span><span class="hljs-number">15</span> <span class="hljs-number">18</span>:<span class="hljs-number">22</span>:<span class="hljs-number">12</span> Get ...: dial tcp <span class="hljs-number">23.21</span>.<span class="hljs-number">222.120</span>:<span class="hljs-number">443</span>: socket: too many open files...</code></pre></li><li><p>最初的错误信息是一个让人莫名的DNS查找失败，即使这个域名是完全可靠的。而随后的错误信息揭示了原因：这个程序一次性创建了太多网络连接，超过了每一个进程的打开文件数限制，既而导致了在调用net.Dial像DNS查找失败这样的问题。</p></li><li><p>这个程序实在是太并行了。无穷无尽地并行化并不是什么好事情，因为不管怎么说，你的系统总是会有一些个限制因素，比如CPU核心数会限制你的计算负载，比如你的硬盘转轴和磁头数限制了你的本地磁盘IO操作频率，比如你的网络带宽限制了你的下载速度上限，或者是你的一个web服务的服务容量上限等等。</p><ul><li>为了解决这个问题，我们可以限制并发程序所使用的资源来使之适应自己的运行环境。对于我们的例子来说，最简单的方法就是限制对links.Extract在同一时间最多不会有超过n次调用，这里的n一般小于文件描述符的上限值，比如20。这和一个夜店里限制客人数目是一个道理，只有当有客人离开时，才会允许新的客人进入店内。</li><li>我们可以用一个有容量限制的buffered channel来控制并发，这类似于操作系统里的计数信号量概念。从概念上讲，channel里的n个空槽代表n个可以处理内容的token（通行证），从channel里接收一个值会释放其中的一个token，并且生成一个新的空槽位。这样保证了在没有接收介入时最多有n个发送操作。（这里可能我们拿channel里填充的槽来做token更直观一些，不过还是这样吧。）由于channel里的元素类型并不重要，我们用一个零值的struct{}来作为其元素。</li></ul></li><li><p>让我们重写crawl函数，将对links.Extract的调用操作用获取、释放token的操作包裹起来，来确保同一时间对其只有20个调用。信号量数量和其能操作的IO资源数量应保持接近。</p><p><u><i>gopl.io/ch8/crawl2</i></u></p><pre><code class="hljs go"><span class="hljs-comment">// tokens is a counting semaphore used to</span><span class="hljs-comment">// enforce a limit of 20 concurrent requests.</span><span class="hljs-keyword">var</span> tokens = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">20</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawl</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;fmt.Println(url)tokens &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125; <span class="hljs-comment">// acquire a token</span>list, err := links.Extract(url)&lt;-tokens <span class="hljs-comment">// release the token</span><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Print(err)&#125;<span class="hljs-keyword">return</span> list&#125;</code></pre><ul><li><p>第二个问题是这个程序永远都不会终止，即使它已经爬到了所有初始链接衍生出的链接。（当然，除非你慎重地选择了合适的初始化URL或者已经实现了练习8.6中的深度限制，你应该还没有意识到这个问题。）为了使这个程序能够终止，我们需要在worklist为空或者没有crawl的goroutine在运行时退出主循环。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;worklist := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">string</span>)<span class="hljs-keyword">var</span> n <span class="hljs-keyword">int</span> <span class="hljs-comment">// number of pending sends to worklist</span><span class="hljs-comment">// Start with the command-line arguments.</span>n++<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- os.Args[<span class="hljs-number">1</span>:] &#125;()<span class="hljs-comment">// Crawl the web concurrently.</span>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)<span class="hljs-keyword">for</span> ; n &gt; <span class="hljs-number">0</span>; n-- &#123;list := &lt;-worklist<span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> list &#123;<span class="hljs-keyword">if</span> !seen[link] &#123;seen[link] = <span class="hljs-literal">true</span>n++<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(link <span class="hljs-keyword">string</span>)</span></span> &#123;worklist &lt;- crawl(link)&#125;(link)&#125;&#125;&#125;&#125;</code></pre></li><li><p>这个版本中，计数器n对worklist的发送操作数量进行了限制。每一次我们发现有元素需要被发送到worklist时，我们都会对n进行++操作，在向worklist中发送初始的命令行参数之前，我们也进行过一次++操作。这里的操作++是在每启动一个crawler的goroutine之前。主循环会在n减为0时终止，这时候说明没活可干了。</p></li><li><p>现在这个并发爬虫会比5.6节中的深度优先搜索版快上20倍，而且不会出什么错，并且在其完成任务时也会正确地终止。</p></li></ul></li><li><p>下面的程序是避免过度并发的另一种思路。这个版本使用了原来的crawl函数，但没有使用计数信号量，取而代之用了20个常驻的crawler goroutine，这样来保证最多20个HTTP请求在并发。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;worklist := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">string</span>)  <span class="hljs-comment">// lists of URLs, may have duplicates</span>unseenLinks := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>) <span class="hljs-comment">// de-duplicated URLs</span><span class="hljs-comment">// Add command-line arguments to worklist.</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- os.Args[<span class="hljs-number">1</span>:] &#125;()<span class="hljs-comment">// Create 20 crawler goroutines to fetch each unseen link.</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> link := <span class="hljs-keyword">range</span> unseenLinks &#123;foundLinks := crawl(link)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; worklist &lt;- foundLinks &#125;()&#125;&#125;()&#125;<span class="hljs-comment">// The main goroutine de-duplicates worklist items</span><span class="hljs-comment">// and sends the unseen ones to the crawlers.</span>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)<span class="hljs-keyword">for</span> list := <span class="hljs-keyword">range</span> worklist &#123;<span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> list &#123;<span class="hljs-keyword">if</span> !seen[link] &#123;seen[link] = <span class="hljs-literal">true</span>unseenLinks &lt;- link&#125;&#125;&#125;&#125;</code></pre><ul><li>所有的爬虫goroutine现在都是被同一个channel - unseenLinks喂饱的了。主goroutine负责拆分它从worklist里拿到的元素，然后把没有抓过的经由unseenLinks channel发送给一个爬虫的goroutine。</li><li>seen这个map被限定在main goroutine中；也就是说这个map只能在main goroutine中进行访问。类似于其它的信息隐藏方式，这样的约束可以让我们从一定程度上保证程序的正确性。</li><li>例如，内部变量不能够在函数外部被访问到；变量（§2.3.4）在没有发生变量逃逸（译注：局部变量被全局变量引用地址导致变量被分配在堆上）的情况下是无法在函数外部访问的；一个对象的封装字段无法被该对象的方法以外的方法访问到。在所有的情况下，信息隐藏都可以帮助我们约束我们的程序，使其不发生意料之外的情况。</li><li>crawl函数爬到的链接在一个专有的goroutine中被发送到worklist中来避免死锁。为了节省篇幅，这个例子的终止问题我们先不进行详细阐述了。</li></ul></li></ul><h3 id="ch8-7-基于select的多路复用"><a href="#ch8-7-基于select的多路复用" class="headerlink" title="ch8.7   基于select的多路复用"></a>ch8.7   基于select的多路复用</h3><ul><li><p>下面的程序会进行火箭发射的倒计时。time.Tick函数返回一个channel，程序会周期性地像一个节拍器一样向这个channel发送事件。每一个事件的值是一个时间戳，不过更有意思的是其传送方式。</p><p><u><i>gopl.io/ch8/countdown1</i></u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(<span class="hljs-string">&quot;Commencing countdown.&quot;</span>)tick := time.Tick(<span class="hljs-number">1</span> * time.Second)<span class="hljs-keyword">for</span> countdown := <span class="hljs-number">10</span>; countdown &gt; <span class="hljs-number">0</span>; countdown-- &#123;fmt.Println(countdown)&lt;-tick&#125;launch()&#125;</code></pre><p>现在我们让这个程序支持在倒计时中，用户按下</p></li><li><p>现在我们让这个程序支持在倒计时中，用户按下return键时直接中断发射流程。首先，我们启动一个goroutine，这个goroutine会尝试从标准输入中读入一个单独的byte并且，如果成功了，会向名为abort的channel发送一个值。</p><p><u><i>gopl.io/ch8/countdown2</i></u></p><pre><code class="hljs go">abort := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;os.Stdin.Read(<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">1</span>)) <span class="hljs-comment">// read a single byte</span>abort &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;&#125;()</code></pre></li><li><p>现在每一次计数循环的迭代都需要等待两个channel中的其中一个返回事件了：当一切正常时的ticker channel（就像NASA jorgon的”nominal”，译注：这梗估计我们是不懂了）或者异常时返回的abort事件。我们无法做到从每一个channel中接收信息，如果我们这么做的话，如果第一个channel中没有事件发过来那么程序就会立刻被阻塞，这样我们就无法收到第二个channel中发过来的事件。这时候我们需要多路复用（multiplex）这些操作了，为了能够多路复用，我们使用了select语句。</p><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-ch1:<span class="hljs-comment">// ...</span><span class="hljs-keyword">case</span> x := &lt;-ch2:<span class="hljs-comment">// ...use x...</span><span class="hljs-keyword">case</span> ch3 &lt;- y:<span class="hljs-comment">// ...</span><span class="hljs-keyword">default</span>:<span class="hljs-comment">// ...</span>&#125;</code></pre></li><li><p>上面是select语句的一般形式。和switch语句稍微有点相似，也会有几个case和最后的default选择分支。每一个case代表一个通信操作（在某个channel上进行发送或者接收），并且会包含一些语句组成的一个语句块。一个接收表达式可能只包含接收表达式自身（译注：不把接收到的值赋值给变量什么的），就像上面的第一个case，或者包含在一个简短的变量声明中，像第二个case里一样；第二种形式让你能够引用接收到的值。</p></li><li><p>select会等待case中有能够执行的case时去执行。当条件满足时，select才会去通信并执行case之后的语句；这时候其它通信是不会执行的。一个没有任何case的select语句写作select{}，会永远地等待下去。</p></li><li><p>让我们回到我们的火箭发射程序。time.After函数会立即返回一个channel，并起一个新的goroutine在经过特定的时间后向该channel发送一个独立的值。下面的select语句会一直等待直到两个事件中的一个到达，无论是abort事件或者一个10秒经过的事件。如果10秒经过了还没有abort事件进入，那么火箭就会发射。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// ...create abort channel...</span>fmt.Println(<span class="hljs-string">&quot;Commencing countdown.  Press return to abort.&quot;</span>)<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">10</span> * time.Second):<span class="hljs-comment">// Do nothing.</span><span class="hljs-keyword">case</span> &lt;-abort:fmt.Println(<span class="hljs-string">&quot;Launch aborted!&quot;</span>)<span class="hljs-keyword">return</span>&#125;launch()&#125;</code></pre></li><li><p>下面这个例子更微妙。ch这个channel的buffer大小是1，所以会交替的为空或为满，所以只有一个case可以进行下去，无论i是奇数或者偶数，它都会打印0 2 4 6 8。</p><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> x := &lt;-ch:fmt.Println(x) <span class="hljs-comment">// &quot;0&quot; &quot;2&quot; &quot;4&quot; &quot;6&quot; &quot;8&quot;</span><span class="hljs-keyword">case</span> ch &lt;- i:&#125;&#125;</code></pre></li><li><p>如果多个case同时就绪时，select会随机地选择一个执行，这样来保证每一个channel都有平等的被select的机会。增加前一个例子的buffer大小会使其输出变得不确定，因为当buffer既不为满也不为空时，select语句的执行情况就像是抛硬币的行为一样是随机的。</p></li><li><p>下面让我们的发射程序打印倒计时。这里的select语句会使每次循环迭代等待一秒来执行退出操作。</p><p><u><i>gopl.io/ch8/countdown3</i></u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// ...create abort channel...</span>fmt.Println(<span class="hljs-string">&quot;Commencing countdown.  Press return to abort.&quot;</span>)tick := time.Tick(<span class="hljs-number">1</span> * time.Second)<span class="hljs-keyword">for</span> countdown := <span class="hljs-number">10</span>; countdown &gt; <span class="hljs-number">0</span>; countdown-- &#123;fmt.Println(countdown)<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-tick:<span class="hljs-comment">// Do nothing.</span><span class="hljs-keyword">case</span> &lt;-abort:fmt.Println(<span class="hljs-string">&quot;Launch aborted!&quot;</span>)<span class="hljs-keyword">return</span>&#125;&#125;launch()&#125;</code></pre><ul><li><p>time.Tick函数表现得好像它创建了一个在循环中调用time.Sleep的goroutine，每次被唤醒时发送一个事件。当countdown函数返回时，它会停止从tick中接收事件，但是ticker这个goroutine还依然存活，继续徒劳地尝试向channel中发送值，然而这时候已经没有其它的goroutine会从该channel中接收值了——这被称为goroutine泄露（§8.4.4）。</p></li><li><p>Tick函数挺方便，但是只有当程序整个生命周期都需要这个时间时我们使用它才比较合适。否则的话，我们应该使用下面的这种模式：</p><pre><code class="hljs go">ticker := time.NewTicker(<span class="hljs-number">1</span> * time.Second)&lt;-ticker.C    <span class="hljs-comment">// receive from the ticker&#x27;s channel</span>ticker.Stop() <span class="hljs-comment">// cause the ticker&#x27;s goroutine to terminate</span></code></pre></li></ul></li><li><p>有时候我们希望能够从channel中发送或者接收值，并避免因为发送或者接收导致的阻塞，尤其是当channel没有准备好写或者读时。select语句就可以实现这样的功能。select会有一个default来设置当其它的操作都不能够马上被处理时程序需要执行哪些逻辑。</p><ul><li><p>下面的select语句会在abort channel中有值时，从其中接收值；无值时什么都不做。这是一个非阻塞的接收操作；反复地做这样的操作叫做“轮询channel”。</p><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-abort:fmt.Printf(<span class="hljs-string">&quot;Launch aborted!\n&quot;</span>)<span class="hljs-keyword">return</span><span class="hljs-keyword">default</span>:<span class="hljs-comment">// do nothing</span>&#125;</code></pre></li><li><p>channel的零值是nil。也许会让你觉得比较奇怪，nil的channel有时候也是有一些用处的。因为对一个nil的channel发送和接收操作会永远阻塞，在select语句中操作nil的channel永远都不会被select到。</p></li><li><p>这使得我们可以用nil来激活或者禁用case，来达成处理其它输入或输出事件时超时和取消的逻辑。我们会在下一节中看到一个例子。</p></li></ul></li></ul><h3 id="ch8-8-示例：并发的字典遍历"><a href="#ch8-8-示例：并发的字典遍历" class="headerlink" title="ch8.8   示例：并发的字典遍历"></a>ch8.8   示例：并发的字典遍历</h3><ul><li><p>在本小节中，我们会创建一个程序来生成指定目录的硬盘使用情况报告，这个程序和Unix里的du工具比较相似。大多数工作用下面这个walkDir函数来完成，这个函数使用dirents函数来枚举一个目录下的所有入口。</p><p><u><i>gopl.io/ch8/du1</i></u></p><pre><code class="hljs go"><span class="hljs-comment">// walkDir recursively walks the file tree rooted at dir</span><span class="hljs-comment">// and sends the size of each found file on fileSizes.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkDir</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>, fileSizes <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int64</span>)</span></span> &#123;<span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> dirents(dir) &#123;<span class="hljs-keyword">if</span> entry.IsDir() &#123;subdir := filepath.Join(dir, entry.Name())walkDir(subdir, fileSizes)&#125; <span class="hljs-keyword">else</span> &#123;fileSizes &lt;- entry.Size()&#125;&#125;&#125;<span class="hljs-comment">// dirents returns the entries of directory dir.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dirents</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">os</span>.<span class="hljs-title">FileInfo</span></span> &#123;entries, err := ioutil.ReadDir(dir)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;du1: %v\n&quot;</span>, err)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> entries&#125;</code></pre></li><li><p>ioutil.ReadDir函数会返回一个os.FileInfo类型的slice，os.FileInfo类型也是os.Stat这个函数的返回值。对每一个子目录而言，walkDir会递归地调用其自身，同时也在递归里获取每一个文件的信息。walkDir函数会向fileSizes这个channel发送一条消息。这条消息包含了文件的字节大小。</p></li><li><p>下面的主函数，用了两个goroutine。后台的goroutine调用walkDir来遍历命令行给出的每一个路径并最终关闭fileSizes这个channel。主goroutine会对其从channel中接收到的文件大小进行累加，并输出其和。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;flag&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io/ioutil&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;path/filepath&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// Determine the initial directories.</span>flag.Parse()roots := flag.Args()<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(roots) == <span class="hljs-number">0</span> &#123;roots = []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;.&quot;</span>&#125;&#125;<span class="hljs-comment">// Traverse the file tree.</span>fileSizes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int64</span>)<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> _, root := <span class="hljs-keyword">range</span> roots &#123;walkDir(root, fileSizes)&#125;<span class="hljs-built_in">close</span>(fileSizes)&#125;()<span class="hljs-comment">// Print the results.</span><span class="hljs-keyword">var</span> nfiles, nbytes <span class="hljs-keyword">int64</span><span class="hljs-keyword">for</span> size := <span class="hljs-keyword">range</span> fileSizes &#123;nfiles++nbytes += size&#125;printDiskUsage(nfiles, nbytes)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printDiskUsage</span><span class="hljs-params">(nfiles, nbytes <span class="hljs-keyword">int64</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;%d files  %.1f GB\n&quot;</span>, nfiles, <span class="hljs-keyword">float64</span>(nbytes)/<span class="hljs-number">1e9</span>)&#125;</code></pre><ul><li><p>这个程序会在打印其结果之前卡住很长时间。</p><pre><code class="hljs awk">$ go build gopl.io<span class="hljs-regexp">/ch8/</span>du1$ .<span class="hljs-regexp">/du1 $HOME /u</span>sr <span class="hljs-regexp">/bin /</span>etc<span class="hljs-number">213201</span> files  <span class="hljs-number">62.7</span> GB</code></pre></li></ul></li><li><p>如果在运行的时候能够让我们知道处理进度的话想必更好。但是，如果简单地把printDiskUsage函数调用移动到循环里会导致其打印出成百上千的输出。</p></li><li><p>下面这个du的变种会间歇打印内容，不过只有在调用时提供了-v的flag才会显示程序进度信息。在roots目录上循环的后台goroutine在这里保持不变。主goroutine现在使用了计时器来每500ms生成事件，然后用select语句来等待文件大小的消息来更新总大小数据，或者一个计时器的事件来打印当前的总大小数据。如果-v的flag在运行时没有传入的话，tick这个channel会保持为nil，这样在select里的case也就相当于被禁用了。</p><p><u><i>gopl.io/ch8/du2</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">var</span> verbose = flag.Bool(<span class="hljs-string">&quot;v&quot;</span>, <span class="hljs-literal">false</span>, <span class="hljs-string">&quot;show verbose progress messages&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// ...start background goroutine...</span><span class="hljs-comment">// Print the results periodically.</span><span class="hljs-keyword">var</span> tick &lt;-<span class="hljs-keyword">chan</span> time.Time<span class="hljs-keyword">if</span> *verbose &#123;tick = time.Tick(<span class="hljs-number">500</span> * time.Millisecond)&#125;<span class="hljs-keyword">var</span> nfiles, nbytes <span class="hljs-keyword">int64</span>loop:<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> size, ok := &lt;-fileSizes:<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">break</span> loop <span class="hljs-comment">// fileSizes was closed</span>&#125;nfiles++nbytes += size<span class="hljs-keyword">case</span> &lt;-tick:printDiskUsage(nfiles, nbytes)&#125;&#125;printDiskUsage(nfiles, nbytes) <span class="hljs-comment">// final totals</span>&#125;</code></pre><ul><li><p>由于我们的程序不再使用range循环，第一个select的case必须显式地判断fileSizes的channel是不是已经被关闭了，这里可以用到channel接收的二值形式。如果channel已经被关闭了的话，程序会直接退出循环。这里的break语句用到了标签break，这样可以同时终结select和for两个循环；如果没有用标签就break的话只会退出内层的select循环，而外层的for循环会使之进入下一轮select循环。</p></li><li><p>现在程序会悠闲地为我们打印更新流：</p><pre><code class="hljs angelscript">$ go build gopl.io/ch8/du2$ ./du2 -v $HOME /usr /bin /etc<span class="hljs-number">28608</span> files  <span class="hljs-number">8.3</span> GB<span class="hljs-number">54147</span> files  <span class="hljs-number">10.3</span> GB<span class="hljs-number">93591</span> files  <span class="hljs-number">15.1</span> GB<span class="hljs-number">127169</span> files  <span class="hljs-number">52.9</span> GB<span class="hljs-number">175931</span> files  <span class="hljs-number">62.2</span> GB<span class="hljs-number">213201</span> files  <span class="hljs-number">62.7</span> GB</code></pre></li></ul></li><li><p>然而这个程序还是会花上很长时间才会结束。完全可以并发调用walkDir，从而发挥磁盘系统的并行性能。下面这个第三个版本的du，会对每一个walkDir的调用创建一个新的goroutine。它使用sync.WaitGroup（§8.5）来对仍旧活跃的walkDir调用进行计数，另一个goroutine会在计数器减为零的时候将fileSizes这个channel关闭。</p><p><u><i>gopl.io/ch8/du3</i></u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// ...determine roots...</span><span class="hljs-comment">// Traverse each root of the file tree in parallel.</span>fileSizes := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int64</span>)<span class="hljs-keyword">var</span> n sync.WaitGroup<span class="hljs-keyword">for</span> _, root := <span class="hljs-keyword">range</span> roots &#123;n.Add(<span class="hljs-number">1</span>)<span class="hljs-keyword">go</span> walkDir(root, &amp;n, fileSizes)&#125;<span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;n.Wait()<span class="hljs-built_in">close</span>(fileSizes)&#125;()<span class="hljs-comment">// ...select loop...</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkDir</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>, n *sync.WaitGroup, fileSizes <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int64</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> n.Done()<span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> dirents(dir) &#123;<span class="hljs-keyword">if</span> entry.IsDir() &#123;n.Add(<span class="hljs-number">1</span>)subdir := filepath.Join(dir, entry.Name())<span class="hljs-keyword">go</span> walkDir(subdir, n, fileSizes)&#125; <span class="hljs-keyword">else</span> &#123;fileSizes &lt;- entry.Size()&#125;&#125;&#125;</code></pre></li><li><p>由于这个程序在高峰期会创建成百上千的goroutine，我们需要修改dirents函数，用计数信号量来阻止他同时打开太多的文件，就像我们在8.7节中的并发爬虫一样</p><pre><code class="hljs go"><span class="hljs-comment">// sema is a counting semaphore for limiting concurrency in dirents.</span><span class="hljs-keyword">var</span> sema = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;, <span class="hljs-number">20</span>)<span class="hljs-comment">// dirents returns the entries of directory dir.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dirents</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">os</span>.<span class="hljs-title">FileInfo</span></span> &#123;sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;        <span class="hljs-comment">// acquire token</span><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; &lt;-sema &#125;() <span class="hljs-comment">// release token</span><span class="hljs-comment">// ...</span></code></pre></li><li><p>这个版本比之前那个快了好几倍，尽管其具体效率还是和你的运行环境，机器配置相关。</p></li></ul><h3 id="ch8-9-并发的退出"><a href="#ch8-9-并发的退出" class="headerlink" title="ch8.9   并发的退出"></a>ch8.9   并发的退出</h3><ul><li><p>有时候我们需要通知goroutine停止它正在干的事情，比如一个正在执行计算的web服务，然而它的客户端已经断开了和服务端的连接。</p></li><li><p>Go语言并没有提供在一个goroutine中终止另一个goroutine的方法，由于这样会导致goroutine之间的共享变量落在未定义的状态上。在8.7节中的rocket launch程序中，我们往名字叫abort的channel里发送了一个简单的值，在countdown的goroutine中会把这个值理解为自己的退出信号。但是如果我们想要退出两个或者任意多个goroutine怎么办呢？</p></li><li><p>一种可能的手段是向abort的channel里发送和goroutine数目一样多的事件来退出它们。如果这些goroutine中已经有一些自己退出了，那么会导致我们的channel里的事件数比goroutine还多，这样导致我们的发送直接被阻塞。</p></li><li><p>另一方面，如果这些goroutine又生成了其它的goroutine，我们的channel里的数目又太少了，所以有些goroutine可能会无法接收到退出消息。一般情况下我们是很难知道在某一个时刻具体有多少个goroutine在运行着的。另外，当一个goroutine从abort channel中接收到一个值的时候，他会消费掉这个值，这样其它的goroutine就没法看到这条信息。为了能够达到我们退出goroutine的目的，我们需要更靠谱的策略，来通过一个channel把消息广播出去，这样goroutine们能够看到这条事件消息，并且在事件完成之后，可以知道这件事已经发生过了。</p></li><li><p>回忆一下我们关闭了一个channel并且被消费掉了所有已发送的值，操作channel之后的代码可以立即被执行，并且会产生零值。我们可以将这个机制扩展一下，来作为我们的广播机制：不要向channel发送值，而是用关闭一个channel来进行广播。</p></li><li><p>只要一些小修改，我们就可以把退出逻辑加入到前一节的du程序。首先，我们创建一个退出的channel，不需要向这个channel发送任何值，但其所在的闭包内要写明程序需要退出。我们同时还定义了一个工具函数，cancelled，这个函数在被调用的时候会轮询退出状态。</p><p><u><i>gopl.io/ch8/du4</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">var</span> done = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">cancelled</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-done:<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><span class="hljs-keyword">default</span>:<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;</code></pre></li><li><p>下面我们创建一个从标准输入流中读取内容的goroutine，这是一个比较典型的连接到终端的程序。每当有输入被读到（比如用户按了回车键），这个goroutine就会把取消消息通过关闭done的channel广播出去。</p><pre><code class="hljs go"><span class="hljs-comment">// Cancel traversal when input is detected.</span><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;os.Stdin.Read(<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">1</span>)) <span class="hljs-comment">// read a single byte</span><span class="hljs-built_in">close</span>(done)&#125;()</code></pre></li><li><p>现在我们需要使我们的goroutine来对取消进行响应。在main goroutine中，我们添加了select的第三个case语句，尝试从done channel中接收内容。如果这个case被满足的话，在select到的时候即会返回，但在结束之前我们需要把fileSizes channel中的内容“排”空，在channel被关闭之前，舍弃掉所有值。这样可以保证对walkDir的调用不要被向fileSizes发送信息阻塞住，可以正确地完成。</p><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> &lt;-done:<span class="hljs-comment">// Drain fileSizes to allow existing goroutines to finish.</span><span class="hljs-keyword">for</span> <span class="hljs-keyword">range</span> fileSizes &#123;<span class="hljs-comment">// Do nothing.</span>&#125;<span class="hljs-keyword">return</span><span class="hljs-keyword">case</span> size, ok := &lt;-fileSizes:<span class="hljs-comment">// ...</span>&#125;&#125;</code></pre></li><li><p>walkDir这个goroutine一启动就会轮询取消状态，如果取消状态被设置的话会直接返回，并且不做额外的事情。这样我们将所有在取消事件之后创建的goroutine改变为无操作。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">walkDir</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>, n *sync.WaitGroup, fileSizes <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int64</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> n.Done()<span class="hljs-keyword">if</span> cancelled() &#123;<span class="hljs-keyword">return</span>&#125;<span class="hljs-keyword">for</span> _, entry := <span class="hljs-keyword">range</span> dirents(dir) &#123;<span class="hljs-comment">// ...</span>&#125;&#125;</code></pre></li><li><p>在walkDir函数的循环中我们对取消状态进行轮询可以带来明显的益处，可以避免在取消事件发生时还去创建goroutine。取消本身是有一些代价的；想要快速的响应需要对程序逻辑进行侵入式的修改。确保在取消发生之后不要有代价太大的操作可能会需要修改你代码里的很多地方，但是在一些重要的地方去检查取消事件也确实能带来很大的好处。</p></li><li><p>对这个程序的一个简单的性能分析可以揭示瓶颈在dirents函数中获取一个信号量。下面的select可以让这种操作可以被取消，并且可以将取消时的延迟从几百毫秒降低到几十毫秒。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">dirents</span><span class="hljs-params">(dir <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">os</span>.<span class="hljs-title">FileInfo</span></span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> sema &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;: <span class="hljs-comment">// acquire token</span><span class="hljs-keyword">case</span> &lt;-done:<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">// cancelled</span>&#125;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; &lt;-sema &#125;() <span class="hljs-comment">// release token</span><span class="hljs-comment">// ...read directory...</span>&#125;</code></pre></li><li><p>现在当取消发生时，所有后台的goroutine都会迅速停止并且主函数会返回。当然，当主函数返回时，一个程序会退出，而我们又无法在主函数退出的时候确认其已经释放了所有的资源</p><ul><li>因为程序都退出了，你的代码都没法执行了</li></ul></li><li><p>这里有一个方便的窍门我们可以一用：取代掉直接从主函数返回，我们调用一个panic，然后runtime会把每一个goroutine的栈dump下来。</p></li><li><p>如果main goroutine是唯一一个剩下的goroutine的话，他会清理掉自己的一切资源。但是如果还有其它的goroutine没有退出，他们可能没办法被正确地取消掉，也有可能被取消但是取消操作会很花时间；所以这里的一个调研还是很有必要的。我们用panic来获取到足够的信息来验证我们上面的判断，看看最终到底是什么样的情况。</p></li></ul><h3 id="ch8-10-示例：聊天服务"><a href="#ch8-10-示例：聊天服务" class="headerlink" title="ch8.10  示例：聊天服务"></a>ch8.10  示例：聊天服务</h3><ul><li><p>我们用一个聊天服务器来终结本章节的内容，这个程序可以让一些用户通过服务器向其它所有用户广播文本消息。这个程序中有四种goroutine。main和broadcaster各自是一个goroutine实例，每一个客户端的连接都会有一个handleConn和clientWriter的goroutine。broadcaster是select用法的不错的样例，因为它需要处理三种不同类型的消息。</p></li><li><p>下面演示的main goroutine的工作，是listen和accept(译注：网络编程里的概念)从客户端过来的连接。对每一个连接，程序都会建立一个新的handleConn的goroutine，就像我们在本章开头的并发的echo服务器里所做的那样。</p><p><u><i>gopl.io/ch8/chat</i></u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-keyword">go</span> broadcaster()<span class="hljs-keyword">for</span> &#123;conn, err := listener.Accept()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Print(err)<span class="hljs-keyword">continue</span>&#125;<span class="hljs-keyword">go</span> handleConn(conn)&#125;&#125;</code></pre></li><li><p>然后是broadcaster的goroutine。他的内部变量clients会记录当前建立连接的客户端集合。其记录的内容是每一个客户端的消息发出channel的“资格”信息。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> client <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">string</span> <span class="hljs-comment">// an outgoing message channel</span><span class="hljs-keyword">var</span> (entering = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)leaving  = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> client)messages = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>) <span class="hljs-comment">// all incoming client messages</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">broadcaster</span><span class="hljs-params">()</span></span> &#123;clients := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[client]<span class="hljs-keyword">bool</span>) <span class="hljs-comment">// all connected clients</span><span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">select</span> &#123;<span class="hljs-keyword">case</span> msg := &lt;-messages:<span class="hljs-comment">// Broadcast incoming message to all</span><span class="hljs-comment">// clients&#x27; outgoing message channels.</span><span class="hljs-keyword">for</span> cli := <span class="hljs-keyword">range</span> clients &#123;cli &lt;- msg&#125;<span class="hljs-keyword">case</span> cli := &lt;-entering:clients[cli] = <span class="hljs-literal">true</span><span class="hljs-keyword">case</span> cli := &lt;-leaving:<span class="hljs-built_in">delete</span>(clients, cli)<span class="hljs-built_in">close</span>(cli)&#125;&#125;&#125;</code></pre><ul><li>broadcaster监听来自全局的entering和leaving的channel来获知客户端的到来和离开事件。当其接收到其中的一个事件时，会更新clients集合，当该事件是离开行为时，它会关闭客户端的消息发送channel。</li><li>broadcaster也会监听全局的消息channel，所有的客户端都会向这个channel中发送消息。当broadcaster接收到什么消息时，就会将其广播至所有连接到服务端的客户端。</li></ul></li><li><p>现在让我们看看每一个客户端的goroutine。handleConn函数会为它的客户端创建一个消息发送channel并通过entering channel来通知客户端的到来。然后它会读取客户端发来的每一行文本，并通过全局的消息channel来将这些文本发送出去，并为每条消息带上发送者的前缀来标明消息身份。当客户端发送完毕后，handleConn会通过leaving这个channel来通知客户端的离开并关闭连接。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>) <span class="hljs-comment">// outgoing client messages</span><span class="hljs-keyword">go</span> clientWriter(conn, ch)who := conn.RemoteAddr().String()ch &lt;- <span class="hljs-string">&quot;You are &quot;</span> + whomessages &lt;- who + <span class="hljs-string">&quot; has arrived&quot;</span>entering &lt;- chinput := bufio.NewScanner(conn)<span class="hljs-keyword">for</span> input.Scan() &#123;messages &lt;- who + <span class="hljs-string">&quot;: &quot;</span> + input.Text()&#125;<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors from input.Err()</span>leaving &lt;- chmessages &lt;- who + <span class="hljs-string">&quot; has left&quot;</span>conn.Close()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">clientWriter</span><span class="hljs-params">(conn net.Conn, ch &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">for</span> msg := <span class="hljs-keyword">range</span> ch &#123;fmt.Fprintln(conn, msg) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring network errors</span>&#125;&#125;</code></pre><ul><li>另外，handleConn为每一个客户端创建了一个clientWriter的goroutine，用来接收向客户端发送消息的channel中的广播消息，并将它们写入到客户端的网络连接。客户端的读取循环会在broadcaster接收到leaving通知并关闭了channel后终止。</li></ul></li><li><p>下面演示的是当服务器有两个活动的客户端连接，并且在两个窗口中运行的情况，使用netcat来聊天：</p><pre><code class="hljs angelscript">$ go build gopl.io/ch8/chat$ go build gopl.io/ch8/netcat3$ ./chat &amp;$ ./netcat3You are <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64208</span>               $ ./netcat3<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span> has arrived           You are <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span>Hi!<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64208</span>: Hi!                  <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64208</span>: Hi!                                      Hi yourself.<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span>: Hi yourself.         <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span>: Hi yourself.^C                                      <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64208</span> has left$ ./netcat3You are <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64216</span>               <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64216</span> has arrived                                      Welcome.<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span>: Welcome.             <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span>: Welcome.                                      ^C<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">64211</span> has left”</code></pre></li><li><p>当与n个客户端保持聊天session时，这个程序会有2n+2个并发的goroutine，然而这个程序却并不需要显式的锁（§9.2）。clients这个map被限制在了一个独立的goroutine broadcaster中，所以它不能被并发地访问。多个goroutine共享的变量只有这些channel和net.Conn的实例，两个东西都是并发安全的。我们会在下一章中更多地讲解约束，并发安全以及goroutine中共享变量的含义。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Go Programming Language（8）- goroutine</title>
    <link href="/2020/11/22/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%888%EF%BC%89-%20goroutine/"/>
    <url>/2020/11/22/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%888%EF%BC%89-%20goroutine/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="The-Go-Programming-Language（8"><a href="#The-Go-Programming-Language（8" class="headerlink" title="The Go Programming Language（8)"></a>The Go Programming Language（8)</h1><h3 id="源码、PDF版、Markdown、xmind版下载链接"><a href="#源码、PDF版、Markdown、xmind版下载链接" class="headerlink" title="源码、PDF版、Markdown、xmind版下载链接"></a>源码、PDF版、Markdown、xmind版下载链接</h3><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://<span class="hljs-number">1</span>tnt<span class="hljs-number">1</span>.lanzous.com/b<span class="hljs-number">00</span>o<span class="hljs-number">36</span>ytc</code></pre><p>密码：</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span>ch0</code></pre><hr><h2 id="ch8-Goroutines和Channels"><a href="#ch8-Goroutines和Channels" class="headerlink" title="ch8  Goroutines和Channels"></a>ch8  Goroutines和Channels</h2><h3 id="ch8-0-简介"><a href="#ch8-0-简介" class="headerlink" title="ch8.0   简介"></a>ch8.0   简介</h3><ul><li><p>并发程序指同时进行多个任务的程序，随着硬件的发展，并发程序变得越来越重要。</p><ul><li>Web服务器会一次处理成千上万的请求。平板电脑和手机app在渲染用户画面同时还会后台执行各种计算任务和网络请求。</li></ul></li><li><p>即使是传统的批处理问题——读取数据、计算、写输出，现在也会用并发来隐藏掉I/O的操作延迟以充分利用现代计算机设备的多个核心。计算机的性能每年都在以非线性的速度增长。</p></li><li><p>Go语言中的并发程序可以用两种手段来实现</p><ul><li>本章讲解goroutine和channel，其支持“顺序通信进程”（communicating sequential processes）或被简称为CSP。</li><li>CSP是一种现代的并发编程模型，在这种编程模型中值会在不同的运行实例（goroutine）中传递，尽管大多数情况下仍然是被限制在单一实例中。</li><li>第9章覆盖更为传统的并发模型：多线程共享内存，如果你在其它的主流语言中写过并发程序的话可能会更熟悉一些。第9章也会深入介绍一些并发程序带来的风险和陷阱。</li></ul></li><li><p>尽管Go对并发的支持是众多强力特性之一，但跟踪调试并发程序还是很困难，在线性程序中形成的直觉往往还会使我们误入歧途。如果这是读者第一次接触并发，推荐稍微多花一些时间来思考这两个章节中的样例。</p></li></ul><h3 id="ch8-1Goroutines"><a href="#ch8-1Goroutines" class="headerlink" title="ch8.1Goroutines"></a>ch8.1Goroutines</h3><ul><li><p>在Go语言中，每一个并发的执行单元叫作一个goroutine。设想这里的一个程序有两个函数，一个函数做计算，另一个输出结果，假设两个函数没有相互之间的调用关系。一个线性的程序会先调用其中的一个函数，然后再调用另一个。如果程序中包含多个goroutine，对两个函数的调用则可能发生在同一时刻。马上就会看到这样的一个程序。</p></li><li><p>如果你使用过操作系统或者其它语言提供的线程，那么你可以简单地把goroutine类比作一个线程，这样你就可以写出一些正确的程序了。goroutine和线程的本质区别会在9.8节中讲。</p></li><li><p>当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。</p><pre><code class="hljs go">f()    <span class="hljs-comment">// call f(); wait for it to return</span><span class="hljs-keyword">go</span> f() <span class="hljs-comment">// create a new goroutine that calls f(); don&#x27;t wait</span></code></pre></li><li><p>下面的例子，main goroutine将计算菲波那契数列的第45个元素值。由于计算函数使用低效的递归，所以会运行相当长时间，在此期间我们想让用户看到一个可见的标识来表明程序依然在正常运行，所以来做一个动画的小图标：</p><p><u><i>gopl.io/ch8/spinner</i><u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">go</span> spinner(<span class="hljs-number">100</span> * time.Millisecond)<span class="hljs-keyword">const</span> n = <span class="hljs-number">45</span>fibN := fib(n) <span class="hljs-comment">// slow</span>fmt.Printf(<span class="hljs-string">&quot;\rFibonacci(%d) = %d\n&quot;</span>, n, fibN)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">spinner</span><span class="hljs-params">(delay time.Duration)</span></span> &#123;<span class="hljs-keyword">for</span> &#123;<span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> <span class="hljs-string">`-\|/`</span> &#123;fmt.Printf(<span class="hljs-string">&quot;\r%c&quot;</span>, r)time.Sleep(delay)&#125;&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fib</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> x &lt; <span class="hljs-number">2</span> &#123;<span class="hljs-keyword">return</span> x&#125;<span class="hljs-keyword">return</span> fib(x<span class="hljs-number">-1</span>) + fib(x<span class="hljs-number">-2</span>)&#125;</code></pre><ul><li><p>动画显示了几秒之后，fib(45)的调用成功地返回，并且打印结果：</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-number">45</span>)</span></span> = <span class="hljs-number">1134903170</span></code></pre></li></ul></li><li><p>然后主函数返回。主函数返回时，所有的goroutine都会被直接打断，程序退出。除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行，但是之后可以看到一种方式来实现这个目的，通过goroutine之间的通信来让一个goroutine请求其它的goroutine，并让被请求的goroutine自行结束执行。</p></li><li><p>留意一下这里的两个独立的单元是如何进行组合的，spinning和菲波那契的计算。分别在独立的函数中，但两个函数会同时执行。</p></li></ul><h3 id="ch8-2-示例：并发的Clock服务"><a href="#ch8-2-示例：并发的Clock服务" class="headerlink" title="ch8.2   示例：并发的Clock服务"></a>ch8.2   示例：并发的Clock服务</h3><ul><li><p>网络编程是并发大显身手的一个领域，由于服务器是最典型的需要同时处理很多连接的程序，这些连接一般来自于彼此独立的客户端。</p></li><li><p>在本小节中，我们会讲解go语言的net包，这个包提供编写一个网络客户端或者服务器程序的基本组件，无论两者间通信是使用TCP、UDP或者Unix domain sockets。在第一章中我们使用过的net/http包里的方法，也算是net包的一部分。</p></li><li><p>我们的第一个例子是一个顺序执行的时钟服务器，它会每隔一秒钟将当前时间写到客户端：</p><p><u><i>gopl.io/ch8/clock1</i></u></p><pre><code class="hljs go"><span class="hljs-comment">// Clock1 is a TCP server that periodically writes the time.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;net&quot;</span><span class="hljs-string">&quot;time&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;listener, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-keyword">for</span> &#123;conn, err := listener.Accept()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Print(err) <span class="hljs-comment">// e.g., connection aborted</span><span class="hljs-keyword">continue</span>&#125;handleConn(conn) <span class="hljs-comment">// handle one connection at a time</span>&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(c net.Conn)</span></span> &#123;<span class="hljs-keyword">defer</span> c.Close()<span class="hljs-keyword">for</span> &#123;_, err := io.WriteString(c, time.Now().Format(<span class="hljs-string">&quot;15:04:05\n&quot;</span>))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-comment">// e.g., client disconnected</span>&#125;time.Sleep(<span class="hljs-number">1</span> * time.Second)&#125;&#125;</code></pre><ul><li>Listen函数创建了一个net.Listener的对象，这个对象会监听一个网络端口上到来的连接，在这个例子里我们用的是TCP的localhost:8000端口。listener对象的Accept方法会直接阻塞，直到一个新的连接被创建，然后会返回一个net.Conn对象来表示这个连接。</li><li>handleConn函数会处理一个完整的客户端连接。在一个for死循环中，用time.Now()获取当前时刻，然后写到客户端。由于net.Conn实现了io.Writer接口，我们可以直接向其写入内容。这个死循环会一直执行，直到写入失败。最可能的原因是客户端主动断开连接。这种情况下handleConn函数会用defer调用关闭服务器侧的连接，然后返回到主函数，继续等待下一个连接请求。</li></ul></li><li><p>time.Time.Format方法提供了一种格式化日期和时间信息的方式。它的参数是一个格式化模板，标识如何来格式化时间，而这个格式化模板限定为Mon Jan 2 03:04:05PM 2006 UTC-0700。有8个部分（周几、月份、一个月的第几天……）。可以以任意的形式来组合前面这个模板；出现在模板中的部分会作为参考来对时间格式进行输出。</p><ul><li><p>在上面的例子中我们只用到了小时、分钟和秒。time包里定义了很多标准时间格式，比如time.RFC1123。在进行格式化的逆向操作time.Parse时，也会用到同样的策略。</p></li><li><p>这是go语言和其它语言相比比较奇葩的一个地方。你需要记住格式化字符串是1月2日下午3点4分5秒零六年UTC-0700，而不像其它语言那样Y-m-d H:i:s一样，当然了这里可以用1234567的方式来记忆，倒是也不麻烦。</p></li><li><p>为了连接例子里的服务器，我们需要一个客户端程序，比如netcat这个工具（nc命令），这个工具可以用来执行网络连接操作。</p><pre><code class="hljs angelscript">$ go build gopl.io/ch8/clock1$ ./clock1 &amp;$ nc localhost <span class="hljs-number">8000</span><span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">54</span><span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">55</span><span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">56</span><span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">57</span>^C</code></pre></li><li><p>客户端将服务器发来的时间显示了出来，我们用Control+C来中断客户端的执行，在Unix系统上，你会看到^C这样的响应。如果你的系统没有装nc这个工具，你可以用telnet来实现同样的效果，或者也可以用我们下面的这个用go写的简单的telnet程序，用net.Dial就可以简单地创建一个TCP连接：</p><p><u><i>gopl.io/ch8/netcat1</i></u></p><pre><code class="hljs go"><span class="hljs-comment">// Netcat1 is a read-only TCP client.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;net&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-keyword">defer</span> conn.Close()mustCopy(os.Stdout, conn)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mustCopy</span><span class="hljs-params">(dst io.Writer, src io.Reader)</span></span> &#123;<span class="hljs-keyword">if</span> _, err := io.Copy(dst, src); err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;&#125;</code></pre></li><li><p>这个程序会从连接中读取数据，并将读到的内容写到标准输出中，直到遇到end of file的条件或者发生错误。mustCopy这个函数我们在本节的几个例子中都会用到。让我们同时运行两个客户端来进行一个测试，这里可以开两个终端窗口，下面左边的是其中的一个的输出，右边的是另一个的输出：</p><pre><code class="hljs angelscript">$ go build gopl.io/ch8/netcat1$ ./netcat1<span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">54</span>                               $ ./netcat1<span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">55</span><span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">56</span>^C                                       <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">57</span>                                       <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">58</span>                                       <span class="hljs-number">13</span>:<span class="hljs-number">58</span>:<span class="hljs-number">59</span>                                       ^C$ killall clock1</code></pre></li><li><p>killall命令是一个Unix命令行工具，可以用给定的进程名来杀掉所有名字匹配的进程。</p></li></ul></li><li><p>第二个客户端必须等待第一个客户端完成工作，这样服务端才能继续向后执行；因为我们这里的服务器程序同一时间只能处理一个客户端连接。我们这里对服务端程序做一点小改动，使其支持并发：在handleConn函数调用的地方增加go关键字，让每一次handleConn的调用都进入一个独立的goroutine。</p><p><u><i>gopl.io/ch8/clock2</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;conn, err := listener.Accept()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Print(err) <span class="hljs-comment">// e.g., connection aborted</span><span class="hljs-keyword">continue</span>&#125;<span class="hljs-keyword">go</span> handleConn(conn) <span class="hljs-comment">// handle connections concurrently</span>&#125;</code></pre><ul><li><p>现在多个客户端可以同时接收到时间了：</p><pre><code class="hljs angelscript">$ go build gopl.io/ch8/clock2$ ./clock2 &amp;$ go build gopl.io/ch8/netcat1$ ./netcat1<span class="hljs-number">14</span>:<span class="hljs-number">02</span>:<span class="hljs-number">54</span>                               $ ./netcat1<span class="hljs-number">14</span>:<span class="hljs-number">02</span>:<span class="hljs-number">55</span>                               <span class="hljs-number">14</span>:<span class="hljs-number">02</span>:<span class="hljs-number">55</span><span class="hljs-number">14</span>:<span class="hljs-number">02</span>:<span class="hljs-number">56</span>                               <span class="hljs-number">14</span>:<span class="hljs-number">02</span>:<span class="hljs-number">56</span><span class="hljs-number">14</span>:<span class="hljs-number">02</span>:<span class="hljs-number">57</span>                               ^C<span class="hljs-number">14</span>:<span class="hljs-number">02</span>:<span class="hljs-number">58</span><span class="hljs-number">14</span>:<span class="hljs-number">02</span>:<span class="hljs-number">59</span>                               $ ./netcat1<span class="hljs-number">14</span>:<span class="hljs-number">03</span>:<span class="hljs-number">00</span>                               <span class="hljs-number">14</span>:<span class="hljs-number">03</span>:<span class="hljs-number">00</span><span class="hljs-number">14</span>:<span class="hljs-number">03</span>:<span class="hljs-number">01</span>                               <span class="hljs-number">14</span>:<span class="hljs-number">03</span>:<span class="hljs-number">01</span>^C                                     <span class="hljs-number">14</span>:<span class="hljs-number">03</span>:<span class="hljs-number">02</span>                                       ^C$ killall clock2</code></pre></li></ul></li></ul><h3 id="ch8-3-示例：并发的Echo服务"><a href="#ch8-3-示例：并发的Echo服务" class="headerlink" title="ch8.3   示例：并发的Echo服务"></a>ch8.3   示例：并发的Echo服务</h3><ul><li><p>clock服务器每一个连接都会起一个goroutine。在本节中我们会创建一个echo服务器，这个服务在每个连接中会有多个goroutine。大多数echo服务仅仅会返回他们读取到的内容，就像下面这个简单的handleConn函数所做的一样：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(c net.Conn)</span></span> &#123;io.Copy(c, c) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring errors</span>c.Close()&#125;</code></pre></li><li><p>一个更有意思的echo服务应该模拟一个实际的echo的“回响”，并且一开始要用大写HELLO来表示“声音很大”，之后经过一小段延迟返回一个有所缓和的Hello，然后一个全小写字母的hello表示声音渐渐变小直至消失，像下面这个版本的handleConn</p><p><u><i>gopl.io/ch8/reverb1</i></u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">echo</span><span class="hljs-params">(c net.Conn, shout <span class="hljs-keyword">string</span>, delay time.Duration)</span></span> &#123;fmt.Fprintln(c, <span class="hljs-string">&quot;\t&quot;</span>, strings.ToUpper(shout))time.Sleep(delay)fmt.Fprintln(c, <span class="hljs-string">&quot;\t&quot;</span>, shout)time.Sleep(delay)fmt.Fprintln(c, <span class="hljs-string">&quot;\t&quot;</span>, strings.ToLower(shout))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(c net.Conn)</span></span> &#123;input := bufio.NewScanner(c)<span class="hljs-keyword">for</span> input.Scan() &#123;echo(c, input.Text(), <span class="hljs-number">1</span>*time.Second)&#125;<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors from input.Err()</span>c.Close()&#125;</code></pre></li><li><p>我们需要升级我们的客户端程序，这样它就可以发送终端的输入到服务器，并把服务端的返回输出到终端上，这使我们有了使用并发的另一个好机会：</p><p><u><i>gopl.io/ch8/netcat2</i></u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;localhost:8000&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-keyword">defer</span> conn.Close()<span class="hljs-keyword">go</span> mustCopy(os.Stdout, conn)mustCopy(conn, os.Stdin)&#125;</code></pre></li><li><p>当main goroutine从标准输入流中读取内容并将其发送给服务器时，另一个goroutine会读取并打印服务端的响应。当main goroutine碰到输入终止时，例如，用户在终端中按了Control-D(^D)，在windows上是Control-Z，这时程序就会被终止，尽管其它goroutine中还有进行中的任务。（在8.4.1中引入了channels后我们会明白如何让程序等待两边都结束。）</p></li><li><p>下面这个会话中，客户端的输入是左对齐的，服务端的响应会用缩进来区别显示。</p></li><li><p>客户端会向服务器“喊三次话”：</p><pre><code class="hljs n1ql">$ go <span class="hljs-keyword">build</span> gopl.io/ch8/reverb1$ ./reverb1 &amp;$ go <span class="hljs-keyword">build</span> gopl.io/ch8/netcat2$ ./netcat2Hello?    HELLO?    Hello?    hello?<span class="hljs-keyword">Is</span> there anybody there?    <span class="hljs-keyword">IS</span> THERE ANYBODY THERE?Yooo-hooo!    <span class="hljs-keyword">Is</span> there anybody there?    <span class="hljs-keyword">is</span> there anybody there?    YOOO-HOOO!    Yooo-hooo!    yooo-hooo!^D$ killall reverb1</code></pre></li><li><p>注意客户端的第三次shout在前一个shout处理完成之前一直没有被处理，这貌似看起来不是特别“现实”。真实世界里的回响应该是会由三次shout的回声组合而成的。为了模拟真实世界的回响，我们需要更多的goroutine来做这件事情。这样我们就再一次地需要go这个关键词了，这次我们用它来调用echo：</p><p><u><i>gopl.io/ch8/reverb2</i></u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">handleConn</span><span class="hljs-params">(c net.Conn)</span></span> &#123;input := bufio.NewScanner(c)<span class="hljs-keyword">for</span> input.Scan() &#123;<span class="hljs-keyword">go</span> echo(c, input.Text(), <span class="hljs-number">1</span>*time.Second)&#125;<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring potential errors from input.Err()</span>c.Close()&#125;</code></pre><ul><li><p>go后跟的函数的参数会在go语句自身执行时被求值；因此input.Text()会在main goroutine中被求值。</p></li><li><p>现在回响是并发并且会按时间来覆盖掉其它响应了：</p><pre><code class="hljs n1ql">$ go <span class="hljs-keyword">build</span> gopl.io/ch8/reverb2$ ./reverb2 &amp;$ ./netcat2<span class="hljs-keyword">Is</span> there anybody there?    <span class="hljs-keyword">IS</span> THERE ANYBODY THERE?Yooo-hooo!    <span class="hljs-keyword">Is</span> there anybody there?    YOOO-HOOO!    <span class="hljs-keyword">is</span> there anybody there?    Yooo-hooo!    yooo-hooo!^D$ killall reverb2</code></pre></li></ul></li><li><p>让服务使用并发不只是处理多个客户端的请求，甚至在处理单个连接时也可能会用到，就像我们上面的两个go关键词的用法。然而在我们使用go关键词的同时，需要慎重地考虑net.Conn中的方法在并发地调用时是否安全，事实上对于大多数类型来说也确实不安全。我们会在下一章中详细地探讨并发安全性。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Go Programming Language（6-7）</title>
    <link href="/2020/11/21/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%886-7%EF%BC%89/"/>
    <url>/2020/11/21/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%886-7%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Go-Programming-Language（6-7）"><a href="#The-Go-Programming-Language（6-7）" class="headerlink" title="The Go Programming Language（6-7）"></a>The Go Programming Language（6-7）</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="本文为Go语言编程圣经中文版内容，本人在阅读时将其制作为思维导图及博客文章形式，仅供学习，若侵权请及时与我联系。"><a href="#本文为Go语言编程圣经中文版内容，本人在阅读时将其制作为思维导图及博客文章形式，仅供学习，若侵权请及时与我联系。" class="headerlink" title="本文为Go语言编程圣经中文版内容，本人在阅读时将其制作为思维导图及博客文章形式，仅供学习，若侵权请及时与我联系。"></a>本文为Go语言编程圣经中文版内容，本人在阅读时将其制作为思维导图及博客文章形式，仅供学习，若侵权请及时与我联系。</h3><h3 id="源码、PDF版、Markdown、xmind版下载链接"><a href="#源码、PDF版、Markdown、xmind版下载链接" class="headerlink" title="源码、PDF版、Markdown、xmind版下载链接"></a>源码、PDF版、Markdown、xmind版下载链接</h3><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://<span class="hljs-number">1</span>tnt<span class="hljs-number">1</span>.lanzous.com/b<span class="hljs-number">00</span>o<span class="hljs-number">36</span>ytc</code></pre><p>密码：</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span>ch0</code></pre><hr><h2 id="ch6-方法"><a href="#ch6-方法" class="headerlink" title="ch6  方法"></a>ch6  方法</h2><h3 id="ch6-0-简介"><a href="#ch6-0-简介" class="headerlink" title="ch6.0   简介"></a>ch6.0   简介</h3><ul><li><p>从90年代早期开始，面向对象编程（OOP）就成为了称霸工程界和教育界的编程范式，所以之后几乎所有大规模被应用的语言都包含了对OOP的支持，go语言也不例外。</p></li><li><p>尽管没有被大众所接受的明确的OOP的定义，从我们的理解来讲，一个对象其实也就是一个简单的值或者一个变量，在这个对象中会包含一些方法，而一个方法则是一个一个和特殊类型关联的函数。</p><ul><li><p>一个面向对象的程序会用方法来表达其属性和对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。</p></li><li><p>在早些的章节中，我们已经使用了标准库提供的一些方法，比如time.Duration这个类型的Seconds方法</p><pre><code class="hljs Go"><span class="hljs-keyword">const</span> day = <span class="hljs-number">24</span> * time.Hourfmt.Println(day.Seconds()) <span class="hljs-comment">// &quot;86400&quot;</span></code></pre></li><li><p>并且在2.5节中，我们定义了一个自己的方法，Celsius类型的String方法:</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Celsius)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123; <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g°C&quot;</span>, c) &#125;</code></pre></li></ul></li><li><p>在本章中，OOP编程的第一方面，我们会向你展示如何有效地定义和使用方法。我们会覆盖到OOP编程的两个关键点，封装和组合。</p></li></ul><h3 id="ch6-1-方法声明"><a href="#ch6-1-方法声明" class="headerlink" title="ch6.1   方法声明"></a>ch6.1   方法声明</h3><ul><li><p>在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。</p><ul><li><p>下面来写我们第一个方法的例子，这个例子在package geometry下：</p><p><u><i>gopl.io/ch6/geometry</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> geometry<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;math&quot;</span><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-keyword">float64</span> &#125;<span class="hljs-comment">// traditional function</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Distance</span><span class="hljs-params">(p, q Point)</span> <span class="hljs-title">float64</span></span> &#123;<span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)&#125;<span class="hljs-comment">// same thing, but as a method of the Point type</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Point)</span> <span class="hljs-title">Distance</span><span class="hljs-params">(q Point)</span> <span class="hljs-title">float64</span></span> &#123;<span class="hljs-keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)&#125;</code></pre></li><li><p>上面的代码里那个附加的参数p，叫做方法的接收器（receiver），早期的面向对象语言留下的遗产将调用一个方法称为“向一个对象发送消息”。</p></li></ul></li><li><p>在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。</p><ul><li>这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。</li></ul></li><li><p>在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前。</p><ul><li><p>下面是例子：</p><pre><code class="hljs Go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;fmt.Println(Distance(p, q)) <span class="hljs-comment">// &quot;5&quot;, function call</span>fmt.Println(p.Distance(q))  <span class="hljs-comment">// &quot;5&quot;, method call</span></code></pre></li><li><p>可以看到，上面的两个函数调用都是Distance，但是却没有发生冲突</p><ul><li>第一个Distance的调用实际上用的是包级别的函数geometry.Distance</li><li>而第二个则是使用刚刚声明的Point，调用的是Point类下声明的Point.Distance方法。</li><li>这种p.Distance的表达式叫做选择器，因为他会选择合适的对应p这个对象的Distance方法来执行。</li><li>选择器也会被用来选择一个struct类型的字段，比如p.X。由于方法和字段都是在同一命名空间，所以如果我们在这里声明一个X方法的话，编译器会报错，因为在调用p.X时会有歧义（译注：这里确实挺奇怪的）。</li></ul></li></ul></li><li><p>因为每种类型都有其方法的命名空间，我们在用Distance这个名字的时候，不同的Distance调用指向了不同类型里的Distance方法。让我们来定义一个Path类型，这个Path代表一个线段的集合，并且也给这个Path定义一个叫Distance的方法。</p><pre><code class="hljs Go"><span class="hljs-comment">// A Path is a journey connecting the points with straight lines.</span><span class="hljs-keyword">type</span> Path []Point<span class="hljs-comment">// Distance returns the distance traveled along the path.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(path Path)</span> <span class="hljs-title">Distance</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> &#123;sum := <span class="hljs-number">0.0</span><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> path &#123;<span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;sum += path[i<span class="hljs-number">-1</span>].Distance(path[i])&#125;&#125;<span class="hljs-keyword">return</span> sum&#125;</code></pre><ul><li>Path是一个命名的slice类型，而不是Point那样的struct类型，然而我们依然可以为它定义方法。</li><li>在能够给任意类型定义方法这一点上，Go和很多其它的面向对象的语言不太一样。因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。</li><li>我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型不是指针或者interface。</li><li>译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型</li></ul></li><li><p>两个Distance方法有不同的类型。他们两个方法之间没有任何关系，尽管Path的Distance方法会在内部调用Point.Distance方法来计算每个连接邻接点的线段的长度。</p><ul><li><p>让我们来调用一个新方法，计算三角形的周长：</p><pre><code class="hljs Go">perim := Path&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;,&#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;,&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;,&#125;fmt.Println(perim.Distance()) <span class="hljs-comment">// &quot;12&quot;</span></code></pre></li><li><p>在上面两个对Distance名字的方法的调用中，编译器会根据方法的名字以及接收器来决定具体调用的是哪一个函数。</p></li><li><p>第一个例子中path[i-1]数组中的类型是Point，因此Point.Distance这个方法被调用；在第二个例子中perim的类型是Path，因此Distance调用的是Path.Distance。</p></li></ul></li><li><p>对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名</p><ul><li><p>比如我们这里Point和Path就都有Distance这个名字的方法；所以我们没有必要非在方法名之前加类型名来消除歧义，比如PathDistance。</p></li><li><p>这里我们已经看到了方法比之函数的一些好处：方法名可以简短。</p></li><li><p>当我们在包外调用的时候这种好处就会被放大，因为我们可以使用这个短名字，而可以省略掉包的名字，下面是例子：</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;gopl.io/ch6/geometry&quot;</span>perim := geometry.Path&#123;&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;&#125;fmt.Println(geometry.PathDistance(perim)) <span class="hljs-comment">// &quot;12&quot;, standalone function</span>fmt.Println(perim.Distance())             <span class="hljs-comment">// &quot;12&quot;, method of geometry.Path</span></code></pre></li><li><p><strong>译注：</strong> 如果我们要用方法去计算perim的distance，还需要去写全geometry的包名，和其函数名，但是因为Path这个类型定义了一个可以直接用的Distance方法，所以我们可以直接写perim.Distance()。相当于可以少打很多字，作者应该是这个意思。因为在Go里包外调用函数需要带上包名，还是挺麻烦的。</p></li></ul></li></ul><h3 id="ch6-2-基于指针对象的方法"><a href="#ch6-2-基于指针对象的方法" class="headerlink" title="ch6.2   基于指针对象的方法"></a>ch6.2   基于指针对象的方法</h3><ul><li><p>ch6.2.0介绍</p><ul><li><p>当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。</p><ul><li><p>对应到我们这里用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法，如下：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Point)</span> <span class="hljs-title">ScaleBy</span><span class="hljs-params">(factor <span class="hljs-keyword">float64</span>)</span></span> &#123;p.X *= factorp.Y *= factor&#125;</code></pre><ul><li>这个方法的名字是<code>(*Point).ScaleBy</code>。这里的括号是必须的；没有括号的话这个表达式可能会被理解为<code>*(Point.ScaleBy)</code>。</li></ul></li></ul></li><li><p>在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。我们在这里打破了这个约定只是为了展示一下两种方法的异同而已。</p></li><li><p>只有类型（Point）和指向他们的指针<code>(*Point)</code>，才可能是出现在接收器声明里的两种接收器。</p><ul><li><p>此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> P *<span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(P)</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125; <span class="hljs-comment">// compile error: invalid receiver type</span></code></pre></li><li><p>想要调用指针类型方法<code>(*Point).ScaleBy</code>，只要提供一个Point类型的指针即可，像下面这样。</p><pre><code class="hljs go">r := &amp;Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;r.ScaleBy(<span class="hljs-number">2</span>)fmt.Println(*r) <span class="hljs-comment">// &quot;&#123;2, 4&#125;&quot;</span></code></pre></li><li><p>或者这样:</p><p>或者这样：</p></li><li><p>或者这样:</p><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;(&amp;p).ScaleBy(<span class="hljs-number">2</span>)fmt.Println(p) <span class="hljs-comment">// &quot;&#123;2, 4&#125;&quot;</span></code></pre></li></ul></li><li><p>不过后面两种方法有些笨拙。幸运的是，go语言本身在这种地方会帮到我们。如果接收器p是一个Point类型的变量，并且其方法需要一个Point指针作为接收器，我们可以用下面这种简短的写法：</p><pre><code class="hljs go">p.ScaleBy(<span class="hljs-number">2</span>)</code></pre><ul><li><p>编译器会隐式地帮我们用&amp;p去调用ScaleBy这个方法。这种简写方法只适用于“变量”，包括struct里的字段比如p.X，以及array和slice内的元素比如perim[0]。</p></li><li><p>我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：</p><pre><code class="hljs go">Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;.ScaleBy(<span class="hljs-number">2</span>) <span class="hljs-comment">// compile error: can&#x27;t take address of Point literal</span></code></pre></li><li><p>但是我们可以用一个<code>*Point</code>这样的接收器来调用Point的方法，因为我们可以通过地址来找到这个变量，只要用解引用符号<code>*</code>来取到该变量即可。</p><ul><li><p>编译器在这里也会给我们隐式地插入<code>*</code>这个操作符，所以下面这两种写法等价的：</p><pre><code class="hljs Go">pptr.Distance(q)(*pptr).Distance(q)</code></pre></li></ul></li></ul></li><li><p>这里的几个例子可能让你有些困惑，所以我们总结一下：在每一个合法的方法调用表达式中，也就是下面三种情况里的任意一种情况都是可以的：</p><ul><li><p>要么接收器的实际参数和其形式参数是相同的类型，比如两者都是类型T或者都是类型<code>*T</code>：</p><pre><code class="hljs go">Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;.Distance(q) <span class="hljs-comment">//  Point</span>pptr.ScaleBy(<span class="hljs-number">2</span>)         <span class="hljs-comment">// *Point</span></code></pre></li><li><p>或者接收器实参是类型T，但接收器形参是类型<code>*T</code>，这种情况下编译器会隐式地为我们取变量的地址：</p><pre><code class="hljs go">p.ScaleBy(<span class="hljs-number">2</span>) <span class="hljs-comment">// implicit (&amp;p)</span></code></pre></li><li><p>或者接收器实参是类型<code>*T</code>，形参是类型T。编译器会隐式地为我们解引用，取到指针指向的实际变量：</p><pre><code class="hljs go">pptr.Distance(q) <span class="hljs-comment">// implicit (*pptr)</span></code></pre></li></ul></li><li><p>如果命名类型T（译注：用type xxx定义的类型）的所有方法都是用T类型自己来做接收器（而不是<code>*T</code>），那么拷贝这种类型的实例就是安全的；调用他的任何一个方法也就会产生一个值的拷贝。</p><ul><li>比如time.Duration的这个类型，在调用其方法时就会被全部拷贝一份，包括在作为参数传入函数的时候。</li></ul></li><li><p>但是如果一个方法使用指针作为接收器，你需要避免对其进行拷贝，因为这样可能会破坏掉该类型内部的不变性。</p><ul><li>比如你对bytes.Buffer对象进行了拷贝，那么可能会引起原始对象和拷贝对象只是别名而已，实际上它们指向的对象是一样的。紧接着对拷贝后的变量进行修改可能会有让你有意外的结果。</li></ul></li><li><p><strong>译注：</strong> 作者这里说的比较绕，其实有两点：</p><ul><li><ol><li>不管你的method的receiver是指针类型还是非指针类型，都是可以通过指针/非指针类型进行调用的，编译器会帮你做类型转换。</li></ol></li><li><ol start="2"><li>在声明一个method的receiver该是指针还是非指针类型时，你需要考虑两方面的因素，第一方面是这个对象本身是不是特别大，如果声明为非指针变量时，调用会产生一次拷贝；第二方面是如果你用指针类型作为receiver，那么你一定要注意，这种指针类型指向的始终是一块内存地址，就算你对其进行了拷贝。熟悉C或者C++的人这里应该很快能明白。</li></ol></li></ul></li></ul></li><li><p>ch6.2.1Nil也是一个合法的接收器类型</p><ul><li><p>就像一些函数允许nil指针作为参数一样，方法理论上也可以用nil指针作为其接收器，尤其当nil对于对象来说是合法的零值时，比如map或者slice。</p><ul><li><p>在下面的简单int链表的例子里，nil代表的是空链表：</p><pre><code class="hljs go"><span class="hljs-comment">// An IntList is a linked list of integers.</span><span class="hljs-comment">// A nil *IntList represents the empty list.</span><span class="hljs-keyword">type</span> IntList <span class="hljs-keyword">struct</span> &#123;Value <span class="hljs-keyword">int</span>Tail  *IntList&#125;<span class="hljs-comment">// Sum returns the sum of the list elements.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(list *IntList)</span> <span class="hljs-title">Sum</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> list == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;<span class="hljs-keyword">return</span> list.Value + list.Tail.Sum()&#125;</code></pre></li></ul></li><li><p>当你定义一个允许nil作为接收器值的方法的类型时，在类型前面的注释中指出nil变量代表的意义是很有必要的，就像我们上面例子里做的这样。</p></li><li><p>下面是net/url包里Values类型定义的一部分。</p><p><u><i>net/url</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> url<span class="hljs-comment">// Values maps a string key to a list of values.</span><span class="hljs-keyword">type</span> Values <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]<span class="hljs-keyword">string</span><span class="hljs-comment">// Get returns the first value associated with the given key,</span><span class="hljs-comment">// or &quot;&quot; if there are none.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Values)</span> <span class="hljs-title">Get</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">if</span> vs := v[key]; <span class="hljs-built_in">len</span>(vs) &gt; <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> vs[<span class="hljs-number">0</span>]&#125;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>&#125;<span class="hljs-comment">// Add adds the value to key.</span><span class="hljs-comment">// It appends to any existing values associated with key.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Values)</span> <span class="hljs-title">Add</span><span class="hljs-params">(key, value <span class="hljs-keyword">string</span>)</span></span> &#123;v[key] = <span class="hljs-built_in">append</span>(v[key], value)&#125;</code></pre><ul><li>这个定义向外部暴露了一个map的命名类型，并且提供了一些能够简单操作这个map的方法。这个map的value字段是一个string的slice，所以这个Values是一个多维map。</li></ul></li><li><p>客户端使用这个变量的时候可以使用map固有的一些操作（make，切片，m[key]等等），也可以使用这里提供的操作方法，或者两者并用，都是可以的</p><p><u><i>gopl.io/ch6/urlvalues</i></u></p><pre><code class="hljs go">m := url.Values&#123;<span class="hljs-string">&quot;lang&quot;</span>: &#123;<span class="hljs-string">&quot;en&quot;</span>&#125;&#125; <span class="hljs-comment">// direct construction</span>m.Add(<span class="hljs-string">&quot;item&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)m.Add(<span class="hljs-string">&quot;item&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>)fmt.Println(m.Get(<span class="hljs-string">&quot;lang&quot;</span>)) <span class="hljs-comment">// &quot;en&quot;</span>fmt.Println(m.Get(<span class="hljs-string">&quot;q&quot;</span>))    <span class="hljs-comment">// &quot;&quot;</span>fmt.Println(m.Get(<span class="hljs-string">&quot;item&quot;</span>)) <span class="hljs-comment">// &quot;1&quot;      (first value)</span>fmt.Println(m[<span class="hljs-string">&quot;item&quot;</span>])     <span class="hljs-comment">// &quot;[1 2]&quot;  (direct map access)</span>m = <span class="hljs-literal">nil</span>fmt.Println(m.Get(<span class="hljs-string">&quot;item&quot;</span>)) <span class="hljs-comment">// &quot;&quot;</span>m.Add(<span class="hljs-string">&quot;item&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>)         <span class="hljs-comment">// panic: assignment to entry in nil map</span></code></pre><ul><li>对Get的最后一次调用中，nil接收器的行为即是一个空map的行为。我们可以等价地将这个操作写成Value(nil).Get(“item”)，但是如果你直接写nil.Get(“item”)的话是无法通过编译的，因为nil的字面量编译器无法判断其准确类型。所以相比之下，最后的那行m.Add的调用就会产生一个panic，因为他尝试更新一个空map。</li></ul></li><li><p>由于url.Values是一个map类型，并且间接引用了其key/value对，因此url.Values.Add对这个map里的元素做任何的更新、删除操作对调用方都是可见的。</p><ul><li>实际上，就像在普通函数中一样，虽然可以通过引用来操作内部值，但在方法想要修改引用本身时是不会影响原始值的，比如把他置换为nil，或者让这个引用指向了其它的对象，调用方都不会受影响。</li><li>（译注：因为传入的是存储了内存地址的变量，你改变这个变量本身是影响不了原始的变量的，想想C语言，是差不多的）</li></ul></li></ul></li></ul><h3 id="ch6-3-通过嵌入结构体来扩展类型"><a href="#ch6-3-通过嵌入结构体来扩展类型" class="headerlink" title="ch6.3   通过嵌入结构体来扩展类型"></a>ch6.3   通过嵌入结构体来扩展类型</h3><ul><li><p>来看看ColoredPoint这个类型：</p><p><u><i>gopl.io/ch6/coloredpoint</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;image/color&quot;</span><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-keyword">float64</span> &#125;<span class="hljs-keyword">type</span> ColoredPoint <span class="hljs-keyword">struct</span> &#123;PointColor color.RGBA&#125;</code></pre><ul><li>我们完全可以将ColoredPoint定义为一个有三个字段的struct，但是我们却将Point这个类型嵌入到ColoredPoint来提供X和Y这两个字段。</li><li>像我们在4.4节中看到的那样，内嵌可以使我们在定义ColoredPoint时得到一种句法上的简写形式，并使其包含Point类型所具有的一切字段，然后再定义一些自己的。</li></ul></li><li><p>如果我们想要的话，我们可以直接认为通过嵌入的字段就是ColoredPoint自身的字段，而完全不需要在调用时指出Point，比如下面这样。</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> cp ColoredPointcp.X = <span class="hljs-number">1</span>fmt.Println(cp.Point.X) <span class="hljs-comment">// &quot;1&quot;</span>cp.Point.Y = <span class="hljs-number">2</span>fmt.Println(cp.Y) <span class="hljs-comment">// &quot;2&quot;</span></code></pre></li><li><p>对于Point中的方法我们也有类似的用法，我们可以把ColoredPoint类型当作接收器来调用Point里的方法，即使ColoredPoint里没有声明这些方法</p><pre><code class="hljs go">red := color.RGBA&#123;<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>&#125;blue := color.RGBA&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">255</span>&#125;<span class="hljs-keyword">var</span> p = ColoredPoint&#123;Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, red&#125;<span class="hljs-keyword">var</span> q = ColoredPoint&#123;Point&#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;, blue&#125;fmt.Println(p.Distance(q.Point)) <span class="hljs-comment">// &quot;5&quot;</span>p.ScaleBy(<span class="hljs-number">2</span>)q.ScaleBy(<span class="hljs-number">2</span>)fmt.Println(p.Distance(q.Point)) <span class="hljs-comment">// &quot;10&quot;</span></code></pre><ul><li><p>Point类的方法也被引入了ColoredPoint。用这种方式，内嵌可以使我们定义字段特别多的复杂类型，我们可以将字段先按小类型分组，然后定义小类型的方法，之后再把它们组合起来。</p></li><li><p>读者如果对基于类来实现面向对象的语言比较熟悉的话，可能会倾向于将Point看作一个基类，而ColoredPoint看作其子类或者继承类，或者将ColoredPoint看作”is a” Point类型。</p></li><li><p>但这是错误的理解。请注意上面例子中对Distance方法的调用。Distance有一个参数是Point类型，但q并不是一个Point类，所以尽管q有着Point这个内嵌类型，我们也必须要显式地选择它。尝试直接传q的话你会看到下面这样的错误：</p><pre><code class="hljs go">p.Distance(q) <span class="hljs-comment">// compile error: cannot use q (ColoredPoint) as Point</span></code></pre></li></ul></li><li><p>一个ColoredPoint并不是一个Point，但他”has a”Point，并且它有从Point类里引入的Distance和ScaleBy方法。如果你喜欢从实现的角度来考虑问题，内嵌字段会指导编译器去生成额外的包装方法来委托已经声明好的方法，和下面的形式是等价的：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p ColoredPoint)</span> <span class="hljs-title">Distance</span><span class="hljs-params">(q Point)</span> <span class="hljs-title">float64</span></span> &#123;<span class="hljs-keyword">return</span> p.Point.Distance(q)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *ColoredPoint)</span> <span class="hljs-title">ScaleBy</span><span class="hljs-params">(factor <span class="hljs-keyword">float64</span>)</span></span> &#123;p.Point.ScaleBy(factor)&#125;</code></pre><ul><li>当Point.Distance被第一个包装方法调用时，它的接收器值是p.Point，而不是p，当然了，在Point类的方法里，你是访问不到ColoredPoint的任何字段的。</li></ul></li><li><p>在类型中内嵌的匿名字段也可能是一个命名类型的指针，这种情况下字段和方法会被间接地引入到当前的类型中</p><ul><li><p>译注：访问需要通过该指针指向的对象去取</p></li><li><p>添加这一层间接关系让我们可以共享通用的结构并动态地改变对象之间的关系。</p></li><li><p>下面这个ColoredPoint的声明内嵌了一个*Point的指针。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> ColoredPoint <span class="hljs-keyword">struct</span> &#123;*PointColor color.RGBA&#125;p := ColoredPoint&#123;&amp;Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>&#125;, red&#125;q := ColoredPoint&#123;&amp;Point&#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>&#125;, blue&#125;fmt.Println(p.Distance(*q.Point)) <span class="hljs-comment">// &quot;5&quot;</span>q.Point = p.Point                 <span class="hljs-comment">// p and q now share the same Point</span>p.ScaleBy(<span class="hljs-number">2</span>)fmt.Println(*p.Point, *q.Point) <span class="hljs-comment">// &quot;&#123;2 2&#125; &#123;2 2&#125;&quot;</span></code></pre></li><li><p>一个struct类型也可能会有多个匿名字段。我们将ColoredPoint定义为下面这样：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> ColoredPoint <span class="hljs-keyword">struct</span> &#123;Pointcolor.RGBA&#125;</code></pre><ul><li>然后这种类型的值便会拥有Point和RGBA类型的所有方法，以及直接定义在ColoredPoint中的方法。</li><li>当编译器解析一个选择器到方法时，比如p.ScaleBy，它会首先去找直接定义在这个类型里的ScaleBy方法，然后找被ColoredPoint的内嵌字段们引入的方法，然后去找Point和RGBA的内嵌字段引入的方法，然后一直递归向下找。</li><li>如果选择器有二义性的话编译器会报错，比如你在同一级里有两个同名的方法。</li></ul></li></ul></li><li><p>方法只能在命名类型（像Point）或者指向类型的指针上定义，但是多亏了内嵌，有些时候我们给匿名struct类型来定义方法也有了手段。</p><ul><li><p>下面是一个小trick。这个例子展示了简单的cache，其使用两个包级别的变量来实现，一个mutex互斥量（§9.2）和它所操作的cache</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> (mu sync.Mutex <span class="hljs-comment">// guards mapping</span>mapping = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>))<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Lookup</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;mu.Lock()v := mapping[key]mu.Unlock()<span class="hljs-keyword">return</span> v&#125;</code></pre></li><li><p>下面这个版本在功能上是一致的，但将两个包级别的变量放在了cache这个struct一组内：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> cache = <span class="hljs-keyword">struct</span> &#123;sync.Mutexmapping <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>&#125;&#123;mapping: <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>),&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Lookup</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;cache.Lock()v := cache.mapping[key]cache.Unlock()<span class="hljs-keyword">return</span> v&#125;</code></pre></li><li><p>我们给新的变量起了一个更具表达性的名字：cache。因为sync.Mutex字段也被嵌入到了这个struct里，其Lock和Unlock方法也就都被引入到了这个匿名结构中了，这让我们能够以一个简单明了的语法来对其进行加锁解锁操作。</p></li></ul></li></ul><h3 id="ch6-4-方法值和方法表达式"><a href="#ch6-4-方法值和方法表达式" class="headerlink" title="ch6.4   方法值和方法表达式"></a>ch6.4   方法值和方法表达式</h3><ul><li><p>我们经常选择一个方法，并且在同一个表达式里执行，比如常见的p.Distance()形式，实际上将其分成两步来执行也是可能的。</p></li><li><p>p.Distance叫作“选择器”，选择器会返回一个方法“值”-&gt;一个将方法（Point.Distance）绑定到特定接收器变量的函数。这个函数可以不通过指定其接收器即可被调用；即调用时不需要指定接收器,只要传入函数的参数即可：</p><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;distanceFromP := p.Distance        <span class="hljs-comment">// method value</span>fmt.Println(distanceFromP(q))      <span class="hljs-comment">// &quot;5&quot;</span><span class="hljs-keyword">var</span> origin Point                   <span class="hljs-comment">// &#123;0, 0&#125;</span>fmt.Println(distanceFromP(origin)) <span class="hljs-comment">// &quot;2.23606797749979&quot;, sqrt(5)</span>scaleP := p.ScaleBy <span class="hljs-comment">// method value</span>scaleP(<span class="hljs-number">2</span>)           <span class="hljs-comment">// p becomes (2, 4)</span>scaleP(<span class="hljs-number">3</span>)           <span class="hljs-comment">//      then (6, 12)</span>scaleP(<span class="hljs-number">10</span>)          <span class="hljs-comment">//      then (60, 120)</span></code></pre></li><li><p>在一个包的API需要一个函数值、且调用方希望操作的是某一个绑定了对象的方法的话，方法“值”会非常实用。</p><ul><li><p>举例来说，下面例子中的time.AfterFunc这个函数的功能是在指定的延迟时间之后来执行一个（译注：另外的）函数。且这个函数操作的是一个Rocket对象r</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Rocket <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Rocket)</span> <span class="hljs-title">Launch</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;r := <span class="hljs-built_in">new</span>(Rocket)time.AfterFunc(<span class="hljs-number">10</span> * time.Second, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; r.Launch() &#125;)</code></pre></li><li><p>直接用方法“值”传入AfterFunc的话可以更为简短：</p><pre><code class="hljs go">time.AfterFunc(<span class="hljs-number">10</span> * time.Second, r.Launch)</code></pre></li></ul></li><li><p>和方法“值”相关的还有方法表达式。当调用一个方法时，与调用一个普通的函数相比，我们必须要用选择器（p.Distance）语法来指定方法的接收器。</p><ul><li><p>当T是一个类型时，方法表达式可能会写作<code>T.f</code>或者<code>(*T).f</code>，会返回一个函数“值”，这种函数会将其第一个参数用作接收器，所以可以用通常（译注：不写选择器）的方式来对其进行调用：</p><pre><code class="hljs go">p := Point&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;q := Point&#123;<span class="hljs-number">4</span>, <span class="hljs-number">6</span>&#125;distance := Point.Distance   <span class="hljs-comment">// method expression</span>fmt.Println(distance(p, q))  <span class="hljs-comment">// &quot;5&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, distance) <span class="hljs-comment">// &quot;func(Point, Point) float64&quot;</span>scale := (*Point).ScaleByscale(&amp;p, <span class="hljs-number">2</span>)fmt.Println(p)            <span class="hljs-comment">// &quot;&#123;2 4&#125;&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, scale) <span class="hljs-comment">// &quot;func(*Point, float64)&quot;</span><span class="hljs-comment">// 译注：这个Distance实际上是指定了Point对象为接收器的一个方法func (p Point) Distance()，</span><span class="hljs-comment">// 但通过Point.Distance得到的函数需要比实际的Distance方法多一个参数，</span><span class="hljs-comment">// 即其需要用第一个额外参数指定接收器，后面排列Distance方法的参数。</span><span class="hljs-comment">// 看起来本书中函数和方法的区别是指有没有接收器，而不像其他语言那样是指有没有返回值。</span></code></pre></li></ul></li><li><p>当你根据一个变量来决定调用同一个类型的哪个函数时，方法表达式就显得很有用了。你可以根据选择来调用接收器各不相同的方法。下面的例子，变量op代表Point类型的addition或者subtraction方法，Path.TranslateBy方法会为其Path数组中的每一个Point来调用对应的方法：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Point <span class="hljs-keyword">struct</span>&#123; X, Y <span class="hljs-keyword">float64</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Point)</span> <span class="hljs-title">Add</span><span class="hljs-params">(q Point)</span> <span class="hljs-title">Point</span></span> &#123; <span class="hljs-keyword">return</span> Point&#123;p.X + q.X, p.Y + q.Y&#125; &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Point)</span> <span class="hljs-title">Sub</span><span class="hljs-params">(q Point)</span> <span class="hljs-title">Point</span></span> &#123; <span class="hljs-keyword">return</span> Point&#123;p.X - q.X, p.Y - q.Y&#125; &#125;<span class="hljs-keyword">type</span> Path []Point<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(path Path)</span> <span class="hljs-title">TranslateBy</span><span class="hljs-params">(offset Point, add <span class="hljs-keyword">bool</span>)</span></span> &#123;<span class="hljs-keyword">var</span> op <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(p, q Point)</span> <span class="hljs-title">Point</span></span><span class="hljs-keyword">if</span> add &#123;op = Point.Add&#125; <span class="hljs-keyword">else</span> &#123;op = Point.Sub&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> path &#123;<span class="hljs-comment">// Call either path[i].Add(offset) or path[i].Sub(offset).</span>path[i] = op(path[i], offset)&#125;&#125;</code></pre></li></ul><h3 id="ch6-5-示例：Bit数组"><a href="#ch6-5-示例：Bit数组" class="headerlink" title="ch6.5   示例：Bit数组"></a>ch6.5   示例：Bit数组</h3><ul><li><p>Go语言里的集合一般会用map[T]bool这种形式来表示，T代表元素类型。集合用map类型来表示虽然非常灵活，但我们可以以一种更好的形式来表示它。</p><ul><li>例如在数据流分析领域，集合元素通常是一个非负整数，集合会包含很多元素，并且集合会经常进行并集、交集操作，这种情况下，bit数组会比map表现更加理想。</li><li>这里再补充一个例子，比如我们执行一个http下载任务，把文件按照16kb一块划分为很多块，需要有一个全局变量来标识哪些块下载完成了，这种时候也需要用到bit数组。</li></ul></li><li><p>一个bit数组通常会用一个无符号数或者称之为“字”的slice来表示，每一个元素的每一位都表示集合里的一个值。当集合的第i位被设置时，我们才说这个集合包含元素i。</p><ul><li><p>下面的这个程序展示了一个简单的bit数组类型，并且实现了三个函数来对这个bit数组来进行操作：</p><p><u><i>gopl.io/ch6/intset</i></u></p><pre><code class="hljs go"><span class="hljs-comment">// An IntSet is a set of small non-negative integers.</span><span class="hljs-comment">// Its zero value represents the empty set.</span><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123;words []<span class="hljs-keyword">uint64</span>&#125;<span class="hljs-comment">// Has reports whether the set contains the non-negative value x.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span> <span class="hljs-title">Has</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-keyword">uint</span>(x%<span class="hljs-number">64</span>)<span class="hljs-keyword">return</span> word &lt; <span class="hljs-built_in">len</span>(s.words) &amp;&amp; s.words[word]&amp;(<span class="hljs-number">1</span>&lt;&lt;bit) != <span class="hljs-number">0</span>&#125;<span class="hljs-comment">// Add adds the non-negative value x to the set.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span> <span class="hljs-title">Add</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;word, bit := x/<span class="hljs-number">64</span>, <span class="hljs-keyword">uint</span>(x%<span class="hljs-number">64</span>)<span class="hljs-keyword">for</span> word &gt;= <span class="hljs-built_in">len</span>(s.words) &#123;s.words = <span class="hljs-built_in">append</span>(s.words, <span class="hljs-number">0</span>)&#125;s.words[word] |= <span class="hljs-number">1</span> &lt;&lt; bit&#125;<span class="hljs-comment">// UnionWith sets s to the union of s and t.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span> <span class="hljs-title">UnionWith</span><span class="hljs-params">(t *IntSet)</span></span> &#123;<span class="hljs-keyword">for</span> i, tword := <span class="hljs-keyword">range</span> t.words &#123;<span class="hljs-keyword">if</span> i &lt; <span class="hljs-built_in">len</span>(s.words) &#123;s.words[i] |= tword&#125; <span class="hljs-keyword">else</span> &#123;s.words = <span class="hljs-built_in">append</span>(s.words, tword)&#125;&#125;&#125;</code></pre></li><li><p>因为每一个字都有64个二进制位，所以为了定位x的bit位，我们用了x/64的商作为字的下标，并且用x%64得到的值作为这个字内的bit的所在位置。UnionWith这个方法里用到了bit位的“或”逻辑操作符号|来一次完成64个元素的或计算。</p></li></ul></li><li><p>当前这个实现还缺少了很多必要的特性，我们把其中一些作为练习题列在本小节之后。但是有一个方法如果缺失的话我们的bit数组可能会比较难混：将IntSet作为一个字符串来打印。</p><ul><li><p>这里我们来实现它，让我们来给上面的例子添加一个String方法，类似2.5节中做的那样：</p><pre><code class="hljs go"><span class="hljs-comment">// String returns the set as a string of the form &quot;&#123;1 2 3&#125;&quot;.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *IntSet)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">var</span> buf bytes.Bufferbuf.WriteByte(<span class="hljs-string">&#x27;&#123;&#x27;</span>)<span class="hljs-keyword">for</span> i, word := <span class="hljs-keyword">range</span> s.words &#123;<span class="hljs-keyword">if</span> word == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">continue</span>&#125;<span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">64</span>; j++ &#123;<span class="hljs-keyword">if</span> word&amp;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-keyword">uint</span>(j)) != <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">if</span> buf.Len() &gt; <span class="hljs-built_in">len</span>(<span class="hljs-string">&quot;&#123;&quot;</span>) &#123;buf.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)&#125;fmt.Fprintf(&amp;buf, <span class="hljs-string">&quot;%d&quot;</span>, <span class="hljs-number">64</span>*i+j)&#125;&#125;&#125;buf.WriteByte(<span class="hljs-string">&#x27;&#125;&#x27;</span>)<span class="hljs-keyword">return</span> buf.String()&#125;</code></pre></li><li><p>这里留意一下String方法，是不是和3.5.4节中的intsToString方法很相似；bytes.Buffer在String方法里经常这么用。当你为一个复杂的类型定义了一个String方法时，fmt包就会特殊对待这种类型的值，这样可以让这些类型在打印的时候看起来更加友好，而不是直接打印其原始的值。fmt会直接调用用户定义的String方法。这种机制依赖于接口和类型断言，</p></li></ul></li><li><p>现在我们就可以在实战中直接用上面定义好的IntSet了：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> x, y IntSetx.Add(<span class="hljs-number">1</span>)x.Add(<span class="hljs-number">144</span>)x.Add(<span class="hljs-number">9</span>)fmt.Println(x.String()) <span class="hljs-comment">// &quot;&#123;1 9 144&#125;&quot;</span>y.Add(<span class="hljs-number">9</span>)y.Add(<span class="hljs-number">42</span>)fmt.Println(y.String()) <span class="hljs-comment">// &quot;&#123;9 42&#125;&quot;</span>x.UnionWith(&amp;y)fmt.Println(x.String()) <span class="hljs-comment">// &quot;&#123;1 9 42 144&#125;&quot;</span>fmt.Println(x.Has(<span class="hljs-number">9</span>), x.Has(<span class="hljs-number">123</span>)) <span class="hljs-comment">// &quot;true false&quot;</span></code></pre><ul><li><p>这里要注意：我们声明的String和Has两个方法都是以指针类型<code>*IntSet</code>来作为接收器的，但实际上对于这两个类型来说，把接收器声明为指针类型也没什么必要。</p></li><li><p>不过另外两个函数就不是这样了，因为另外两个函数操作的是s.words对象，如果你不把接收器声明为指针对象，那么实际操作的是拷贝对象，而不是原来的那个对象。</p></li><li><p>因此，因为我们的String方法定义在IntSet指针上，所以当我们的变量是IntSet类型而不是IntSet指针时，可能会有下面这样让人意外的情况</p><pre><code class="hljs go">fmt.Println(&amp;x)         <span class="hljs-comment">// &quot;&#123;1 9 42 144&#125;&quot;</span>fmt.Println(x.String()) <span class="hljs-comment">// &quot;&#123;1 9 42 144&#125;&quot;</span>fmt.Println(x)          <span class="hljs-comment">// &quot;&#123;[4398046511618 0 65536]&#125;&quot;</span></code></pre><ul><li>在第一个Println中，我们打印一个<code>*IntSet</code>的指针，这个类型的指针确实有自定义的String方法。</li><li>第二Println，我们直接调用了x变量的String()方法；这种情况下编译器会隐式地在x前插入&amp;操作符，这样相当于我们还是调用的IntSet指针的String方法。</li><li>在第三个Println中，因为IntSet类型没有String方法，所以Println方法会直接以原始的方式理解并打印。所以在这种情况下&amp;符号是不能忘的。</li><li>在我们这种场景下，你把String方法绑定到IntSet对象上，而不是IntSet指针上可能会更合适一些，不过这也需要具体问题具体分析。</li></ul></li></ul></li></ul><h3 id="ch6-6-封装"><a href="#ch6-6-封装" class="headerlink" title="ch6.6   封装"></a>ch6.6   封装</h3><ul><li><p>一个对象的变量或者方法如果对调用方是不可见的话，一般就被定义为“封装”。封装有时候也被叫做信息隐藏，同时也是面向对象编程最关键的一个方面。</p></li><li><p>Go语言只有一种控制可见性的手段：大写首字母的标识符会从定义它们的包中被导出，小写字母的则不会。这种限制包内成员的方式同样适用于struct或者一个类型的方法。因而如果我们想要封装一个对象，我们必须将其定义为一个struct。</p><ul><li><p>这也就是前面的小节中IntSet被定义为struct类型的原因，尽管它只有一个字段：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123;    words []<span class="hljs-keyword">uint64</span>&#125;</code></pre></li><li><p>当然，我们也可以把IntSet定义为一个slice类型，但这样我们就需要把代码中所有方法里用到的s.words用<code>*s</code>替换掉了：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntSet []<span class="hljs-keyword">uint64</span></code></pre></li><li><p>尽管这个版本的IntSet在本质上是一样的，但它也允许其它包中可以直接读取并编辑这个slice。换句话说，相对于<code>*s</code>这个表达式会出现在所有的包中，s.words只需要在定义IntSet的包中出现</p><ul><li>（译注：所以还是推荐后者吧的意思）</li></ul></li></ul></li><li><p>这种基于名字的手段使得在语言中最小的封装单元是package，而不是像其它语言一样的类型。一个struct类型的字段对同一个包的所有代码都有可见性，无论你的代码是写在一个函数还是一个方法里。</p></li><li><p>封装提供了三方面的优点。</p><ul><li><p>首先，因为调用方不能直接修改对象的变量值，其只需要关注少量的语句并且只要弄懂少量变量的可能的值即可。</p></li><li><p>第二，隐藏实现的细节，可以防止调用方依赖那些可能变化的具体实现，这样使设计包的程序员在不破坏对外的api情况下能得到更大的自由。</p><ul><li><p>把bytes.Buffer这个类型作为例子来考虑。这个类型在做短字符串叠加的时候很常用，所以在设计的时候可以做一些预先的优化，比如提前预留一部分空间，来避免反复的内存分配。又因为Buffer是一个struct类型，这些额外的空间可以用附加的字节数组来保存，且放在一个小写字母开头的字段中。</p></li><li><p>这样在外部的调用方只能看到性能的提升，但并不会得到这个附加变量。Buffer和其增长算法我们列在这里，为了简洁性稍微做了一些精简：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Buffer <span class="hljs-keyword">struct</span> &#123;    buf     []<span class="hljs-keyword">byte</span>    initial [<span class="hljs-number">64</span>]<span class="hljs-keyword">byte</span>    <span class="hljs-comment">/* ... */</span>&#125;<span class="hljs-comment">// Grow expands the buffer&#x27;s capacity, if necessary,</span><span class="hljs-comment">// to guarantee space for another n bytes. [...]</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Buffer)</span> <span class="hljs-title">Grow</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span></span> &#123;    <span class="hljs-keyword">if</span> b.buf == <span class="hljs-literal">nil</span> &#123;        b.buf = b.initial[:<span class="hljs-number">0</span>] <span class="hljs-comment">// use preallocated space initially</span>    &#125;    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(b.buf)+n &gt; <span class="hljs-built_in">cap</span>(b.buf) &#123;        buf := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, b.Len(), <span class="hljs-number">2</span>*<span class="hljs-built_in">cap</span>(b.buf) + n)        <span class="hljs-built_in">copy</span>(buf, b.buf)        b.buf = buf    &#125;&#125;</code></pre></li></ul></li><li><p>封装的第三个优点也是最重要的优点，是阻止了外部调用方对对象内部的值任意地进行修改。因为对象内部变量只可以被同一个包内的函数修改，所以包的作者可以让这些函数确保对象内部的一些值的不变性。</p><ul><li><p>比如下面的Counter类型允许调用方来增加counter变量的值，并且允许将这个值reset为0，但是不允许随便设置这个值（译注：因为压根就访问不到）：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123; n <span class="hljs-keyword">int</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span> <span class="hljs-title">N</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span>     &#123; <span class="hljs-keyword">return</span> c.n &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span> <span class="hljs-title">Increment</span><span class="hljs-params">()</span></span> &#123; c.n++ &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Counter)</span> <span class="hljs-title">Reset</span><span class="hljs-params">()</span></span>     &#123; c.n = <span class="hljs-number">0</span> &#125;</code></pre></li><li><p>只用来访问或修改内部变量的函数被称为setter或者getter，例子如下，比如log包里的Logger类型对应的一些函数。在命名一个getter方法时，我们通常会省略掉前面的Get前缀。这种简洁上的偏好也可以推广到各种类型的前缀比如Fetch，Find或者Lookup。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> log<span class="hljs-keyword">type</span> Logger <span class="hljs-keyword">struct</span> &#123;flags  <span class="hljs-keyword">int</span>prefix <span class="hljs-keyword">string</span><span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *Logger)</span> <span class="hljs-title">Flags</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *Logger)</span> <span class="hljs-title">SetFlags</span><span class="hljs-params">(flag <span class="hljs-keyword">int</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *Logger)</span> <span class="hljs-title">Prefix</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l *Logger)</span> <span class="hljs-title">SetPrefix</span><span class="hljs-params">(prefix <span class="hljs-keyword">string</span>)</span></span></code></pre></li></ul></li></ul></li><li><p>Go的编码风格不禁止直接导出字段。当然，一旦进行了导出，就没有办法在保证API兼容的情况下去除对其的导出，所以在一开始的选择一定要经过深思熟虑并且要考虑到包内部的一些不变量的保证，未来可能的变化，以及调用方的代码质量是否会因为包的一点修改而变差。</p></li><li><p>封装并不总是理想的。</p><ul><li><p>虽然封装在有些情况是必要的，但有时候我们也需要暴露一些内部内容，比如：time.Duration将其表现暴露为一个int64数字的纳秒，使得我们可以用一般的数值操作来对时间进行对比，甚至可以定义这种类型的常量：</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> day = <span class="hljs-number">24</span> * time.Hourfmt.Println(day.Seconds()) <span class="hljs-comment">// &quot;86400&quot;</span></code></pre></li><li><p>另一个例子，将IntSet和本章开头的geometry.Path进行对比。Path被定义为一个slice类型，这允许其调用slice的字面方法来对其内部的points用range进行迭代遍历；在这一点上，IntSet是没有办法让你这么做的。</p></li><li><p>这两种类型决定性的不同：geometry.Path的本质是一个坐标点的序列，不多也不少，我们可以预见到之后也并不会给他增加额外的字段，所以在geometry包中将Path暴露为一个slice。相比之下，IntSet仅仅是在这里用了一个[]uint64的slice。这个类型还可以用[]uint类型来表示，或者我们甚至可以用其它完全不同的占用更小内存空间的东西来表示这个集合，所以我们可能还会需要额外的字段来在这个类型中记录元素的个数。也正是因为这些原因，我们让IntSet对调用方不透明。</p></li></ul></li><li><p>在这章中，我们学到了如何将方法与命名类型进行组合，并且知道了如何调用这些方法。尽管方法对于OOP编程来说至关重要，但他们只是OOP编程里的半边天。为了完成OOP，我们还需要接口。Go里的接口会在下一章中介绍。</p></li></ul><h2 id="ch7-接口"><a href="#ch7-接口" class="headerlink" title="ch7  接口"></a>ch7  接口</h2><h3 id="ch7-0-简介"><a href="#ch7-0-简介" class="headerlink" title="ch7.0   简介"></a>ch7.0   简介</h3><ul><li>接口类型是对其它类型行为的抽象和概括；因为接口类型不会和特定的实现细节绑定在一起，通过这种抽象的方式我们可以让我们的函数更加灵活和更具有适应能力。</li><li>很多面向对象的语言都有相似的接口概念，但Go语言中接口类型的独特之处在于它是满足隐式实现的。也就是说，我们没有必要对于给定的具体类型定义所有满足的接口类型；简单地拥有一些必需的方法就足够了。</li><li>这种设计可以让你创建一个新的接口类型满足已经存在的具体类型却不会去改变这些类型的定义；当我们使用的类型来自于不受我们控制的包时这种设计尤其有用。</li><li>在本章，我们会开始看到接口类型和值的一些基本技巧。顺着这种方式我们将学习几个来自标准库的重要接口。很多Go程序中都尽可能多的去使用标准库中的接口。最后，我们会在（§7.10）看到类型断言的知识，在（§7.13）看到类型开关的使用并且学到他们是怎样让不同的类型的概括成为可能。</li></ul><h3 id="ch7-1-接口是合约"><a href="#ch7-1-接口是合约" class="headerlink" title="ch7.1   接口是合约"></a>ch7.1   接口是合约</h3><ul><li><p>目前为止，我们看到的类型都是具体的类型。一个具体的类型可以准确的描述它所代表的值，并且展示出对类型本身的一些操作方式：就像数字类型的算术操作，切片类型的取下标、添加元素和范围获取操作。具体的类型还可以通过它的内置方法提供额外的行为操作。总的来说，当你拿到一个具体的类型时你就知道它的本身是什么和你可以用它来做什么。</p></li><li><p>在Go语言中还存在着另外一种类型：接口类型。接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。</p></li><li><p>在本书中，我们一直使用两个相似的函数来进行字符串的格式化：fmt.Printf，它会把结果写到标准输出，和fmt.Sprintf，它会把结果以字符串的形式返回。</p><ul><li><p>得益于使用接口，我们不必可悲的因为返回结果在使用方式上的一些浅显不同就必需把格式化这个最困难的过程复制一份。实际上，这两个函数都使用了另一个函数fmt.Fprintf来进行封装。fmt.Fprintf这个函数对它的计算结果会被怎么使用是完全不知道的。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> fmt<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fprintf</span><span class="hljs-params">(w io.Writer, format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Printf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<span class="hljs-keyword">return</span> Fprintf(os.Stdout, format, args...)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sprintf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">var</span> buf bytes.BufferFprintf(&amp;buf, format, args...)<span class="hljs-keyword">return</span> buf.String()&#125;</code></pre></li><li><p>Fprintf的前缀F表示文件（File）也表明格式化输出结果应该被写入第一个参数提供的文件中。在Printf函数中的第一个参数os.Stdout是<code>*os.File</code>类型；在Sprintf函数中的第一个参数&amp;buf是一个指向可以写入字节的内存缓冲区，然而它并不是一个文件类型尽管它在某种意义上和文件类型相似。</p></li><li><p>即使Fprintf函数中的第一个参数也不是一个文件类型。它是io.Writer类型，这是一个接口类型定义如下：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> io<span class="hljs-comment">// Writer is the interface that wraps the basic Write method.</span><span class="hljs-keyword">type</span> Writer <span class="hljs-keyword">interface</span> &#123;<span class="hljs-comment">// Write writes len(p) bytes from p to the underlying data stream.</span><span class="hljs-comment">// It returns the number of bytes written from p (0 &lt;= n &lt;= len(p))</span><span class="hljs-comment">// and any error encountered that caused the write to stop early.</span><span class="hljs-comment">// Write must return a non-nil error if it returns n &lt; len(p).</span><span class="hljs-comment">// Write must not modify the slice data, even temporarily.</span><span class="hljs-comment">//</span><span class="hljs-comment">// Implementations must not retain p.</span>Write(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)&#125;</code></pre></li><li><p>io.Writer类型定义了函数Fprintf和这个函数调用者之间的约定。一方面这个约定需要调用者提供具体类型的值就像<code>*os.File</code>和<code>*bytes.Buffer</code>，这些类型都有一个特定签名和行为的Write的函数。另一方面这个约定保证了Fprintf接受任何满足io.Writer接口的值都可以工作。Fprintf函数可能没有假定写入的是一个文件或是一段内存，而是写入一个可以调用Write函数的值。</p></li><li><p>因为fmt.Fprintf函数没有对具体操作的值做任何假设，而是仅仅通过io.Writer接口的约定来保证行为，所以第一个参数可以安全地传入一个只需要满足io.Writer接口的任意具体类型的值。一个类型可以自由地被另一个满足相同接口的类型替换，被称作可替换性（LSP里氏替换）。这是一个面向对象的特征。</p></li></ul></li><li><p>让我们通过一个新的类型来进行校验，下面<code>*ByteCounter</code>类型里的Write方法，仅仅在丢弃写向它的字节前统计它们的长度。（在这个+=赋值语句中，让len(p)的类型和<code>*c</code>的类型匹配的转换是必须的。）</p><p><u><i>gopl.io/ch7/bytecounter</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">type</span> ByteCounter <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *ByteCounter)</span> <span class="hljs-title">Write</span><span class="hljs-params">(p []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;*c += ByteCounter(<span class="hljs-built_in">len</span>(p)) <span class="hljs-comment">// convert int to ByteCounter</span><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(p), <span class="hljs-literal">nil</span>&#125;</code></pre><ul><li><p>因为*ByteCounter满足io.Writer的约定，我们可以把它传入Fprintf函数中；Fprintf函数执行字符串格式化的过程不会去关注ByteCounter正确的累加结果的长度。</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> c ByteCounterc.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>))fmt.Println(c) <span class="hljs-comment">// &quot;5&quot;, = len(&quot;hello&quot;)</span>c = <span class="hljs-number">0</span>          <span class="hljs-comment">// reset the counter</span><span class="hljs-keyword">var</span> name = <span class="hljs-string">&quot;Dolly&quot;</span>fmt.Fprintf(&amp;c, <span class="hljs-string">&quot;hello, %s&quot;</span>, name)fmt.Println(c) <span class="hljs-comment">// &quot;12&quot;, = len(&quot;hello, Dolly&quot;)</span></code></pre></li></ul></li><li><p>除了io.Writer这个接口类型，还有另一个对fmt包很重要的接口类型。Fprintf和Fprintln函数向类型提供了一种控制它们值输出的途径。在2.5节中，我们为Celsius类型提供了一个String方法以便于可以打印成这样”100°C” ，在6.5节中我们给*IntSet添加一个String方法，这样集合可以用传统的符号来进行表示就像”{1 2 3}”。给一个类型定义String方法，可以让它满足最广泛使用之一的接口类型fmt.Stringer：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> fmt<span class="hljs-comment">// The String method is used to print values passed</span><span class="hljs-comment">// as an operand to any format that accepts a string</span><span class="hljs-comment">// or to an unformatted printer such as Print.</span><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;String() <span class="hljs-keyword">string</span>&#125;</code></pre></li><li><p>我们会在7.10节解释fmt包怎么发现哪些值是满足这个接口类型的。</p></li></ul><h3 id="ch7-2-接口类型"><a href="#ch7-2-接口类型" class="headerlink" title="ch7.2   接口类型"></a>ch7.2   接口类型</h3><ul><li><p>接口类型具体描述了一系列方法的集合，一个实现了这些方法的具体类型是这个接口类型的实例。</p></li><li><p>io.Writer类型是用得最广泛的接口之一，因为它提供了所有类型的写入bytes的抽象，包括文件类型，内存缓冲区，网络链接，HTTP客户端，压缩工具，哈希等等。</p></li><li><p>io包中定义了很多其它有用的接口类型。Reader可以代表任意可以读取bytes的类型，Closer可以是任意可以关闭的值，例如一个文件或是网络链接。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> io<span class="hljs-keyword">type</span> Reader <span class="hljs-keyword">interface</span> &#123;Read(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)&#125;<span class="hljs-keyword">type</span> Closer <span class="hljs-keyword">interface</span> &#123;Close() error&#125;</code></pre><ul><li>到现在你可能注意到了很多Go语言中单方法接口的命名习惯</li></ul></li><li><p>再往下看，我们发现有些新的接口类型通过组合已有的接口来定义。下面是两个例子：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;ReaderWriter&#125;<span class="hljs-keyword">type</span> ReadWriteCloser <span class="hljs-keyword">interface</span> &#123;ReaderWriterCloser&#125;</code></pre></li><li><p>上面用到的语法和结构内嵌相似，我们可以用这种方式以一个简写命名一个接口，而不用声明它所有的方法。这种方式称为接口内嵌。尽管略失简洁，我们可以像下面这样，不使用内嵌来声明io.ReadWriter接口。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;Read(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)Write(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)&#125;</code></pre></li><li><p>或者甚至使用一种混合的风格：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> ReadWriter <span class="hljs-keyword">interface</span> &#123;Read(p []<span class="hljs-keyword">byte</span>) (n <span class="hljs-keyword">int</span>, err error)Writer&#125;</code></pre></li><li><p>上面3种定义方式都是一样的效果。方法顺序的变化也没有影响，唯一重要的就是这个集合里面的方法。</p></li></ul><h3 id="ch7-3-实现接口的条件"><a href="#ch7-3-实现接口的条件" class="headerlink" title="ch7.3   实现接口的条件"></a>ch7.3   实现接口的条件</h3><ul><li><p>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。</p><ul><li>例如，<code>*os.File</code>类型实现了io.Reader，Writer，Closer，和ReadWriter接口。</li><li><code>*bytes.Buffer</code>实现了Reader，Writer，和ReadWriter这些接口，但是它没有实现Closer接口因为它不具有Close方法。</li><li>Go的程序员经常会简要的把一个具体的类型描述成一个特定的接口类型。举个例子，<code>*bytes.Buffer</code>是io.Writer；<code>*os.Files</code>是io.ReadWriter。</li></ul></li><li><p>接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口。所以：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writerw = os.Stdout           <span class="hljs-comment">// OK: *os.File has Write method</span>w = <span class="hljs-built_in">new</span>(bytes.Buffer)   <span class="hljs-comment">// OK: *bytes.Buffer has Write method</span>w = time.Second         <span class="hljs-comment">// compile error: time.Duration lacks Write method</span><span class="hljs-keyword">var</span> rwc io.ReadWriteCloserrwc = os.Stdout         <span class="hljs-comment">// OK: *os.File has Read, Write, Close methods</span>rwc = <span class="hljs-built_in">new</span>(bytes.Buffer) <span class="hljs-comment">// compile error: *bytes.Buffer lacks Close method</span></code></pre><ul><li><p>这个规则甚至适用于等式右边本身也是一个接口类型</p><pre><code class="hljs go">w = rwc                 <span class="hljs-comment">// OK: io.ReadWriteCloser has Write method</span>rwc = w                 <span class="hljs-comment">// compile error: io.Writer lacks Close method</span></code></pre></li><li><p>因为ReadWriter和ReadWriteCloser包含有Writer的方法，所以任何实现了ReadWriter和ReadWriteCloser的类型必定也实现了Writer接口</p></li></ul></li><li><p>在进一步学习前，必须先解释一个类型持有一个方法的表示当中的细节。回想在6.2章中，对于每一个命名过的具体类型T；它的一些方法的接收者是类型T本身然而另一些则是一个<code>*T</code>的指针。还记得在T类型的参数上调用一个<code>*T</code>的方法是合法的，只要这个参数是一个变量；编译器隐式的获取了它的地址。但这仅仅是一个语法糖：T类型的值不拥有所有<code>*T</code>指针的方法，这样它就可能只实现了更少的接口。</p><ul><li><p>举个例子可能会更清晰一点。在第6.5章中，IntSet类型的String方法的接收者是一个指针类型，所以我们不能在一个不能寻址的IntSet值上调用这个方法：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> IntSet <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*IntSet)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span><span class="hljs-keyword">var</span> _ = IntSet&#123;&#125;.String() <span class="hljs-comment">// compile error: String requires *IntSet receiver</span></code></pre></li><li><p>但是我们可以在一个IntSet变量上调用这个方法：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> s IntSet<span class="hljs-keyword">var</span> _ = s.String() <span class="hljs-comment">// OK: s is a variable and &amp;s has a String method</span></code></pre></li><li><p>然而，由于只有<code>*IntSet</code>类型有String方法，所以也只有<code>*IntSet</code>类型实现了fmt.Stringer接口：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> _ fmt.Stringer = &amp;s <span class="hljs-comment">// OK</span><span class="hljs-keyword">var</span> _ fmt.Stringer = s  <span class="hljs-comment">// compile error: IntSet lacks String method</span></code></pre></li></ul></li><li><p>12.8章包含了一个打印出任意值的所有方法的程序，然后可以使用godoc -analysis=type tool(§10.7.4)展示每个类型的方法和具体类型和接口之间的关系</p></li><li><p>就像信封封装和隐藏起信件来一样，接口类型封装和隐藏具体类型和它的值。即使具体类型有其它的方法，也只有接口类型暴露出来的方法会被调用到：</p><pre><code class="hljs go">os.Stdout.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">// OK: *os.File has Write method</span>os.Stdout.Close()                <span class="hljs-comment">// OK: *os.File has Close method</span><span class="hljs-keyword">var</span> w io.Writerw = os.Stdoutw.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">// OK: io.Writer has Write method</span>w.Close()                <span class="hljs-comment">// compile error: io.Writer lacks Close method</span></code></pre></li><li><p>一个有更多方法的接口类型，比如io.ReadWriter，和少一些方法的接口类型例如io.Reader，进行对比；更多方法的接口类型会告诉我们更多关于它的值持有的信息，并且对实现它的类型要求更加严格。</p></li><li><p>那么关于interface{}类型，它没有任何方法，请讲出哪些具体的类型实现了它？</p><ul><li><p>这看上去好像没有用，但实际上interface{}被称为空接口类型是不可或缺的。因为空接口类型对实现它的类型没有要求，所以我们可以将任意一个值赋给空接口类型。</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> any <span class="hljs-keyword">interface</span>&#123;&#125;any = <span class="hljs-literal">true</span>any = <span class="hljs-number">12.34</span>any = <span class="hljs-string">&quot;hello&quot;</span>any = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-string">&quot;one&quot;</span>: <span class="hljs-number">1</span>&#125;any = <span class="hljs-built_in">new</span>(bytes.Buffer)</code></pre></li><li><p>尽管不是很明显，从本书最早的例子中我们就已经在使用空接口类型。它允许像fmt.Println或者5.7章中的errorf函数接受任何类型的参数。</p></li></ul></li><li><p>对于创建的一个interface{}值持有一个boolean，float，string，map，pointer，或者任意其它的类型；我们当然不能直接对它持有的值做操作，因为interface{}没有任何方法。我们会在7.10章中学到一种用类型断言来获取interface{}中值的方法。</p></li><li><p>因为接口与实现只依赖于判断两个类型的方法，所以没有必要定义一个具体类型和它实现的接口之间的关系。也就是说，有意地在文档里说明或者程序上断言这种关系偶尔是有用的，但程序上不强制这么做。下面的定义在编译期断言一个<code>*bytes.Buffer</code>的值实现了io.Writer接口类型:</p><pre><code class="hljs go"><span class="hljs-comment">// *bytes.Buffer must satisfy io.Writer</span><span class="hljs-keyword">var</span> w io.Writer = <span class="hljs-built_in">new</span>(bytes.Buffer)</code></pre><ul><li><p>因为任意<code>*bytes.Buffer</code>的值，甚至包括nil通过<code>(*bytes.Buffer)(nil)</code>进行显示的转换都实现了这个接口，所以我们不必分配一个新的变量。并且因为我们绝不会引用变量w，我们可以使用空标识符来进行代替。总的看，这些变化可以让我们得到一个更朴素的版本：</p><pre><code class="hljs go"><span class="hljs-comment">// *bytes.Buffer must satisfy io.Writer</span><span class="hljs-keyword">var</span> _ io.Writer = (*bytes.Buffer)(<span class="hljs-literal">nil</span>)</code></pre></li></ul></li><li><p>非空的接口类型比如io.Writer经常被指针类型实现，尤其当一个或多个接口方法像Write方法那样隐式的给接收者带来变化的时候。一个结构体的指针是非常常见的承载方法的类型。</p></li><li><p>但是并不意味着只有指针类型满足接口类型，甚至连一些有设置方法的接口类型也可能会被Go语言中其它的引用类型实现。我们已经看过slice类型的方法（geometry.Path，§6.1）和map类型的方法（url.Values，§6.2.1），后面还会看到函数类型的方法的例子（http.HandlerFunc，§7.7）。甚至基本的类型也可能会实现一些接口；就如我们在7.4章中看到的time.Duration类型实现了fmt.Stringer接口。</p></li><li><p>一个具体的类型可能实现了很多不相关的接口。考虑在一个组织出售数字文化产品比如音乐，电影和书籍的程序中可能定义了下列的具体类型：</p><pre><code class="hljs ebnf"><span class="hljs-attribute">Album</span><span class="hljs-attribute">Book</span><span class="hljs-attribute">Movie</span><span class="hljs-attribute">Magazine</span><span class="hljs-attribute">Podcast</span><span class="hljs-attribute">TVEpisode</span><span class="hljs-attribute">Track</span></code></pre><ul><li><p>我们可以把每个抽象的特点用接口来表示。一些特性对于所有的这些文化产品都是共通的，例如标题，创作日期和作者列表。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Artifact <span class="hljs-keyword">interface</span> &#123;Title() <span class="hljs-keyword">string</span>Creators() []<span class="hljs-keyword">string</span>Created() time.Time&#125;</code></pre></li><li><p>其它的一些特性只对特定类型的文化产品才有。和文字排版特性相关的只有books和magazines，还有只有movies和TV剧集和屏幕分辨率相关。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Text <span class="hljs-keyword">interface</span> &#123;Pages() <span class="hljs-keyword">int</span>Words() <span class="hljs-keyword">int</span>PageSize() <span class="hljs-keyword">int</span>&#125;<span class="hljs-keyword">type</span> Audio <span class="hljs-keyword">interface</span> &#123;Stream() (io.ReadCloser, error)RunningTime() time.DurationFormat() <span class="hljs-keyword">string</span> <span class="hljs-comment">// e.g., &quot;MP3&quot;, &quot;WAV&quot;</span>&#125;<span class="hljs-keyword">type</span> Video <span class="hljs-keyword">interface</span> &#123;Stream() (io.ReadCloser, error)RunningTime() time.DurationFormat() <span class="hljs-keyword">string</span> <span class="hljs-comment">// e.g., &quot;MP4&quot;, &quot;WMV&quot;</span>Resolution() (x, y <span class="hljs-keyword">int</span>)&#125;</code></pre></li><li><p>这些接口不止是一种有用的方式来分组相关的具体类型和表示他们之间的共同特点。我们后面可能会发现其它的分组。举例，如果我们发现我们需要以同样的方式处理Audio和Video，我们可以定义一个Streamer接口来代表它们之间相同的部分而不必对已经存在的类型做改变。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Streamer <span class="hljs-keyword">interface</span> &#123;Stream() (io.ReadCloser, error)RunningTime() time.DurationFormat() <span class="hljs-keyword">string</span>&#125;</code></pre></li></ul></li><li><p>每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。不像基于类的语言，他们一个类实现的接口集合需要进行显式的定义，在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。当具体的类型来自不同的作者时这种方式会特别有用。当然也确实没有必要在具体的类型中指出这些共性。</p></li></ul><h3 id="ch7-4-flag-Value接口"><a href="#ch7-4-flag-Value接口" class="headerlink" title="ch7.4   flag.Value接口"></a>ch7.4   flag.Value接口</h3><ul><li><p>在本章，我们会学到另一个标准的接口类型flag.Value是怎么帮助命令行标记定义新的符号的。思考下面这个会休眠特定时间的程序：</p><p><u><i>gopl.io/ch7/sleep</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">var</span> period = flag.Duration(<span class="hljs-string">&quot;period&quot;</span>, <span class="hljs-number">1</span>*time.Second, <span class="hljs-string">&quot;sleep period&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;flag.Parse()fmt.Printf(<span class="hljs-string">&quot;Sleeping for %v...&quot;</span>, *period)time.Sleep(*period)fmt.Println()&#125;</code></pre></li><li><p>在它休眠前它会打印出休眠的时间周期。fmt包调用time.Duration的String方法打印这个时间周期是以用户友好的注解方式，而不是一个纳秒数字：</p><pre><code class="hljs gams"><span class="hljs-symbol">$</span> go build gopl.io/ch7/<span class="hljs-built_in">sleep</span><span class="hljs-symbol">$</span> ./<span class="hljs-built_in">sleep</span><span class="hljs-function"><span class="hljs-title">Sleeping</span></span> <span class="hljs-keyword">for</span> <span class="hljs-number">1</span>s...</code></pre><ul><li>默认情况下，休眠周期是一秒，但是可以通过 -period 这个命令行标记来控制。flag.Duration函数创建一个time.Duration类型的标记变量并且允许用户通过多种用户友好的方式来设置这个变量的大小，这种方式还包括和String方法相同的符号排版形式。这种对称设计使得用户交互良好。</li></ul></li><li><p>因为时间周期标记值非常的有用，所以这个特性被构建到了flag包中；但是我们为我们自己的数据类型定义新的标记符号是简单容易的。我们只需要定义一个实现flag.Value接口的类型，如下：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> flag<span class="hljs-comment">// Value is the interface to the value stored in a flag.</span><span class="hljs-keyword">type</span> Value <span class="hljs-keyword">interface</span> &#123;String() <span class="hljs-keyword">string</span>Set(<span class="hljs-keyword">string</span>) error&#125;</code></pre><ul><li>String方法格式化标记的值用在命令行帮助消息中；这样每一个flag.Value也是一个fmt.Stringer。</li><li>Set方法解析它的字符串参数并且更新标记变量的值。</li><li>实际上，Set方法和String是两个相反的操作，所以最好的办法就是对他们使用相同的注解方式。</li></ul></li><li><p>让我们定义一个允许通过摄氏度或者华氏温度变换的形式指定温度的celsiusFlag类型。注意celsiusFlag内嵌了一个Celsius类型（§2.5），因此不用实现本身就已经有String方法了。为了实现flag.Value，我们只需要定义Set方法：</p><p><u><i>gopl.io/ch7/tempconv</i></u></p><pre><code class="hljs go"><span class="hljs-comment">// *celsiusFlag satisfies the flag.Value interface.</span><span class="hljs-keyword">type</span> celsiusFlag <span class="hljs-keyword">struct</span>&#123; Celsius &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f *celsiusFlag)</span> <span class="hljs-title">Set</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">var</span> unit <span class="hljs-keyword">string</span><span class="hljs-keyword">var</span> value <span class="hljs-keyword">float64</span>fmt.Sscanf(s, <span class="hljs-string">&quot;%f%s&quot;</span>, &amp;value, &amp;unit) <span class="hljs-comment">// no error check needed</span><span class="hljs-keyword">switch</span> unit &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;°C&quot;</span>:f.Celsius = Celsius(value)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;F&quot;</span>, <span class="hljs-string">&quot;°F&quot;</span>:f.Celsius = FToC(Fahrenheit(value))<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;invalid temperature %q&quot;</span>, s)&#125;</code></pre><ul><li>调用fmt.Sscanf函数从输入s中解析一个浮点数（value）和一个字符串（unit）。虽然通常必须检查Sscanf的错误返回，但是在这个例子中我们不需要因为如果有错误发生，就没有switch case会匹配到。</li></ul></li><li><p>下面的CelsiusFlag函数将所有逻辑都封装在一起。它返回一个内嵌在celsiusFlag变量f中的Celsius指针给调用者。</p><pre><code class="hljs go"><span class="hljs-comment">// CelsiusFlag defines a Celsius flag with the specified name,</span><span class="hljs-comment">// default value, and usage, and returns the address of the flag variable.</span><span class="hljs-comment">// The flag argument must have a quantity and a unit, e.g., &quot;100C&quot;.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CelsiusFlag</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, value Celsius, usage <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">Celsius</span></span> &#123;f := celsiusFlag&#123;value&#125;flag.CommandLine.Var(&amp;f, name, usage)<span class="hljs-keyword">return</span> &amp;f.Celsius&#125;</code></pre><ul><li>Celsius字段是一个会通过Set方法在标记处理的过程中更新的变量。</li><li>用Var方法将标记加入应用的命令行标记集合中，有异常复杂命令行接口的全局变量flag.CommandLine.Programs可能有几个这个类型的变量。</li><li>调用Var方法将一个<code>*celsiusFlag</code>参数赋值给一个flag.Value参数，导致编译器去检查<code>*celsiusFlag</code>是否有必须的方法。</li></ul></li><li><p>现在我们可以开始在我们的程序中使用新的标记：</p><p><u><i>gopl.io/ch7/tempflag</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">var</span> temp = tempconv.CelsiusFlag(<span class="hljs-string">&quot;temp&quot;</span>, <span class="hljs-number">20.0</span>, <span class="hljs-string">&quot;the temperature&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;flag.Parse()fmt.Println(*temp)&#125;</code></pre><ul><li><p>下面是典型的场景：</p><pre><code class="hljs yaml"><span class="hljs-string">$</span> <span class="hljs-string">go</span> <span class="hljs-string">build</span> <span class="hljs-string">gopl.io/ch7/tempflag</span><span class="hljs-string">$</span> <span class="hljs-string">./tempflag</span><span class="hljs-number">20</span><span class="hljs-string">°C</span><span class="hljs-string">$</span> <span class="hljs-string">./tempflag</span> <span class="hljs-string">-temp</span> <span class="hljs-string">-18C</span><span class="hljs-number">-18</span><span class="hljs-string">°C</span><span class="hljs-string">$</span> <span class="hljs-string">./tempflag</span> <span class="hljs-string">-temp</span> <span class="hljs-number">212</span><span class="hljs-string">°F</span><span class="hljs-number">100</span><span class="hljs-string">°C</span><span class="hljs-string">$</span> <span class="hljs-string">./tempflag</span> <span class="hljs-string">-temp</span> <span class="hljs-number">273.</span><span class="hljs-string">15K</span><span class="hljs-string">invalid</span> <span class="hljs-string">value</span> <span class="hljs-string">&quot;273.15K&quot;</span> <span class="hljs-attr">for flag -temp:</span> <span class="hljs-string">invalid</span> <span class="hljs-string">temperature</span> <span class="hljs-string">&quot;273.15K&quot;</span><span class="hljs-attr">Usage of ./tempflag:</span>  <span class="hljs-string">-temp</span> <span class="hljs-string">value</span>        <span class="hljs-string">the</span> <span class="hljs-string">temperature</span> <span class="hljs-string">(default</span> <span class="hljs-number">20</span><span class="hljs-string">°C)</span><span class="hljs-string">$</span> <span class="hljs-string">./tempflag</span> <span class="hljs-string">-help</span><span class="hljs-attr">Usage of ./tempflag:</span>  <span class="hljs-string">-temp</span> <span class="hljs-string">value</span>        <span class="hljs-string">the</span> <span class="hljs-string">temperature</span> <span class="hljs-string">(default</span> <span class="hljs-number">20</span><span class="hljs-string">°C)</span></code></pre></li></ul></li></ul><h3 id="ch7-5-接口值"><a href="#ch7-5-接口值" class="headerlink" title="ch7.5   接口值"></a>ch7.5   接口值</h3><ul><li><p>ch7.5.0   简介</p><ul><li><p>概念上讲一个接口的值，接口值，由两个部分组成，一个具体的类型和那个类型的值。它们被称为接口的动态类型和动态值。对于像Go语言这种静态类型的语言，类型是编译期的概念；因此一个类型不是一个值。在我们的概念模型中，一些提供每个类型信息的值被称为类型描述符，比如类型的名称和方法。在一个接口值中，类型部分代表与之相关类型的描述符</p></li><li><p>下面4个语句中，变量w得到了3个不同的值。（开始和最后的值是相同的）</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writerw = os.Stdoutw = <span class="hljs-built_in">new</span>(bytes.Buffer)w = <span class="hljs-literal">nil</span></code></pre><ul><li><p>让我们进一步观察在每一个语句后的w变量的值和动态行为。第一个语句定义了变量w:</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer</code></pre><ul><li><p>在Go语言中，变量总是被一个定义明确的值初始化，即使接口类型也不例外。对于一个接口的零值就是它的类型和值的部分都是nil</p></li><li><p>一个接口值基于它的动态类型被描述为空或非空，所以这是一个空的接口值。你可以通过使用w==nil或者w!=nil来判断接口值是否为空。调用一个空接口值上的任意方法都会产生panic:</p><pre><code class="hljs go">w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">// panic: nil pointer dereference</span></code></pre></li></ul></li><li><p>第二个语句将一个<code>*os.File</code>类型的值赋给变量w</p><pre><code class="hljs go">w = os.Stdout</code></pre><ul><li><p>这个赋值过程调用了一个具体类型到接口类型的隐式转换，这和显式的使用io.Writer(os.Stdout)是等价的。这类转换不管是显式的还是隐式的，都会刻画出操作到的类型和值。这个接口值的动态类型被设为<code>*os.File</code>指针的类型描述符，它的动态值持有os.Stdout的拷贝；这是一个代表处理标准输出的os.File类型变量的指针</p></li><li><p>调用一个包含<code>*os.File</code>类型指针的接口值的Write方法，使得<code>(*os.File).Write</code>方法被调用。这个调用输出“hello”。</p><pre><code class="hljs go">w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">// &quot;hello&quot;</span></code></pre></li><li><p>通常在编译期，我们不知道接口值的动态类型是什么，所以一个接口上的调用必须使用动态分配。因为不是直接进行调用，所以编译器必须把代码生成在类型描述符的方法Write上，然后间接调用那个地址。这个调用的接收者是一个接口动态值的拷贝，os.Stdout。效果和下面这个直接调用一样：</p><pre><code class="hljs go">os.Stdout.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">// &quot;hello&quot;</span></code></pre></li></ul></li><li><p>第三个语句给接口值赋了一个*bytes.Buffer类型的值</p><pre><code class="hljs go">w = <span class="hljs-built_in">new</span>(bytes.Buffer)</code></pre><ul><li><p>现在动态类型是*bytes.Buffer并且动态值是一个指向新分配的缓冲区的指针</p></li><li><p>Write方法的调用也使用了和之前一样的机制：</p><pre><code class="hljs go">w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello&quot;</span>)) <span class="hljs-comment">// writes &quot;hello&quot; to the bytes.Buffers</span></code></pre></li><li><p>这次类型描述符是*bytes.Buffer，所以调用了(*bytes.Buffer).Write方法，并且接收者是该缓冲区的地址。这个调用把字符串“hello”添加到缓冲区中。</p></li></ul></li><li><p>最后，第四个语句将nil赋给了接口值：</p><pre><code class="hljs go">w = <span class="hljs-literal">nil</span></code></pre><ul><li>这个重置将它所有的部分都设为nil值，把变量w恢复到和它之前定义时相同的状态</li></ul></li></ul></li><li><p>一个接口值可以持有任意大的动态值。例如，表示时间实例的time.Time类型，这个类型有几个对外不公开的字段。我们从它上面创建一个接口值：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125; = time.Now()</code></pre><ul><li>从概念上讲，不论接口值多大，动态值总是可以容下它。</li></ul></li><li><p>接口值可以使用==和!＝来进行比较。两个接口值相等仅当它们都是nil值，或者它们的动态类型相同并且动态值也根据这个动态类型的==操作相等。因为接口值是可比较的，所以它们可以用在map的键或者作为switch语句的操作数。</p></li><li><p>然而，如果两个接口值的动态类型相同，但是这个动态类型是不可比较的（比如切片），将它们进行比较就会失败并且panic</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125; = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;fmt.Println(x == x) <span class="hljs-comment">// panic: comparing uncomparable type []int</span></code></pre></li><li><p>考虑到这点，接口类型是非常与众不同的。</p><ul><li>其它类型要么是安全的可比较类型（如基本类型和指针）</li><li>要么是完全不可比较的类型（如切片，映射类型，和函数）</li><li>但是在比较接口值或者包含了接口值的聚合类型时，我们必须要意识到潜在的panic</li><li>同样的风险也存在于使用接口作为map的键或者switch的操作数</li><li>只能比较你非常确定它们的动态值是可比较类型的接口值。</li></ul></li><li><p>当我们处理错误或者调试的过程中，得知接口值的动态类型是非常有帮助的。所以我们使用fmt包的%T动作:</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writerfmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, w) <span class="hljs-comment">// &quot;&lt;nil&gt;&quot;</span>w = os.Stdoutfmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, w) <span class="hljs-comment">// &quot;*os.File&quot;</span>w = <span class="hljs-built_in">new</span>(bytes.Buffer)fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, w) <span class="hljs-comment">// &quot;*bytes.Buffer&quot;</span></code></pre><ul><li>在fmt包内部，使用反射来获取接口动态类型的名称。</li></ul></li></ul></li><li><p>ch7.5.1   警告：一个包含nil指针的接口不是nil接口</p><ul><li><p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。</p></li><li><p>思考下面的程序。当debug变量设置为true时，main函数会将f函数的输出收集到一个bytes.Buffer类型中。</p><pre><code class="hljs go"><span class="hljs-keyword">const</span> debug = <span class="hljs-literal">true</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> buf *bytes.Buffer<span class="hljs-keyword">if</span> debug &#123;buf = <span class="hljs-built_in">new</span>(bytes.Buffer) <span class="hljs-comment">// enable collection of output</span>&#125;f(buf) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> subtly incorrect!</span><span class="hljs-keyword">if</span> debug &#123;<span class="hljs-comment">// ...use buf...</span>&#125;&#125;<span class="hljs-comment">// If out is non-nil, output will be written to it.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(out io.Writer)</span></span> &#123;<span class="hljs-comment">// ...do something...</span><span class="hljs-keyword">if</span> out != <span class="hljs-literal">nil</span> &#123;out.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;done!\n&quot;</span>))&#125;&#125;</code></pre></li><li><p>我们可能会预计当把变量debug设置为false时可以禁止对输出的收集，但是实际上在out.Write方法调用时程序发生了panic：</p><pre><code class="hljs go"><span class="hljs-keyword">if</span> out != <span class="hljs-literal">nil</span> &#123;out.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;done!\n&quot;</span>)) <span class="hljs-comment">// panic: nil pointer dereference</span>&#125;</code></pre></li><li><p>当main函数调用函数f时，它给f函数的out参数赋了一个*bytes.Buffer的空指针，所以out的动态值是nil。然而，它的动态类型是*bytes.Buffer，意思就是out变量是一个包含空指针值的非空接口（如图7.5），所以防御性检查out!=nil的结果依然是true。</p></li><li><p>动态分配机制依然决定(*bytes.Buffer).Write的方法会被调用，但是这次的接收者的值是nil。对于一些如*os.File的类型，nil是一个有效的接收者（§6.2.1），但是*bytes.Buffer类型不在这些种类中。这个方法会被调用，但是当它尝试去获取缓冲区时会发生panic。</p></li><li><p>问题在于尽管一个nil的*bytes.Buffer指针有实现这个接口的方法，它也不满足这个接口具体的行为上的要求。特别是这个调用违反了(*bytes.Buffer).Write方法的接收者非空的隐含先觉条件，所以将nil指针赋给这个接口是错误的。解决方案就是将main函数中的变量buf的类型改为io.Writer，因此可以避免一开始就将一个不完整的值赋值给这个接口：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> buf io.Writer<span class="hljs-keyword">if</span> debug &#123;buf = <span class="hljs-built_in">new</span>(bytes.Buffer) <span class="hljs-comment">// enable collection of output</span>&#125;f(buf) <span class="hljs-comment">// OK</span></code></pre></li><li><p>现在我们已经把接口值的技巧都讲完了，让我们来看更多的一些在Go标准库中的重要接口类型。在下面的三章中，我们会看到接口类型是怎样用在排序，web服务，错误处理中的。</p></li></ul></li></ul><h3 id="ch7-6-sort-Interface接口"><a href="#ch7-6-sort-Interface接口" class="headerlink" title="ch7.6   sort.Interface接口"></a>ch7.6   sort.Interface接口</h3><ul><li><p>排序操作和字符串格式化一样是很多程序经常使用的操作。尽管一个最短的快排程序只要15行就可以搞定，但是一个健壮的实现需要更多的代码，并且我们不希望每次我们需要的时候都重写或者拷贝这些代码。</p></li><li><p>幸运的是，sort包内置的提供了根据一些排序函数来对任何序列排序的功能。它的设计非常独到。在很多语言中，排序算法都是和序列数据类型关联，同时排序函数和具体类型元素关联。</p></li><li><p>相比之下，Go语言的sort.Sort函数不会对具体的序列和它的元素做任何假设。相反，它使用了一个接口类型sort.Interface来指定通用的排序算法和可能被排序到的序列类型之间的约定。这个接口的实现由序列的具体表示和它希望排序的元素决定，序列的表示经常是一个切片。</p></li><li><p>一个内置的排序算法需要知道三个东西</p><ul><li><p>序列的长度</p></li><li><p>表示两个元素比较的结果</p></li><li><p>一种交换两个元素的方式</p></li><li><p>这就是sort.Interface的三个方法：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> sort<span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;Len() <span class="hljs-keyword">int</span>Less(i, j <span class="hljs-keyword">int</span>) <span class="hljs-keyword">bool</span> <span class="hljs-comment">// i, j are indices of sequence elements</span>Swap(i, j <span class="hljs-keyword">int</span>)&#125;</code></pre></li></ul></li><li><p>为了对序列进行排序，我们需要定义一个实现了这三个方法的类型，然后对这个类型的一个实例应用sort.Sort函数。</p><ul><li><p>思考对一个字符串切片进行排序，这可能是最简单的例子了。下面是这个新的类型StringSlice和它的Len，Less和Swap方法</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> StringSlice []<span class="hljs-keyword">string</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p StringSlice)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(p) &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p StringSlice)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123; <span class="hljs-keyword">return</span> p[i] &lt; p[j] &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p StringSlice)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span>      &#123; p[i], p[j] = p[j], p[i] &#125;</code></pre></li><li><p>现在我们可以通过像下面这样将一个切片转换为一个StringSlice类型来进行排序：</p><pre><code class="hljs go">sort.Sort(StringSlice(names))</code></pre></li><li><p>这个转换得到一个相同长度，容量，和基于names数组的切片值；并且这个切片值的类型有三个排序需要的方法。</p></li></ul></li><li><p>对字符串切片的排序是很常用的需要，所以sort包提供了StringSlice类型，也提供了Strings函数能让上面这些调用简化成sort.Strings(names)。</p></li><li><p>这里用到的技术很容易适用到其它排序序列中，例如我们可以忽略大小写或者含有的特殊字符。（本书使用Go程序对索引词和页码进行排序也用到了这个技术，对罗马数字做了额外逻辑处理。）对于更复杂的排序，我们使用相同的方法，但是会用更复杂的数据结构和更复杂地实现sort.Interface的方法。</p></li><li><p>我们会运行上面的例子来对一个表格中的音乐播放列表进行排序。每个track都是单独的一行，每一列都是这个track的属性像艺术家，标题，和运行时间。想象一个图形用户界面来呈现这个表格，并且点击一个属性的顶部会使这个列表按照这个属性进行排序；再一次点击相同属性的顶部会进行逆向排序。让我们看下每个点击会发生什么响应。</p></li><li><p>下面的变量tracks包含了一个播放列表。（One of the authors apologizes for the other author’s musical tastes.）每个元素都不是Track本身而是指向它的指针。尽管我们在下面的代码中直接存储Tracks也可以工作，sort函数会交换很多对元素，所以如果每个元素都是指针而不是Track类型会更快，指针是一个机器字码长度而Track类型可能是八个或更多。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Track <span class="hljs-keyword">struct</span> &#123;Title  <span class="hljs-keyword">string</span>Artist <span class="hljs-keyword">string</span>Album  <span class="hljs-keyword">string</span>Year   <span class="hljs-keyword">int</span>Length time.Duration&#125;<span class="hljs-keyword">var</span> tracks = []*Track&#123;&#123;<span class="hljs-string">&quot;Go&quot;</span>, <span class="hljs-string">&quot;Delilah&quot;</span>, <span class="hljs-string">&quot;From the Roots Up&quot;</span>, <span class="hljs-number">2012</span>, length(<span class="hljs-string">&quot;3m38s&quot;</span>)&#125;,&#123;<span class="hljs-string">&quot;Go&quot;</span>, <span class="hljs-string">&quot;Moby&quot;</span>, <span class="hljs-string">&quot;Moby&quot;</span>, <span class="hljs-number">1992</span>, length(<span class="hljs-string">&quot;3m37s&quot;</span>)&#125;,&#123;<span class="hljs-string">&quot;Go Ahead&quot;</span>, <span class="hljs-string">&quot;Alicia Keys&quot;</span>, <span class="hljs-string">&quot;As I Am&quot;</span>, <span class="hljs-number">2007</span>, length(<span class="hljs-string">&quot;4m36s&quot;</span>)&#125;,&#123;<span class="hljs-string">&quot;Ready 2 Go&quot;</span>, <span class="hljs-string">&quot;Martin Solveig&quot;</span>, <span class="hljs-string">&quot;Smash&quot;</span>, <span class="hljs-number">2011</span>, length(<span class="hljs-string">&quot;4m24s&quot;</span>)&#125;,&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">length</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">time</span>.<span class="hljs-title">Duration</span></span> &#123;d, err := time.ParseDuration(s)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(s)&#125;<span class="hljs-keyword">return</span> d&#125;</code></pre></li><li><p>printTracks函数将播放列表打印成一个表格。一个图形化的展示可能会更好点，但是这个小程序使用text/tabwriter包来生成一个列整齐对齐和隔开的表格，像下面展示的这样。注意到<code>*tabwriter.Writer</code>是满足io.Writer接口的。它会收集每一片写向它的数据；它的Flush方法会格式化整个表格并且将它写向os.Stdout（标准输出）。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printTracks</span><span class="hljs-params">(tracks []*Track)</span></span> &#123;<span class="hljs-keyword">const</span> format = <span class="hljs-string">&quot;%v\t%v\t%v\t%v\t%v\t\n&quot;</span>tw := <span class="hljs-built_in">new</span>(tabwriter.Writer).Init(os.Stdout, <span class="hljs-number">0</span>, <span class="hljs-number">8</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&#x27; &#x27;</span>, <span class="hljs-number">0</span>)fmt.Fprintf(tw, format, <span class="hljs-string">&quot;Title&quot;</span>, <span class="hljs-string">&quot;Artist&quot;</span>, <span class="hljs-string">&quot;Album&quot;</span>, <span class="hljs-string">&quot;Year&quot;</span>, <span class="hljs-string">&quot;Length&quot;</span>)fmt.Fprintf(tw, format, <span class="hljs-string">&quot;-----&quot;</span>, <span class="hljs-string">&quot;------&quot;</span>, <span class="hljs-string">&quot;-----&quot;</span>, <span class="hljs-string">&quot;----&quot;</span>, <span class="hljs-string">&quot;------&quot;</span>)<span class="hljs-keyword">for</span> _, t := <span class="hljs-keyword">range</span> tracks &#123;fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length)&#125;tw.Flush() <span class="hljs-comment">// calculate column widths and print table</span>&#125;</code></pre><ul><li><p>为了能按照Artist字段对播放列表进行排序，我们会像对StringSlice那样定义一个新的带有必须的Len，Less和Swap方法的切片类型。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> byArtist []*Track<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x byArtist)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(x) &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x byArtist)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123; <span class="hljs-keyword">return</span> x[i].Artist &lt; x[j].Artist &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x byArtist)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span>      &#123; x[i], x[j] = x[j], x[i] &#125;</code></pre></li><li><p>为了调用通用的排序程序，我们必须先将tracks转换为新的byArtist类型，它定义了具体的排序：</p><pre><code class="hljs go">sort.Sort(byArtist(tracks))</code></pre><ul><li><p>在按照artist对这个切片进行排序后，printTrack的输出如下</p><pre><code class="hljs angelscript">Title       Artist          Album               Year Length-----       ------          -----               ---- ------Go Ahead    Alicia Keys     As I Am             <span class="hljs-number">2007</span> <span class="hljs-number">4</span>m36sGo          Delilah         From the Roots Up   <span class="hljs-number">2012</span> <span class="hljs-number">3</span>m38sReady <span class="hljs-number">2</span> Go  Martin Solveig  Smash               <span class="hljs-number">2011</span> <span class="hljs-number">4</span>m24sGo          Moby            Moby                <span class="hljs-number">1992</span> <span class="hljs-number">3</span>m37s</code></pre></li></ul></li><li><p>如果用户第二次请求“按照artist排序”，我们会对tracks进行逆向排序。然而我们不需要定义一个有颠倒Less方法的新类型byReverseArtist，因为sort包中提供了Reverse函数将排序顺序转换成逆序。</p><pre><code class="hljs go">sort.Sort(sort.Reverse(byArtist(tracks)))</code></pre><ul><li><p>在按照artist对这个切片进行逆向排序后，printTrack的输出如下</p><pre><code class="hljs angelscript">Title       Artist          Album               Year Length-----       ------          -----               ---- ------Go          Moby            Moby                <span class="hljs-number">1992</span> <span class="hljs-number">3</span>m37sReady <span class="hljs-number">2</span> Go  Martin Solveig  Smash               <span class="hljs-number">2011</span> <span class="hljs-number">4</span>m24sGo          Delilah         From the Roots Up   <span class="hljs-number">2012</span> <span class="hljs-number">3</span>m38sGo Ahead    Alicia Keys     As I Am             <span class="hljs-number">2007</span> <span class="hljs-number">4</span>m36s</code></pre></li></ul></li></ul></li><li><p>sort.Reverse函数值得进行更近一步的学习，因为它使用了（§6.3）章中的组合，这是一个重要的思路。sort包定义了一个不公开的struct类型reverse，它嵌入了一个sort.Interface。reverse的Less方法调用了内嵌的sort.Interface值的Less方法，但是通过交换索引的方式使排序结果变成逆序。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> sort<span class="hljs-keyword">type</span> reverse <span class="hljs-keyword">struct</span>&#123; Interface &#125; <span class="hljs-comment">// that is, sort.Interface</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r reverse)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123; <span class="hljs-keyword">return</span> r.Interface.Less(j, i) &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reverse</span><span class="hljs-params">(data Interface)</span> <span class="hljs-title">Interface</span></span> &#123; <span class="hljs-keyword">return</span> reverse&#123;data&#125; &#125;</code></pre><ul><li>reverse的另外两个方法Len和Swap隐式地由原有内嵌的sort.Interface提供。因为reverse是一个不公开的类型，所以导出函数Reverse返回一个包含原有sort.Interface值的reverse类型实例。</li></ul></li><li><p>为了可以按照不同的列进行排序，我们必须定义一个新的类型例如byYear：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> byYear []*Track<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x byYear)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(x) &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x byYear)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123; <span class="hljs-keyword">return</span> x[i].Year &lt; x[j].Year &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x byYear)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span>      &#123; x[i], x[j] = x[j], x[i] &#125;</code></pre><ul><li><p>在使用sort.Sort(byYear(tracks))按照年对tracks进行排序后，printTrack展示了一个按时间先后顺序的列表：</p><pre><code class="hljs angelscript">Title       Artist          Album               Year Length-----       ------          -----               ---- ------Go          Moby            Moby                <span class="hljs-number">1992</span> <span class="hljs-number">3</span>m37sGo Ahead    Alicia Keys     As I Am             <span class="hljs-number">2007</span> <span class="hljs-number">4</span>m36sReady <span class="hljs-number">2</span> Go  Martin Solveig  Smash               <span class="hljs-number">2011</span> <span class="hljs-number">4</span>m24sGo          Delilah         From the Roots Up   <span class="hljs-number">2012</span> <span class="hljs-number">3</span>m38s</code></pre></li></ul></li><li><p>对于我们需要的每个切片元素类型和每个排序函数，我们需要定义一个新的sort.Interface实现。如你所见，Len和Swap方法对于所有的切片类型都有相同的定义。</p><ul><li><p>下个例子，具体的类型customSort会将一个切片和函数结合，使我们只需要写比较函数就可以定义一个新的排序。顺便说下，实现了sort.Interface的具体类型不一定是切片类型；customSort是一个结构体类型。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> customSort <span class="hljs-keyword">struct</span> &#123;t    []*Trackless <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span> <span class="hljs-title">bool</span></span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x customSort)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span>           &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(x.t) &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x customSort)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123; <span class="hljs-keyword">return</span> x.less(x.t[i], x.t[j]) &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(x customSort)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span>&#123; x.t[i], x.t[j] = x.t[j], x.t[i] &#125;</code></pre></li></ul></li><li><p>让我们定义一个多层的排序函数，它主要的排序键是标题，第二个键是年，第三个键是运行时间Length。下面是该排序的调用，其中这个排序使用了匿名排序函数：</p><pre><code class="hljs go">sort.Sort(customSort&#123;tracks, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y *Track)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> x.Title != y.Title &#123;<span class="hljs-keyword">return</span> x.Title &lt; y.Title&#125;<span class="hljs-keyword">if</span> x.Year != y.Year &#123;<span class="hljs-keyword">return</span> x.Year &lt; y.Year&#125;<span class="hljs-keyword">if</span> x.Length != y.Length &#123;<span class="hljs-keyword">return</span> x.Length &lt; y.Length&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;)</code></pre><ul><li><p>这下面是排序的结果。注意到两个标题是“Go”的track按照标题排序是相同的顺序，但是在按照year排序上更久的那个track优先。</p><pre><code class="hljs angelscript">Title       Artist          Album               Year Length-----       ------          -----               ---- ------Go          Moby            Moby                <span class="hljs-number">1992</span> <span class="hljs-number">3</span>m37sGo          Delilah         From the Roots Up   <span class="hljs-number">2012</span> <span class="hljs-number">3</span>m38sGo Ahead    Alicia Keys     As I Am             <span class="hljs-number">2007</span> <span class="hljs-number">4</span>m36sReady <span class="hljs-number">2</span> Go  Martin Solveig  Smash               <span class="hljs-number">2011</span> <span class="hljs-number">4</span>m24s</code></pre></li></ul></li><li><p>尽管对长度为n的序列排序需要 O(n log n)次比较操作，检查一个序列是否已经有序至少需要n-1次比较。sort包中的IsSorted函数帮我们做这样的检查。像sort.Sort一样，它也使用sort.Interface对这个序列和它的排序函数进行抽象，但是它从不会调用Swap方法：这段代码示范了IntsAreSorted和Ints函数在IntSlice类型上的使用：</p><pre><code class="hljs go">values := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>&#125;fmt.Println(sort.IntsAreSorted(values)) <span class="hljs-comment">// &quot;false&quot;</span>sort.Ints(values)fmt.Println(values)                     <span class="hljs-comment">// &quot;[1 1 3 4]&quot;</span>fmt.Println(sort.IntsAreSorted(values)) <span class="hljs-comment">// &quot;true&quot;</span>sort.Sort(sort.Reverse(sort.IntSlice(values)))fmt.Println(values)                     <span class="hljs-comment">// &quot;[4 3 1 1]&quot;</span>fmt.Println(sort.IntsAreSorted(values)) <span class="hljs-comment">// &quot;false&quot;</span></code></pre></li><li><p>为了使用方便，sort包为[]int、[]string和[]float64的正常排序提供了特定版本的函数和类型。对于其他类型，例如[]int64或者[]uint，尽管路径也很简单，还是依赖我们自己实现。</p></li></ul><h3 id="ch7-7-http-Handler接口"><a href="#ch7-7-http-Handler接口" class="headerlink" title="ch7.7   http.Handler接口"></a>ch7.7   http.Handler接口</h3><ul><li><p>在第一章中，我们粗略的了解了怎么用net/http包去实现网络客户端（§1.5）和服务器（§1.7）。在这个小节中，我们会对那些基于http.Handler接口的服务器API做更进一步的学习：</p><p><u><i>net/http</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> http<span class="hljs-keyword">type</span> Handler <span class="hljs-keyword">interface</span> &#123;ServeHTTP(w ResponseWriter, r *Request)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ListenAndServe</span><span class="hljs-params">(address <span class="hljs-keyword">string</span>, h Handler)</span> <span class="hljs-title">error</span></span></code></pre></li><li><p>ListenAndServe函数需要一个例如“localhost:8000”的服务器地址，和一个所有请求都可以分派的Handler接口实例。它会一直运行，直到这个服务因为一个错误而失败（或者启动失败），它的返回值一定是一个非空的错误。</p></li><li><p>想象一个电子商务网站，为了销售，将数据库中物品的价格映射成美元。</p></li><li><p>下面这个程序可能是能想到的最简单的实现了。它将库存清单模型化为一个命名为database的map类型，我们给这个类型一个ServeHttp方法，这样它可以满足http.Handler接口。这个handler会遍历整个map并输出物品信息。</p><p><u><i>gopl.io/ch7/http1</i></u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;db := database&#123;<span class="hljs-string">&quot;shoes&quot;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&quot;socks&quot;</span>: <span class="hljs-number">5</span>&#125;log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, db))&#125;<span class="hljs-keyword">type</span> dollars <span class="hljs-keyword">float32</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dollars)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123; <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;$%.2f&quot;</span>, d) &#125;<span class="hljs-keyword">type</span> database <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]dollars<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<span class="hljs-keyword">for</span> item, price := <span class="hljs-keyword">range</span> db &#123;fmt.Fprintf(w, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, item, price)&#125;&#125;</code></pre><ul><li><p>如果我们启动这个服务，</p><pre><code class="hljs awk">$ go build gopl.io<span class="hljs-regexp">/ch7/</span>http1$ ./http1 &amp;</code></pre></li><li><p>然后用1.5节中的获取程序（如果你更喜欢可以使用web浏览器）来连接服务器，我们得到下面的输出：</p><pre><code class="hljs gams"><span class="hljs-symbol">$</span> go build gopl.io/ch1/fetch<span class="hljs-symbol">$</span> ./fetch http:<span class="hljs-comment">//localhost:8000</span>shoes: <span class="hljs-symbol">$</span><span class="hljs-number">50.00</span>socks: <span class="hljs-symbol">$</span><span class="hljs-number">5.00</span></code></pre></li></ul></li><li><p>目前为止，这个服务器不考虑URL，只能为每个请求列出它全部的库存清单。更真实的服务器会定义多个不同的URL，每一个都会触发一个不同的行为。让我们使用/list来调用已经存在的这个行为并且增加另一个/price调用表明单个货品的价格，像这样/price?item=socks来指定一个请求参数。</p><p></i></u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<span class="hljs-keyword">switch</span> req.URL.Path &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/list&quot;</span>:<span class="hljs-keyword">for</span> item, price := <span class="hljs-keyword">range</span> db &#123;fmt.Fprintf(w, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, item, price)&#125;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;/price&quot;</span>:item := req.URL.Query().Get(<span class="hljs-string">&quot;item&quot;</span>)price, ok := db[item]<span class="hljs-keyword">if</span> !ok &#123;w.WriteHeader(http.StatusNotFound) <span class="hljs-comment">// 404</span>fmt.Fprintf(w, <span class="hljs-string">&quot;no such item: %q\n&quot;</span>, item)<span class="hljs-keyword">return</span>&#125;fmt.Fprintf(w, <span class="hljs-string">&quot;%s\n&quot;</span>, price)<span class="hljs-keyword">default</span>:w.WriteHeader(http.StatusNotFound) <span class="hljs-comment">// 404</span>fmt.Fprintf(w, <span class="hljs-string">&quot;no such page: %s\n&quot;</span>, req.URL)&#125;&#125;</code></pre><ul><li><p>现在handler基于URL的路径部分（req.URL.Path）来决定执行什么逻辑。如果这个handler不能识别这个路径，它会通过调用w.WriteHeader(http.StatusNotFound)返回客户端一个HTTP错误；这个检查应该在向w写入任何值前完成。（顺便提一下，http.ResponseWriter是另一个接口。它在io.Writer上增加了发送HTTP相应头的方法。）等效地，我们可以使用实用的http.Error函数：</p><pre><code class="hljs go">msg := fmt.Sprintf(<span class="hljs-string">&quot;no such page: %s\n&quot;</span>, req.URL)http.Error(w, msg, http.StatusNotFound) <span class="hljs-comment">// 404</span></code></pre></li><li><p>/price的case会调用URL的Query方法来将HTTP请求参数解析为一个map，或者更准确地说一个net/url包中url.Values(§6.2.1)类型的多重映射。然后找到第一个item参数并查找它的价格。如果这个货品没有找到会返回一个错误。</p></li><li><p>这里是一个和新服务器会话的例子：</p><pre><code class="hljs awk">$ go build gopl.io<span class="hljs-regexp">/ch7/</span>http2$ go build gopl.io<span class="hljs-regexp">/ch1/</span>fetch$ ./http2 &amp;$ .<span class="hljs-regexp">/fetch http:/</span><span class="hljs-regexp">/localhost:8000/</span>listshoes: <span class="hljs-variable">$50</span>.<span class="hljs-number">00</span>socks: <span class="hljs-variable">$5</span>.<span class="hljs-number">00</span>$ .<span class="hljs-regexp">/fetch http:/</span><span class="hljs-regexp">/localhost:8000/</span>price?item=socks<span class="hljs-variable">$5</span>.<span class="hljs-number">00</span>$ .<span class="hljs-regexp">/fetch http:/</span><span class="hljs-regexp">/localhost:8000/</span>price?item=shoes<span class="hljs-variable">$50</span>.<span class="hljs-number">00</span>$ .<span class="hljs-regexp">/fetch http:/</span><span class="hljs-regexp">/localhost:8000/</span>price?item=hatno such item: <span class="hljs-string">&quot;hat&quot;</span>$ .<span class="hljs-regexp">/fetch http:/</span><span class="hljs-regexp">/localhost:8000/</span>helpno such page: /help</code></pre></li></ul></li><li><p>显然我们可以继续向ServeHTTP方法中添加case，但在一个实际的应用中，将每个case中的逻辑定义到一个分开的方法或函数中会很实用。此外，相近的URL可能需要相似的逻辑；例如几个图片文件可能有形如/images/*.png的URL。因为这些原因，net/http包提供了一个请求多路器ServeMux来简化URL和handlers的联系。一个ServeMux将一批http.Handler聚集到一个单一的http.Handler中。再一次，我们可以看到满足同一接口的不同类型是可替换的：web服务器将请求指派给任意的http.Handler而不需要考虑它后面的具体类型</p></li><li><p>对于更复杂的应用，一些ServeMux可以通过组合来处理更加错综复杂的路由需求。Go语言目前没有一个权威的web框架，就像Ruby语言有Rails和python有Django。这并不是说这样的框架不存在，而是Go语言标准库中的构建模块就已经非常灵活以至于这些框架都是不必要的。此外，尽管在一个项目早期使用框架是非常方便的，但是它们带来额外的复杂度会使长期的维护更加困难。</p></li><li><p>在下面的程序中，我们创建一个ServeMux并且使用它将URL和相应处理/list和/price操作的handler联系起来，这些操作逻辑都已经被分到不同的方法中。然后我们在调用ListenAndServe函数中使用ServeMux为主要的handler。</p><p></i></u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;db := database&#123;<span class="hljs-string">&quot;shoes&quot;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&quot;socks&quot;</span>: <span class="hljs-number">5</span>&#125;mux := http.NewServeMux()mux.Handle(<span class="hljs-string">&quot;/list&quot;</span>, http.HandlerFunc(db.list))mux.Handle(<span class="hljs-string">&quot;/price&quot;</span>, http.HandlerFunc(db.price))log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, mux))&#125;<span class="hljs-keyword">type</span> database <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]dollars<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span> <span class="hljs-title">list</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;<span class="hljs-keyword">for</span> item, price := <span class="hljs-keyword">range</span> db &#123;fmt.Fprintf(w, <span class="hljs-string">&quot;%s: %s\n&quot;</span>, item, price)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(db database)</span> <span class="hljs-title">price</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span> &#123;item := req.URL.Query().Get(<span class="hljs-string">&quot;item&quot;</span>)price, ok := db[item]<span class="hljs-keyword">if</span> !ok &#123;w.WriteHeader(http.StatusNotFound) <span class="hljs-comment">// 404</span>fmt.Fprintf(w, <span class="hljs-string">&quot;no such item: %q\n&quot;</span>, item)<span class="hljs-keyword">return</span>&#125;fmt.Fprintf(w, <span class="hljs-string">&quot;%s\n&quot;</span>, price)&#125;</code></pre><ul><li><p>让我们关注这两个注册到handlers上的调用。第一个db.list是一个方法值（§6.4），它是下面这个类型的值。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w http.ResponseWriter, req *http.Request)</span></span></code></pre></li></ul></li><li><p>也就是说db.list的调用会援引一个接收者是db的database.list方法。所以db.list是一个实现了handler类似行为的函数，但是因为它没有方法（理解：该方法没有它自己的方法），所以它不满足http.Handler接口并且不能直接传给mux.Handle。</p><ul><li><p>语句http.HandlerFunc(db.list)是一个转换而非一个函数调用，因为http.HandlerFunc是一个类型。它有如下的定义：</p><p><u><i>net/http</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> http<span class="hljs-keyword">type</span> HandlerFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(w ResponseWriter, r *Request)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f HandlerFunc)</span> <span class="hljs-title">ServeHTTP</span><span class="hljs-params">(w ResponseWriter, r *Request)</span></span> &#123;f(w, r)&#125;</code></pre></li></ul></li><li><p>HandlerFunc显示了在Go语言接口机制中一些不同寻常的特点。这是一个实现了接口http.Handler的方法的函数类型。ServeHTTP方法的行为是调用了它的函数本身。因此HandlerFunc是一个让函数值满足一个接口的适配器，这里函数和这个接口仅有的方法有相同的函数签名。实际上，这个技巧让一个单一的类型例如database以多种方式满足http.Handler接口：一种通过它的list方法，一种通过它的price方法等等。</p><ul><li><p>因为handler通过这种方式注册非常普遍，ServeMux有一个方便的HandleFunc方法，它帮我们简化handler注册代码成这样：</p><p><u><i>gopl.io/ch7/http3a</i></u></p><pre><code class="hljs go">mux.HandleFunc(<span class="hljs-string">&quot;/list&quot;</span>, db.list)mux.HandleFunc(<span class="hljs-string">&quot;/price&quot;</span>, db.price)</code></pre></li></ul></li><li><p>从上面的代码很容易看出应该怎么构建一个程序：由两个不同的web服务器监听不同的端口，并且定义不同的URL将它们指派到不同的handler。我们只要构建另外一个ServeMux并且再调用一次ListenAndServe（可能并行的）。但是在大多数程序中，一个web服务器就足够了。此外，在一个应用程序的多个文件中定义HTTP handler也是非常典型的，如果它们必须全部都显式地注册到这个应用的ServeMux实例上会比较麻烦。</p></li><li><p>所以为了方便，net/http包提供了一个全局的ServeMux实例DefaultServerMux和包级别的http.Handle和http.HandleFunc函数。现在，为了使用DefaultServeMux作为服务器的主handler，我们不需要将它传给ListenAndServe函数；nil值就可以工作。</p><ul><li><p>然后服务器的主函数可以简化成：</p><p><u><i>gopl.io/ch7/http4</i></u></p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;db := database&#123;<span class="hljs-string">&quot;shoes&quot;</span>: <span class="hljs-number">50</span>, <span class="hljs-string">&quot;socks&quot;</span>: <span class="hljs-number">5</span>&#125;http.HandleFunc(<span class="hljs-string">&quot;/list&quot;</span>, db.list)http.HandleFunc(<span class="hljs-string">&quot;/price&quot;</span>, db.price)log.Fatal(http.ListenAndServe(<span class="hljs-string">&quot;localhost:8000&quot;</span>, <span class="hljs-literal">nil</span>))&#125;</code></pre></li></ul></li><li><p>最后，一个重要的提示：就像我们在1.7节中提到的，web服务器在一个新的协程中调用每一个handler，所以当handler获取其它协程或者这个handler本身的其它请求也可以访问到变量时，一定要使用预防措施，比如锁机制。我们后面的两章中将讲到并发相关的知识。</p></li></ul><h3 id="ch7-8-error接口"><a href="#ch7-8-error接口" class="headerlink" title="ch7.8   error接口"></a>ch7.8   error接口</h3><ul><li><p>从本书的开始，我们就已经创建和使用过神秘的预定义error类型，而且没有解释它究竟是什么。实际上它就是interface类型，这个类型有一个返回错误信息的单一方法：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> error <span class="hljs-keyword">interface</span> &#123;Error() <span class="hljs-keyword">string</span>&#125;</code></pre></li><li><p>创建一个error最简单的方法就是调用errors.New函数，它会根据传入的错误信息返回一个新的error。整个errors包仅只有4行：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> errors<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(text <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123; <span class="hljs-keyword">return</span> &amp;errorString&#123;text&#125; &#125;<span class="hljs-keyword">type</span> errorString <span class="hljs-keyword">struct</span> &#123; text <span class="hljs-keyword">string</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *errorString)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123; <span class="hljs-keyword">return</span> e.text &#125;</code></pre></li><li><p>承载errorString的类型是一个结构体而非一个字符串，这是为了保护它表示的错误避免粗心（或有意）的更新。并且因为是指针类型<code>*errorString</code>满足error接口而非errorString类型，所以每个New函数的调用都分配了一个独特的和其他错误不相同的实例。我们也不想要重要的error例如io.EOF和一个刚好有相同错误消息的error比较后相等。</p><pre><code class="hljs go">fmt.Println(errors.New(<span class="hljs-string">&quot;EOF&quot;</span>) == errors.New(<span class="hljs-string">&quot;EOF&quot;</span>)) <span class="hljs-comment">// &quot;false&quot;</span></code></pre></li><li><p>调用errors.New函数是非常稀少的，因为有一个方便的封装函数fmt.Errorf，它还会处理字符串格式化。我们曾多次在第5章中用到它。</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> fmt<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;errors&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> errors.New(Sprintf(format, args...))&#125;</code></pre></li><li><p>虽然<code>*errorString</code>可能是最简单的错误类型，但远非只有它一个。例如，syscall包提供了Go语言底层系统调用API。在多个平台上，它定义一个实现error接口的数字类型Errno，并且在Unix平台上，Errno的Error方法会从一个字符串表中查找错误消息，如下面展示的这样：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> syscall<span class="hljs-keyword">type</span> Errno <span class="hljs-keyword">uintptr</span> <span class="hljs-comment">// operating system error code</span><span class="hljs-keyword">var</span> errors = [...]<span class="hljs-keyword">string</span>&#123;<span class="hljs-number">1</span>:   <span class="hljs-string">&quot;operation not permitted&quot;</span>,   <span class="hljs-comment">// EPERM</span><span class="hljs-number">2</span>:   <span class="hljs-string">&quot;no such file or directory&quot;</span>, <span class="hljs-comment">// ENOENT</span><span class="hljs-number">3</span>:   <span class="hljs-string">&quot;no such process&quot;</span>,           <span class="hljs-comment">// ESRCH</span><span class="hljs-comment">// ...</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e Errno)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-number">0</span> &lt;= <span class="hljs-keyword">int</span>(e) &amp;&amp; <span class="hljs-keyword">int</span>(e) &lt; <span class="hljs-built_in">len</span>(errors) &#123;<span class="hljs-keyword">return</span> errors[e]&#125;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;errno %d&quot;</span>, e)&#125;</code></pre><ul><li><p>下面的语句创建了一个持有Errno值为2的接口值，表示POSIX ENOENT状况：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> err error = syscall.Errno(<span class="hljs-number">2</span>)fmt.Println(err.Error()) <span class="hljs-comment">// &quot;no such file or directory&quot;</span>fmt.Println(err)         <span class="hljs-comment">// &quot;no such file or directory&quot;</span></code></pre></li></ul></li><li><p>Errno是一个系统调用错误的高效表示方式，它通过一个有限的集合进行描述，并且它满足标准的错误接口。我们会在第7.11节了解到其它满足这个接口的类型。</p></li></ul><h3 id="ch7-9-示例：表达式求值"><a href="#ch7-9-示例：表达式求值" class="headerlink" title="ch7.9   示例：表达式求值"></a>ch7.9   示例：表达式求值</h3><ul><li><p>在本节中，我们会构建一个简单算术表达式的求值器。我们将使用一个接口Expr来表示Go语言中任意的表达式。现在这个接口不需要有方法，但是我们后面会为它增加一些。</p><pre><code class="hljs go"><span class="hljs-comment">// An Expr is an arithmetic expression.</span><span class="hljs-keyword">type</span> Expr <span class="hljs-keyword">interface</span>&#123;&#125;</code></pre></li><li><p>我们的表达式语言由浮点数符号（小数点）；二元操作符+，-，*， 和/；一元操作符-x和+x；调用pow(x,y)，sin(x)，和sqrt(x)的函数；例如x和pi的变量；当然也有括号和标准的优先级运算符。所有的值都是float64类型。这下面是一些表达式的例子：</p><pre><code class="hljs go">sqrt(A / pi)pow(x, <span class="hljs-number">3</span>) + pow(y, <span class="hljs-number">3</span>)(F - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span></code></pre></li><li><p>下面的五个具体类型表示了具体的表达式类型。</p><p></i></u></p><pre><code class="hljs go"><span class="hljs-comment">// A Var identifies a variable, e.g., x.</span><span class="hljs-keyword">type</span> Var <span class="hljs-keyword">string</span><span class="hljs-comment">// A literal is a numeric constant, e.g., 3.141.</span><span class="hljs-keyword">type</span> literal <span class="hljs-keyword">float64</span><span class="hljs-comment">// A unary represents a unary operator expression, e.g., -x.</span><span class="hljs-keyword">type</span> unary <span class="hljs-keyword">struct</span> &#123;op <span class="hljs-keyword">rune</span> <span class="hljs-comment">// one of &#x27;+&#x27;, &#x27;-&#x27;</span>x  Expr&#125;<span class="hljs-comment">// A binary represents a binary operator expression, e.g., x+y.</span><span class="hljs-keyword">type</span> binary <span class="hljs-keyword">struct</span> &#123;op   <span class="hljs-keyword">rune</span> <span class="hljs-comment">// one of &#x27;+&#x27;, &#x27;-&#x27;, &#x27;*&#x27;, &#x27;/&#x27;</span>x, y Expr&#125;<span class="hljs-comment">// A call represents a function call expression, e.g., sin(x).</span><span class="hljs-keyword">type</span> call <span class="hljs-keyword">struct</span> &#123;fn   <span class="hljs-keyword">string</span> <span class="hljs-comment">// one of &quot;pow&quot;, &quot;sin&quot;, &quot;sqrt&quot;</span>args []Expr&#125;</code></pre><ul><li><p>Var类型表示对一个变量的引用。</p><ul><li>我们很快会知道为什么它可以被输出</li></ul></li><li><p>literal类型表示一个浮点型常量。</p></li><li><p>unary和binary类型表示有一到两个运算对象的运算符表达式，这些操作数可以是任意的Expr类型。</p></li><li><p>call类型表示对一个函数的调用；我们限制它的fn字段只能是pow，sin或者sqrt。</p></li></ul></li><li><p>为了计算一个包含变量的表达式，我们需要一个environment变量将变量的名字映射成对应的值：</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Env <span class="hljs-keyword">map</span>[Var]<span class="hljs-keyword">float64</span></code></pre></li><li><p>我们也需要每个表达式去定义一个Eval方法，这个方法会根据给定的environment变量返回表达式的值。因为每个表达式都必须提供这个方法，我们将它加入到Expr接口中。这个包只会对外公开Expr，Env，和Var类型。调用方不需要获取其它的表达式类型就可以使用这个求值器。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Expr <span class="hljs-keyword">interface</span> &#123;<span class="hljs-comment">// Eval returns the value of this Expr in the environment env.</span>Eval(env Env) <span class="hljs-keyword">float64</span>&#125;</code></pre></li><li><p>下面给大家展示一个具体的Eval方法。Var类型的这个方法对一个environment变量进行查找，如果这个变量没有在environment中定义过这个方法会返回一个零值，literal类型的这个方法简单的返回它真实的值。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span> <span class="hljs-title">Eval</span><span class="hljs-params">(env Env)</span> <span class="hljs-title">float64</span></span> &#123;<span class="hljs-keyword">return</span> env[v]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(l literal)</span> <span class="hljs-title">Eval</span><span class="hljs-params">(_ Env)</span> <span class="hljs-title">float64</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">float64</span>(l)&#125;</code></pre></li><li><p>unary和binary的Eval方法会递归的计算它的运算对象，然后将运算符op作用到它们上。我们不将被零或无穷数除作为一个错误，因为它们都会产生一个固定的结果——无限。最后，call的这个方法会计算对于pow，sin，或者sqrt函数的参数值，然后调用对应在math包中的函数。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span> <span class="hljs-title">Eval</span><span class="hljs-params">(env Env)</span> <span class="hljs-title">float64</span></span> &#123;<span class="hljs-keyword">switch</span> u.op &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> +u.x.Eval(env)<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> -u.x.Eval(env)&#125;<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unsupported unary operator: %q&quot;</span>, u.op))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span> <span class="hljs-title">Eval</span><span class="hljs-params">(env Env)</span> <span class="hljs-title">float64</span></span> &#123;<span class="hljs-keyword">switch</span> b.op &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;+&#x27;</span>:<span class="hljs-keyword">return</span> b.x.Eval(env) + b.y.Eval(env)<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;-&#x27;</span>:<span class="hljs-keyword">return</span> b.x.Eval(env) - b.y.Eval(env)<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;*&#x27;</span>:<span class="hljs-keyword">return</span> b.x.Eval(env) * b.y.Eval(env)<span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;/&#x27;</span>:<span class="hljs-keyword">return</span> b.x.Eval(env) / b.y.Eval(env)&#125;<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unsupported binary operator: %q&quot;</span>, b.op))&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span> <span class="hljs-title">Eval</span><span class="hljs-params">(env Env)</span> <span class="hljs-title">float64</span></span> &#123;<span class="hljs-keyword">switch</span> c.fn &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;pow&quot;</span>:<span class="hljs-keyword">return</span> math.Pow(c.args[<span class="hljs-number">0</span>].Eval(env), c.args[<span class="hljs-number">1</span>].Eval(env))<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sin&quot;</span>:<span class="hljs-keyword">return</span> math.Sin(c.args[<span class="hljs-number">0</span>].Eval(env))<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;sqrt&quot;</span>:<span class="hljs-keyword">return</span> math.Sqrt(c.args[<span class="hljs-number">0</span>].Eval(env))&#125;<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unsupported function call: %s&quot;</span>, c.fn))&#125;</code></pre></li><li><p>一些方法会失败。例如，一个call表达式可能有未知的函数或者错误的参数个数。用一个无效的运算符如!或者&lt;去构建一个unary或者binary表达式也是可能会发生的（尽管下面提到的Parse函数不会这样做）。这些错误会让Eval方法panic。其它的错误，像计算一个没有在environment变量中出现过的Var，只会让Eval方法返回一个错误的结果。所有的这些错误都可以通过在计算前检查Expr来发现。这是我们接下来要讲的Check方法的工作，但是让我们先测试Eval方法。</p></li><li><p>下面的TestEval函数是对evaluator的一个测试。它使用了我们会在第11章讲解的testing包，但是现在知道调用t.Errof会报告一个错误就足够了。这个函数循环遍历一个表格中的输入，这个表格中定义了三个表达式和针对每个表达式不同的环境变量。第一个表达式根据给定圆的面积A计算它的半径，第二个表达式通过两个变量x和y计算两个立方体的体积之和，第三个表达式将华氏温度F转换成摄氏度。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestEval</span><span class="hljs-params">(t *testing.T)</span></span> &#123;tests := []<span class="hljs-keyword">struct</span> &#123;expr <span class="hljs-keyword">string</span>env  Envwant <span class="hljs-keyword">string</span>&#125;&#123;&#123;<span class="hljs-string">&quot;sqrt(A / pi)&quot;</span>, Env&#123;<span class="hljs-string">&quot;A&quot;</span>: <span class="hljs-number">87616</span>, <span class="hljs-string">&quot;pi&quot;</span>: math.Pi&#125;, <span class="hljs-string">&quot;167&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;pow(x, 3) + pow(y, 3)&quot;</span>, Env&#123;<span class="hljs-string">&quot;x&quot;</span>: <span class="hljs-number">12</span>, <span class="hljs-string">&quot;y&quot;</span>: <span class="hljs-number">1</span>&#125;, <span class="hljs-string">&quot;1729&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;pow(x, 3) + pow(y, 3)&quot;</span>, Env&#123;<span class="hljs-string">&quot;x&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-string">&quot;y&quot;</span>: <span class="hljs-number">10</span>&#125;, <span class="hljs-string">&quot;1729&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-number">-40</span>&#125;, <span class="hljs-string">&quot;-40&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-number">32</span>&#125;, <span class="hljs-string">&quot;0&quot;</span>&#125;,&#123;<span class="hljs-string">&quot;5 / 9 * (F - 32)&quot;</span>, Env&#123;<span class="hljs-string">&quot;F&quot;</span>: <span class="hljs-number">212</span>&#125;, <span class="hljs-string">&quot;100&quot;</span>&#125;,&#125;<span class="hljs-keyword">var</span> prevExpr <span class="hljs-keyword">string</span><span class="hljs-keyword">for</span> _, test := <span class="hljs-keyword">range</span> tests &#123;<span class="hljs-comment">// Print expr only when it changes.</span><span class="hljs-keyword">if</span> test.expr != prevExpr &#123;fmt.Printf(<span class="hljs-string">&quot;\n%s\n&quot;</span>, test.expr)prevExpr = test.expr&#125;expr, err := Parse(test.expr)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;t.Error(err) <span class="hljs-comment">// parse error</span><span class="hljs-keyword">continue</span>&#125;got := fmt.Sprintf(<span class="hljs-string">&quot;%.6g&quot;</span>, expr.Eval(test.env))fmt.Printf(<span class="hljs-string">&quot;\t%v =&gt; %s\n&quot;</span>, test.env, got)<span class="hljs-keyword">if</span> got != test.want &#123;t.Errorf(<span class="hljs-string">&quot;%s.Eval() in %v = %q, want %q\n&quot;</span>,test.expr, test.env, got, test.want)&#125;&#125;&#125;</code></pre></li><li><p>对于表格中的每一条记录，这个测试会解析它的表达式然后在环境变量中计算它，输出结果。这里我们没有空间来展示Parse函数，但是如果你使用go get下载这个包你就可以看到这个函数。</p></li><li><p>go test(§11.1) 命令会运行一个包的测试用例：</p><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> go <span class="hljs-built_in">test</span> -v gopl.io/ch7/<span class="hljs-built_in">eval</span></span></code></pre></li><li><p>这个-v标识可以让我们看到测试用例打印的输出；正常情况下像这样一个成功的测试用例会阻止打印结果的输出。这里是测试用例里fmt.Printf语句的输出：</p><pre><code class="hljs angelscript">sqrt(A / pi)    map[A:<span class="hljs-number">87616</span> pi:<span class="hljs-number">3.141592653589793</span>] =&gt; <span class="hljs-number">167</span>pow(x, <span class="hljs-number">3</span>) + pow(y, <span class="hljs-number">3</span>)    map[x:<span class="hljs-number">12</span> y:<span class="hljs-number">1</span>] =&gt; <span class="hljs-number">1729</span>    map[x:<span class="hljs-number">9</span> y:<span class="hljs-number">10</span>] =&gt; <span class="hljs-number">1729</span><span class="hljs-number">5</span> / <span class="hljs-number">9</span> * (F - <span class="hljs-number">32</span>)    map[F:<span class="hljs-number">-40</span>] =&gt; <span class="hljs-number">-40</span>    map[F:<span class="hljs-number">32</span>] =&gt; <span class="hljs-number">0</span>    map[F:<span class="hljs-number">212</span>] =&gt; <span class="hljs-number">100</span></code></pre></li><li><p>幸运的是目前为止所有的输入都是适合的格式，但是我们的运气不可能一直都有。甚至在解释型语言中，为了静态错误检查语法是非常常见的；静态错误就是不用运行程序就可以检测出来的错误。通过将静态检查和动态的部分分开，我们可以快速的检查错误并且对于多次检查只执行一次而不是每次表达式计算的时候都进行检查。</p></li><li><p>让我们往Expr接口中增加另一个方法。Check方法对一个表达式语义树检查出静态错误。我们马上会说明它的vars参数。</p><pre><code class="hljs go"><span class="hljs-keyword">type</span> Expr <span class="hljs-keyword">interface</span> &#123;Eval(env Env) <span class="hljs-keyword">float64</span><span class="hljs-comment">// Check reports errors in this Expr and adds its Vars to the set.</span>Check(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-keyword">bool</span>) error&#125;</code></pre></li><li><p>具体的Check方法展示在下面。literal和Var类型的计算不可能失败，所以这些类型的Check方法会返回一个nil值。对于unary和binary的Check方法会首先检查操作符是否有效，然后递归的检查运算单元。相似地对于call的这个方法首先检查调用的函数是否已知并且有没有正确个数的参数，然后递归的检查每一个参数。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(v Var)</span> <span class="hljs-title">Check</span><span class="hljs-params">(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">error</span></span> &#123;vars[v] = <span class="hljs-literal">true</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(literal)</span> <span class="hljs-title">Check</span><span class="hljs-params">(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(u unary)</span> <span class="hljs-title">Check</span><span class="hljs-params">(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> !strings.ContainsRune(<span class="hljs-string">&quot;+-&quot;</span>, u.op) &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unexpected unary op %q&quot;</span>, u.op)&#125;<span class="hljs-keyword">return</span> u.x.Check(vars)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b binary)</span> <span class="hljs-title">Check</span><span class="hljs-params">(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> !strings.ContainsRune(<span class="hljs-string">&quot;+-*/&quot;</span>, b.op) &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unexpected binary op %q&quot;</span>, b.op)&#125;<span class="hljs-keyword">if</span> err := b.x.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">return</span> b.y.Check(vars)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c call)</span> <span class="hljs-title">Check</span><span class="hljs-params">(vars <span class="hljs-keyword">map</span>[Var]<span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">error</span></span> &#123;arity, ok := numParams[c.fn]<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;unknown function %q&quot;</span>, c.fn)&#125;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(c.args) != arity &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;call to %s has %d args, want %d&quot;</span>,c.fn, <span class="hljs-built_in">len</span>(c.args), arity)&#125;<span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> c.args &#123;<span class="hljs-keyword">if</span> err := arg.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;<span class="hljs-keyword">var</span> numParams = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-string">&quot;pow&quot;</span>: <span class="hljs-number">2</span>, <span class="hljs-string">&quot;sin&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;sqrt&quot;</span>: <span class="hljs-number">1</span>&#125;</code></pre></li><li><p>我们在两个组中有选择地列出有问题的输入和它们得出的错误。Parse函数（这里没有出现）会报出一个语法错误和Check函数会报出语义错误。</p><pre><code class="hljs livecodeserver">x % <span class="hljs-number">2</span>               unexpected <span class="hljs-string">&#x27;%&#x27;</span>math.Pi             unexpected <span class="hljs-string">&#x27;.&#x27;</span>!<span class="hljs-literal">true</span>               unexpected <span class="hljs-string">&#x27;!&#x27;</span><span class="hljs-string">&quot;hello&quot;</span>             unexpected <span class="hljs-string">&#x27;&quot;&#x27;</span><span class="hljs-built_in">log</span>(<span class="hljs-number">10</span>)             unknown <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-string">&quot;log&quot;</span></span><span class="hljs-built_in">sqrt</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)          call <span class="hljs-built_in">to</span> <span class="hljs-built_in">sqrt</span> has <span class="hljs-number">2</span> args, want <span class="hljs-number">1</span></code></pre></li><li><p>Check方法的参数是一个Var类型的集合，这个集合聚集从表达式中找到的变量名。为了保证成功的计算，这些变量中的每一个都必须出现在环境变量中。从逻辑上讲，这个集合就是调用Check方法返回的结果，但是因为这个方法是递归调用的，所以对于Check方法，填充结果到一个作为参数传入的集合中会更加的方便。调用方在初始调用时必须提供一个空的集合。</p></li><li><p>在第3.2节中，我们绘制了一个在编译期才确定的函数f(x,y)。现在我们可以解析，检查和计算在字符串中的表达式，我们可以构建一个在运行时从客户端接收表达式的web应用并且它会绘制这个函数的表示的曲面。我们可以使用集合vars来检查表达式是否是一个只有两个变量x和y的函数——实际上是3个，因为我们为了方便会提供半径大小r。并且我们会在计算前使用Check方法拒绝有格式问题的表达式，这样我们就不会在下面函数的40000个计算过程（100x100个栅格，每一个有4个角）重复这些检查。</p></li><li><p>这个ParseAndCheck函数混合了解析和检查步骤的过程：</p><p><u><i>gopl.io/ch7/surface</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;gopl.io/ch7/eval&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseAndCheck</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(eval.Expr, error)</span></span> &#123;<span class="hljs-keyword">if</span> s == <span class="hljs-string">&quot;&quot;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;empty expression&quot;</span>)&#125;expr, err := eval.Parse(s)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;vars := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[eval.Var]<span class="hljs-keyword">bool</span>)<span class="hljs-keyword">if</span> err := expr.Check(vars); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;<span class="hljs-keyword">for</span> v := <span class="hljs-keyword">range</span> vars &#123;<span class="hljs-keyword">if</span> v != <span class="hljs-string">&quot;x&quot;</span> &amp;&amp; v != <span class="hljs-string">&quot;y&quot;</span> &amp;&amp; v != <span class="hljs-string">&quot;r&quot;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;undefined variable: %s&quot;</span>, v)&#125;&#125;<span class="hljs-keyword">return</span> expr, <span class="hljs-literal">nil</span>&#125;</code></pre></li><li><p>为了编写这个web应用，所有我们需要做的就是下面这个plot函数，这个函数有和http.HandlerFunc相似的签名：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">plot</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;r.ParseForm()expr, err := parseAndCheck(r.Form.Get(<span class="hljs-string">&quot;expr&quot;</span>))<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;http.Error(w, <span class="hljs-string">&quot;bad expr: &quot;</span>+err.Error(), http.StatusBadRequest)<span class="hljs-keyword">return</span>&#125;w.Header().Set(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;image/svg+xml&quot;</span>)surface(w, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x, y <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span> &#123;r := math.Hypot(x, y) <span class="hljs-comment">// distance from (0,0)</span><span class="hljs-keyword">return</span> expr.Eval(eval.Env&#123;<span class="hljs-string">&quot;x&quot;</span>: x, <span class="hljs-string">&quot;y&quot;</span>: y, <span class="hljs-string">&quot;r&quot;</span>: r&#125;)&#125;)&#125;</code></pre><ul><li>这个plot函数解析和检查在HTTP请求中指定的表达式并且用它来创建一个两个变量的匿名函数。这个匿名函数和来自原来surface-plotting程序中的固定函数f有相同的签名，但是它计算一个用户提供的表达式。环境变量中定义了x，y和半径r。最后plot调用surface函数，它就是gopl.io/ch3/surface中的主要函数，修改后它可以接受plot中的函数和输出io.Writer作为参数，而不是使用固定的函数f和os.Stdout。图7.7中显示了通过程序产生的3个曲面。</li></ul></li></ul><h3 id="ch7-10-类型断言"><a href="#ch7-10-类型断言" class="headerlink" title="ch7.10  类型断言"></a>ch7.10  类型断言</h3><ul><li><p>类型断言是一个使用在接口值上的操作。语法上它看起来像x.(T)被称为断言类型，这里x表示一个接口的类型和T表示一个类型。一个类型断言检查它操作对象的动态类型是否和断言的类型匹配。</p></li><li><p>这里有两种可能。</p><ul><li><p>第一种，如果断言的类型T是一个具体类型，然后类型断言检查x的动态类型是否和T相同。如果这个检查成功了，类型断言的结果是x的动态值，当然它的类型是T。换句话说，具体类型的类型断言从它的操作对象中获得具体的值。如果检查失败，接下来这个操作会抛出panic。例如：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writerw = os.Stdoutf := w.(*os.File)      <span class="hljs-comment">// success: f == os.Stdout</span>c := w.(*bytes.Buffer) <span class="hljs-comment">// panic: interface holds *os.File, not *bytes.Buffer</span></code></pre></li><li><p>第二种，如果相反地断言的类型T是一个接口类型，然后类型断言检查是否x的动态类型满足T。如果这个检查成功了，动态值没有获取到；这个结果仍然是一个有相同动态类型和值部分的接口值，但是结果为类型T。换句话说，对一个接口类型的类型断言改变了类型的表述方式，改变了可以获取的方法集合（通常更大），但是它保留了接口值内部的动态类型和值的部分。</p></li></ul></li><li><p>在下面的第一个类型断言后，w和rw都持有os.Stdout，因此它们都有一个动态类型<code>*os.File</code>，但是变量w是一个io.Writer类型，只对外公开了文件的Write方法，而rw变量还公开了它的Read方法。</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writerw = os.Stdoutrw := w.(io.ReadWriter) <span class="hljs-comment">// success: *os.File has both Read and Write</span>w = <span class="hljs-built_in">new</span>(ByteCounter)rw = w.(io.ReadWriter) <span class="hljs-comment">// panic: *ByteCounter has no Read method</span></code></pre></li><li><p>如果断言操作的对象是一个nil接口值，那么不论被断言的类型是什么这个类型断言都会失败。我们几乎不需要对一个更少限制性的接口类型（更少的方法集合）做断言，因为它表现的就像是赋值操作一样，除了对于nil接口值的情况。</p><pre><code class="hljs go">w = rw             <span class="hljs-comment">// io.ReadWriter is assignable to io.Writer</span>w = rw.(io.Writer) <span class="hljs-comment">// fails only if rw == nil</span></code></pre></li><li><p>经常地，对一个接口值的动态类型我们是不确定的，并且我们更愿意去检验它是否是一些特定的类型。如果类型断言出现在一个预期有两个结果的赋值操作中，例如如下的定义，这个操作不会在失败的时候发生panic，但是替代地返回一个额外的第二个结果，这个结果是一个标识成功与否的布尔值：</p><pre><code class="hljs go"><span class="hljs-keyword">var</span> w io.Writer = os.Stdoutf, ok := w.(*os.File)      <span class="hljs-comment">// success:  ok, f == os.Stdout</span>b, ok := w.(*bytes.Buffer) <span class="hljs-comment">// failure: !ok, b == nil</span></code></pre></li><li><p>第二个结果通常赋值给一个命名为ok的变量。如果这个操作失败了，那么ok就是false值，第一个结果等于被断言类型的零值，在这个例子中就是一个nil的<code>*bytes.Buffer</code>类型。</p><ul><li><p>这个ok结果经常立即用于决定程序下面做什么。if语句的扩展格式让这个变的很简洁：</p><pre><code class="hljs go"><span class="hljs-keyword">if</span> f, ok := w.(*os.File); ok &#123;<span class="hljs-comment">// ...use f...</span>&#125;</code></pre></li></ul></li><li><p>当类型断言的操作对象是一个变量，你有时会看见原来的变量名重用而不是声明一个新的本地变量名，这个重用的变量原来的值会被覆盖，如下面这样：</p><pre><code class="hljs go"><span class="hljs-keyword">if</span> w, ok := w.(*os.File); ok &#123;<span class="hljs-comment">// ...use w...</span>&#125;</code></pre><ul><li>其实是声明了一个同名的新的本地变量，外层原来的w不会被改变</li></ul></li></ul><h3 id="ch7-11-基于类型断言识别错误类型"><a href="#ch7-11-基于类型断言识别错误类型" class="headerlink" title="ch7.11  基于类型断言识别错误类型"></a>ch7.11  基于类型断言识别错误类型</h3><ul><li><p>思考在os包中文件操作返回的错误集合。I/O可以因为任何数量的原因失败，但是有三种经常的错误必须进行不同的处理：文件已经存在（对于创建操作），找不到文件（对于读取操作），和权限拒绝。</p><ul><li><p>os包中提供了三个帮助函数来对给定的错误值表示的失败进行分类：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> os<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsExist</span><span class="hljs-params">(err error)</span> <span class="hljs-title">bool</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsNotExist</span><span class="hljs-params">(err error)</span> <span class="hljs-title">bool</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsPermission</span><span class="hljs-params">(err error)</span> <span class="hljs-title">bool</span></span></code></pre></li><li><p>对这些判断的一个缺乏经验的实现可能会去检查错误消息是否包含了特定的子字符串</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsNotExist</span><span class="hljs-params">(err error)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> not robust!</span><span class="hljs-keyword">return</span> strings.Contains(err.Error(), <span class="hljs-string">&quot;file does not exist&quot;</span>)&#125;</code></pre></li></ul></li><li><p>但是处理I/O错误的逻辑可能一个和另一个平台非常的不同，所以这种方案并不健壮，并且对相同的失败可能会报出各种不同的错误消息。在测试的过程中，通过检查错误消息的子字符串来保证特定的函数以期望的方式失败是非常有用的，但对于线上的代码是不够的。</p></li><li><p>一个更可靠的方式是使用一个专门的类型来描述结构化的错误。os包中定义了一个PathError类型来描述在文件路径操作中涉及到的失败，像Open或者Delete操作；并且定义了一个叫LinkError的变体来描述涉及到两个文件路径的操作，像Symlink和Rename。这下面是os.PathError：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> os<span class="hljs-comment">// PathError records an error and the operation and file path that caused it.</span><span class="hljs-keyword">type</span> PathError <span class="hljs-keyword">struct</span> &#123;Op   <span class="hljs-keyword">string</span>Path <span class="hljs-keyword">string</span>Err  error&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *PathError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">return</span> e.Op + <span class="hljs-string">&quot; &quot;</span> + e.Path + <span class="hljs-string">&quot;: &quot;</span> + e.Err.Error()&#125;</code></pre></li><li><p>大多数调用方都不知道PathError并且通过调用错误本身的Error方法来统一处理所有的错误。尽管PathError的Error方法简单地把这些字段连接起来生成错误消息，PathError的结构保护了内部的错误组件。调用方需要使用类型断言来检测错误的具体类型以便将一种失败和另一种区分开；具体的类型可以比字符串提供更多的细节。</p><pre><code class="hljs go">_, err := os.Open(<span class="hljs-string">&quot;/no/such/file&quot;</span>)fmt.Println(err) <span class="hljs-comment">// &quot;open /no/such/file: No such file or directory&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%[[v]]\n&quot;</span>, err)<span class="hljs-comment">// Output:</span><span class="hljs-comment">// &amp;os.PathError&#123;Op:&quot;open&quot;, Path:&quot;/no/such/file&quot;, Err:0x2&#125;</span></code></pre></li><li><p>这就是三个帮助函数是怎么工作的。例如下面展示的IsNotExist，它会报出是否一个错误和syscall.ENOENT（§7.8）或者和有名的错误os.ErrNotExist相等（可以在§5.4.2中找到io.EOF）；或者是一个<code>*PathError</code>，它内部的错误是syscall.ENOENT和os.ErrNotExist其中之一。</p><pre><code class="hljs go"><span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;errors&quot;</span><span class="hljs-string">&quot;syscall&quot;</span>)<span class="hljs-keyword">var</span> ErrNotExist = errors.New(<span class="hljs-string">&quot;file does not exist&quot;</span>)<span class="hljs-comment">// IsNotExist returns a boolean indicating whether the error is known to</span><span class="hljs-comment">// report that a file or directory does not exist. It is satisfied by</span><span class="hljs-comment">// ErrNotExist as well as some syscall errors.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsNotExist</span><span class="hljs-params">(err error)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> pe, ok := err.(*PathError); ok &#123;err = pe.Err&#125;<span class="hljs-keyword">return</span> err == syscall.ENOENT || err == ErrNotExist&#125;</code></pre><ul><li><p>下面这里是它的实际使用：</p><pre><code class="hljs go">_, err := os.Open(<span class="hljs-string">&quot;/no/such/file&quot;</span>)fmt.Println(os.IsNotExist(err)) <span class="hljs-comment">// &quot;true&quot;</span></code></pre></li></ul></li><li><p>如果错误消息结合成一个更大的字符串，当然PathError的结构就不再为人所知，例如通过一个对fmt.Errorf函数的调用。区别错误通常必须在失败操作后，错误传回调用者前进行。</p></li></ul><h3 id="ch7-12-通过类型断言查询接口"><a href="#ch7-12-通过类型断言查询接口" class="headerlink" title="ch7.12  通过类型断言查询接口"></a>ch7.12  通过类型断言查询接口</h3><ul><li><p>下面这段逻辑和net/http包中web服务器负责写入HTTP头字段（例如：”Content-type:text/html”）的部分相似。io.Writer接口类型的变量w代表HTTP响应；写入它的字节最终被发送到某个人的web浏览器上。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeHeader</span><span class="hljs-params">(w io.Writer, contentType <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> _, err := w.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;Content-Type: &quot;</span>)); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">if</span> _, err := w.Write([]<span class="hljs-keyword">byte</span>(contentType)); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-comment">// ...</span>&#125;</code></pre></li><li><p>因为Write方法需要传入一个byte切片而我们希望写入的值是一个字符串，所以我们需要使用[]byte(…)进行转换。这个转换分配内存并且做一个拷贝，但是这个拷贝在转换后几乎立马就被丢弃掉。让我们假装这是一个web服务器的核心部分并且我们的性能分析表示这个内存分配使服务器的速度变慢。这里我们可以避免掉内存分配么？</p></li><li><p>这个io.Writer接口告诉我们关于w持有的具体类型的唯一东西：就是可以向它写入字节切片。如果我们回顾net/http包中的内幕，我们知道在这个程序中的w变量持有的动态类型也有一个允许字符串高效写入的WriteString方法；这个方法会避免去分配一个临时的拷贝。（这可能像在黑夜中射击一样，但是许多满足io.Writer接口的重要类型同时也有WriteString方法，包括<code>*bytes.Buffer</code>，<code>*os.File</code>和<code>*bufio.Writer</code>。）</p></li><li><p>我们不能对任意io.Writer类型的变量w，假设它也拥有WriteString方法。但是我们可以定义一个只有这个方法的新接口并且使用类型断言来检测是否w的动态类型满足这个新接口。</p><pre><code class="hljs go"><span class="hljs-comment">// writeString writes s to w.</span><span class="hljs-comment">// If w has a WriteString method, it is invoked instead of w.Write.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeString</span><span class="hljs-params">(w io.Writer, s <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(n <span class="hljs-keyword">int</span>, err error)</span></span> &#123;<span class="hljs-keyword">type</span> stringWriter <span class="hljs-keyword">interface</span> &#123;WriteString(<span class="hljs-keyword">string</span>) (n <span class="hljs-keyword">int</span>, err error)&#125;<span class="hljs-keyword">if</span> sw, ok := w.(stringWriter); ok &#123;<span class="hljs-keyword">return</span> sw.WriteString(s) <span class="hljs-comment">// avoid a copy</span>&#125;<span class="hljs-keyword">return</span> w.Write([]<span class="hljs-keyword">byte</span>(s)) <span class="hljs-comment">// allocate temporary copy</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">writeHeader</span><span class="hljs-params">(w io.Writer, contentType <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">if</span> _, err := writeString(w, <span class="hljs-string">&quot;Content-Type: &quot;</span>); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">if</span> _, err := writeString(w, contentType); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-comment">// ...</span>&#125;</code></pre></li><li><p>为了避免重复定义，我们将这个检查移入到一个实用工具函数writeString中，但是它太有用了以致于标准库将它作为io.WriteString函数提供。这是向一个io.Writer接口写入字符串的推荐方法。</p></li><li><p>这个例子的神奇之处在于，没有定义了WriteString方法的标准接口，也没有指定它是一个所需行为的标准接口。一个具体类型只会通过它的方法决定它是否满足stringWriter接口，而不是任何它和这个接口类型所表达的关系。它的意思就是上面的技术依赖于一个假设，这个假设就是：如果一个类型满足下面的这个接口，然后WriteString(s)方法就必须和Write([]byte(s))有相同的效果。</p><pre><code class="hljs go"><span class="hljs-keyword">interface</span> &#123;io.WriterWriteString(s <span class="hljs-keyword">string</span>) (n <span class="hljs-keyword">int</span>, err error)&#125;</code></pre></li><li><p>尽管io.WriteString实施了这个假设，但是调用它的函数极少可能会去实施类似的假设。定义一个特定类型的方法隐式地获取了对特定行为的协约。对于Go语言的新手，特别是那些来自有强类型语言使用背景的新手，可能会发现它缺乏显式的意图令人感到混乱，但是在实战的过程中这几乎不是一个问题。除了空接口interface{}，接口类型很少意外巧合地被实现。</p></li><li><p>上面的writeString函数使用一个类型断言来获知一个普遍接口类型的值是否满足一个更加具体的接口类型；并且如果满足，它会使用这个更具体接口的行为。这个技术可以被很好的使用，不论这个被询问的接口是一个标准如io.ReadWriter，或者用户定义的如stringWriter接口。</p></li><li><p>这也是fmt.Fprintf函数怎么从其它所有值中区分满足error或者fmt.Stringer接口的值。在fmt.Fprintf内部，有一个将单个操作对象转换成一个字符串的步骤，像下面这样：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> fmt<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">formatOneValue</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">if</span> err, ok := x.(error); ok &#123;<span class="hljs-keyword">return</span> err.Error()&#125;<span class="hljs-keyword">if</span> str, ok := x.(Stringer); ok &#123;<span class="hljs-keyword">return</span> str.String()&#125;<span class="hljs-comment">// ...all other types...</span>&#125;</code></pre></li><li><p>如果x满足这两个接口类型中的一个，具体满足的接口决定对值的格式化方式。如果都不满足，默认的case或多或少会统一地使用反射来处理所有的其它类型；我们可以在第12章知道具体是怎么实现的。</p></li><li><p>再一次的，它假设任何有String方法的类型都满足fmt.Stringer中约定的行为，这个行为会返回一个适合打印的字符串。</p></li></ul><h3 id="ch7-13-类型分支"><a href="#ch7-13-类型分支" class="headerlink" title="ch7.13  类型分支"></a>ch7.13  类型分支</h3><ul><li><p>接口被以两种不同的方式使用。</p><ul><li>在第一个方式中，以io.Reader，io.Writer，fmt.Stringer，sort.Interface，http.Handler和error为典型，一个接口的方法表达了实现这个接口的具体类型间的相似性，但是隐藏了代码的细节和这些具体类型本身的操作。重点在于方法上，而不是具体的类型上。</li><li>第二个方式是利用一个接口值可以持有各种具体类型值的能力，将这个接口认为是这些类型的联合。类型断言用来动态地区别这些类型，使得对每一种情况都不一样。在这个方式中，重点在于具体的类型满足这个接口，而不在于接口的方法（如果它确实有一些的话），并且没有任何的信息隐藏。我们将以这种方式使用的接口描述为discriminated unions（可辨识联合）。</li></ul></li><li><p>如果你熟悉面向对象编程，你可能会将这两种方式当作是subtype polymorphism（子类型多态）和 ad hoc polymorphism（非参数多态），但是你不需要去记住这些术语。对于本章剩下的部分，我们将会呈现一些第二种方式的例子。</p></li><li><p>和其它那些语言一样，Go语言查询一个SQL数据库的API会干净地将查询中固定的部分和变化的部分分开。一个调用的例子可能看起来像这样：</p><pre><code class="hljs go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;database/sql&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">listTracks</span><span class="hljs-params">(db sql.DB, artist <span class="hljs-keyword">string</span>, minYear, maxYear <span class="hljs-keyword">int</span>)</span></span> &#123;result, err := db.Exec(<span class="hljs-string">&quot;SELECT * FROM tracks WHERE artist = ? AND ? &lt;= year AND year &lt;= ?&quot;</span>,artist, minYear, maxYear)<span class="hljs-comment">// ...</span>&#125;</code></pre><ul><li><p>Exec方法使用SQL字面量替换在查询字符串中的每个’?’；SQL字面量表示相应参数的值，它有可能是一个布尔值，一个数字，一个字符串，或者nil空值。</p></li><li><p>用这种方式构造查询可以帮助避免SQL注入攻击；这种攻击就是对方可以通过利用输入内容中不正确的引号来控制查询语句。在Exec函数内部，我们可能会找到像下面这样的一个函数，它会将每一个参数值转换成它的SQL字面量符号。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sqlQuote</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, ok := x.(<span class="hljs-keyword">int</span>); ok &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, x)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> _, ok := x.(<span class="hljs-keyword">uint</span>); ok &#123;<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, x)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> b, ok := x.(<span class="hljs-keyword">bool</span>); ok &#123;<span class="hljs-keyword">if</span> b &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TRUE&quot;</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FALSE&quot;</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> s, ok := x.(<span class="hljs-keyword">string</span>); ok &#123;<span class="hljs-keyword">return</span> sqlQuoteString(s) <span class="hljs-comment">// (not shown)</span>&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected type %T: %v&quot;</span>, x, x))&#125;&#125;</code></pre></li></ul></li><li><p>switch语句可以简化if-else链，如果这个if-else链对一连串值做相等测试。一个相似的type switch（类型分支）可以简化类型断言的if-else链。</p></li><li><p>在最简单的形式中，一个类型分支像普通的switch语句一样，它的运算对象是x.(type)——它使用了关键词字面量type——并且每个case有一到多个类型。一个类型分支基于这个接口值的动态类型使一个多路分支有效。这个nil的case和if x == nil匹配，并且这个default的case和如果其它case都不匹配的情况匹配。一个对sqlQuote的类型分支可能会有这些case：</p><pre><code class="hljs go"><span class="hljs-keyword">switch</span> x.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:       <span class="hljs-comment">// ...</span><span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>, <span class="hljs-keyword">uint</span>: <span class="hljs-comment">// ...</span><span class="hljs-keyword">case</span> <span class="hljs-keyword">bool</span>:      <span class="hljs-comment">// ...</span><span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:    <span class="hljs-comment">// ...</span><span class="hljs-keyword">default</span>:        <span class="hljs-comment">// ...</span>&#125;</code></pre></li><li><p>和（§1.8）中的普通switch语句一样，每一个case会被顺序的进行考虑，并且当一个匹配找到时，这个case中的内容会被执行。当一个或多个case类型是接口时，case的顺序就会变得很重要，因为可能会有两个case同时匹配的情况。default case相对其它case的位置是无所谓的。它不会允许落空发生。</p></li><li><p>注意到在原来的函数中，对于bool和string情况的逻辑需要通过类型断言访问提取的值。因为这个做法很典型，类型分支语句有一个扩展的形式，它可以将提取的值绑定到一个在每个case范围内都有效的新变量。</p><pre><code class="hljs go"><span class="hljs-keyword">switch</span> x := x.(<span class="hljs-keyword">type</span>) &#123; <span class="hljs-comment">/* ... */</span> &#125;</code></pre></li><li><p>这里我们已经将新的变量也命名为x；和类型断言一样，重用变量名是很常见的。和一个switch语句相似地，一个类型分支隐式的创建了一个词法块，因此新变量x的定义不会和外面块中的x变量冲突。每一个case也会隐式的创建一个单独的词法块。</p></li><li><p>使用类型分支的扩展形式来重写sqlQuote函数会让这个函数更加的清晰：</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sqlQuote</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">switch</span> x := x.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;NULL&quot;</span><span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>, <span class="hljs-keyword">uint</span>:<span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, x) <span class="hljs-comment">// x has type interface&#123;&#125; here.</span><span class="hljs-keyword">case</span> <span class="hljs-keyword">bool</span>:<span class="hljs-keyword">if</span> x &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;TRUE&quot;</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;FALSE&quot;</span><span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:<span class="hljs-keyword">return</span> sqlQuoteString(x) <span class="hljs-comment">// (not shown)</span><span class="hljs-keyword">default</span>:<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;unexpected type %T: %v&quot;</span>, x, x))&#125;&#125;</code></pre></li><li><p>在这个版本的函数中，在每个单一类型的case内部，变量x和这个case的类型相同。例如，变量x在bool的case中是bool类型和string的case中是string类型。在所有其它的情况中，变量x是switch运算对象的类型（接口）；在这个例子中运算对象是一个interface{}。当多个case需要相同的操作时，比如int和uint的情况，类型分支可以很容易的合并这些情况。</p></li><li><p>尽管sqlQuote接受一个任意类型的参数，但是这个函数只会在它的参数匹配类型分支中的一个case时运行到结束；其它情况的它会panic出“unexpected type”消息。虽然x的类型是interface{}，但是我们把它认为是一个int，uint，bool，string，和nil值的discriminated union（可识别联合）</p></li></ul><h3 id="ch7-14-示例：基于标记的XML解码"><a href="#ch7-14-示例：基于标记的XML解码" class="headerlink" title="ch7.14  示例：基于标记的XML解码"></a>ch7.14  示例：基于标记的XML解码</h3><ul><li><p>第4.5章节展示了如何使用encoding/json包中的Marshal和Unmarshal函数来将JSON文档转换成Go语言的数据结构。encoding/xml包提供了一个相似的API。当我们想构造一个文档树的表示时使用encoding/xml包会很方便，但是对于很多程序并不是必须的。encoding/xml包也提供了一个更低层的基于标记的API用于XML解码。在基于标记的样式中，解析器消费输入并产生一个标记流；四个主要的标记类型－StartElement，EndElement，CharData，和Comment－每一个都是encoding/xml包中的具体类型。每一个对(*xml.Decoder).Token的调用都返回一个标记。</p></li><li><p>这里显示的是和这个API相关的部分：</p><p><u><i>encoding/xml</i></u></p><pre><code class="hljs go"><span class="hljs-keyword">package</span> xml<span class="hljs-keyword">type</span> Name <span class="hljs-keyword">struct</span> &#123;Local <span class="hljs-keyword">string</span> <span class="hljs-comment">// e.g., &quot;Title&quot; or &quot;id&quot;</span>&#125;<span class="hljs-keyword">type</span> Attr <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// e.g., name=&quot;value&quot;</span>Name  NameValue <span class="hljs-keyword">string</span>&#125;<span class="hljs-comment">// A Token includes StartElement, EndElement, CharData,</span><span class="hljs-comment">// and Comment, plus a few esoteric types (not shown).</span><span class="hljs-keyword">type</span> Token <span class="hljs-keyword">interface</span>&#123;&#125;<span class="hljs-keyword">type</span> StartElement <span class="hljs-keyword">struct</span> &#123; <span class="hljs-comment">// e.g., &lt;name&gt;</span>    Name Name    Attr []Attr&#125;<span class="hljs-keyword">type</span> EndElement <span class="hljs-keyword">struct</span> &#123; Name Name &#125; <span class="hljs-comment">// e.g., &lt;/name&gt;</span><span class="hljs-keyword">type</span> CharData []<span class="hljs-keyword">byte</span>                 <span class="hljs-comment">// e.g., &lt;p&gt;CharData&lt;/p&gt;</span><span class="hljs-keyword">type</span> Comment []<span class="hljs-keyword">byte</span>                  <span class="hljs-comment">// e.g., &lt;!-- Comment --&gt;</span><span class="hljs-keyword">type</span> Decoder <span class="hljs-keyword">struct</span>&#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewDecoder</span><span class="hljs-params">(io.Reader)</span> *<span class="hljs-title">Decoder</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(*Decoder)</span> <span class="hljs-title">Token</span><span class="hljs-params">()</span> <span class="hljs-params">(Token, error)</span> // <span class="hljs-title">returns</span> <span class="hljs-title">next</span> <span class="hljs-title">Token</span> <span class="hljs-title">in</span> <span class="hljs-title">sequence</span></span></code></pre></li><li><p>这个没有方法的Token接口也是一个可识别联合的例子。传统的接口如io.Reader的目的是隐藏满足它的具体类型的细节，这样就可以创造出新的实现：在这个实现中每个具体类型都被统一地对待。相反，满足可识别联合的具体类型的集合被设计为确定和暴露，而不是隐藏。可识别联合的类型几乎没有方法，操作它们的函数使用一个类型分支的case集合来进行表述，这个case集合中每一个case都有不同的逻辑。</p></li><li><p>下面的xmlselect程序获取和打印在一个XML文档树中确定的元素下找到的文本。使用上面的API，它可以在输入上一次完成它的工作而从来不要实例化这个文档树。</p><p><u><i>gopl.io/ch7/xmlselect</i></u></p><pre><code class="hljs go"><span class="hljs-comment">// Xmlselect prints the text of selected elements of an XML document.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;encoding/xml&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;io&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;dec := xml.NewDecoder(os.Stdin)<span class="hljs-keyword">var</span> stack []<span class="hljs-keyword">string</span> <span class="hljs-comment">// stack of element names</span><span class="hljs-keyword">for</span> &#123;tok, err := dec.Token()<span class="hljs-keyword">if</span> err == io.EOF &#123;<span class="hljs-keyword">break</span>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;xmlselect: %v\n&quot;</span>, err)os.Exit(<span class="hljs-number">1</span>)&#125;<span class="hljs-keyword">switch</span> tok := tok.(<span class="hljs-keyword">type</span>) &#123;<span class="hljs-keyword">case</span> xml.StartElement:stack = <span class="hljs-built_in">append</span>(stack, tok.Name.Local) <span class="hljs-comment">// push</span><span class="hljs-keyword">case</span> xml.EndElement:stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] <span class="hljs-comment">// pop</span><span class="hljs-keyword">case</span> xml.CharData:<span class="hljs-keyword">if</span> containsAll(stack, os.Args[<span class="hljs-number">1</span>:]) &#123;fmt.Printf(<span class="hljs-string">&quot;%s: %s\n&quot;</span>, strings.Join(stack, <span class="hljs-string">&quot; &quot;</span>), tok)&#125;&#125;&#125;&#125;<span class="hljs-comment">// containsAll reports whether x contains the elements of y, in order.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">containsAll</span><span class="hljs-params">(x, y []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(y) &lt;= <span class="hljs-built_in">len</span>(x) &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(y) == <span class="hljs-number">0</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;<span class="hljs-keyword">if</span> x[<span class="hljs-number">0</span>] == y[<span class="hljs-number">0</span>] &#123;y = y[<span class="hljs-number">1</span>:]&#125;x = x[<span class="hljs-number">1</span>:]&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre><ul><li><p>main函数中的循环每遇到一个StartElement时，它把这个元素的名称压到一个栈里，并且每次遇到EndElement时，它将名称从这个栈中推出。这个API保证了StartElement和EndElement的序列可以被完全的匹配，甚至在一个糟糕的文档格式中。注释会被忽略。当xmlselect遇到一个CharData时，只有当栈中有序地包含所有通过命令行参数传入的元素名称时，它才会输出相应的文本。</p></li><li><p>下面的命令打印出任意出现在两层div元素下的h2元素的文本。它的输入是XML的说明文档，并且它自己就是XML文档格式的。</p><pre><code class="hljs stylus">$ go build gopl.io/ch1/fetch$ ./fetch http:<span class="hljs-comment">//www.w3.org/TR/2006/REC-xml11-20060816 |</span>    ./xmlselect <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">div</span> h2<span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">h2</span>: <span class="hljs-number">1</span> Introduction<span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">h2</span>: <span class="hljs-number">2</span> Documents<span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">h2</span>: <span class="hljs-number">3</span> Logical Structures<span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">h2</span>: <span class="hljs-number">4</span> Physical Structures<span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">h2</span>: <span class="hljs-number">5</span> Conformance<span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">h2</span>: <span class="hljs-number">6</span> Notation<span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">h2</span>: A References<span class="hljs-selector-tag">html</span> <span class="hljs-selector-tag">body</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">div</span> <span class="hljs-selector-tag">h2</span>: B Definitions <span class="hljs-keyword">for</span> Character Normalization...</code></pre></li></ul></li></ul><h3 id="ch7-15-补充几点"><a href="#ch7-15-补充几点" class="headerlink" title="ch7.15  补充几点"></a>ch7.15  补充几点</h3><ul><li>当设计一个新的包时，新手Go程序员总是先创建一套接口，然后再定义一些满足它们的具体类型。这种方式的结果就是有很多的接口，它们中的每一个仅只有一个实现。不要再这么做了。这种接口是不必要的抽象；它们也有一个运行时损耗。你可以使用导出机制（§6.6）来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。</li><li>当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式。</li><li>因为在Go语言中只有当两个或更多的类型实现一个接口时才使用接口，它们必定会从任意特定的实现细节中抽象出来。结果就是有更少和更简单方法的更小的接口（经常和io.Writer或 fmt.Stringer一样只有一个）。当新的类型出现时，小的接口更容易满足。对于接口设计的一个好的标准就是 ask only for what you need（只考虑你需要的东西）</li><li>我们完成了对方法和接口的学习过程。Go语言对面向对象风格的编程支持良好，但这并不意味着你只能使用这一风格。不是任何事物都需要被当做一个对象；独立的函数有它们自己的用处，未封装的数据类型也是这样。观察一下，在本书前五章的例子中像input.Scan这样的方法被调用不超过二十次，与之相反的是普遍调用的函数如fmt.Printf。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Go Programming Language（0-5）</title>
    <link href="/2020/11/20/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%880-5%EF%BC%89/"/>
    <url>/2020/11/20/book/go/The%20Go%20Programming%20Language/The%20Go%20Programming%20Language%EF%BC%880-5%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="The-Go-Programming-Language（0-5）"><a href="#The-Go-Programming-Language（0-5）" class="headerlink" title="The Go Programming Language（0-5）"></a>The Go Programming Language（0-5）</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="本文为Go语言编程圣经中文版内容，本人在阅读时将其制作为思维导图及博客文章形式，仅供学习，若侵权请及时与我联系。"><a href="#本文为Go语言编程圣经中文版内容，本人在阅读时将其制作为思维导图及博客文章形式，仅供学习，若侵权请及时与我联系。" class="headerlink" title="本文为Go语言编程圣经中文版内容，本人在阅读时将其制作为思维导图及博客文章形式，仅供学习，若侵权请及时与我联系。"></a>本文为Go语言编程圣经中文版内容，本人在阅读时将其制作为思维导图及博客文章形式，仅供学习，若侵权请及时与我联系。</h3><h3 id="源码、PDF版、Markdown、xmind版下载链接"><a href="#源码、PDF版、Markdown、xmind版下载链接" class="headerlink" title="源码、PDF版、Markdown、xmind版下载链接"></a>源码、PDF版、Markdown、xmind版下载链接</h3><pre><code class="hljs apache"><span class="hljs-attribute">https</span>://<span class="hljs-number">1</span>tnt<span class="hljs-number">1</span>.lanzous.com/b<span class="hljs-number">00</span>o<span class="hljs-number">36</span>ytc</code></pre><p>密码：</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span>ch0</code></pre><hr><p><img src="/img/TheGoProgrammingLanguage.jpg" alt="avatar"></p><h2 id="ch0-前言"><a href="#ch0-前言" class="headerlink" title="ch0  前言"></a>ch0  前言</h2><h3 id="ch0-1-Go语言起源"><a href="#ch0-1-Go语言起源" class="headerlink" title="ch0.1   Go语言起源"></a>ch0.1   Go语言起源</h3><ul><li>编程语言的演化跟生物物种的演化类似，一个成功的编程语言的后代一般都会继承它们祖先的优点；当然有时多种语言杂合也可能会产生令人惊讶的特性；还有一些激进的新特性可能并没有先例。通过观察这些影响，我们可以学到为什么一门语言是这样子的，它已经适应了怎样的环境。</li><li>Go语言有时候被描述为“C类似语言”，或者是“21世纪的C语言”。Go从C语言继承了相似的表达式语法、控制流结构、基础数据类型、调用参数传值、指针等很多思想，还有C语言一直所看中的编译后机器码的运行效率以及和现有操作系统的无缝适配。</li><li>但是在Go语言的家族树中还有其它的祖先。其中一个有影响力的分支来自<a href="https://en.wikipedia.org/wiki/Niklaus_Wirth">Niklaus Wirth</a>所设计的[Pascal][Pascal]语言。然后[Modula-2][Modula-2]语言激发了包的概念。然后[Oberon][Oberon]语言摒弃了模块接口文件和模块实现文件之间的区别。第二代的[Oberon-2][Oberon-2]语言直接影响了包的导入和声明的语法，还有[Oberon][Oberon]语言的面向对象特性所提供的方法的声明语法等。</li><li>Go语言的另一支祖先，带来了Go语言区别其他语言的重要特性，灵感来自于贝尔实验室的<a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a>于1978年发表的鲜为外界所知的关于并发研究的基础文献 <em>顺序通信进程</em> （ <em>[communicating sequential processes][CSP]</em> ，缩写为[CSP][CSP]。在[CSP][CSP]中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步。不过<a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a>的[CSP][CSP]只是一个用于描述并发性基本概念的描述语言，并不是一个可以编写可执行程序的通用编程语言。</li><li>接下来，Rob Pike和其他人开始不断尝试将<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a>引入实际的编程语言中。他们第一次尝试引入<a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a>特性的编程语言叫<a href="http://doc.cat-v.org/bell_labs/squeak/">Squeak</a>（老鼠间交流的语言），是一个提供鼠标和键盘事件处理的编程语言，它的管道是静态创建的。然后是改进版的<a href="http://doc.cat-v.org/bell_labs/squeak/">Newsqueak</a>语言，提供了类似C语言语句和表达式的语法和类似[Pascal][Pascal]语言的推导语法。Newsqueak是一个带垃圾回收的纯函数式语言，它再次针对键盘、鼠标和窗口事件管理。但是在Newsqueak语言中管道是动态创建的，属于第一类值，可以保存到变量中。</li><li>在Plan9操作系统中，这些优秀的想法被吸收到了一个叫[Alef][Alef]的编程语言中。Alef试图将Newsqueak语言改造为系统编程语言，但是因为缺少垃圾回收机制而导致并发编程很痛苦。（译注：在Alef之后还有一个叫[Limbo][Limbo]的编程语言，Go语言从其中借鉴了很多特性。 具体请参考Pike的讲稿：<a href="http://talks.golang.org/2012/concurrency.slide#9">http://talks.golang.org/2012/concurrency.slide#9</a> ）</li><li>Go语言的其他的一些特性零散地来自于其他一些编程语言；比如iota语法是从[APL][APL]语言借鉴，词法作用域与嵌套函数来自于[Scheme][Scheme]语言（和其他很多语言）。当然，我们也可以从Go中发现很多创新的设计。比如Go语言的切片为动态数组提供了有效的随机存取的性能，这可能会让人联想到链表的底层的共享机制。还有Go语言新发明的defer语句。</li></ul><h3 id="ch0-2-Go语言项目"><a href="#ch0-2-Go语言项目" class="headerlink" title="ch0.2   Go语言项目"></a>ch0.2   Go语言项目</h3><ul><li>所有的编程语言都反映了语言设计者对编程哲学的反思，通常包括之前的语言所暴露的一些不足地方的改进。Go项目是在Google公司维护超级复杂的几个软件系统遇到的一些问题的反思（但是这类问题绝不是Google公司所特有的）。</li><li>正如<a href="http://genius.cat-v.org/rob-pike/">Rob Pike</a>所说，“软件的复杂性是乘法级相关的”，通过增加一个部分的复杂性来修复问题通常将慢慢地增加其他部分的复杂性。通过增加功能、选项和配置是修复问题的最快的途径，但是这很容易让人忘记简洁的内涵，即从长远来看，简洁依然是好软件的关键因素。</li><li>简洁的设计需要在工作开始的时候舍弃不必要的想法，并且在软件的生命周期内严格区别好的改变和坏的改变。通过足够的努力，一个好的改变可以在不破坏原有完整概念的前提下保持自适应，正如<a href="http://www.cs.unc.edu/~brooks/">Fred Brooks</a>所说的“概念完整性”；而一个坏的改变则不能达到这个效果，它们仅仅是通过肤浅的和简单的妥协来破坏原有设计的一致性。只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化。</li><li>Go项目包括编程语言本身，附带了相关的工具和标准库，最后但并非代表不重要的是，关于简洁编程哲学的宣言。就事后诸葛的角度来看，Go语言的这些地方都做的还不错：拥有自动垃圾回收、一个包系统、函数作为一等公民、词法作用域、系统调用接口、只读的UTF8字符串等。但是Go语言本身只有很少的特性，也不太可能添加太多的特性。例如，它没有隐式的数值转换，没有构造函数和析构函数，没有运算符重载，没有默认参数，也没有继承，没有泛型，没有异常，没有宏，没有函数修饰，更没有线程局部存储。但是，语言本身是成熟和稳定的，而且承诺保证向后兼容：用之前的Go语言编写程序可以用新版本的Go语言编译器和标准库直接构建而不需要修改代码。</li><li>Go语言有足够的类型系统以避免动态语言中那些粗心的类型错误，但是，Go语言的类型系统相比传统的强类型语言又要简洁很多。虽然，有时候这会导致一个“无类型”的抽象类型概念，但是Go语言程序员并不需要像C++或Haskell程序员那样纠结于具体类型的安全属性。在实践中，Go语言简洁的类型系统给程序员带来了更多的安全性和更好的运行时性能。</li><li>Go语言鼓励当代计算机系统设计的原则，特别是局部的重要性。它的内置数据类型和大多数的准库数据结构都经过精心设计而避免显式的初始化或隐式的构造函数，因为很少的内存分配和内存初始化代码被隐藏在库代码中了。Go语言的聚合类型（结构体和数组）可以直接操作它们的元素，只需要更少的存储空间、更少的内存写操作，而且指针操作比其他间接操作的语言也更有效率。由于现代计算机是一个并行的机器，Go语言提供了基于CSP的并发特性支持。Go语言的动态栈使得轻量级线程goroutine的初始栈可以很小，因此，创建一个goroutine的代价很小，创建百万级的goroutine完全是可行的。</li><li>Go语言的标准库（通常被称为语言自带的电池），提供了清晰的构建模块和公共接口，包含I/O操作、文本处理、图像、密码学、网络和分布式应用程序等，并支持许多标准化的文件格式和编解码协议。库和工具使用了大量的约定来减少额外的配置和解释，从而最终简化程序的逻辑，而且，每个Go程序结构都是如此的相似，因此，Go程序也很容易学习。使用Go语言自带工具构建Go语言项目只需要使用文件名和标识符名称，一个偶尔的特殊注释来确定所有的库、可执行文件、测试、基准测试、例子、以及特定于平台的变量、项目的文档等；Go语言源代码本身就包含了构建规范。</li></ul><h3 id="ch0-3-本书的组织"><a href="#ch0-3-本书的组织" class="headerlink" title="ch0.3   本书的组织"></a>ch0.3   本书的组织</h3><ul><li><p>我们假设你已经有一种或多种其他编程语言的使用经历，不管是类似C、C++或Java的编译型语言，还是类似Python、Ruby、JavaScript的脚本语言，因此我们不会像对完全的编程语言初学者那样解释所有的细节。因为，Go语言的变量、常量、表达式、控制流和函数等基本语法也是类似的。</p></li><li><p>第一章包含了本教程的基本结构，通过十几个程序介绍了用Go语言如何实现类似读写文件、文本格式化、创建图像、网络客户端和服务器通讯等日常工作。</p></li><li><p>第二章描述了Go语言程序的基本元素结构、变量、新类型定义、包和文件、以及作用域等概念。第三章讨论了数字、布尔值、字符串和常量，并演示了如何显示和处理Unicode字符。第四章描述了复合类型，从简单的数组、字典、切片到动态列表。第五章涵盖了函数，并讨论了错误处理、panic和recover，还有defer语句。</p></li><li><p>第一章到第五章是基础部分，主流命令式编程语言这部分都类似。个别之处，Go语言有自己特色的语法和风格，但是大多数程序员能很快适应。其余章节是Go语言特有的：方法、接口、并发、包、测试和反射等语言特性。</p></li><li><p>Go语言的面向对象机制与一般语言不同。它没有类层次结构，甚至可以说没有类；仅仅通过组合（而不是继承）简单的对象来构建复杂的对象。方法不仅可以定义在结构体上，而且，可以定义在任何用户自定义的类型上；并且，具体类型和抽象类型（接口）之间的关系是隐式的，所以很多类型的设计者可能并不知道该类型到底实现了哪些接口。方法在第六章讨论，接口在第七章讨论。</p></li><li><p>第八章讨论了基于顺序通信进程（CSP）概念的并发编程，使用goroutines和channels处理并发编程。第九章则讨论了传统的基于共享变量的并发编程。</p></li><li><p>第十章描述了包机制和包的组织结构。这一章还展示了如何有效地利用Go自带的工具，使用单个命令完成编译、测试、基准测试、代码格式化、文档以及其他诸多任务。</p></li><li><p>第十一章讨论了单元测试，Go语言的工具和标准库中集成了轻量级的测试功能，避免了强大但复杂的测试框架。测试库提供了一些基本构件，必要时可以用来构建复杂的测试构件。</p></li><li><p>第十二章讨论了反射，一种程序在运行期间审视自己的能力。反射是一个强大的编程工具，不过要谨慎地使用；这一章利用反射机制实现一些重要的Go语言库函数，展示了反射的强大用法。第十三章解释了底层编程的细节，在必要时，可以使用unsafe包绕过Go语言安全的类型系统。</p></li><li><p>每一章都有一些练习题，你可以用来测试你对Go的理解，你也可以探讨书中这些例子的扩展和替代。</p></li><li><p>书中所有的代码都可以从 <a href="http://gopl.io/">http://gopl.io</a> 上的Git仓库下载。go get命令根据每个例子的导入路径智能地获取、构建并安装。只需要选择一个目录作为工作空间，然后将GOPATH环境变量设置为该路径。</p><ul><li><p>必要时，Go语言工具会创建目录。例如：</p><pre><code class="hljs awk">$ export GOPATH=<span class="hljs-variable">$HOME</span>/gobook    <span class="hljs-comment"># 选择工作目录</span>$ go get gopl.io<span class="hljs-regexp">/ch1/</span>helloworld <span class="hljs-comment"># 获取/编译/安装</span>$ <span class="hljs-variable">$GOPATH</span><span class="hljs-regexp">/bin/</span>helloworld        <span class="hljs-comment"># 运行程序</span>Hello, 世界                     <span class="hljs-comment"># 这是中文</span></code></pre></li><li><p>运行这些例子需要安装Go1.5以上的版本。</p><pre><code class="hljs vim">$ <span class="hljs-keyword">go</span> <span class="hljs-keyword">version</span><span class="hljs-keyword">go</span> <span class="hljs-keyword">version</span> go1.<span class="hljs-number">5</span> linux/amd64</code></pre></li><li><p>如果使用其他的操作系统，请参考 <a href="https://golang.org/doc/install">https://golang.org/doc/install</a> 提供的说明安装。</p></li></ul></li></ul><h3 id="ch0-4-更多的信息"><a href="#ch0-4-更多的信息" class="headerlink" title="ch0.4   更多的信息"></a>ch0.4   更多的信息</h3><ul><li>最佳的帮助信息来自Go语言的官方网站，<a href="https://golang.org/">https://golang.org</a> ，它提供了完善的参考文档，包括编程语言规范和标准库等诸多权威的帮助信息。同时也包含了如何编写更地道的Go程序的基本教程，还有各种各样的在线文本资源和视频资源，它们是本书最有价值的补充。Go语言的官方博客 <a href="https://blog.golang.org/">https://blog.golang.org</a> 会不定期发布一些Go语言最好的实践文章，包括当前语言的发展状态、未来的计划、会议报告和Go语言相关的各种会议的主题等信息（译注： <a href="http://talks.golang.org/">http://talks.golang.org/</a> 包含了官方收录的各种报告的讲稿）。</li><li>在线访问的一个有价值的地方是可以从web页面运行Go语言的程序（而纸质书则没有这么便利了）。这个功能由来自 <a href="https://play.golang.org/">https://play.golang.org</a> 的 Go Playground 提供，并且可以方便地嵌入到其他页面中，例如 <a href="https://golang.org/">https://golang.org</a> 的主页，或 godoc 提供的文档页面中。</li><li>Playground可以简单的通过执行一个小程序来测试对语法、语义和对程序库的理解，类似其他很多语言提供的REPL即时运行的工具。同时它可以生成对应的url，非常适合共享Go语言代码片段，汇报bug或提供反馈意见等。</li><li>基于 Playground 构建的 Go Tour，<a href="https://tour.golang.org/">https://tour.golang.org</a> ，是一个系列的Go语言入门教程，它包含了诸多基本概念和结构相关的并可在线运行的互动小程序。</li><li>当然，Playground 和 Tour 也有一些限制，它们只能导入标准库，而且因为安全的原因对一些网络库做了限制。如果要在编译和运行时需要访问互联网，对于一些更复杂的实验，你可能需要在自己的电脑上构建并运行程序。幸运的是下载Go语言的过程很简单，从 <a href="https://golang.org/">https://golang.org</a> 下载安装包应该不超过几分钟（译注：感谢伟大的长城，让大陆的Gopher们都学会了自己打洞的基本生活技能，下载时间可能会因为洞的大小等因素从几分钟到几天或更久），然后就可以在自己电脑上编写和运行Go程序了。</li><li>Go语言是一个开源项目，你可以在 <a href="https://golang.org/pkg">https://golang.org/pkg</a> 阅读标准库中任意函数和类型的实现代码，和下载安装包的代码完全一致。这样，你可以知道很多函数是如何工作的， 通过挖掘找出一些答案的细节，或者仅仅是出于欣赏专业级Go代码。</li></ul><h3 id="ch0-5-致谢"><a href="#ch0-5-致谢" class="headerlink" title="ch0.5   致谢"></a>ch0.5   致谢</h3><ul><li><a href="http://genius.cat-v.org/rob-pike/">Rob Pike</a>和<a href="http://research.swtch.com/">Russ Cox</a>，以及很多其他Go团队的核心成员多次仔细阅读了本书的手稿，他们对本书的组织结构和表述用词等给出了很多宝贵的建议。在准备日文版翻译的时候，Yoshiki Shibata更是仔细地审阅了本书的每个部分，及时发现了诸多英文和代码的错误。我们非常感谢本书的每一位审阅者，并感谢对本书给出了重要的建议的Brian Goetz、Corey Kosak、Arnold Robbins、Josh Bleecher Snyder和Peter Weinberger等人。</li><li>我们还感谢Sameer Ajmani、Ittai Balaban、David Crawshaw、Billy Donohue、Jonathan Feinberg、Andrew Gerrand、Robert Griesemer、John Linderman、Minux Ma（译注：中国人，Go团队成员。）、Bryan Mills、Bala Natarajan、Cosmos Nicolaou、Paul Staniforth、Nigel Tao（译注：好像是陶哲轩的兄弟）以及Howard Trickey给出的许多有价值的建议。我们还要感谢David Brailsford和Raph Levien关于类型设置的建议。</li><li>我们从来自Addison-Wesley的编辑Greg Doench收到了很多帮助，从最开始就得到了越来越多的帮助。来自AW生产团队的John Fuller、Dayna Isley、Julie Nahil、Chuti Prasertsith到Barbara Wood，感谢你们的热心帮助。</li><li><a href="https://github.com/adonovan">Alan Donovan</a>特别感谢：Sameer Ajmani、Chris Demetriou、Walt Drummond和Google公司的Reid Tatge允许他有充裕的时间去写本书；感谢Stephen Donovan的建议和始终如一的鼓励，以及他的妻子Leila Kazemi并没有让他为了家庭琐事而分心，并热情坚定地支持这个项目。</li><li><a href="http://www.cs.princeton.edu/~bwk/">Brian Kernighan</a>特别感谢：朋友和同事对他的耐心和宽容，让他慢慢地梳理本书的写作思路。同时感谢他的妻子Meg和其他很多朋友对他写作事业的支持。</li><li>2015年 10月 于 纽约</li></ul><h2 id="ch1-入门"><a href="#ch1-入门" class="headerlink" title="ch1  入门"></a>ch1  入门</h2><h3 id="ch1-1-helloworld"><a href="#ch1-1-helloworld" class="headerlink" title="ch1.1   helloworld"></a>ch1.1   helloworld</h3><p>编译器会主动把特定符号后的换行符转换为分号，因此换行符添加的位置会影响Go代码的正确解析。<br>比如行末是标识符、整数、浮点数、虚数、字符或字符串文字、关键字<code>break</code>、<code>continue</code>、<code>fallthrough</code>或<code>return</code>中的一个、运算符和分隔符<code>++</code>、<code>--</code>、<code>)</code>、<code>]</code>或<code>&#125;</code>中的一个<br>以+结尾的话不会被插入分号分隔符，但是以x结尾的话则会被分号分隔符，从而导致编译错误。<br><code>goimports</code>，可以根据代码需要，自动地添加或删除<code>import</code>声明。这个工具并没有包含在标准的分发包中，可以用下面的命令安装：</p><pre><code class="hljs awk">$ go get golang.org<span class="hljs-regexp">/x/</span>tools<span class="hljs-regexp">/cmd/g</span>oimports</code></pre><p>对于大多数用户来说，下载、编译包、运行测试用例、察看Go语言的文档等等常用功能都可以用go的工具完成。10.7节详细介绍这些知识。</p><h3 id="ch1-2-命令行参数"><a href="#ch1-2-命令行参数" class="headerlink" title="ch1.2   命令行参数"></a>ch1.2   命令行参数</h3><ul><li><p>区间索引，左闭右开</p><ul><li>a = [1, 2, 3, 4, 5], a[0:3] = [1, 2, 3]<br>s[m:n]这个切片，0 ≤ m ≤ n ≤ len(s)，包含n-m个元素</li></ul></li><li><p>os.Args[1:len(os.Args)]</p><ul><li>如果省略切片表达式的m或n，会默认传入0或len(s)</li></ul></li><li><p>变量在声明时直接初始化</p><ul><li>如果变量没有显式初始化，则被隐式地赋予其类型的<em>零值</em>（zero value），数值类型是0，字符串类型是空字符串””</li></ul></li><li><p>s += sep + os.Args[i]</p><ul><li>运算符<code>+=</code>是赋值运算符（assignment operator），每种数值运算符或逻辑运算符，如<code>+</code>或<code>*</code>，都有对应的赋值运算符</li></ul></li><li><p>:=</p><ul><li>符号<code>:=</code>是<em>短变量声明</em>（short variable declaration）</li></ul></li><li><p>i++</p><ul><li><code>j = i++</code>非法，而且++和–都只能放在变量名后面，因此<code>--i</code>也非法</li></ul></li><li><p>for</p><ul><li>for initialization; condition; post {<br>// zero or more statements<br>}</li><li>// a traditional infinite loop<br>for {<br>// …<br>}</li></ul></li><li><p>range</p><ul><li>range产生一堆值</li><li>索引以及在该索引处的元素值</li></ul></li><li><p>_   空标识符（blank identifier）</p><ul><li>空标识符可用于在任何语法需要变量名但程序逻辑不需要的时候丢弃不需要的循环索引，并保留元素值。</li></ul></li><li><p>短变量声明</p><ul><li>s := “”  //只能用在函数内部<br>var s string //被初始化为零值<br>var s = “” //同时声明多个变量<br>var s string = “” //显示声明</li></ul></li><li><p>strings包的Join函数</p></li></ul><h3 id="ch1-3-查找重复的行"><a href="#ch1-3-查找重复的行" class="headerlink" title="ch1.3   查找重复的行"></a>ch1.3   查找重复的行</h3><ul><li><p>文件操作</p><ul><li>一个处理输入的循环，在每个元素上执行计算处理，在处理的同时或最后产生输出。</li></ul></li><li><p>if</p><ul><li>if语句条件连变更不加括号，但是主体部分需要加</li><li>if语句的else部分是可选的，在if的条件为false时执行</li></ul></li><li><p>map</p><ul><li>map存储了键/值（key/value）的集合</li><li>对集合元素，提供常数时间的存取或测试操作</li><li>键可以是任意类型，只要其值能用==运算符比较，最常见的例子是字符串</li><li>值则可以是任意类型</li><li>map的迭代顺序并不确定，从实践来看，其顺序随机，每次运行都会变化，这种设计为了防止程序依赖特定遍历顺序，但是这种遍历无法保证</li><li>map是一个由make函数创建的数据结构的引用。</li><li>map作为参数传递给某函数时，该函数接收这个引用的一份拷贝copy，被调用函数对map底层数据结构的任何修改，调用者函数都可以通过持有的mao引用看到。</li></ul></li><li><p>counts[input.Text()]++</p><ul><li>line := input.Text()<br>counts[line] = counts[line] + 1</li></ul></li><li><p>bufio</p><ul><li><p>使处理输入和输出方便又高效</p></li><li><p>Scanner</p><ul><li><p>Scanner类型使该包最有用的特性之一，它读取输入并将其拆成行或单词</p></li><li><p>通常是处理行形式的输入最简单的方法</p></li><li><p>input := bufio.NewScanner(os.Stdin)</p><ul><li><p>input.Scan</p><ul><li>调用读取下一行，并移出行末的换行符</li></ul></li><li><p>input.Text()</p><ul><li>获取读取的内容</li></ul></li></ul></li><li><p>Scan函数</p><ul><li>在读到一行时返回true</li><li>不再有输入时返回false</li></ul></li></ul></li></ul></li><li><p>fmt.printf</p><ul><li><p>对一些表达式产生格式化输出</p></li><li><p>首个参数时个格式字符串，指定后续参数如何被格式化</p></li><li><p>各个参数的格式取决于“转换字符”(conversion character)，形式为百分号后跟一个字母</p></li><li><p>%d          十进制整数<br>%x, %o, %b  十六进制，八进制，二进制整数。<br>%f, %g, %e  浮点数： 3.141593 3.141592653589793 3.141593e+00<br>%t          布尔：true或false<br>%c          字符（rune） (Unicode码点)<br>%s          字符串<br>%q          带双引号的字符串”abc”或带单引号的字符’c’<br>%v          变量的自然形式（natural format）<br>%T          变量的类型<br>%%          字面上的百分号标志（无操作数）</p></li><li><p>转义字符（escape sequences）</p></li><li><p>默认Printf不会换行</p></li><li><p>以 f 结尾的格式化函数都采用fmt.Printf的格式化准则</p><ul><li>log.Printf</li><li>fmt.Errorf</li></ul></li><li><p>以ln结尾的格式化函数遵循Println的方式，以跟$v差不多的方式格式化蚕食，并在最后添加一个换行符</p></li><li><p>后缀f指format,ln指line</p></li></ul></li><li><p>os.Open</p><ul><li><p>返回两个值</p><ul><li><p>第一个值时被打开的文件（*os.File)，其后被Scanner读取</p></li><li><p>第二个值是内置error类型的值</p><ul><li><p>如果err等于内置值nil，那么文件被成功打开。</p><ul><li>读取文件知道文件结束，然后调用Close关闭该文件，并释放占用的所有资源。</li></ul></li><li><p>如果err的值不是nil，说明打开文件时出错了</p><ul><li>这种情况下，错误值描述了所遇到的问莪媞，我们的错误处理非常简单，只是使用Fprintf与表示任意类型默认格式值得动词%v，向标准错误流打印一条信息，然后dup继续处理下一个文件</li><li>continue语句直接跳到for循环得下个迭代开始执行</li></ul></li></ul></li></ul></li></ul></li><li><p>countLines函数</p><ul><li>在其声明前被调用</li><li>函数和包级别的变量（package-level entities）可以任意顺序声明，并不影响啊其被调用，最好还是遵循一定的规范</li></ul></li><li><p>dup3</p><ul><li>一次把全部输入数据读取到内存中，一次分隔为多行，然后处理它们</li></ul></li><li><p>ReadFile函数</p><ul><li>io/ioutil包</li><li>读取指定文件的全部内容</li><li>返回一个字节切片（byte slice），必须把它转换为string，才能用strings.Split分割。</li></ul></li><li><p>strings.Split函数</p><ul><li>把字符串分割成字串的切片</li><li>Split的作用与之前的strings.Join相反</li></ul></li><li><p>总结</p><ul><li>实现上，bufio.Scanner、ioutil.ReadFile和ioutil.WriteFile都使用 *os.File的Read和Write方法，但是大多数程序员很少需要直接调用哪些低级（lower-level）函数。高级（higher-level）函数，像bufio和io/ioutil包中所提供的那些，用起来要容易点。</li></ul></li></ul><h3 id="ch1-4-GIF动画"><a href="#ch1-4-GIF动画" class="headerlink" title="ch1.4   GIF动画"></a>ch1.4   GIF动画</h3><ul><li><p>image包</p></li><li><p>Lissajous figures,莉萨如图形</p><ul><li>1960年代老电影出现的视觉特效</li><li>协振子在两个纬度上震动所产生的曲线</li></ul></li><li><p>输出到一个GIF图像文件</p><ul><li>./lissajous &gt; output.gif</li></ul></li><li><p>import</p><ul><li><p>imaeg/color</p><ul><li>当import了一个包路径包含有多个单词的package时，通常我们只需要用最后那个单词表示这个包就行</li><li>当我们写color.White时，这个变量指向的是image/color包里的变量，同理gif.GIF是属于image/gif包里的变量</li></ul></li></ul></li><li><p>const声明</p><ul><li>常量是指在程序编译后运行时始终都不会变化的值</li><li>常量声明和变量声明一般都会出现在包级别，所以这些常量在整个包中都是可以共享的，或者你也可以把常量声明定义在函数体内部，那么这种常量就只能在函数体内用</li><li>目前常量声明的值必须是一个数字值、字符串或者一个固定的boolean值</li></ul></li><li><p>struct结构体类型</p><ul><li><p>是一组值或者叫字段的集合，不同的类型集合在一个struct可以让我们以一个同一的单元进行处理</p></li><li><p>anim := gif.GIF{LoopCount: nframes}</p><ul><li>anim是一个gif.GIF类型的struct变量。这种写法会生成一个struct变量，并且其内部变量LoopCount字段会被设置为nframes；而其它的字段会被设置为各自类型默认的零值。</li></ul></li><li><p>struct内部的变量可以以一个点（.）来进行访问，就像在最后两个赋值语句中显示地更新了anim这个struct地Delay和Image字段</p></li></ul></li><li><p>复合声明</p><ul><li>[]color.Color{…}</li><li>gif.GIF{…}</li></ul></li><li><p>lissajous函数</p><ul><li><p>外层循环</p><ul><li>外层循环会循环64次，每一次都会生成一个单独的动画帧。它生成了一个包含两种颜色的201*201大小的图片，白色和黑色。所有像素点都会被默认设置为其零值（也就是调色板palette里的第0个值），这里我们设置的是白色。每次外层循环都会生成一张新图片，并将一些像素设置为黑色。其结果会append到之前结果之后。这里我们用到了append(参考4.2.1)内置函数，将结果append到anim中的帧列表末尾，并设置一个默认的80ms的延迟值。循环结束后所有的延迟值被编码进了GIF图片中，并将结果写入到输出流。out这个变量是io.Writer类型，这个类型支持把输出结果写到很多目标，很快我们就可以看到例子。</li></ul></li><li><p>内层循环</p><ul><li><p>两个偏振值</p><ul><li>x轴偏振使用sin函数</li><li>y轴偏振也是正弦波，但其相对x轴的偏振是一个0-3的随机值，初始偏振值是一个零值，随着动画的每一帧逐渐增加。循环会一直跑到x轴完成五次完整的循环。每一步它都会调用SetColorIndex来为(x,y)点来染黑色。</li></ul></li></ul></li></ul></li></ul><h3 id="ch1-5-获取URL"><a href="#ch1-5-获取URL" class="headerlink" title="ch1.5   获取URL"></a>ch1.5   获取URL</h3><ul><li><p>net</p><ul><li><p>http</p><ul><li><p>http.Get</p><ul><li>创建HTTP请求地函数，如果获取过程没有出错，那么会在resp这个结构体中得到访问的请求结果。</li></ul></li></ul></li></ul></li><li><p>resp</p><ul><li><p>resp的Body字段包括一个可读的服务器响应流。</p></li><li><p>resp.Body.Close</p><ul><li>关闭resp的Body流，防止资源泄露，Printf函数会将结果b写出到标准输出流中</li></ul></li></ul></li><li><p>ioutil.ReadAll函数</p><ul><li>从response中读取到全部内容</li><li>结果保存在变量b中。</li></ul></li><li><p>错误</p><ul><li>无论哪种失败原因，我们的程序都用了os.Exit函数来终止进程，并且返回一个status错误码，其值为1。</li></ul></li></ul><h3 id="ch1-6-并发获取多个URL"><a href="#ch1-6-并发获取多个URL" class="headerlink" title="ch1.6   并发获取多个URL"></a>ch1.6   并发获取多个URL</h3><ul><li><p>并发编程</p><ul><li>goroutine是一种函数的并发执行方式，而channel是用来在goroutine之间进行参数传递。</li></ul></li><li><p>goroutine</p><ul><li>main函数本身也运行在一个goroutine中，而go  function则表示创建要给新的goroutine，并在这个新的goroutine中执行这个函数</li><li>当一个goroutine尝试在一个channel上做send或者receive操作时，这个goroutine会阻塞在调用处，知道另一个goroutine从这个channel里接收或者写入值，这样两个goroutine才会继续执行channel操作之后的逻辑</li></ul></li><li><p>channel</p></li><li><p>main函数</p><ul><li><p>func main() {<br>start := time.Now()<br>ch := make(chan string)<br>for _, url := range os.Args[1:]{<br>  go fetch(url, ch)<br>}<br>for range os.Args[1:]{<br>  fmt.Println(&lt;-ch)<br>}<br>fmt.Printf(“%.2fs elapsed\n”, time.Since(start).Seconds())<br>}</p></li><li><p>main函数中用make函数创建了一个传递string类型参数的channel，对每一个命令行参数，我们都用go这个关键字来创建一个goroutine，并且让函数在这个goroutine异步执行http.Get方法。</p></li><li><p>io.Copy</p><ul><li>这个程序里的io.Copy会把响应的Body内容拷贝到ioutil.Discard输出流中</li><li>可以把这个变量看作一个垃圾桶，可以向里面写一些不需要的数据</li></ul></li><li><p>这个程序中我们用main函数来接收所有fetch函数传回的字符串，可以避免在goroutine异步执行还没有完成时main函数提前退出。</p></li></ul></li><li><p>fetch函数</p><ul><li>func fetch(url string, ch chan&lt;- string){<br>start := time.Now()<br>resp, err := http.Get(url)<br>if err != nil{<br>  ch &lt;- fmt.Sprint(err)<br>  return<br>}<br>nbytes, err := io.Copy(ioutil.Discard, resp.Body)<br>resp.Body.Close()<br>if err != nil{<br>  ch &lt;- fmt.Sprint(“while reading %s : %v”, url, err)<br>  return<br>}<br>secs := time.Since(start).Seconds()<br>ch &lt;- fmt.Sprintf(“%.2fs %7d %s”, secs, nbytes, url)<br>}</li></ul></li></ul><h3 id="ch1-7-Web服务"><a href="#ch1-7-Web服务" class="headerlink" title="ch1.7   Web服务"></a>ch1.7   Web服务</h3><ul><li><p>‘’’go<br>  if err := r.ParseForm(); err != nil{</p><pre><code>  log.Print(err)</code></pre><p>  }<br>  ‘’’</p><ul><li>err := r.ParseForm()<br>if err != nil {<br>log.Print(err)<br>}</li><li>用if和ParseForm结合可以让代码更加简单，并且可以限制err这个变量的作用域，这么做是很不错的。</li></ul></li><li><p>handler := func(w http.ResponseWriter, r *http.Request) {<br>  lissajous(w)<br>  }<br>  http.HandleFunc(“/“, handler)</p><ul><li>http.HandleFunc(“/“, func(w http.ResponseWriter, r *http.Request) {<br>lissajous(w)<br>})</li></ul></li></ul><h3 id="ch1-8-总结"><a href="#ch1-8-总结" class="headerlink" title="ch1.8   总结"></a>ch1.8   总结</h3><ul><li><p>控制流</p><ul><li><p>switch</p><ul><li><p>switch coinflip() {<br>case “heads”:<br>heads++<br>case “tails”:<br>tails++<br>default:<br>fmt.Println(“landed on edge!”)<br>}</p><ul><li>Go语言并不需要显式地在每一个case后写break，语言默认执行完case后的逻辑语句会自动退出。</li><li>当然了，如果你想要相邻的几个case都执行同一逻辑的话，需要自己显式地写上一个fallthrough语句来覆盖这种默认行为。不过fallthrough语句在一般的程序中很少用到。</li></ul></li><li><p>无tag switch(tagless switch)</p><ul><li><p>和 switch true等价</p></li><li><p>Go语言里的switch还可以不带操作对象</p><ul><li>func Signum(x int) int {<br>switch {<br>case x &gt; 0:<br>return +1<br>default:<br>return 0<br>case x &lt; 0:<br>return -1<br>}<br>}</li><li>switch不带操作对象时默认用true值代替，然后将每个case的表达式和true值进行比较</li><li>可以直接罗列多种条件，像其它语言里面的多个if else一样</li></ul></li></ul></li><li><p>witch也可以紧跟一个简短的变量声明，一个自增表达式、赋值语句，或者一个函数调用</p></li></ul></li><li><p>break会中断当前的循环，并开始执行循环之后的内容，而continue会跳过当前循环，并开始执行下一次循环。</p><ul><li>如果我们想跳过的是更外层的循环的话，我们可以在相应的位置加上label，这样break和continue就可以根据我们的想法来continue和break任意循环。</li><li>这看起来甚至有点像goto语句的作用了。当然，一般程序员也不会用到这种操作。这两种行为更多地被用到机器生成的代码中</li></ul></li></ul></li><li><p>命令类型</p><ul><li>type Point struct {<br>X, Y int<br>}<br>var p Point</li></ul></li><li><p>指针</p><ul><li>指针是一种直接存储了变量的内存地址的数据类型</li><li>指针是可见的内存地址，&amp;操作符可以返回一个变量的内存地址，并且*操作符可以获取指针指向的变量内容</li><li>，但是在Go语言里没有指针运算，也就是不能像c语言里可以对指针进行加或减操作</li></ul></li><li><p>方法和接口</p><ul><li>方法是和命名类型关联的一类函数</li><li>Go语言里比较特殊的是方法可以被关联到任意一种命名类型。</li><li>接口是一种抽象类型，这种类型可以让我们以同样的方式来处理不同的固有类型，不用关心它们的具体实现，而只需要关注它们提供的方法。</li></ul></li><li><p>包</p><ul><li><p>Go语言提供了一些很好用的package，并且这些package是可以扩展的。</p></li><li><p>在你开始写一个新程序之前，最好先去检查一下是不是已经有了现成的库可以帮助你更高效地完成这件事情。</p></li><li><p>你可以在 <a href="https://golang.org/pkg">https://golang.org/pkg</a> 和 <a href="https://godoc.org/">https://godoc.org</a> 中找到标准库和社区写的package。</p></li><li><p>godoc这个工具可以让你直接在本地命令行阅读标准库的文档。</p><ul><li>$ go doc http.ListenAndServe<br>package http // import “net/http”<br>func ListenAndServe(addr string, handler Handler) error<br>ListenAndServe listens on the TCP network address addr and then<br>calls Serve with handler to handle requests on incoming connections.<br>…</li></ul></li></ul></li><li><p>注释</p><ul><li>在每一个函数之前写一个说明函数行为的注释也是一个好习惯。</li><li>因为这些内容会被像godoc这样的工具检测到，并且在执行命令时显示这些注释。</li><li>多行注释可以用 <code>/* ... */</code> 来包裹，和其它大多数语言一样。在文件一开头的注释一般都是这种形式，或者一大段的解释性的注释文字也会被这符号包住，来避免每一行都需要加//。</li><li>在注释中//和/*是没什么意义的，所以不要在注释中再嵌入注释。</li></ul></li></ul><h2 id="ch2-程序结构"><a href="#ch2-程序结构" class="headerlink" title="ch2  程序结构"></a>ch2  程序结构</h2><h3 id="ch2-1-命名"><a href="#ch2-1-命名" class="headerlink" title="ch2.1   命名"></a>ch2.1   命名</h3><ul><li><p>命名规则</p><ul><li>一个名字必须以一个字母（Unicode字母）或下划线开头，后面可以跟任意数量的字母、数字或下划线。</li><li>大写字母和小写字母是不同的：heapSort和Heapsort是两个不同的名字。</li></ul></li><li><p>关键字</p><ul><li>break      default       func     interface   select<br>case       defer         go       map         struct<br>chan       else          goto     package     switch<br>const      fallthrough   if       range       type<br>continue   for           import   return      var</li><li>关键字不能用于自定义名字，只能在特定语法结构中使用。</li></ul></li><li><p>预定义名字</p><ul><li><p>内建常量</p><ul><li>true false iota nil</li></ul></li><li><p>内建类型</p><ul><li>int int8 int16 int32 int64<br>uint uint8 uint16 uint32 uint64 uintptr<br>float32 float64 complex128 complex64<br>bool byte rune string error</li></ul></li><li><p>内建函数</p><ul><li>make len cap new append copy close delete<br>complex real imag<br>panic recover</li></ul></li><li><p>这些内部预先定义的名字并不是关键字，你可以在定义中重新使用它们。在一些特殊的场景中重新定义它们也是有意义的，但是也要注意避免过度而引起语义混乱。</p></li></ul></li><li><p>作用域</p><ul><li><p>如果一个名字是在函数内部定义，那么它就只在函数内部有效。</p></li><li><p>如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。</p></li><li><p>名字的开头字母的大小写决定了名字在包外的可见性。</p><ul><li>如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问</li><li>包本身的名字一般总是用小写字母。</li></ul></li></ul></li><li><p>长度</p><ul><li>名字的长度没有逻辑限制</li><li>但是Go语言的风格是尽量使用短小的名字，对于局部变量尤其是这样</li><li>你会经常看到i之类的短名字，而不是冗长的theLoopIndex命名</li><li>通常来说，如果一个名字的作用域比较大，生命周期也比较长，那么用长的名字将会更有意义。</li></ul></li><li><p>驼峰命名</p><ul><li>当名字由几个单词组成时优先使用大小写分隔，而不是优先用下划线分隔。</li><li>在标准库有QuoteRuneToASCII和parseRequestLine这样的函数命名，但是一般不会用quote_rune_to_ASCII和parse_request_line这样的命名。</li><li>而像ASCII和HTML这样的缩略词则避免使用大小写混合的写法，它们可能被称为htmlEscape、HTMLEscape或escapeHTML，但不会是escapeHtml。</li></ul></li></ul><h3 id="ch2-2-声明"><a href="#ch2-2-声明" class="headerlink" title="ch2.2   声明"></a>ch2.2   声明</h3><ul><li><p>4种类型</p><ul><li><p>var、const、type和func</p><ul><li>分别对应变量、常量、类型和函数实体对象的声明</li></ul></li></ul></li><li><p>一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件</p></li><li><p>每个源文件中以包的声明语句开始，说明该源文件是属于哪个包</p></li><li><p>包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要</p><ul><li>// Boiling prints the boiling point of water.<br>package main</li></ul></li></ul><p>import “fmt”</p><p>const boilingF = 212.0</p><p>func main() {<br>    var f = boilingF<br>    var c = (f - 32) * 5 / 9<br>    fmt.Printf(“boiling point = %g°F or %g°C\n”, f, c)<br>    // Output:<br>    // boiling point = 212°F or 100°C<br>}</p><pre><code>    - 声明了一个常量、一个函数和两个变量    - 其中常量boilingF是在包一级范围声明语句声明的，然后f和c两个变量是在main函数内部声明的声明语句声明的。    - 在包一级声明语句声明的名字可在整个包对应的每个源文件中访问，而不是仅仅在其声明语句所在的源文件中访问。    - 相比之下，局部声明的名字就只能在函数内部很小的范围被访问。</code></pre><ul><li><p>函数内部的名字则必须先声明之后才能使用</p></li><li><p>函数</p><ul><li>一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。</li><li>如果函数没有返回值，那么返回值列表是省略的。</li><li>执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。</li><li>// Ftoc prints two Fahrenheit-to-Celsius conversions.<br>package main</li></ul></li></ul><p>import “fmt”</p><p>func main() {<br>    const freezingF, boilingF = 32.0, 212.0<br>    fmt.Printf(“%g°F = %g°C\n”, freezingF, fToC(freezingF)) // “32°F = 0°C”<br>    fmt.Printf(“%g°F = %g°C\n”, boilingF, fToC(boilingF))   // “212°F = 100°C”<br>}</p><p>func fToC(f float64) float64 {<br>    return (f - 32) * 5 / 9<br>}</p><pre><code>    - fToC函数封装了温度转换的处理逻辑，这样它只需要被定义一次，就可以在多个地方多次被使用。在这个例子中，main函数就调用了两次fToC函数，分别使用在局部定义的两个常量作为调用函数的参数。</code></pre><h3 id="ch2-3-变量"><a href="#ch2-3-变量" class="headerlink" title="ch2.3   变量"></a>ch2.3   变量</h3><ul><li><p>2.3.0简介</p><ul><li><p>var 变量名字 类型 = 表达式</p><ul><li><p>其中“<em>类型</em>”或“*= 表达式*”两个部分可以省略其中的一个</p><ul><li><p>如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。</p></li><li><p>如果初始化表达式被省略，那么将用零值初始化该变量。</p><ul><li><p>数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。</p></li><li><p>数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</p></li><li><p>零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。</p><ul><li><p>var s string<br>fmt.Println(s) // “”</p><ul><li>这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为。</li><li>这段代码将打印一个空字符串，而不是导致错误或产生不可预知的行为。</li></ul></li><li><p>Go语言程序员应该让一些聚合类型的零值也具有意义，这样可以保证不管任何类型的变量总是有一个合理有效的零值状态。</p></li></ul></li><li><p>也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。</p><ul><li>var i, j, k int                 // int, int, int<br>var b, f, s = true, 2.3, “four” // bool, float64, string</li></ul></li></ul></li></ul></li><li><p>初始化表达式可以是字面量或任意的表达式。</p><ul><li><p>在包级别声明的变量会在main入口函数执行前完成初始化（§2.6.2），局部变量将在声明语句被执行到的时候完成初始化。</p></li><li><p>一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：</p><ul><li>var f, err = os.Open(name) // os.Open returns a file and an error</li></ul></li></ul></li></ul></li></ul></li><li><p>2.3.1简短变量声明</p><ul><li><p>用于声明和初始化局部变量</p></li><li><p>名字 := 表达式</p></li><li><p>变量的类型根据表达式来自动推导</p></li><li><p>var形式的声明语句往往是用于需要显式指定变量类型的地方，或者因为变量稍后会被重新赋值而初始值无关紧要的地方。</p><ul><li>i := 100                  // an int<br>var boiling float64 = 100 // a float64<br>var names []string<br>var err error<br>var p Point</li></ul></li><li><p>和var形式声明语句一样，简短变量声明语句也可以用来声明和初始化一组变量</p><ul><li><p>i, j := 0, 1</p><ul><li>但是这种同时声明多个变量的方式应该限制只在可以提高代码可读性的地方使用，比如for语句的循环的初始化语句部分。</li></ul></li></ul></li><li><p>“:=”是一个变量声明语句，而“=”是一个变量赋值操作</p><ul><li>也不要混淆多个变量的声明和元组的多重赋值（§2.4.1），后者是将右边各个表达式的值赋值给左边对应位置的各个变量</li></ul></li><li><p>简短变量声明语句也可以用函数的返回值来声明和初始化变量</p><ul><li>f, err := os.Open(name)<br>if err != nil {<br>return err<br>}<br>// …use f…<br>f.Close()</li></ul></li><li><p>简短变量声明左边的变量可能并不是全部都是刚刚声明的</p><ul><li><p>那么简短变量声明语句对这些已经声明过的变量就只有赋值行为了</p><ul><li><p>in, err := os.Open(infile)<br>// …<br>out, err := os.Create(outfile)</p><ul><li>第一个语句声明了in和err两个变量。在第二个语句只声明了out一个变量，然后对已经声明的err进行了赋值操作。</li></ul></li></ul></li></ul></li><li><p>简短变量声明语句中必须至少要声明一个新的变量</p><ul><li><p>f, err := os.Open(infile)<br>// …<br>f, err := os.Create(outfile) // compile error: no new variables题 1</p><ul><li>不能编译通过</li><li>解决的方法是第二个简短变量声明语句改用普通的多重赋值语句</li></ul></li></ul></li><li><p>简短变量声明语句只有对已经在同级词法域声明过的变量才和赋值操作语句等价</p></li><li><p>如果变量是在外部词法域声明的，那么简短变量声明语句将会在当前词法域重新声明一个新的变量</p></li></ul></li><li><p>2.3.2指针</p><ul><li><p>一个指针的值是另一个变量的地址。</p></li><li><p>一个指针对应变量在内存中的存储位置。</p></li><li><p>并不是每一个值都会有一个内存地址，但是对于每一个变量必然有对应的内存地址。</p></li><li><p>通过指针，我们可以直接读或更新对应变量的值，而不需要知道该变量的名字</p></li><li><p>var x int</p><ul><li>&amp;x表达式（取x变量的内存地址）将产生一个指向该整数变量的指针</li><li>指针对应的数据类型是<code>*int</code>，指针被称之为“指向int类型的指针”</li><li>如果指针名字为p，那么可以说“p指针指向变量x”，或者说“p指针保存了x变量的内存地址”</li><li>同时<code>*p</code>表达式对应p指针指向的变量的值</li><li>x := 1<br>p := &amp;x         // p, of type *int, points to x<br>fmt.Println(*p) // “1”</li></ul></li></ul><p>  *p = 2          // equivalent to x = 2<br>  fmt.Println(x)  // “2”</p><ul><li><p>聚合类型每个成员</p><ul><li>比如结构体的每个字段、或者是数组的每个元素——也都是对应一个变量，因此可以被取地址。</li></ul></li><li><p>变量有时候被称为可寻址的值。即使变量由表达式临时生成，那么表达式也必须能接受<code>&amp;</code>取地址操作。</p></li><li><p>任何类型的指针的零值都是nil</p><ul><li><p>如果p指向某个有效变量，那么<code>p != nil</code>测试为真。</p></li><li><p>指针之间也是可以进行相等测试的，只有当它们指向同一个变量或全部是nil时才相等。</p><ul><li>var x, y int<br>fmt.Println(&amp;x == &amp;x, &amp;x == &amp;y, &amp;x == nil) // “true false false”</li></ul></li></ul></li><li><p>返回函数中局部变量的地址也是安全的</p><ul><li>var p = f()</li></ul></li></ul></li></ul><p>func f() *int {<br>    v := 1<br>    return &amp;v<br>}</p><pre><code>        - 调用f函数时创建局部变量v，在局部变量地址被返回之后依然有效，因为指针p依然引用这个变量        - 每次调用f函数都将返回不同的结果            - fmt.Println(f() == f()) // &quot;false&quot;- 指针包含了一个变量的地址，因此如果将指针作为参数调用函数，那将可以在函数中通过该指针来更新变量的值    - func incr(p *int) int &#123;*p++ // 非常重要：只是增加p指向的变量的值，并不改变p指针！！！return *p</code></pre><p>}</p><p>v := 1<br>incr(&amp;v)              // side effect: v is now 2<br>fmt.Println(incr(&amp;v)) // “3” (and v is 3)</p><pre><code>        - 通过指针来更新变量的值，然后返回更新后的值，可用在一个表达式中- 每次我们对一个变量取地址，或者复制指针，我们都是为原变量创建了新的别名- 指针特别有价值的地方在于我们可以不用名字而访问一个变量，但是这是一把双刃剑：要找到一个变量的所有访问者并不容易，我们必须知道变量全部的别名    - 这是Go语言的垃圾回收器所做的工作- 不仅仅是指针会创建别名，很多其他引用类型也会创建别名    - 例如slice、map和chan，甚至结构体、数组和接口都会创建所引用变量的别名- 指针是实现标准库中flag包的关键技术    - 它使用命令行参数来设置对应变量的值，而这些对应命令行标志参数的变量可能会零散分布在整个程序中    - `-n`用于忽略行尾的换行符，`-s sep`用于指定分隔字符（默认是空格）        - // Echo4 prints its command-line arguments.</code></pre><p>package main</p><p>import (<br>    “flag”<br>    “fmt”<br>    “strings”<br>)</p><p>var n = flag.Bool(“n”, false, “omit trailing newline”)<br>var sep = flag.String(“s”, “ “, “separator”)</p><p>func main() {<br>    flag.Parse()<br>    fmt.Print(strings.Join(flag.Args(), *sep))<br>    if !*n {<br>        fmt.Println()<br>    }<br>}</p><pre><code>            - 调用flag.Bool函数会创建一个新的对应布尔型标志参数的变量。                - 它有三个属性：第一个是命令行标志参数的名字“n”，                - 然后是该标志参数的默认值（这里是false），                - 最后是该标志参数对应的描述信息。                - 如果用户在命令行输入了一个无效的标志参数，或者输入`-h`或`-help`参数，那么将打印所有标志参数的名字、默认值和描述信息。            - 调用flag.String函数将创建一个对应字符串类型的标志参数变量。                - 同样包含命令行标志参数对应的参数名、默认值、和描述信息。            - 程序中的`sep`和`n`变量分别是指向对应命令行标志参数变量的指针，因此必须用`*sep`和`*n`形式的指针语法间接引用它们            - 当程序运行时，必须在使用标志参数对应的变量之前先调用flag.Parse函数，用于更新每个标志参数对应变量的值（之前是默认值）            - 对于非标志参数的普通命令行参数可以通过调用flag.Args()函数来访问，返回值对应一个字符串类型的slice。            - 如果在flag.Parse函数解析命令行参数时遇到错误，默认将打印相关的提示信息，然后调用os.Exit(2)终止程序。</code></pre><ul><li><p>2.3.3new函数</p><ul><li><p>new(T)</p><ul><li>表达式new(T)将创建一个T类型的匿名变量</li><li>初始化为T类型的零值</li><li>然后返回变量地址，返回的指针类型为<code>*T</code></li><li>p := new(int)   // p, *int 类型, 指向匿名的 int 变量<br>fmt.Println(*p) // “0”</li></ul></li></ul></li></ul><p>*p = 2          // 设置 int 匿名变量的值为 2<br>fmt.Println(*p) // “2”<br>        - 子主题 5</p><pre><code>- func newInt() *int &#123;return new(int)</code></pre><p>}</p><p>func newInt() *int {<br>    var dummy int<br>    return &amp;dummy<br>}</p><pre><code>    - 两个newInt函数有着相同的行为- 每次调用new函数都是返回一个新的变量的地址    - p := new(int)</code></pre><p>q := new(int)<br>fmt.Println(p == q) // “false”</p><pre><code>        - 下面两个地址是不同的- 如果两个类型都是空的，也就是说类型的大小是0，例如`struct&#123;&#125;`和`[0]int`，有可能有相同的地址    - 请谨慎使用大小为0的类型，因为如果类型的大小为0的话，可能导致Go语言的自动垃圾回收器有不同的行为，具体请查看`runtime.SetFinalizer`函数相关文档- new函数使用通常相对比较少，因为对于结构体来说，直接用字面量语法创建新变量的方法会更灵活（§4.4.1）- 由于new只是一个预定义的函数，它并不是一个关键字，因此我们可以将new名字重新定义为别的类型    - func delta(old, new int) int &#123; return new - old &#125;        - 由于new被定义为int类型的变量名，因此在delta函数内部是无法使用内置的new函数的</code></pre><ul><li><p>2.3.4变量的生命周期</p><ul><li><p>变量的生命周期指的是在程序运行期间变量有效存在的时间段</p></li><li><p>对于在包一级声明的变量来说，它们的生命周期和整个程序的运行周期是一致的</p></li><li><p>局部变量的生命周期则是动态的：每次从创建一个新变量的声明语句开始，直到该变量不再被引用为止，然后变量的存储空间可能被回收。</p></li><li><p>函数的参数变量和返回值变量都是局部变量。它们在函数每次被调用的时候创建。</p><ul><li>for t := 0.0; t &lt; cycles<em>2</em>math.Pi; t += res {<br>x := math.Sin(t)<br>y := math.Sin(t<em>freq + phase)<br>img.SetColorIndex(size+int(x</em>size+0.5), size+int(y*size+0.5),<br>blackIndex)<br>}</li></ul></li><li><p>函数的右小括弧也可以另起一行缩进，同时为了防止编译器在行尾自动插入分号而导致的编译错误，可以在末尾的参数变量后面显式插入逗号</p><ul><li><p>for t := 0.0; t &lt; cycles<em>2</em>math.Pi; t += res {<br>x := math.Sin(t)<br>y := math.Sin(t<em>freq + phase)<br>img.SetColorIndex(<br>  size+int(x</em>size+0.5), size+int(y*size+0.5),<br>  blackIndex, // 最后插入的逗号不会导致编译错误，这是Go编译器的一个特性<br>)               // 小括弧另起一行缩进，和大括弧的风格保存一致<br>}</p><ul><li>在每次循环的开始会创建临时变量t，然后在每次循环迭代中创建临时变量x和y。</li></ul></li></ul></li><li><p>Go语言的自动垃圾收集器是如何知道一个变量是何时可以被回收</p><ul><li><p>基本的实现思路是，从每个包级的变量和每个当前运行函数的每一个局部变量开始，通过指针或引用的访问路径遍历，是否可以找到该变量。</p><ul><li>如果不存在这样的访问路径，那么说明该变量是不可达的，也就是说它是否存在并不会影响程序后续的计算结果。</li></ul></li><li><p>因为一个变量的有效周期只取决于是否可达，因此一个循环迭代内部的局部变量的生命周期可能超出其局部作用域。</p></li><li><p>同时，局部变量可能在函数返回之后依然存在。</p></li><li><p>编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，但可能令人惊讶的是，这个选择并不是由用var还是new声明变量的方式决定的。</p></li></ul></li><li><p>var global *int</p></li></ul></li></ul><p>func f() {<br>    var x int<br>    x = 1<br>    global = &amp;x<br>}</p><p>func g() {<br>    y := new(int)<br>    *y = 1<br>}</p><pre><code>    - f函数里的x变量必须在堆上分配，因为它在函数退出后依然可以通过包一级的global变量找到，虽然它是在函数内部定义的    - 用Go语言的术语说，这个x局部变量从函数f中逃逸了。    - 当g函数返回时，变量`*y`将是不可达的，也就是说可以马上被回收的。因此，`*y`并没有从函数g中逃逸，编译器可以选择在栈上分配`*y`的存储空间        - 也可以选择在堆上分配，然后由Go语言的GC回收这个变量的内存空间    - 其实在任何时候，你并不需为了编写正确的代码而要考虑变量的逃逸行为，要记住的是，逃逸的变量需要额外分配内存，同时对性能的优化可能会产生细微的影响- Go语言的自动垃圾收集器对编写正确的代码是一个巨大的帮助，但也并不是说你完全不用考虑内存了。- 你虽然不需要显式地分配和释放内存，但是要编写高效的程序你依然需要了解变量的生命周期。    - 如果将指向短生命周期对象的指针保存到具有长生命周期的对象中，特别是保存到全局变量时，会阻止对短生命周期对象的垃圾回收（从而可能影响程序的性能）</code></pre><h3 id="ch2-4-赋值"><a href="#ch2-4-赋值" class="headerlink" title="ch2.4   赋值"></a>ch2.4   赋值</h3><ul><li><p>2.4.0简介</p><ul><li><p>使用赋值语句可以更新一个变量的值，最简单的赋值语句是将要被赋值的变量放在=的左边，新值的表达式放在=的右边。</p><ul><li>x = 1                       // 命名变量的赋值</li></ul></li></ul></li></ul><p>*p = true                   // 通过指针间接赋值<br>person.name = “bob”         // 结构体字段赋值<br>count[x] = count[x] * scale // 数组、slice或map的元素赋值</p><pre><code>- 特定的二元算术运算符和赋值语句的复合操作有一个简洁形式    - count[x] *= scale        - count[x] = count[x] * scale    - 这样可以省去对变量表达式的重复计算    - 数值变量也可以支持`++`递增和`--`递减语句        - 自增和自减是语句，而不是表达式，因此`x = i++`之类的表达式是错误的        - v := 1</code></pre><p>v++    // 等价方式 v = v + 1；v 变成 2<br>v–    // 等价方式 v = v - 1；v 变成 1</p><ul><li><p>2.4.1元组赋值</p><ul><li><p>元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值</p></li><li><p>元组赋值也可以使一系列琐碎赋值更加紧凑</p><ul><li>i, j, k = 2, 3, 5</li><li>特别是在for循环的初始化部分</li></ul></li><li><p>在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再统一更新左边对应变量的值。</p><ul><li><p>这对于处理有些同时出现在元组赋值语句左右两边的变量很有帮助</p></li><li><p>我们可以这样交换两个变量的值</p><ul><li>x, y = y, x</li></ul></li></ul></li></ul></li></ul><p>a[i], a[j] = a[j], a[i]</p><pre><code>    - 计算两个整数值的的最大公约数（GCD）        - func gcd(x, y int) int &#123;for y != 0 &#123;    x, y = y, x%y&#125;return x</code></pre><p>}<br>            - GCD不是那个敏感字，而是greatest common divisor的缩写，欧几里德的GCD是最早的非平凡算法</p><pre><code>    - 计算斐波纳契数列（Fibonacci）的第N个数        - func fib(n int) int &#123;x, y := 0, 1for i := 0; i &lt; n; i++ &#123;    x, y = y, x+y&#125;return x</code></pre><p>}</p><pre><code>- 如果表达式太复杂的话，应该尽量避免过度使用元组赋值    - 因为每个变量单独赋值语句的写法可读性会更好。    - 有些表达式会产生多个值，左边变量的数目必须和右边一致。        - f, err = os.Open(&quot;foo.txt&quot;) // function call returns two values    - 通常，这类函数会用额外的返回值来表达某种错误类型        - os.Open是用额外的返回值返回一个error类型的错误，还有一些是用来返回布尔值，通常被称为ok        - 如果map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边，它们都可能会产生两个结果，有一个额外的布尔结果表示操作是否成功            - v, ok = m[key]             // map lookup</code></pre><p>v, ok = x.(T)              // type assertion<br>v, ok = &lt;-ch               // channel receive<br>                - map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边时，并不一定是产生两个结果，也可能只产生一个结果。<br>                - 对于只产生一个结果的情形，map查找失败时会返回零值，类型断言失败时会发生运行时panic异常，通道接收失败时会返回零值（阻塞不算是失败）</p><pre><code>                - v = m[key]                // map查找，失败时返回零值</code></pre><p>v = x.(T)                 // type断言，失败时panic异常<br>v = &lt;-ch                  // 管道接收，失败时返回零值（阻塞不算是失败）</p><p>_, ok = m[key]            // map返回2个值<br>_, ok = mm[“”], false     // map返回1个值<br>_ = mm[“”]                // map返回1个值</p><pre><code>- 和变量声明一样，我们可以用下划线空白标识符`_`来丢弃不需要的值。    - _, err = io.Copy(dst, src) // 丢弃字节数</code></pre><p>_, ok = x.(T)              // 只检测类型，忽略具体值</p><ul><li><p>2.4.2可赋值性</p><ul><li><p>赋值语句是显式的赋值形式</p></li><li><p>程序中还有很多地方会发生隐式的赋值行为</p><ul><li><p>函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量（§4.2）也会产生赋值行为。</p><ul><li>medals := []string{“gold”, “silver”, “bronze”}</li></ul></li><li><p>隐式地对slice的每个元素进行赋值操作</p><ul><li>medals[0] = “gold”<br>medals[1] = “silver”<br>medals[2] = “bronze”</li></ul></li><li><p>map和chan的元素，虽然不是普通的变量，但是也有类似的隐式赋值行为。</p></li></ul></li><li><p>不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。</p><ul><li>只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的。</li></ul></li><li><p>可赋值性的规则对于不同类型有着不同要求</p><ul><li>类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。常量（§3.6）则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。</li></ul></li><li><p>对于两个值是否可以用<code>==</code>或<code>!=</code>进行相等比较的能力也和可赋值能力有关系</p><ul><li>对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的</li></ul></li></ul></li></ul><h3 id="ch2-5-类型"><a href="#ch2-5-类型" class="headerlink" title="ch2.5   类型"></a>ch2.5   类型</h3><ul><li><p>变量或表达式的类型定义了对应存储值的属性特征</p><ul><li>数值在内存的存储大小（或者是元素的bit个数）</li><li>它们在内部是如何表达的</li><li>是否支持一些操作符</li><li>它们自己关联的方法集</li></ul></li><li><p>在任何程序中都会存在一些变量有着相同的内部结构，但是却表示完全不同的概念。</p><ul><li>一个int类型的变量可以用来表示一个循环的迭代索引、或者一个时间戳、或者一个文件描述符、或者一个月份</li><li>一个float64类型的变量可以用来表示每秒移动几米的速度、或者是不同温度单位下的温度</li><li>一个字符串可以用来表示一个密码或者一个颜色的名称</li></ul></li><li><p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构</p><ul><li><p>type 类型名字 底层类型</p></li><li><p>新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p></li><li><p>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用。</p><ul><li><p>对于中文汉字，Unicode标志都作为小写字母处理，因此中文的命名默认不能导出；</p></li><li><p>不过国内的用户针对该问题提出了不同的看法，根据RobPike的回复，在Go2中有可能会将中日韩等字符当作大写字母处理。</p><ul><li>A solution that’s been kicking around for a while:</li></ul></li></ul></li></ul></li></ul><p>For Go 2 (can’t do it before then): Change the definition to “lower case letters and _ are package-local; all else is exported”. Then with non-cased languages, such as Japanese, we can write 日本语 for an exported name and _日本语 for a local name. This rule has no effect, relative to the Go 1 rule, with cased languages. They behave exactly the same.</p><ul><li><p>tempconv0</p><pre><code class="hljs Go"><span class="hljs-comment">// Package tempconv performs Celsius and Fahrenheit temperature computations.</span><span class="hljs-keyword">package</span> tempconv<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-keyword">type</span> Celsius <span class="hljs-keyword">float64</span>    <span class="hljs-comment">// 摄氏温度</span><span class="hljs-keyword">type</span> Fahrenheit <span class="hljs-keyword">float64</span> <span class="hljs-comment">// 华氏温度</span><span class="hljs-keyword">const</span> (AbsoluteZeroC Celsius = <span class="hljs-number">-273.15</span> <span class="hljs-comment">// 绝对零度</span>FreezingC     Celsius = <span class="hljs-number">0</span>       <span class="hljs-comment">// 结冰点温度</span>BoilingC      Celsius = <span class="hljs-number">100</span>     <span class="hljs-comment">// 沸水温度</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CToF</span><span class="hljs-params">(c Celsius)</span> <span class="hljs-title">Fahrenheit</span></span> &#123; <span class="hljs-keyword">return</span> Fahrenheit(c*<span class="hljs-number">9</span>/<span class="hljs-number">5</span> + <span class="hljs-number">32</span>) &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FToC</span><span class="hljs-params">(f Fahrenheit)</span> <span class="hljs-title">Celsius</span></span> &#123; <span class="hljs-keyword">return</span> Celsius((f - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>) &#125;</code></pre><ul><li><p>这个包声明了两种类型：Celsius和Fahrenheit分别对应不同的温度单位。</p><ul><li>它们虽然有着相同的底层类型float64，但是它们是不同的数据类型，因此它们不可以被相互比较或混在一个表达式运算</li><li>刻意区分类型，可以避免一些像无意中使用不同单位的温度混合计算导致的错误</li><li>因此需要一个类似Celsius(t)或Fahrenheit(t)形式的显式转型操作才能将float64转为对应的类型</li><li>Celsius(t)和Fahrenheit(t)是类型转换操作，它们并不是函数调用</li></ul></li><li><p>类型转换不会改变值本身，但是会使它们的语义发生变化</p></li><li><p>另一方面，CToF和FToC两个函数则是对不同温度单位下的温度进行换算，它们会返回不同的值</p></li></ul></li><li><p>对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T</p><ul><li>(*int)(0)</li><li>只有当两个类型的底层基础类型相同时，才允许这种转型操作</li><li>或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身</li><li>如果x是可以赋值给T类型的值，那么x必然也可以被转为T类型，但是一般没有这个必要</li></ul></li><li><p>数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的，</p><ul><li><p>这类转换可能改变值的表现</p><ul><li>将一个浮点数转为整数将丢弃小数部分，</li><li>将一个字符串转为<code>[]byte</code>类型的slice将拷贝一个字符串数据的副本</li></ul></li><li><p>在任何情况下，运行时不会发生转换失败的错误（译注: 错误只会发生在编译阶段）。</p></li></ul></li><li><p>底层数据类型决定了内部结构和表达方式</p><ul><li>也决定是否可以像底层类型一样对内置运算符的支持</li></ul></li><li><p>比较运算符<code>==</code>和<code>&lt;</code>也可以用来比较一个命名类型的变量和另一个有相同类型的变量，或有着相同底层类型的未命名类型的值之间做比较。</p><ul><li><p>但是如果两个值有着不同的类型，则不能直接进行比较：</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> c Celsius<span class="hljs-keyword">var</span> f Fahrenheitfmt.Println(c == <span class="hljs-number">0</span>)          <span class="hljs-comment">// &quot;true&quot;</span>fmt.Println(f &gt;= <span class="hljs-number">0</span>)          <span class="hljs-comment">// &quot;true&quot;</span>fmt.Println(c == f)          <span class="hljs-comment">// compile error: type mismatch</span>fmt.Println(c == Celsius(f)) <span class="hljs-comment">// &quot;true&quot;!</span></code></pre><ul><li>注意最后那个语句。尽管看起来像函数调用，但是Celsius(f)是类型转换操作，它并不会改变值，仅仅是改变值的类型而已。</li><li>测试为真的原因是因为c和g都是零值。</li></ul></li></ul></li><li><p>一个命名的类型可以提供书写方便，特别是可以避免一遍又一遍地书写复杂类型</p><ul><li>如用匿名的结构体定义变量</li><li>虽然对于像float64这种简单的底层类型没有简洁很多，但是如果是复杂的类型将会简洁很多，特别是我们即将讨论的结构体类型。</li></ul></li><li><p>命名类型还可以为该类型的值定义新的行为</p><ul><li><p>这些行为表示为一组关联到该类型的函数集合，我们称为类型的方法集。</p></li><li><p>下面的声明语句，Celsius类型的参数c出现在了函数名的前面，表示声明的是Celsius类型的一个名叫String的方法，该方法返回该类型对象c带着°C温度单位的字符串</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c Celsius)</span> <span class="hljs-title">String</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123; <span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;%g°C&quot;</span>, c) &#125;</code></pre></li></ul></li><li><p>许多类型都会定义一个String方法，因为当使用fmt包的打印方法时，将会优先使用该类型对应的String方法返回的结果打印</p><pre><code class="hljs Go">c := FToC(<span class="hljs-number">212.0</span>)fmt.Println(c.String()) <span class="hljs-comment">// &quot;100°C&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, c)   <span class="hljs-comment">// &quot;100°C&quot;; no need to call String explicitly</span>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, c)   <span class="hljs-comment">// &quot;100°C&quot;</span>fmt.Println(c)          <span class="hljs-comment">// &quot;100°C&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%g\n&quot;</span>, c)   <span class="hljs-comment">// &quot;100&quot;; does not call String</span>fmt.Println(<span class="hljs-keyword">float64</span>(c)) <span class="hljs-comment">// &quot;100&quot;; does not call String</span></code></pre></li></ul><h3 id="ch2-6-包和文件"><a href="#ch2-6-包和文件" class="headerlink" title="ch2.6   包和文件"></a>ch2.6   包和文件</h3><ul><li><p>2.6.0基础概念</p><ul><li><p>为了支持模块化、封装、单独编译和代码重用</p><ul><li><p>Go语言中的包和其他语言的库或模块的概念类似</p></li><li><p>一个包的源代码保存在一个或多个以.go为文件后缀名的源文件中，通常一个包所在目录路径的后缀是包的导入路径</p><ul><li>例如包gopl.io/ch1/helloworld对应的目录路径是$GOPATH/src/gopl.io/ch1/helloworld。</li></ul></li></ul></li><li><p>每个包都对应一个独立的名字空间。</p><ul><li>例如，在image包中的Decode函数和在unicode/utf16包中的 Decode函数是不同的。</li><li>要在外部引用该函数，必须显式使用image.Decode或utf16.Decode形式访问。</li></ul></li><li><p>包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息</p><ul><li>如果一个名字是大写字母开头的，那么该名字是导出的</li><li>因为汉字不区分大小写，因此汉字开头的名字是没有导出的</li></ul></li><li><p>每个源文件都是以包的声明语句开始，用来指明包的名字。当包被导入的时候，包内的成员将通过类似tempconv.CToF的形式访问</p><ul><li><p>而包级别的名字，例如在一个文件声明的类型和常量，在同一个包的其他源文件也是可以直接访问的，就好像所有代码都在一个文件一样。</p></li><li><p>要注意的是tempconv.go源文件导入了fmt包，但是conv.go源文件并没有，因为这个源文件中的代码并没有用到fmt包。</p></li><li><p>因为包级别的常量名都是以大写字母开头，它们可以像tempconv.AbsoluteZeroC这样被外部代码访问</p><ul><li><p>要将摄氏温度转换为华氏温度，需要先用import语句导入gopl.io/ch2/tempconv包，然后就可以使用下面的代码进行转换了</p><pre><code class="hljs Go">fmt.Println(tempconv.CToF(tempconv.BoilingC)) <span class="hljs-comment">// &quot;212°F&quot;</span></code></pre></li></ul></li></ul></li><li><p>在每个源文件的包声明前紧跟着的注释是包注释（§10.7.4）。</p><ul><li>通常，包注释的第一句应该先是包的功能概要说明。</li><li>一个包通常只有一个源文件有包注释</li><li>如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释</li><li>如果包注释很大，通常会放到一个独立的doc.go文件中。</li></ul></li></ul></li><li><p>2.6.1导入包</p><ul><li><p>每个包都有一个全局唯一的导入路径。</p><ul><li>导入语句中类似”gopl.io/ch2/tempconv”的字符串对应包的导入路径</li><li>当使用Go语言自带的go工具箱时（第十章），一个导入路径代表一个目录中的一个或多个Go源文件</li><li>Go语言的规范并没有定义这些字符串的具体含义或包来自哪里，它们是由构建工具来解释的。</li></ul></li><li><p>除了包的导入路径，每个包还有一个包名，包名一般是短小的名字（并不要求包名是唯一的），包名在包的声明处指定。</p><ul><li><p>按照惯例，一个包的名字和包的导入路径的最后一个字段相同，例如gopl.io/ch2/tempconv包的名字一般是tempconv。</p></li><li><p>要使用gopl.io/ch2/tempconv包，需要先导入</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// Cf converts its numeric argument to Celsius and Fahrenheit.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;strconv&quot;</span><span class="hljs-string">&quot;gopl.io/ch2/tempconv&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> _, arg := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;t, err := strconv.ParseFloat(arg, <span class="hljs-number">64</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;cf: %v\n&quot;</span>, err)os.Exit(<span class="hljs-number">1</span>)&#125;f := tempconv.Fahrenheit(t)c := tempconv.Celsius(t)fmt.Printf(<span class="hljs-string">&quot;%s = %s, %s = %s\n&quot;</span>,f, tempconv.FToC(f), c, tempconv.CToF(c))&#125;&#125;</code></pre></li></ul></li><li><p>导入语句将导入的包绑定到一个短小的名字，然后通过该短小的名字就可以引用包中导出的全部内容。</p><ul><li>上面的导入声明将允许我们以tempconv.CToF的形式来访问gopl.io/ch2/tempconv包中的内容。</li><li>在默认情况下，导入的包绑定到tempconv名字（译注：指包声明语句指定的名字），但是我们也可以绑定到另一个名称，以避免名字冲突（§10.4）。</li></ul></li><li><p>如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。</p><ul><li><p>这种强制规则可以有效减少不必要的依赖，虽然在调试期间可能会让人讨厌，因为删除一个类似log.Print(“got here!”)的打印语句可能导致需要同时删除log包导入声明，否则，编译器将会发出一个错误。</p><ul><li>在这种情况下，我们需要将不必要的导入删除或注释掉。</li></ul></li><li><p>不过有更好的解决方案，我们可以使用golang.org/x/tools/cmd/goimports导入工具，它可以根据需要自动添加或删除导入的包</p></li><li><p>许多编辑器都可以集成goimports工具，然后在保存文件的时候自动运行。类似的还有gofmt工具，可以用来格式化Go源文件。</p></li></ul></li></ul></li><li><p>2.6.2包的初始化</p><ul><li><p>包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> a = b + c <span class="hljs-comment">// a 第三个初始化, 为 3</span><span class="hljs-keyword">var</span> b = f()   <span class="hljs-comment">// b 第二个初始化, 为 2, 通过调用 f (依赖c)</span><span class="hljs-keyword">var</span> c = <span class="hljs-number">1</span>     <span class="hljs-comment">// c 第一个初始化, 为 1</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> c + <span class="hljs-number">1</span> &#125;</code></pre></li><li><p>如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化</p><ul><li>Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。</li></ul></li><li><p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化</p><ul><li><p>还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。</p></li><li><p>每个文件都可以包含多个init初始化函数</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;</code></pre><ul><li>这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似</li><li>在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。</li></ul></li></ul></li><li><p>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次</p><ul><li>因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。</li><li>初始化工作是自下而上进行的，main包最后被初始化。</li><li>以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。</li></ul></li><li><p>gopl.io/ch2/popcount</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> popcount<span class="hljs-comment">// pc[i] is the population count of i.</span><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-keyword">byte</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-keyword">byte</span>(i&amp;<span class="hljs-number">1</span>)&#125;&#125;<span class="hljs-comment">// PopCount returns the population count (number of set bits) of x.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">PopCount</span><span class="hljs-params">(x <span class="hljs-keyword">uint64</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">int</span>(pc[<span class="hljs-keyword">byte</span>(x&gt;&gt;(<span class="hljs-number">0</span>*<span class="hljs-number">8</span>))] +pc[<span class="hljs-keyword">byte</span>(x&gt;&gt;(<span class="hljs-number">1</span>*<span class="hljs-number">8</span>))] +pc[<span class="hljs-keyword">byte</span>(x&gt;&gt;(<span class="hljs-number">2</span>*<span class="hljs-number">8</span>))] +pc[<span class="hljs-keyword">byte</span>(x&gt;&gt;(<span class="hljs-number">3</span>*<span class="hljs-number">8</span>))] +pc[<span class="hljs-keyword">byte</span>(x&gt;&gt;(<span class="hljs-number">4</span>*<span class="hljs-number">8</span>))] +pc[<span class="hljs-keyword">byte</span>(x&gt;&gt;(<span class="hljs-number">5</span>*<span class="hljs-number">8</span>))] +pc[<span class="hljs-keyword">byte</span>(x&gt;&gt;(<span class="hljs-number">6</span>*<span class="hljs-number">8</span>))] +pc[<span class="hljs-keyword">byte</span>(x&gt;&gt;(<span class="hljs-number">7</span>*<span class="hljs-number">8</span>))])&#125;</code></pre><ul><li><p>代码定义了一个PopCount函数，用于返回一个数字中含二进制1bit的个数。它使用init初始化函数来生成辅助表格pc，pc表格用于处理每个8bit宽度的数字含二进制的1bit的bit个数，这样的话在处理64bit宽度的数字时就没有必要循环64次，只需要8次查表就可以了。（这并不是最快的统计1bit数目的算法，但是它可以方便演示init函数的用法，并且演示了如何预生成辅助表格，这是编程中常用的技术）。</p></li><li><p>对于pc这类需要复杂处理的初始化，可以通过将初始化逻辑包装为一个匿名函数处理</p><pre><code class="hljs Go"><span class="hljs-comment">// pc[i] is the population count of i.</span><span class="hljs-keyword">var</span> pc [<span class="hljs-number">256</span>]<span class="hljs-keyword">byte</span> = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-params">(pc [256]<span class="hljs-keyword">byte</span>)</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> pc &#123;pc[i] = pc[i/<span class="hljs-number">2</span>] + <span class="hljs-keyword">byte</span>(i&amp;<span class="hljs-number">1</span>)&#125;<span class="hljs-keyword">return</span>&#125;()</code></pre></li><li><p>要注意的是在init函数中，range循环只使用了索引，省略了没有用到的值部分。循环也可以这样写：</p><pre><code class="hljs Go"><span class="hljs-keyword">for</span> i, _ := <span class="hljs-keyword">range</span> pc &#123;</code></pre></li></ul></li></ul></li></ul><h3 id="ch2-7-作用域"><a href="#ch2-7-作用域" class="headerlink" title="ch2.7   作用域"></a>ch2.7   作用域</h3><ul><li><p>一个声明语句将程序中的实体和一个名字关联，比如一个函数或一个变量。声明语句的作用域是指源代码中可以有效使用这个名字的范围。</p></li><li><p>不要将作用域和生命周期混为一谈。</p><ul><li><p>声明语句的作用域对应的是一个源代码的文本区域</p><ul><li>它是一个编译时的属性</li></ul></li><li><p>一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；</p><ul><li>是一个运行时的概念。</li></ul></li></ul></li><li><p>句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。</p><ul><li><p>句法块内部声明的名字是无法被外部块访问的。</p></li><li><p>这个块决定了内部声明的名字的作用域范围。</p></li><li><p>我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块</p><ul><li>对全局的源代码来说，存在一个整体的词法块，称为全局词法块；</li><li>对于每个包；每个for、if和switch语句，也都有对应词法块</li><li>每个switch或select的分支也有独立的词法块</li><li>当然也包括显式书写的词法块（花括弧包含的语句）</li></ul></li></ul></li><li><p>声明语句对应的词法域决定了作用域范围的大小。</p><ul><li>对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用</li><li>任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的</li><li>对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。</li><li>还有许多声明语句，比如tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。</li></ul></li><li><p>控制流标号</p><ul><li>就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。</li></ul></li><li><p>一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系。</p><ul><li>声明一个局部变量，和包级的变量同名。</li><li>将一个函数参数的名字声明为new，虽然内置的new是全局作用域的。</li><li>如果滥用不同词法域可重名的特性的话，可能导致程序很难阅读。</li></ul></li><li><p>当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。</p><ul><li><p>如果查找失败，则报告“未声明的名字”这样的错误。</p></li><li><p>如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。</p><ul><li><p>在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> &#123;&#125;<span class="hljs-keyword">var</span> g = <span class="hljs-string">&quot;g&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f := <span class="hljs-string">&quot;f&quot;</span>fmt.Println(f) <span class="hljs-comment">// &quot;f&quot;; local var f shadows package-level func f</span>fmt.Println(g) <span class="hljs-comment">// &quot;g&quot;; package-level var</span>fmt.Println(h) <span class="hljs-comment">// compile error: undefined: h</span>&#125;</code></pre></li></ul></li></ul></li><li><p>在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明。</p><ul><li><p>还有许多语法块是if或for等控制流语句构造的。</p></li><li><p>下面的代码有三个不同的变量x，因为它们是定义在不同的词法域（这个例子只是为了演示作用域规则，但不是好的编程风格）。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;x := <span class="hljs-string">&quot;hello!&quot;</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(x); i++ &#123;x := x[i]<span class="hljs-keyword">if</span> x != <span class="hljs-string">&#x27;!&#x27;</span> &#123;x := x + <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, x) <span class="hljs-comment">// &quot;HELLO&quot; (one letter per iteration)</span>&#125;&#125;&#125;</code></pre><ul><li><p>在<code>x[i]</code>和<code>x + &#39;A&#39; - &#39;a&#39;</code>声明语句的初始化的表达式中都引用了外部作用域声明的x变量，稍后我们会解释这个。</p><ul><li>注意，后面的表达式与unicode.ToUpper并不等价。</li></ul></li><li><p>正如上面例子所示，并不是所有的词法域都显式地对应到由花括弧包含的语句，还有一些隐含的规则</p></li><li><p>上面的for语句创建了两个词法域</p><ul><li><p>花括弧包含的是显式的部分，是for的循环体部分词法域</p></li><li><p>另外一个隐式的部分则是循环的初始化部分，比如用于迭代变量i的初始化。</p><ul><li>隐式的词法域部分的作用域还包含条件测试部分和循环后的迭代部分（<code>i++</code>），当然也包含循环体词法域。</li></ul></li></ul></li></ul></li><li><p>下面的例子同样有三个不同的x变量，每个声明在不同的词法域，一个在函数体词法域，一个在for隐式的初始化词法域，一个在for循环体词法域；只有两个块是显式创建的</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;x := <span class="hljs-string">&quot;hello&quot;</span><span class="hljs-keyword">for</span> _, x := <span class="hljs-keyword">range</span> x &#123;x := x + <span class="hljs-string">&#x27;A&#x27;</span> - <span class="hljs-string">&#x27;a&#x27;</span>fmt.Printf(<span class="hljs-string">&quot;%c&quot;</span>, x) <span class="hljs-comment">// &quot;HELLO&quot; (one letter per iteration)</span>&#125;&#125;</code></pre></li><li><p>和for循环类似，if和switch语句也会在条件部分创建隐式词法域，还有它们对应的执行体词法域。下面的if-else测试链演示了x和y的有效作用域范围</p><pre><code class="hljs Go"><span class="hljs-keyword">if</span> x := f(); x == <span class="hljs-number">0</span> &#123;fmt.Println(x)&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> y := g(x); x == y &#123;fmt.Println(x, y)&#125; <span class="hljs-keyword">else</span> &#123;fmt.Println(x, y)&#125;fmt.Println(x, y) <span class="hljs-comment">// compile error: x and y are not visible here</span></code></pre><ul><li>第二个if语句嵌套在第一个内部，因此第一个if语句条件初始化词法域声明的变量在第二个if中也可以访问。</li></ul></li><li><p>switch语句的每个分支也有类似的词法域规则：条件部分为一个隐式词法域，然后是每个分支的词法域。</p></li></ul></li><li><p>在包级别，声明的顺序并不会影响作用域范围</p><ul><li><p>因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数</p></li><li><p>但是如果一个变量或常量递归引用了自身，则会产生编译错误。</p><pre><code class="hljs Go"><span class="hljs-keyword">if</span> f, err := os.Open(fname); err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">// compile error: unused: f</span><span class="hljs-keyword">return</span> err&#125;f.ReadByte() <span class="hljs-comment">// compile error: undefined f</span>f.Close()    <span class="hljs-comment">// compile error: undefined f</span></code></pre><ul><li><p>变量f的作用域只在if语句内，因此后面的语句将无法引入它，这将导致编译错误</p></li><li><p>你可能会收到一个局部变量f没有声明的错误提示，具体错误信息依赖编译器的实现。</p></li><li><p>通常需要在if之前声明变量，这样可以确保后面的语句依然可以访问变量</p><pre><code class="hljs Go">f, err := os.Open(fname)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;f.ReadByte()f.Close()</code></pre><ul><li><p>你可能会考虑通过将ReadByte和Close移动到if的else块来解决这个问题</p><pre><code class="hljs Go"><span class="hljs-keyword">if</span> f, err := os.Open(fname); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// f and err are visible here too</span>f.ReadByte()f.Close()&#125;</code></pre></li><li><p>但这不是Go语言推荐的做法，Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进。</p></li></ul></li></ul></li></ul></li><li><p>要特别注意短变量声明语句的作用域范围</p><ul><li><p>考虑下面的程序，它的目的是获取当前的工作目录然后保存到一个包级的变量中。</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> cwd <span class="hljs-keyword">string</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;cwd, err := os.Getwd() <span class="hljs-comment">// compile error: unused: cwd</span><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;os.Getwd failed: %v&quot;</span>, err)&#125;&#125;</code></pre></li><li><p>这本来可以通过直接调用os.Getwd完成，但是将这个从主逻辑中分离出来可能会更好，特别是在需要处理错误的时候。函数log.Fatalf用于打印日志信息，然后调用os.Exit(1)终止程序。</p></li><li><p>虽然cwd在外部已经声明过，但是<code>:=</code>语句还是将cwd和err重新声明为新的局部变量。</p><ul><li><p>因为内部声明的cwd将屏蔽外部的声明，因此上面的代码并不会正确更新包级声明的cwd变量。</p></li><li><p>由于当前的编译器会检测到局部声明的cwd并没有使用，然后报告这可能是一个错误，但是这种检测并不可靠。</p><ul><li><p>因为一些小的代码变更，例如增加一个局部cwd的打印语句，就可能导致这种检测失效。</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> cwd <span class="hljs-keyword">string</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;cwd, err := os.Getwd() <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> wrong!</span><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;os.Getwd failed: %v&quot;</span>, err)&#125;log.Printf(<span class="hljs-string">&quot;Working directory = %s&quot;</span>, cwd)&#125;</code></pre></li><li><p>全局的cwd变量依然是没有被正确初始化的，而且看似正常的日志输出更是让这个BUG更加隐晦。</p></li><li><p>有许多方式可以避免出现类似潜在的问题。最直接的方法是通过单独声明err变量，来避免使用<code>:=</code>的简短声明方式</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> cwd <span class="hljs-keyword">string</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> err errorcwd, err = os.Getwd()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;os.Getwd failed: %v&quot;</span>, err)&#125;&#125;</code></pre></li></ul></li></ul></li></ul></li></ul><h2 id="ch3-基础数据类型"><a href="#ch3-基础数据类型" class="headerlink" title="ch3  基础数据类型"></a>ch3  基础数据类型</h2><h3 id="ch3-0-引言"><a href="#ch3-0-引言" class="headerlink" title="ch3.0   引言"></a>ch3.0   引言</h3><ul><li><p>虽然从底层而言，所有的数据都是由比特组成，但计算机一般操作的是固定大小的数</p><ul><li>如整数、浮点数、比特数组、内存地址等。</li></ul></li><li><p>进一步将这些数组织在一起，就可表达更多的对象</p><ul><li>如数据包、像素点、诗歌，甚至其他任何对象</li></ul></li><li><p>Go语言提供了丰富的数据组织形式，这依赖于Go语言内置的数据类型。</p><ul><li>这些内置的数据类型，兼顾了硬件的特性和表达复杂数据结构的便捷性。</li></ul></li><li><p>Go语言将数据类型分为四类</p><ul><li><p>基础类型</p><ul><li>数字、字符串和布尔型。</li></ul></li><li><p>复合类型</p><ul><li><p>数组和结构体</p><ul><li>是通过组合简单类型，来表达更加复杂的数据结构</li></ul></li></ul></li><li><p>引用类型</p><ul><li><p>指针、切片、字典、函数、通道</p><ul><li>虽然数据种类很多，但它们都是对程序中一个变量或状态的间接引用</li><li>这意味着对任一引用类型数据的修改都会影响所有该引用的拷贝</li></ul></li></ul></li><li><p>接口类型</p></li></ul></li></ul><h3 id="ch3-1-整型"><a href="#ch3-1-整型" class="headerlink" title="ch3.1   整型"></a>ch3.1   整型</h3><ul><li><p>Go语言的数值类型包括几种不同大小的整数、浮点数和复数，每种数值类型都决定了对应的大小范围和是否支持正负符号。</p></li><li><p>Go语言同时提供了有符号和无符号类型的整数运算</p><ul><li><p>这里有int8、int16、int32和int64四种截然不同大小的有符号整数类型，分别对应8、16、32、64bit大小的有符号整数，与此对应的是uint8、uint16、uint32和uint64四种无符号整数类型。</p></li><li><p>这里还有两种一般对应特定CPU平台机器字大小的有符号和无符号整数int和uint</p><ul><li>其中int是应用最广泛的数值类型</li><li>这两种类型都有同样的大小，32或64bit，但是我们不能对此做任何的假设</li><li>因为不同的编译器即使在相同的硬件平台上可能产生不同的大小。</li></ul></li><li><p>Unicode字符rune类型是和int32等价的类型，通常用于表示一个Unicode码点</p><ul><li>这两个名称可以互换使用。同样byte也是uint8类型的等价类型，byte类型一般用于强调数值是一个原始的数据而不是一个小的整数。</li></ul></li><li><p>还有一种无符号的整数类型uintptr，没有指定具体的bit大小但是足以容纳指针。</p><ul><li>uintptr类型只有在底层编程时才需要，特别是Go语言和C语言函数库或操作系统接口相交互的地方</li></ul></li><li><p>不管它们的具体大小，int、uint和uintptr是不同类型的兄弟类型</p><ul><li>其中int和int32也是不同的类型，即使int的大小也是32bit，在需要将int当作int32类型的地方需要一个显式的类型转换操作，反之亦然。</li></ul></li><li><p>其中有符号整数采用2的补码形式表示，也就是最高bit位用来表示符号位，一个n-bit的有符号数的值域是从$-2^{n-1}$到$2^{n-1}-1$。</p></li><li><p>无符号整数的所有bit位都用于表示非负数，值域是0到$2^n-1$。</p><ul><li>int8类型整数的值域是从-128到127，而uint8类型整数的值域是从0到255。</li></ul></li></ul></li><li><p>算术运算、逻辑运算和比较运算的二元运算符，它们按照优先级递减的顺序排列</p><pre><code class="hljs asciidoc"><span class="hljs-bullet">*      </span>/      %      &lt;&lt;       &gt;&gt;     &amp;       &amp;^+      -      |      ^<span class="hljs-section">==     !=     &lt;      &lt;=       &gt;      &gt;=</span>&amp;&amp;||</code></pre><ul><li><p>二元运算符有五种优先级</p><ul><li>在同一个优先级，使用左优先结合规则，但是使用括号可以明确优先顺序，使用括号也可以用于提升优先级，例如<code>mask &amp; (1 &lt;&lt; 28)</code></li></ul></li><li><p>对于上表中前两行的运算符，例如+运算符还有一个与赋值相结合的对应运算符+=，可以用于简化赋值语句。</p></li><li><p>算术运算符<code>+</code>、<code>-</code>、<code>*</code>和<code>/</code>可以适用于整数、浮点数和复数，但是取模运算符%仅用于整数间的运算。</p><ul><li><p>对于不同编程语言，%取模运算的行为可能并不相同</p></li><li><p>在Go语言中，%取模运算符的符号和被取模数的符号总是一致的，因此<code>-5%3</code>和<code>-5%-3</code>结果都是-2。</p></li><li><p>除法运算符<code>/</code>的行为则依赖于操作数是否全为整数</p><ul><li>比如<code>5.0/4.0</code>的结果是1.25，但是5/4的结果是1，因为整数除法会向着0方向截断余数。</li></ul></li></ul></li></ul></li><li><p>一个算术运算的结果，不管是有符号或者是无符号的，如果需要更多的bit位才能正确表示的话，就说明计算结果是溢出了。</p><ul><li><p>超出的高位的bit位部分将被丢弃。</p></li><li><p>如果原始的数值是有符号类型，而且最左边的bit位是1的话，那么最终结果可能是负的</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> u <span class="hljs-keyword">uint8</span> = <span class="hljs-number">255</span>fmt.Println(u, u+<span class="hljs-number">1</span>, u*u) <span class="hljs-comment">// &quot;255 0 1&quot;</span><span class="hljs-keyword">var</span> i <span class="hljs-keyword">int8</span> = <span class="hljs-number">127</span>fmt.Println(i, i+<span class="hljs-number">1</span>, i*i) <span class="hljs-comment">// &quot;127 -128 1&quot;</span></code></pre></li></ul></li><li><p>两个相同的整数类型可以使用下面的二元比较运算符进行比较；比较表达式的结果是布尔类型。</p><pre><code class="hljs asciidoc"><span class="hljs-section">==    等于</span>!=    不等于&lt;     小于&lt;=    小于等于&gt;     大于&gt;=    大于等于</code></pre><ul><li>事实上，布尔型、数字类型和字符串等基本类型都是可比较的，也就是说两个相同类型的值可以用==和!=进行比较</li><li>此外，整数、浮点数和字符串可以根据比较结果排序</li><li>许多其它类型的值可能是不可比较的，因此也就可能是不可排序的。对于我们遇到的每种类型，我们需要保证规则的一致性。</li></ul></li><li><p>一元的加法和减法运算符</p><pre><code class="hljs markdown"><span class="hljs-bullet">+</span>      一元加法（无效果）<span class="hljs-bullet">-</span>      负数</code></pre><ul><li>对于整数，+x是0+x的简写，-x则是0-x的简写</li><li>对于浮点数和复数，+x就是x，-x则是x 的负数</li></ul></li><li><p>bit位操作运算符</p><pre><code class="hljs 1c"><span class="hljs-meta">&amp;      位运算 AND</span><span class="hljs-string">|      位运算 OR</span>^      位运算 XOR<span class="hljs-meta">&amp;^     位清空（AND NOT）</span>&lt;&lt;     左移&gt;&gt;     右移</code></pre><ul><li><p>前面4个操作运算符并不区分是有符号还是无符号数</p></li><li><p>位操作运算符<code>^</code>作为二元运算符时是按位异或（XOR），当用作一元运算符时表示按位取反</p><ul><li>也就是说，它返回一个每个bit位都取反的数</li></ul></li><li><p>位操作运算符<code>&amp;^</code>用于按位置零（AND NOT）</p><ul><li>如果对应y中bit位为1的话，表达式<code>z = x &amp;^ y</code>结果z的对应的bit位为0，否则z对应的bit位等于x相应的bit位的值</li></ul></li><li><p>下面的代码演示了如何使用位操作解释uint8类型值的8个独立的bit位。</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">uint8</span> = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span> | <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">5</span><span class="hljs-keyword">var</span> y <span class="hljs-keyword">uint8</span> = <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">1</span> | <span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">2</span>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x) <span class="hljs-comment">// &quot;00100010&quot;, the set &#123;1, 5&#125;</span>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, y) <span class="hljs-comment">// &quot;00000110&quot;, the set &#123;1, 2&#125;</span>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x&amp;y)  <span class="hljs-comment">// &quot;00000010&quot;, the intersection &#123;1&#125;</span>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x|y)  <span class="hljs-comment">// &quot;00100110&quot;, the union &#123;1, 2, 5&#125;</span>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x^y)  <span class="hljs-comment">// &quot;00100100&quot;, the symmetric difference &#123;2, 5&#125;</span>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x&amp;^y) <span class="hljs-comment">// &quot;00100000&quot;, the difference &#123;5&#125;</span><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">uint</span>(<span class="hljs-number">0</span>); i &lt; <span class="hljs-number">8</span>; i++ &#123;<span class="hljs-keyword">if</span> x&amp;(<span class="hljs-number">1</span>&lt;&lt;i) != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// membership test</span>fmt.Println(i) <span class="hljs-comment">// &quot;1&quot;, &quot;5&quot;</span>&#125;&#125;fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x&lt;&lt;<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;01000100&quot;, the set &#123;2, 6&#125;</span>fmt.Printf(<span class="hljs-string">&quot;%08b\n&quot;</span>, x&gt;&gt;<span class="hljs-number">1</span>) <span class="hljs-comment">// &quot;00010001&quot;, the set &#123;0, 4&#125;</span></code></pre><ul><li>它使用了Printf函数的%b参数打印二进制格式的数字；其中%08b中08表示打印至少8个字符宽度，不足的前缀部分用0填充。</li></ul></li><li><p>在<code>x&lt;&lt;n</code>和<code>x&gt;&gt;n</code>移位运算中，决定了移位操作的bit数部分必须是无符号数</p><ul><li>被操作的x可以是有符号数或无符号数</li><li>算术上，一个<code>x&lt;&lt;n</code>左移运算等价于乘以$2^n$，一个<code>x&gt;&gt;n</code>右移运算等价于除以$2^n$。</li></ul></li><li><p>左移运算用零填充右边空缺的bit位，无符号数的右移运算也是用0填充左边空缺的bit位，但是有符号数的右移运算会用符号位的值填充左边空缺的bit位</p><ul><li>因为这个原因，最好用无符号运算，这样你可以将整数完全当作一个bit位模式处理。</li></ul></li><li><p>尽管Go语言提供了无符号数的运算，但即使数值本身不可能出现负数，我们还是倾向于使用有符号的int类型，就像数组的长度那样，虽然使用uint无符号类型似乎是一个更合理的选择。</p><ul><li><p>事实上，内置的len函数返回一个有符号的int，我们可以像下面例子那样处理逆序循环。</p><pre><code class="hljs Go">medals := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;gold&quot;</span>, <span class="hljs-string">&quot;silver&quot;</span>, <span class="hljs-string">&quot;bronze&quot;</span>&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(medals) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;fmt.Println(medals[i]) <span class="hljs-comment">// &quot;bronze&quot;, &quot;silver&quot;, &quot;gold&quot;</span>&#125;</code></pre><ul><li>另一个选择对于上面的例子来说将是灾难性的。如果len函数返回一个无符号数，那么i也将是无符号的uint类型，然后条件<code>i &gt;= 0</code>则永远为真。在三次迭代之后，也就是<code>i == 0</code>时，i–语句将不会产生-1，而是变成一个uint类型的最大值（可能是$2^64-1$），然后medals[i]表达式运行时将发生panic异常（§5.9），也就是试图访问一个slice范围以外的元素。</li><li>出于这个原因，无符号数往往只有在位运算或其它特殊的运算场景才会使用，就像bit集合、分析二进制文件格式或者是哈希和加密操作等。它们通常并不用于仅仅是表达非负数量的场合。</li></ul></li></ul></li><li><p>一般来说，需要一个显式的转换将一个值从一种类型转化为另一种类型，并且算术和逻辑运算的二元操作中必须是相同的类型。</p><ul><li><p>虽然这偶尔会导致需要很长的表达式，但是它消除了所有和类型相关的问题，而且也使得程序容易理解。</p><ul><li><p>在很多场景，会遇到类似下面代码的常见的错误</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> apples <span class="hljs-keyword">int32</span> = <span class="hljs-number">1</span><span class="hljs-keyword">var</span> oranges <span class="hljs-keyword">int16</span> = <span class="hljs-number">2</span><span class="hljs-keyword">var</span> compote <span class="hljs-keyword">int</span> = apples + oranges <span class="hljs-comment">// compile error</span></code></pre><ul><li><p>当尝试编译这三个语句时，将产生一个错误信息：</p><pre><code class="hljs angelscript">invalid operation: apples + oranges (mismatched types <span class="hljs-built_in">int</span>32 <span class="hljs-keyword">and</span> <span class="hljs-built_in">int</span>16)</code></pre></li><li><p>这种类型不匹配的问题可以有几种不同的方法修复，最常见方法是将它们都显式转型为一个常见类型</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> compote = <span class="hljs-keyword">int</span>(apples) + <span class="hljs-keyword">int</span>(oranges)</code></pre></li><li><p>对于每种类型T，如果转换允许的话，类型转换操作T(x)将x转换为T类型。</p><ul><li><p>许多整数之间的相互转换并不会改变数值；它们只是告诉编译器如何解释这个值。</p></li><li><p>但是对于将一个大尺寸的整数类型转为一个小尺寸的整数类型，或者是将一个浮点数转为整数，可能会改变数值或丢失精度</p><pre><code class="hljs Go">f := <span class="hljs-number">3.141</span> <span class="hljs-comment">// a float64</span>i := <span class="hljs-keyword">int</span>(f)fmt.Println(f, i) <span class="hljs-comment">// &quot;3.141 3&quot;</span>f = <span class="hljs-number">1.99</span>fmt.Println(<span class="hljs-keyword">int</span>(f)) <span class="hljs-comment">// &quot;1&quot;</span></code></pre></li><li><p>浮点数到整数的转换将丢失任何小数部分，然后向数轴零方向截断。你应该避免对可能会超出目标类型表示范围的数值做类型转换，因为截断的行为可能依赖于具体的实现</p><pre><code class="hljs Go">f := <span class="hljs-number">1e100</span>  <span class="hljs-comment">// a float64</span>i := <span class="hljs-keyword">int</span>(f) <span class="hljs-comment">// 结果依赖于具体实现</span></code></pre></li></ul></li></ul></li></ul></li></ul></li><li><p>任何大小的整数字面值都可以用以0开始的八进制格式书写，例如0666；或用以0x或0X开头的十六进制格式书写，例如0xdeadbeef。</p><ul><li><p>十六进制数字可以用大写或小写字母。如今八进制数据通常用于POSIX操作系统上的文件访问权限标志，十六进制数字则更强调数字值的bit位模式。</p></li><li><p>当使用fmt包打印一个数值时，我们可以用%d、%o或%x参数控制输出的进制格式</p><pre><code class="hljs Go">o := <span class="hljs-number">0666</span>fmt.Printf(<span class="hljs-string">&quot;%d %[1]o %#[1]o\n&quot;</span>, o) <span class="hljs-comment">// &quot;438 666 0666&quot;</span>x := <span class="hljs-keyword">int64</span>(<span class="hljs-number">0xdeadbeef</span>)fmt.Printf(<span class="hljs-string">&quot;%d %[1]x %#[1]x %#[1]X\n&quot;</span>, x)<span class="hljs-comment">// Output:</span><span class="hljs-comment">// 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF</span></code></pre><ul><li><p>请注意fmt的两个使用技巧</p><ul><li>通常Printf格式化字符串包含多个%参数时将会包含对应相同数量的额外操作数，但是%之后的<code>[1]</code>副词告诉Printf函数再次使用第一个操作数。</li><li>第二，%后的<code>#</code>副词告诉Printf在用%o、%x或%X输出时生成0、0x或0X前缀。</li></ul></li></ul></li></ul></li><li><p>字符面值通过一对单引号直接包含对应字符。</p><ul><li><p>最简单的例子是ASCII中类似’a’写法的字符面值，但是我们也可以通过转义的数值来表示任意的Unicode码点对应的字符，马上将会看到这样的例子。</p></li><li><p>字符使用<code>%c</code>参数打印，或者是用<code>%q</code>参数打印带单引号的字符</p><pre><code class="hljs Go">ascii := <span class="hljs-string">&#x27;a&#x27;</span>unicode := <span class="hljs-string">&#x27;国&#x27;</span>newline := <span class="hljs-string">&#x27;\n&#x27;</span>fmt.Printf(<span class="hljs-string">&quot;%d %[1]c %[1]q\n&quot;</span>, ascii)   <span class="hljs-comment">// &quot;97 a &#x27;a&#x27;&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%d %[1]c %[1]q\n&quot;</span>, unicode) <span class="hljs-comment">// &quot;22269 国 &#x27;国&#x27;&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%d %[1]q\n&quot;</span>, newline)       <span class="hljs-comment">// &quot;10 &#x27;\n&#x27;&quot;</span></code></pre></li></ul></li></ul></li></ul><h3 id="ch3-2-浮点数"><a href="#ch3-2-浮点数" class="headerlink" title="ch3.2   浮点数"></a>ch3.2   浮点数</h3><ul><li><p>Go语言提供了两种精度的浮点数，float32和float64</p><ul><li>它们的算术规范由IEEE754浮点数国际标准定义，该浮点数规范被所有现代的CPU支持。</li></ul></li><li><p>这些浮点数类型的取值范围可以从很微小到很巨大。</p><ul><li><p>浮点数的范围极限值可以在math包找到。</p><ul><li>常量math.MaxFloat32表示float32能表示的最大数值，大约是 3.4e38</li><li>应的math.MaxFloat64常量大约是1.8e308</li><li>它们分别能表示的最小值近似为1.4e-45和4.9e-324</li></ul></li></ul></li><li><p>一个float32类型的浮点数可以提供大约6个十进制数的精度，而float64则可以提供约15个十进制数的精度</p><ul><li><p>通常应该优先使用float64类型，因为float32类型的累计计算误差很容易扩散，并且float32能精确表示的正整数并不是很大</p><ul><li><p>因为float32的有效bit位只有23个，其它的bit位用于指数和符号；当整数大于23bit能表达的范围时，float32的表示将出现误差</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> f <span class="hljs-keyword">float32</span> = <span class="hljs-number">16777216</span> <span class="hljs-comment">// 1 &lt;&lt; 24</span>fmt.Println(f == f+<span class="hljs-number">1</span>)    <span class="hljs-comment">// &quot;true&quot;!</span></code></pre></li></ul></li><li><p>浮点数的字面值可以直接写小数部分</p><pre><code class="hljs Go"><span class="hljs-keyword">const</span> e = <span class="hljs-number">2.71828</span> <span class="hljs-comment">// (approximately)</span></code></pre></li><li><p>小数点前面或后面的数字都可能被省略（例如.707或1.）。很小或很大的数最好用科学计数法书写，通过e或E来指定指数部分</p><pre><code class="hljs Go"><span class="hljs-keyword">const</span> Avogadro = <span class="hljs-number">6.02214129e23</span>  <span class="hljs-comment">// 阿伏伽德罗常数</span><span class="hljs-keyword">const</span> Planck   = <span class="hljs-number">6.62606957e-34</span> <span class="hljs-comment">// 普朗克常数</span></code></pre></li><li><p>用Printf函数的%g参数打印浮点数，将采用更紧凑的表示形式打印，并提供足够的精度，但是对应表格的数据，使用%e（带指数）或%f的形式打印可能更合适。</p><pre><code class="hljs Go"><span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">8</span>; x++ &#123;fmt.Printf(<span class="hljs-string">&quot;x = %d e^x = %8.3f\n&quot;</span>, x, math.Exp(<span class="hljs-keyword">float64</span>(x)))&#125;</code></pre><ul><li><p>所有的这三个打印形式都可以指定打印的宽度和控制打印精度。</p></li><li><p>上面代码打印e的幂，打印精度是小数点后三个小数精度和8个字符宽度</p><pre><code class="hljs apache"><span class="hljs-attribute">x</span> = <span class="hljs-number">0</span>       e^x =    <span class="hljs-number">1</span>.<span class="hljs-number">000</span><span class="hljs-attribute">x</span> = <span class="hljs-number">1</span>       e^x =    <span class="hljs-number">2</span>.<span class="hljs-number">718</span><span class="hljs-attribute">x</span> = <span class="hljs-number">2</span>       e^x =    <span class="hljs-number">7</span>.<span class="hljs-number">389</span><span class="hljs-attribute">x</span> = <span class="hljs-number">3</span>       e^x =   <span class="hljs-number">20</span>.<span class="hljs-number">086</span><span class="hljs-attribute">x</span> = <span class="hljs-number">4</span>       e^x =   <span class="hljs-number">54</span>.<span class="hljs-number">598</span><span class="hljs-attribute">x</span> = <span class="hljs-number">5</span>       e^x =  <span class="hljs-number">148</span>.<span class="hljs-number">413</span><span class="hljs-attribute">x</span> = <span class="hljs-number">6</span>       e^x =  <span class="hljs-number">403</span>.<span class="hljs-number">429</span><span class="hljs-attribute">x</span> = <span class="hljs-number">7</span>       e^x = <span class="hljs-number">1096</span>.<span class="hljs-number">633</span></code></pre></li></ul></li></ul></li><li><p>math包中除了提供大量常用的数学函数外，还提供了IEEE754浮点数标准中定义的特殊值的创建和测试</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> z <span class="hljs-keyword">float64</span>fmt.Println(z, -z, <span class="hljs-number">1</span>/z, <span class="hljs-number">-1</span>/z, z/z) <span class="hljs-comment">// &quot;0 -0 +Inf -Inf NaN&quot;</span></code></pre><ul><li><p>正无穷大和负无穷大，分别用于表示太大溢出的数字和除零的结果</p></li><li><p>还有NaN非数，一般用于表示无效的除法操作结果0/0或Sqrt(-1).</p><pre><code class="hljs Go">nan := math.NaN()fmt.Println(nan == nan, nan &lt; nan, nan &gt; nan) <span class="hljs-comment">// &quot;false false false&quot;</span></code></pre><ul><li>函数math.IsNaN用于测试一个数是否是非数NaN，math.NaN则返回非数对应的值。</li><li>虽然可以用math.NaN来表示一个非法的结果，但是测试一个结果是否是非数NaN则是充满风险的，因为NaN和任何数都是不相等的</li><li>在浮点数中，NaN、正无穷大和负无穷大都不是唯一的，每个都有非常多种的bit模式表示</li></ul></li><li><p>如果一个函数返回的浮点数结果可能失败，最好的做法是用单独的标志报告失败</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">compute</span><span class="hljs-params">()</span> <span class="hljs-params">(value <span class="hljs-keyword">float64</span>, ok <span class="hljs-keyword">bool</span>)</span></span> &#123;<span class="hljs-comment">// ...</span><span class="hljs-keyword">if</span> failed &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">return</span> result, <span class="hljs-literal">true</span>&#125;</code></pre></li></ul></li></ul><h3 id="ch3-3-复数"><a href="#ch3-3-复数" class="headerlink" title="ch3.3   复数"></a>ch3.3   复数</h3><ul><li><p>Go语言提供了两种精度的复数类型：complex64和complex128，分别对应float32和float64两种浮点数精度。内置的complex函数用于构建复数，内建的real和imag函数分别返回复数的实部和虚部</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 1+2i</span><span class="hljs-keyword">var</span> y <span class="hljs-keyword">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 3+4i</span>fmt.Println(x*y)                 <span class="hljs-comment">// &quot;(-5+10i)&quot;</span>fmt.Println(<span class="hljs-built_in">real</span>(x*y))           <span class="hljs-comment">// &quot;-5&quot;</span>fmt.Println(<span class="hljs-built_in">imag</span>(x*y))           <span class="hljs-comment">// &quot;10&quot;</span></code></pre><ul><li><p>如果一个浮点数面值或一个十进制整数面值后面跟着一个i，例如3.141592i或2i，它将构成一个复数的虚部，复数的实部是0</p><pre><code class="hljs Go">fmt.Println(<span class="hljs-number">1i</span> * <span class="hljs-number">1i</span>) <span class="hljs-comment">// &quot;(-1+0i)&quot;, i^2 = -1</span></code></pre></li><li><p>在常量算术规则下，一个复数常量可以加到另一个普通数值常量（整数或浮点数、实部或虚部），我们可以用自然的方式书写复数，就像1+2i或与之等价的写法2i+1。</p><pre><code class="hljs Go">x := <span class="hljs-number">1</span> + <span class="hljs-number">2i</span>y := <span class="hljs-number">3</span> + <span class="hljs-number">4i</span></code></pre></li></ul></li><li><p>复数也可以用==和!=进行相等比较。</p><ul><li>只有两个复数的实部和虚部都相等的时候它们才是相等的</li><li>浮点数的相等比较是危险的，需要特别小心处理精度问题</li></ul></li><li><p>math/cmplx包提供了复数处理的许多函数</p><ul><li><p>例如求复数的平方根函数和求幂函数</p><pre><code class="hljs Go">fmt.Println(cmplx.Sqrt(<span class="hljs-number">-1</span>)) <span class="hljs-comment">// &quot;(0+1i)&quot;</span></code></pre></li><li><p>下面的程序使用complex128复数算法来生成一个Mandelbrot图像</p><pre><code class="hljs Go"><span class="hljs-comment">// Mandelbrot emits a PNG image of the Mandelbrot fractal.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;image&quot;</span><span class="hljs-string">&quot;image/color&quot;</span><span class="hljs-string">&quot;image/png&quot;</span><span class="hljs-string">&quot;math/cmplx&quot;</span><span class="hljs-string">&quot;os&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> (xmin, ymin, xmax, ymax = <span class="hljs-number">-2</span>, <span class="hljs-number">-2</span>, +<span class="hljs-number">2</span>, +<span class="hljs-number">2</span>width, height          = <span class="hljs-number">1024</span>, <span class="hljs-number">1024</span>)img := image.NewRGBA(image.Rect(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, width, height))<span class="hljs-keyword">for</span> py := <span class="hljs-number">0</span>; py &lt; height; py++ &#123;y := <span class="hljs-keyword">float64</span>(py)/height*(ymax-ymin) + ymin<span class="hljs-keyword">for</span> px := <span class="hljs-number">0</span>; px &lt; width; px++ &#123;x := <span class="hljs-keyword">float64</span>(px)/width*(xmax-xmin) + xminz := <span class="hljs-built_in">complex</span>(x, y)<span class="hljs-comment">// Image point (px, py) represents complex value z.</span>img.Set(px, py, mandelbrot(z))&#125;&#125;png.Encode(os.Stdout, img) <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> ignoring errors</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mandelbrot</span><span class="hljs-params">(z <span class="hljs-keyword">complex128</span>)</span> <span class="hljs-title">color</span>.<span class="hljs-title">Color</span></span> &#123;<span class="hljs-keyword">const</span> iterations = <span class="hljs-number">200</span><span class="hljs-keyword">const</span> contrast = <span class="hljs-number">15</span><span class="hljs-keyword">var</span> v <span class="hljs-keyword">complex128</span><span class="hljs-keyword">for</span> n := <span class="hljs-keyword">uint8</span>(<span class="hljs-number">0</span>); n &lt; iterations; n++ &#123;v = v*v + z<span class="hljs-keyword">if</span> cmplx.Abs(v) &gt; <span class="hljs-number">2</span> &#123;<span class="hljs-keyword">return</span> color.Gray&#123;<span class="hljs-number">255</span> - contrast*n&#125;&#125;&#125;<span class="hljs-keyword">return</span> color.Black&#125;</code></pre><ul><li>用于遍历1024x1024图像每个点的两个嵌套的循环对应-2到+2区间的复数平面。程序反复测试每个点对应复数值平方值加一个增量值对应的点是否超出半径为2的圆。如果超过了，通过根据预设置的逃逸迭代次数对应的灰度颜色来代替。如果不是，那么该点属于Mandelbrot集合，使用黑色颜色标记。最终程序将生成的PNG格式分形图像输出到标准输出</li></ul></li></ul></li></ul><h3 id="ch3-4-布尔型"><a href="#ch3-4-布尔型" class="headerlink" title="ch3.4   布尔型"></a>ch3.4   布尔型</h3><ul><li><p>一个布尔类型的值只有两种：true和false。</p><ul><li><p>if和for语句的条件部分都是布尔类型的值，并且==和&lt;等比较操作也会产生布尔型的值。</p></li><li><p>一元操作符<code>!</code>对应逻辑非操作，因此<code>!true</code>的值为<code>false</code></p><ul><li>更罗嗦的说法是<code>(!true==false)==true</code></li><li>虽然表达方式不一样，不过我们一般会采用简洁的布尔表达式，就像用x来表示<code>x==true</code>。</li></ul></li></ul></li><li><p>布尔值可以和&amp;&amp;（AND）和||（OR）操作符结合，并且有短路行为</p><ul><li><p>如果运算符左边值已经可以确定整个布尔表达式的值，那么运算符右边的值将不再被求值</p><ul><li><p>因此下面的表达式总是安全的</p><pre><code class="hljs Go">s != <span class="hljs-string">&quot;&quot;</span> &amp;&amp; s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;x&#x27;</span></code></pre><ul><li>其中s[0]操作如果应用于空字符串将会导致panic异常。</li></ul></li></ul></li><li><p>因为<code>&amp;&amp;</code>的优先级比<code>||</code>高</p><ul><li><p><code>&amp;&amp;</code>对应逻辑乘法，<code>||</code>对应逻辑加法，乘法比加法优先级要高</p></li><li><p>下面形式的布尔表达式是不需要加小括弧的</p><pre><code class="hljs Go"><span class="hljs-keyword">if</span> <span class="hljs-string">&#x27;a&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span> ||<span class="hljs-string">&#x27;A&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span> ||<span class="hljs-string">&#x27;0&#x27;</span> &lt;= c &amp;&amp; c &lt;= <span class="hljs-string">&#x27;9&#x27;</span> &#123;<span class="hljs-comment">// ...ASCII letter or digit...</span>&#125;</code></pre></li></ul></li></ul></li><li><p>布尔值并不会隐式转换为数字值0或1，反之亦然。</p><ul><li><p>必须使用一个显式的if语句辅助转换</p><pre><code class="hljs Go">i := <span class="hljs-number">0</span><span class="hljs-keyword">if</span> b &#123;i = <span class="hljs-number">1</span>&#125;</code></pre></li><li><p>如果需要经常做类似的转换，包装成一个函数会更方便</p><pre><code class="hljs Go"><span class="hljs-comment">// btoi returns 1 if b is true and 0 if false.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">btoi</span><span class="hljs-params">(b <span class="hljs-keyword">bool</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">if</span> b &#123;<span class="hljs-keyword">return</span> <span class="hljs-number">1</span>&#125;<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>&#125;</code></pre></li><li><p>数字到布尔型的逆转换则非常简单，不过为了保持对称，我们也可以包装一个函数</p><pre><code class="hljs Go"><span class="hljs-comment">// itob reports whether i is non-zero.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">itob</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123; <span class="hljs-keyword">return</span> i != <span class="hljs-number">0</span> &#125;</code></pre></li></ul></li></ul><h3 id="ch3-5-字符串"><a href="#ch3-5-字符串" class="headerlink" title="ch3.5   字符串"></a>ch3.5   字符串</h3><ul><li><p>ch3.5.0简介</p><ul><li><p>一个字符串是一个不可改变的字节序列。</p><ul><li>字符串可以包含任意的数据，包括byte值0，但是通常是用来包含人类可读的文本。</li><li>文本字符串通常被解释为采用UTF8编码的Unicode码点（rune）序列，我们稍后会详细讨论这个问题。</li></ul></li><li><p>内置的len函数可以返回一个字符串中的字节数目（不是rune字符数目），索引操作s[i]返回第i个字节的字节值，i必须满足0 ≤ i&lt; len(s)条件约束。</p><pre><code class="hljs Go">s := <span class="hljs-string">&quot;hello, world&quot;</span>fmt.Println(<span class="hljs-built_in">len</span>(s))     <span class="hljs-comment">// &quot;12&quot;</span>fmt.Println(s[<span class="hljs-number">0</span>], s[<span class="hljs-number">7</span>]) <span class="hljs-comment">// &quot;104 119&quot; (&#x27;h&#x27; and &#x27;w&#x27;)</span></code></pre><ul><li><p>如果试图访问超出字符串索引范围的字节将会导致panic异常</p><pre><code class="hljs Go">c := s[<span class="hljs-built_in">len</span>(s)] <span class="hljs-comment">// panic: index out of range</span></code></pre></li></ul></li><li><p>第i个字节并不一定是字符串的第i个字符，因为对于非ASCII字符的UTF8编码会要两个或多个字节</p></li><li><p>字符的工作方式</p><ul><li><p>子字符串操作s[i:j]基于原始的s字符串的第i个字节开始到第j个字节（并不包含j本身）生成一个新字符串。</p><ul><li><p>生成的新字符串将包含j-i个字节</p><pre><code class="hljs Go">fmt.Println(s[<span class="hljs-number">0</span>:<span class="hljs-number">5</span>]) <span class="hljs-comment">// &quot;hello&quot;</span></code></pre></li></ul></li><li><p>同样，如果索引超出字符串范围或者j小于i的话将导致panic异常。</p></li><li><p>不管i还是j都可能被忽略，当它们被忽略时将采用0作为开始位置，采用len(s)作为结束的位置。</p><pre><code class="hljs Go">fmt.Println(s[:<span class="hljs-number">5</span>]) <span class="hljs-comment">// &quot;hello&quot;</span>fmt.Println(s[<span class="hljs-number">7</span>:]) <span class="hljs-comment">// &quot;world&quot;</span>fmt.Println(s[:])  <span class="hljs-comment">// &quot;hello, world&quot;</span></code></pre></li><li><p>其中+操作符将两个字符串连接构造一个新字符串</p><pre><code class="hljs Go">fmt.Println(<span class="hljs-string">&quot;goodbye&quot;</span> + s[<span class="hljs-number">5</span>:]) <span class="hljs-comment">// &quot;goodbye, world&quot;</span></code></pre></li></ul></li><li><p>字符串可以用==和&lt;进行比较</p><ul><li>比较通过逐个字节比较完成的，因此比较的结果是字符串自然编码的顺序。</li></ul></li><li><p>字符串的值是不可变的</p><ul><li><p>一个字符串包含的字节序列永远不会被改变，当然我们也可以给一个字符串变量分配一个新字符串值。</p><ul><li><p>可以像下面这样将一个字符串追加到另一个字符串</p><pre><code class="hljs Go">s := <span class="hljs-string">&quot;left foot&quot;</span>t := ss += <span class="hljs-string">&quot;, right foot&quot;</span></code></pre></li><li><p>这并不会导致原始的字符串值被改变，但是变量s将因为+=语句持有一个新的字符串值，但是t依然是包含原先的字符串值。</p><pre><code class="hljs Go">fmt.Println(s) <span class="hljs-comment">// &quot;left foot, right foot&quot;</span>fmt.Println(t) <span class="hljs-comment">// &quot;left foot&quot;</span></code></pre></li></ul></li><li><p>因为字符串是不可修改的，因此尝试修改字符串内部数据的操作也是被禁止的</p><pre><code class="hljs Go">s[<span class="hljs-number">0</span>] = <span class="hljs-string">&#x27;L&#x27;</span> <span class="hljs-comment">// compile error: cannot assign to s[0]</span></code></pre></li><li><p>不变性意味着如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的。</p><ul><li>一个字符串s和对应的子字符串切片s[7:]的操作也可以安全地共享相同的内存，因此字符串切片操作代价也是低廉的。</li><li>在这两种情况下都没有必要分配新的内存</li></ul></li></ul></li></ul></li><li><p>ch3.5.1字符串面值</p><ul><li><p>字符串值也可以用字符串面值方式编写，只要将一系列字节序列包含在双引号内即可</p><pre><code class="hljs 1c"><span class="hljs-string">&quot;Hello, 世界&quot;</span></code></pre></li><li><p>因为Go语言源文件总是用UTF8编码，并且Go语言的文本字符串也以UTF8编码的方式处理，因此我们可以将Unicode码点也写到字符串面值中。</p></li><li><p>在一个双引号包含的字符串面值中，可以用以反斜杠<code>\</code>开头的转义序列插入任意的数据。</p><pre><code class="hljs livescript"><span class="hljs-string">\a</span>      响铃<span class="hljs-string">\b</span>      退格<span class="hljs-string">\f</span>      换页<span class="hljs-string">\n</span>      换行<span class="hljs-string">\r</span>      回车<span class="hljs-string">\t</span>      制表符<span class="hljs-string">\v</span>      垂直制表符<span class="hljs-string">\&#x27;</span>      单引号（只用在 <span class="hljs-string">&#x27;\&#x27;&#x27;</span> 形式的rune符号面值中）<span class="hljs-string">\&quot;</span>      双引号（只用在 <span class="hljs-string">&quot;...&quot;</span> 形式的字符串面值中）<span class="hljs-string">\\</span>      反斜杠</code></pre></li><li><p>可以通过十六进制或八进制转义在字符串面值中包含任意的字节。</p><ul><li><p>一个十六进制的转义形式是<code>\xhh</code>，其中两个h表示十六进制数字（大写或小写都可以）</p></li><li><p>一个八进制转义形式是<code>\ooo</code>，包含三个八进制的o数字（0到7），但是不能超过<code>\377</code></p><ul><li>对应一个字节的范围，十进制为255）</li></ul></li><li><p>每一个单一的字节表达一个特定的值。稍后我们将看到如何将一个Unicode码点写到字符串面值中。</p></li><li><p>在原生的字符串面值中，没有转义操作；全部的内容都是字面的意思，包含退格和换行</p><ul><li>因此一个程序中的原生字符串面值可能跨越多行</li></ul></li></ul></li><li><p>一个原生的字符串面值形式是`…`，使用反引号代替双引号。</p><ul><li>在原生字符串面值内部是无法直接写`字符的，可以用八进制或十六进制转义或+”`“连接字符串常量完成）</li><li>唯一的特殊处理是会删除回车以保证在所有平台上的值都是一样的，包括那些把回车也放入文本文件的系统（译注：Windows系统会把回车和换行一起放入文本文件中）</li></ul></li><li><p>原生字符串面值用于编写正则表达式会很方便</p><ul><li><p>因为正则表达式往往会包含很多反斜杠。原生字符串面值同时被广泛应用于HTML模板、JSON面值、命令行提示信息以及那些需要扩展到多行的场景。</p><pre><code class="hljs Go"><span class="hljs-keyword">const</span> GoUsage = <span class="hljs-string">`Go is a tool for managing Go source code.</span><span class="hljs-string"></span><span class="hljs-string">Usage:</span><span class="hljs-string">go command [arguments]</span><span class="hljs-string">...`</span></code></pre></li></ul></li></ul></li><li><p>ch3.5.2Unicode</p><ul><li><p>在很久以前，世界还是比较简单的，起码计算机世界就只有一个ASCII字符集</p><ul><li>美国信息交换标准代码</li><li>ASCII，更准确地说是美国的ASCII，使用7bit来表示128个字符</li><li>包含英文字母的大小写、数字、各种标点符号和设备控制符。</li><li>对于早期的计算机程序来说，这些就足够了，但是这也导致了世界上很多其他地区的用户无法直接使用自己的符号系统。</li></ul></li><li><p>随着互联网的发展，混合多种语言的数据变得很常见</p><ul><li>比如本身的英文原文或中文翻译都包含了ASCII、中文、日文等多种语言字符</li><li>使用unicode有效处理这些包含了各种语言的丰富多样的文本数据</li></ul></li><li><p>收集了这个世界上所有的符号系统，包括重音符号和其它变音符号，制表符和回车符，还有很多神秘的符号，每个符号都分配一个唯一的Unicode码点，Unicode码点对应Go语言中的rune整数类型（译注：rune是int32等价类型）。</p></li><li><p>在第八版本的Unicode标准里收集了超过120,000个字符，涵盖超过100多种语言。</p><ul><li>通用的表示一个Unicode码点的数据类型是int32，也就是Go语言中rune对应的类型；它的同义词rune符文正是这个意思</li></ul></li><li><p>我们可以将一个符文序列表示为一个int32序列。</p><ul><li>这种编码方式叫UTF-32或UCS-4，每个Unicode码点都使用同样大小的32bit来表示。</li><li>这种方式比较简单统一，但是它会浪费很多存储空间，因为大多数计算机可读的文本是ASCII字符，本来每个ASCII字符只需要8bit或1字节就能表示。</li><li>而且即使是常用的字符也远少于65,536个，也就是说用16bit编码方式就能表达常用字符</li></ul></li></ul></li><li><p>ch3.5.3UTF-8</p><ul><li><p>UTF8是一个将Unicode码点编码为字节序列的变长编码。</p></li><li><p>UTF8编码是由Go语言之父Ken Thompson和Rob Pike共同发明的，现在已经是Unicode的标准。</p></li><li><p>UTF8编码使用1到4个字节来表示每个Unicode码点，ASCII部分字符只使用1个字节，常用字符部分使用2或3个字节表示。</p></li><li><p>每个符号编码后第一个字节的高端bit位用于表示编码总共有多少个字节。</p><ul><li><p>如果第一个字节的高端bit为0，则表示对应7bit的ASCII字符，ASCII字符每个字符依然是一个字节，和传统的ASCII编码兼容。</p></li><li><p>如果第一个字节的高端bit是110，则说明需要2个字节</p></li><li><p>后续的每个高端bit都以10开头。更大的Unicode码点也是采用类似的策略处理</p><pre><code class="hljs angelscript"><span class="hljs-number">0</span>xxxxxxx                             runes <span class="hljs-number">0</span><span class="hljs-number">-127</span>    (ASCII)<span class="hljs-number">110</span>xxxxx <span class="hljs-number">10</span>xxxxxx                    <span class="hljs-number">128</span><span class="hljs-number">-2047</span>       (values &lt;<span class="hljs-number">128</span> unused)<span class="hljs-number">1110</span>xxxx <span class="hljs-number">10</span>xxxxxx <span class="hljs-number">10</span>xxxxxx           <span class="hljs-number">2048</span><span class="hljs-number">-65535</span>     (values &lt;<span class="hljs-number">2048</span> unused)<span class="hljs-number">11110</span>xxx <span class="hljs-number">10</span>xxxxxx <span class="hljs-number">10</span>xxxxxx <span class="hljs-number">10</span>xxxxxx  <span class="hljs-number">65536</span><span class="hljs-number">-0x10ffff</span> (other values unused)</code></pre></li></ul></li><li><p>变长的编码无法直接通过索引来访问第n个字符，但是UTF8编码获得了很多额外的优点。</p><ul><li><p>首先UTF8编码比较紧凑，完全兼容ASCII码，并且可以自动同步</p><ul><li><p>它可以通过向前回朔最多3个字节就能确定当前字符编码的开始字节的位置。</p></li><li><p>它也是一个前缀编码，所以当从左向右解码时不会有任何歧义也并不需要向前查看</p><ul><li>像GBK之类的编码，如果不知道起点位置则可能会出现歧义</li></ul></li></ul></li><li><p>没有任何字符的编码是其它字符编码的子串，或是其它编码序列的字串，因此搜索一个字符时只要搜索它的字节编码序列即可，不用担心前后的上下文会对搜索结果产生干扰</p></li><li><p>同时UTF8编码的顺序和Unicode码点的顺序一致，因此可以直接排序UTF8编码序列。</p></li><li><p>同时因为没有嵌入的NUL(0)字节，可以很好地兼容那些使用NUL作为字符串结尾的编程语言。</p></li></ul></li><li><p>Go语言的源文件采用UTF8编码，并且Go语言处理UTF8编码的文本也很出色。</p><ul><li><p>unicode包提供了诸多处理rune字符相关功能的函数</p><ul><li>比如区分字母和数字，或者是字母的大写和小写转换等）</li></ul></li><li><p>unicode/utf8包则提供了用于rune字符序列的UTF8编码和解码的功能</p></li></ul></li><li><p>有很多Unicode字符很难直接从键盘输入，并且还有很多字符有着相似的结构；有一些甚至是不可见的字符</p><ul><li><p>中文和日文就有很多相似但不同的字</p></li><li><p>Go语言字符串面值中的Unicode转义字符让我们可以通过Unicode码点输入特殊的字符</p><ul><li><p>有两种形式：<code>\uhhhh</code>对应16bit的码点值</p></li><li><p><code>\Uhhhhhhhh</code>对应32bit的码点值，其中h是一个十六进制数字</p></li><li><p>一般很少需要使用32bit的形式。</p></li><li><p>每一个对应码点的UTF8编码</p></li><li><p>下面的字母串面值都表示相同的值</p><pre><code class="hljs taggerscript">&quot;世界&quot;&quot;<span class="hljs-symbol">\x</span>e4<span class="hljs-symbol">\x</span>b8<span class="hljs-symbol">\x</span>96<span class="hljs-symbol">\x</span>e7<span class="hljs-symbol">\x</span>95<span class="hljs-symbol">\x</span>8c&quot;&quot;<span class="hljs-symbol">\u</span>4e16<span class="hljs-symbol">\u</span>754c&quot;&quot;<span class="hljs-symbol">\U</span>00004e16<span class="hljs-symbol">\U</span>0000754c&quot;</code></pre><ul><li>上面三个转义序列都为第一个字符串提供替代写法，但是它们的值都是相同的。</li></ul></li><li><p>Unicode转义也可以使用在rune字符中。</p><ul><li><p>下面三个字符是等价的</p><pre><code class="hljs 1c">&#x27;世&#x27; &#x27;\u4e16&#x27; &#x27;\U<span class="hljs-number">0000</span>4e16&#x27;</code></pre></li></ul></li></ul></li><li><p>对于小于256的码点值可以写在一个十六进制转义字节中</p><ul><li>例如<code>\x41</code>对应字符’A’，但是对于更大的码点则必须使用<code>\u</code>或<code>\U</code>转义形式。</li><li>因此，<code>\xe4\xb8\x96</code>并不是一个合法的rune字符，虽然这三个字节对应一个有效的UTF8编码的码点。</li></ul></li></ul></li><li><p>得益于UTF8编码优良的设计，诸多字符串操作都不需要解码操作。</p><ul><li><p>我们可以不用解码直接测试一个字符串是否是另一个字符串的前缀</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasPrefix</span><span class="hljs-params">(s, prefix <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s) &gt;= <span class="hljs-built_in">len</span>(prefix) &amp;&amp; s[:<span class="hljs-built_in">len</span>(prefix)] == prefix&#125;</code></pre></li><li><p>或者是后缀测试：</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasSuffix</span><span class="hljs-params">(s, suffix <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s) &gt;= <span class="hljs-built_in">len</span>(suffix) &amp;&amp; s[<span class="hljs-built_in">len</span>(s)-<span class="hljs-built_in">len</span>(suffix):] == suffix&#125;</code></pre></li><li><p>或者是包含子串测试</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(s, substr <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); i++ &#123;<span class="hljs-keyword">if</span> HasPrefix(s[i:], substr) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;</code></pre></li></ul></li><li><p>对于UTF8编码后文本的处理和原始的字节处理逻辑是一样的。</p><ul><li>但是对应很多其它编码则并不是这样的。</li><li>上面的函数都来自strings字符串处理包，真实的代码包含了一个用哈希技术优化的Contains 实现。</li></ul></li><li><p>如果我们真的关心每个Unicode字符，我们可以使用其它处理方式。</p><ul><li><p>考虑前面的第一个例子中的字符串，它混合了中西两种字符。字符串包含13个字节，以UTF8形式编码，但是只对应9个Unicode字符</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;unicode/utf8&quot;</span>s := <span class="hljs-string">&quot;Hello, 世界&quot;</span>fmt.Println(<span class="hljs-built_in">len</span>(s))                    <span class="hljs-comment">// &quot;13&quot;</span>fmt.Println(utf8.RuneCountInString(s)) <span class="hljs-comment">// &quot;9&quot;</span></code></pre></li><li><p>为了处理这些真实的字符，我们需要一个UTF8解码器。,unicode/utf8包提供了该功能，我们可以这样使用</p><pre><code class="hljs Go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(s); &#123;r, size := utf8.DecodeRuneInString(s[i:])fmt.Printf(<span class="hljs-string">&quot;%d\t%c\n&quot;</span>, i, r)i += size&#125;</code></pre><ul><li>每一次调用DecodeRuneInString函数都返回一个r和长度，r对应字符本身，长度对应r采用UTF8编码后的编码字节数目。</li><li>长度可以用于更新第i个字符在字符串中的字节索引位置。</li><li>但是这种编码方式是笨拙的，我们需要更简洁的语法</li><li>Go语言的range循环在处理字符串的时候，会自动隐式解码UTF8字符串。</li><li>对于非ASCII，索引更新的步长将超过1个字节</li></ul></li></ul></li><li><p>每一个UTF8字符解码，不管是显式地调用utf8.DecodeRuneInString解码或是在range循环中隐式地解码，如果遇到一个错误的UTF8编码输入，将生成一个特别的Unicode字符<code>\uFFFD</code>，在印刷中这个符号通常是一个黑色六角或钻石形状，里面包含一个白色的问号”?”。当程序遇到这样的一个字符，通常是一个危险信号，说明输入并不是一个完美没有错误的UTF8字符串。</p></li><li><p>UTF8字符串作为交换格式是非常方便的，但是在程序内部采用rune序列可能更方便，因为rune大小一致，支持数组索引和方便切割。</p><ul><li><p>将[]rune类型转换应用到UTF8编码的字符串，将返回字符串编码的Unicode码点序列</p><pre><code class="hljs Go"><span class="hljs-comment">// &quot;program&quot; in Japanese katakana</span>s := <span class="hljs-string">&quot;プログラム&quot;</span>fmt.Printf(<span class="hljs-string">&quot;% x\n&quot;</span>, s) <span class="hljs-comment">// &quot;e3 83 97 e3 83 ad e3 82 b0 e3 83 a9 e3 83 a0&quot;</span>r := []<span class="hljs-keyword">rune</span>(s)fmt.Printf(<span class="hljs-string">&quot;%x\n&quot;</span>, r)  <span class="hljs-comment">// &quot;[30d7 30ed 30b0 30e9 30e0]&quot;</span></code></pre><ul><li>在第一个Printf中的<code>% x</code>参数用于在每个十六进制数字前插入一个空格。</li></ul></li><li><p>如果是将一个[]rune类型的Unicode字符slice或数组转为string，则对它们进行UTF8编码</p><pre><code class="hljs Go">fmt.Println(<span class="hljs-keyword">string</span>(r)) <span class="hljs-comment">// &quot;プログラム&quot;</span></code></pre></li><li><p>将一个整数转型为字符串意思是生成以只包含对应Unicode码点字符的UTF8字符串</p><pre><code class="hljs Go">fmt.Println(<span class="hljs-keyword">string</span>(<span class="hljs-number">65</span>))     <span class="hljs-comment">// &quot;A&quot;, not &quot;65&quot;</span>fmt.Println(<span class="hljs-keyword">string</span>(<span class="hljs-number">0x4eac</span>)) <span class="hljs-comment">// &quot;京&quot;</span></code></pre></li><li><p>如果对应码点的字符是无效的，则用<code>\uFFFD</code>无效字符作为替换</p><pre><code class="hljs Go">fmt.Println(<span class="hljs-keyword">string</span>(<span class="hljs-number">1234567</span>)) <span class="hljs-comment">// &quot;?&quot;</span></code></pre></li></ul></li></ul></li><li><p>ch3.5.4字符串和Byte切片</p><ul><li><p>标准库中有四个包对字符串处理尤为重要：bytes、strings、strconv和unicode包。</p><ul><li><p>strings包提供了许多如字符串的查询、替换、比较、截断、拆分和合并等功能。</p></li><li><p>bytes包也提供了很多类似功能的函数，但是针对和字符串有着相同结构的[]byte类型。</p><ul><li>因为字符串是只读的，因此逐步构建字符串会导致很多分配和复制。在这种情况下，使用bytes.Buffer类型将会更有效，稍后我们将展示。</li></ul></li><li><p>strconv包提供了布尔型、整型数、浮点数和对应字符串的相互转换，还提供了双引号转义相关的转换。</p></li><li><p>unicode包提供了IsDigit、IsLetter、IsUpper和IsLower等类似功能，它们用于给字符分类。</p><ul><li>每个函数有一个单一的rune类型的参数，然后返回一个布尔值。</li><li>而像ToUpper和ToLower之类的转换函数将用于rune字符的大小写转换。</li><li>所有的这些函数都是遵循Unicode标准定义的字母、数字等分类规范。</li><li>strings包也有类似的函数，它们是ToUpper和ToLower，将原始字符串的每个字符都做相应的转换，然后返回新的字符串。</li></ul></li><li><p>下面例子的basename函数灵感源于Unix shell的同名工具。在我们实现的版本中，basename(s)将看起来像是系统路径的前缀删除，同时将看似文件类型的后缀名部分删除</p><pre><code class="hljs Go">fmt.Println(basename(<span class="hljs-string">&quot;a/b/c.go&quot;</span>)) <span class="hljs-comment">// &quot;c&quot;</span>fmt.Println(basename(<span class="hljs-string">&quot;c.d.go&quot;</span>))   <span class="hljs-comment">// &quot;c.d&quot;</span>fmt.Println(basename(<span class="hljs-string">&quot;abc&quot;</span>))      <span class="hljs-comment">// &quot;abc&quot;</span></code></pre><ul><li><p>第一个版本并没有使用任何库，全部手工硬编码实现</p><pre><code class="hljs Go"><span class="hljs-comment">// basename removes directory components and a .suffix.</span><span class="hljs-comment">// e.g., a =&gt; a, a.go =&gt; a, a/b/c.go =&gt; c, a/b.c.go =&gt; b.c</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">basename</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-comment">// Discard last &#x27;/&#x27; and everything before.</span><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;/&#x27;</span> &#123;s = s[i+<span class="hljs-number">1</span>:]<span class="hljs-keyword">break</span>&#125;&#125;<span class="hljs-comment">// Preserve everything before last &#x27;.&#x27;.</span><span class="hljs-keyword">for</span> i := <span class="hljs-built_in">len</span>(s) - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i-- &#123;<span class="hljs-keyword">if</span> s[i] == <span class="hljs-string">&#x27;.&#x27;</span> &#123;s = s[:i]<span class="hljs-keyword">break</span>&#125;&#125;<span class="hljs-keyword">return</span> s&#125;</code></pre></li><li><p>这个简化版本使用了strings.LastIndex库函数</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">basename</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123; slash := strings.LastIndex(s, <span class="hljs-string">&quot;/&quot;</span>) <span class="hljs-comment">// -1 if &quot;/&quot; not found</span> s = s[slash+<span class="hljs-number">1</span>:] <span class="hljs-keyword">if</span> dot := strings.LastIndex(s, <span class="hljs-string">&quot;.&quot;</span>); dot &gt;= <span class="hljs-number">0</span> &#123; s = s[:dot] &#125; <span class="hljs-keyword">return</span> s&#125;</code></pre></li><li><p>path和path/filepath包提供了关于文件路径名更一般的函数操作。</p><ul><li><p>使用斜杠分隔路径可以在任何操作系统上工作。</p><ul><li>斜杠本身不应该用于文件名，但是在其他一些领域可能会用于文件名，例如URL路径组件。相比之下，path/filepath包则使用操作系统本身的路径规则，例如POSIX系统使用/foo/bar，而Microsoft Windows使用<code>c:\foo\bar</code>等。</li></ul></li></ul></li><li><p>函数的功能是将一个表示整数值的字符串，每隔三个字符插入一个逗号分隔符，例如“12345”处理后成为“12,345”。这个版本只适用于整数类型</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// comma inserts commas in a non-negative decimal integer string.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">comma</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;n := <span class="hljs-built_in">len</span>(s)<span class="hljs-keyword">if</span> n &lt;= <span class="hljs-number">3</span> &#123;<span class="hljs-keyword">return</span> s&#125;<span class="hljs-keyword">return</span> comma(s[:n<span class="hljs-number">-3</span>]) + <span class="hljs-string">&quot;,&quot;</span> + s[n<span class="hljs-number">-3</span>:]&#125;</code></pre><ul><li>输入comma函数的参数是一个字符串。</li><li>如果输入字符串的长度小于或等于3的话，则不需要插入逗号分隔符。否则，comma函数将在最后三个字符前的位置将字符串切割为两个子串并插入逗号分隔符，然后通过递归调用自身来得出前面的子串。</li></ul></li></ul></li><li><p>一个字符串是包含只读字节的数组，一旦创建，是不可变的。相比之下，一个字节slice的元素则可以自由地修改。</p><ul><li><p>字符串和字节slice之间可以相互转换</p><pre><code class="hljs Go">s := <span class="hljs-string">&quot;abc&quot;</span>b := []<span class="hljs-keyword">byte</span>(s)s2 := <span class="hljs-keyword">string</span>(b)</code></pre><ul><li>从概念上讲，一个[]byte(s)转换是分配了一个新的字节数组用于保存字符串数据的拷贝，然后引用这个底层的字节数组。</li><li>编译器的优化可以避免在一些场景下分配和复制字符串数据，但总的来说需要确保在变量b被修改的情况下，原始的s字符串也不会改变。</li><li>将一个字节slice转换到字符串的string(b)操作则是构造一个字符串拷贝，以确保s2字符串是只读的。</li></ul></li></ul></li><li><p>为了避免转换中不必要的内存分配，bytes包和strings同时提供了许多实用函数。</p><ul><li><p>strings包中的六个函数：</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(s, substr <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Count</span><span class="hljs-params">(s, sep <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fields</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasPrefix</span><span class="hljs-params">(s, prefix <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Index</span><span class="hljs-params">(s, sep <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Join</span><span class="hljs-params">(a []<span class="hljs-keyword">string</span>, sep <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span></code></pre></li><li><p>bytes包中也对应的六个函数：</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(b, subslice []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">bool</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Count</span><span class="hljs-params">(s, sep []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">int</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fields</span><span class="hljs-params">(s []<span class="hljs-keyword">byte</span>)</span> [][]<span class="hljs-title">byte</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HasPrefix</span><span class="hljs-params">(s, prefix []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">bool</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Index</span><span class="hljs-params">(s, sep []<span class="hljs-keyword">byte</span>)</span> <span class="hljs-title">int</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Join</span><span class="hljs-params">(s [][]<span class="hljs-keyword">byte</span>, sep []<span class="hljs-keyword">byte</span>)</span> []<span class="hljs-title">byte</span></span></code></pre><ul><li><p>bytes包还提供了Buffer类型用于字节slice的缓存。</p><ul><li><p>一个Buffer开始是空的，但是随着string、byte或[]byte等类型数据的写入可以动态增长</p></li><li><p>一个bytes.Buffer变量并不需要初始化，因为零值也是有效的</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// intsToString is like fmt.Sprint(values) but adds commas.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">intsToString</span><span class="hljs-params">(values []<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">var</span> buf bytes.Bufferbuf.WriteByte(<span class="hljs-string">&#x27;[&#x27;</span>)<span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> values &#123;<span class="hljs-keyword">if</span> i &gt; <span class="hljs-number">0</span> &#123;buf.WriteString(<span class="hljs-string">&quot;, &quot;</span>)&#125;fmt.Fprintf(&amp;buf, <span class="hljs-string">&quot;%d&quot;</span>, v)&#125;buf.WriteByte(<span class="hljs-string">&#x27;]&#x27;</span>)<span class="hljs-keyword">return</span> buf.String()&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;fmt.Println(intsToString([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;)) <span class="hljs-comment">// &quot;[1, 2, 3]&quot;</span>&#125;</code></pre><ul><li>当向bytes.Buffer添加任意字符的UTF8编码时，最好使用bytes.Buffer的WriteRune方法，但是WriteByte方法对于写入类似’[‘和’]’等ASCII字符则会更加有效。</li><li>bytes.Buffer类型有着很多实用的功能，我们在第七章讨论接口时将会涉及到，我们将看看如何将它用作一个I/O的输入和输出对象，例如当做Fprintf的io.Writer输出对象，或者当作io.Reader类型的输入源对象。</li></ul></li></ul></li></ul></li><li><p>它们之间唯一的区别是字符串类型参数被替换成了字节slice类型的参数。</p></li></ul></li></ul></li></ul></li><li><p>ch3.5.5字符串和数字的转换</p><ul><li><p>除了字符串、字符、字节之间的转换，字符串和数值之间的转换也比较常见。由strconv包提供这类转换功能。</p><ul><li><p>将一个整数转为字符串，一种方法是用fmt.Sprintf返回一个格式化的字符串；另一个方法是用strconv.Itoa(“整数到ASCII”)</p><pre><code class="hljs Go">x := <span class="hljs-number">123</span>y := fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, x)fmt.Println(y, strconv.Itoa(x)) <span class="hljs-comment">// &quot;123 123&quot;</span></code></pre></li><li><p>FormatInt和FormatUint函数可以用不同的进制来格式化数字</p><pre><code class="hljs Go">fmt.Println(strconv.FormatInt(<span class="hljs-keyword">int64</span>(x), <span class="hljs-number">2</span>)) <span class="hljs-comment">// &quot;1111011&quot;</span></code></pre></li><li><p>fmt.Printf函数的%b、%d、%o和%x等参数提供功能往往比strconv包的Format函数方便很多，特别是在需要包含有附加额外信息的时候</p><pre><code class="hljs Go">s := fmt.Sprintf(<span class="hljs-string">&quot;x=%b&quot;</span>, x) <span class="hljs-comment">// &quot;x=1111011&quot;</span></code></pre></li></ul></li><li><p>如果要将一个字符串解析为整数，可以使用strconv包的Atoi或ParseInt函数，还有用于解析无符号整数的ParseUint函数</p><pre><code class="hljs Go">x, err := strconv.Atoi(<span class="hljs-string">&quot;123&quot;</span>)             <span class="hljs-comment">// x is an int</span>y, err := strconv.ParseInt(<span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>) <span class="hljs-comment">// base 10, up to 64 bits</span></code></pre><ul><li>ParseInt函数的第三个参数是用于指定整型数的大小；例如16表示int16，0则表示int。在任何情况下，返回的结果y总是int64类型，你可以通过强制类型转换将它转为更小的整数类型。</li></ul></li><li><p>有时候也会使用fmt.Scanf来解析输入的字符串和数字，特别是当字符串和数字混合在一行的时候，它可以灵活处理不完整或不规则的输入。</p></li></ul></li></ul><h3 id="ch3-6-常量"><a href="#ch3-6-常量" class="headerlink" title="ch3.6   常量"></a>ch3.6   常量</h3><ul><li><p>ch3.6.0简介</p><ul><li><p>常量表达式的值在编译期计算，而不是在运行期。</p></li><li><p>每种常量的潜在类型都是基础类型：boolean、string或数字。</p></li><li><p>一个常量的声明语句定义了常量的名字，和变量的声明语法类似，常量的值不可修改，这样可以防止在运行期被意外或恶意的修改</p><ul><li><p>例如，常量比变量更适合用于表达像Π之类的数字常数，因为它们的值不会发生变化。</p><pre><code class="hljs Go"><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.14159</span> <span class="hljs-comment">// approximately; math.Pi is a better approximation</span></code></pre></li><li><p>和声明变量一样，可以批量声明多个常量，者比较适合声明一组相关的常量</p><pre><code class="hljs Go"><span class="hljs-keyword">const</span> (e  = <span class="hljs-number">2.71828182845904523536028747135266249775724709369995957496696763</span>pi = <span class="hljs-number">3.14159265358979323846264338327950288419716939937510582097494459</span>)</code></pre></li></ul></li><li><p>所有常量的运算都可以在编译期完成，这样可以减少运行时的工作，也方便其他编译优化。当操作数是常量时，一些运行时的错误也可以在编译时被发现</p><ul><li>例如整数除零、字符串索引月结、任何导致无效浮点数的操作</li></ul></li><li><p>常量间的所有算术运算、比较运算、逻辑运算的结果也是常量，对常量的类型转换或者以下操作都是返回常量结果</p><ul><li><p>len、cap、real、imag、complex、unsafe.Sizeof</p></li><li><p>因为它们的值在编译期就是确定的，因此常量可以是构成类型的一部分</p><ul><li><p>例如用于指定数组类型的长度</p><pre><code class="hljs Go"><span class="hljs-keyword">const</span> IPv4Len = <span class="hljs-number">4</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseIPv4</span><span class="hljs-params">(s <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">IP</span></span>&#123;<span class="hljs-keyword">var</span> p [IPv4Len]<span class="hljs-keyword">byte</span>&#125;</code></pre></li></ul></li></ul></li><li><p>一个常量的声明可以包含一个类型和一个值，但是如果没有显示指明类型，那么将从右边的表达式推断类型。</p><ul><li><p>在下面的代码中，time.Duration是一个命名类型，底层类型是int64，time.Minute是对应类型的常量。下面声明的两个常量都是time.Duration类型，可以通过%T参数打印类型信息</p><pre><code class="hljs Go"><span class="hljs-keyword">const</span> noDelay time.Duration = <span class="hljs-number">0</span><span class="hljs-keyword">const</span> timeout = <span class="hljs-number">5</span> * time.Minutefmt.Printf(<span class="hljs-string">&quot;%T %[1]v\n&quot;</span>, noDelay)     <span class="hljs-comment">// &quot;time.Duration 0&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%T %[1]v\n&quot;</span>, timeout)     <span class="hljs-comment">// &quot;time.Duration 5m0s&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%T %[1]v\n&quot;</span>, time.Minute) <span class="hljs-comment">// &quot;time.Duration 1m0s&quot;</span></code></pre></li></ul></li><li><p>如果是批量声明的常量，除了第一个外其他的常量右边的表达式都可以省略，如果省略初始化表达式则表示使用前面常量的初始化表达式写法，对应的常量类型也一样的。</p><pre><code class="hljs Go"><span class="hljs-keyword">const</span> (a = <span class="hljs-number">1</span>bc = <span class="hljs-number">2</span>d)fmt.Println(a, b, c, d) <span class="hljs-comment">// &quot;1 1 2 2&quot;</span></code></pre></li><li><p>如果只是简单地赋值右边地常量表达式，其实并没有太实用地价值。但是它可以带来其它地特性，那就是iota常量生成器语法。</p></li></ul></li><li><p>ch3.6.1iota常量生成器</p><ul><li><p>常量声明可以使用iota常量生成器初始化，它用于生成一组具有相似规则初始化的常量，但是不用每一行都写一遍初始化表达式。在一个const声明语句中，在第一个声明的常量所在的行，iota将会被置0，然后在每一个有常量声明的行加一。</p><ul><li><p>下面是来自time包的例子，它首先定义了一个Weekday命名类型，然后为一周的每天定义了一个常量，从周日0开始。在其它编程语言中，这种类型一般被称为枚举类型。</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Weekday <span class="hljs-keyword">int</span><span class="hljs-keyword">const</span> (Sunday Weekday = <span class="hljs-literal">iota</span>MondayTuesdayWednesdayThursdayFridaySaturday)</code></pre><ul><li>周日将对应0，周一为1，如此等等。</li></ul></li><li><p>我们也可以在复杂的常量表达式中使用iota，下面是来自net包的例子，用于给一个无符号整数的最低5bit的每个bit指定一个名字</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Flags <span class="hljs-keyword">uint</span><span class="hljs-keyword">const</span> (FlagUp Flags = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// is up</span>FlagBroadcast            <span class="hljs-comment">// supports broadcast access capability</span>FlagLoopback             <span class="hljs-comment">// is a loopback interface</span>FlagPointToPoint         <span class="hljs-comment">// belongs to a point-to-point link</span>FlagMulticast            <span class="hljs-comment">// supports multicast access capability</span>)</code></pre></li><li><p>随着iota的递增，每个常量对应表达式1 &lt;&lt; iota，是连续的2的幂，分别对应一个bit位置。使用这些常量可以用于测试、设置或清除对应的bit位的值</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsUp</span><span class="hljs-params">(v Flags)</span> <span class="hljs-title">bool</span></span>     &#123; <span class="hljs-keyword">return</span> v&amp;FlagUp == FlagUp &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TurnDown</span><span class="hljs-params">(v *Flags)</span></span>     &#123; *v &amp;^= FlagUp &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SetBroadcast</span><span class="hljs-params">(v *Flags)</span></span> &#123; *v |= FlagBroadcast &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsCast</span><span class="hljs-params">(v Flags)</span> <span class="hljs-title">bool</span></span>   &#123; <span class="hljs-keyword">return</span> v&amp;(FlagBroadcast|FlagMulticast) != <span class="hljs-number">0</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> v Flags = FlagMulticast | FlagUpfmt.Printf(<span class="hljs-string">&quot;%b %t\n&quot;</span>, v, IsUp(v)) <span class="hljs-comment">// &quot;10001 true&quot;</span>TurnDown(&amp;v)fmt.Printf(<span class="hljs-string">&quot;%b %t\n&quot;</span>, v, IsUp(v)) <span class="hljs-comment">// &quot;10000 false&quot;</span>SetBroadcast(&amp;v)fmt.Printf(<span class="hljs-string">&quot;%b %t\n&quot;</span>, v, IsUp(v))   <span class="hljs-comment">// &quot;10010 false&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%b %t\n&quot;</span>, v, IsCast(v)) <span class="hljs-comment">// &quot;10010 true&quot;</span>&#125;</code></pre></li><li><p>下面是一个更复杂的例子，每个常量都是1024的幂</p><pre><code class="hljs Go"><span class="hljs-keyword">const</span> (_ = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)KiB <span class="hljs-comment">// 1024</span>MiB <span class="hljs-comment">// 1048576</span>GiB <span class="hljs-comment">// 1073741824</span>TiB <span class="hljs-comment">// 1099511627776             (exceeds 1 &lt;&lt; 32)</span>PiB <span class="hljs-comment">// 1125899906842624</span>EiB <span class="hljs-comment">// 1152921504606846976</span>ZiB <span class="hljs-comment">// 1180591620717411303424    (exceeds 1 &lt;&lt; 64)</span>YiB <span class="hljs-comment">// 1208925819614629174706176</span>)</code></pre></li></ul></li><li><p>不过iota常量生成规则也有其局限性。</p><ul><li>例如，它并不能用于产生1000的幂（KB、MB等），因为Go语言并没有计算幂的运算符</li></ul></li></ul></li><li><p>ch3.6.2无类型常量</p><ul><li><p>Go语言的常量有个不同寻常之处，虽然一个常量可以有任意一个确定的基础类型，例如int或float64，或者是类似time.Duration这样命名的基础类型，但是许多常量并没有一个明确的基础类型。</p><ul><li>编译器为这些没有明确基础类型的数字常量提供比基础类型更高精度的算术运算；你可以认为至少有256bit的运算精度。</li><li>这里有六种未明确类型的常量类型，分别是无类型的布尔型、无类型的整数、无类型的字符、无类型的浮点数、无类型的复数、无类型的字符串。</li></ul></li><li><p>通过延迟明确常量的具体类型，无类型的常量不仅可以提供更高的运算精度，而且可以直接用于更多的表达式而不需要显式的类型转换。</p><ul><li><p>例如，例子中的ZiB和YiB的值已经超出任何Go语言中整数类型能表达的范围，但是它们依然是合法的常量，而且像下面的常量表达式依然有效（译注：YiB/ZiB是在编译期计算出来的，并且结果常量是1024，是Go语言int变量能有效表示的）</p><pre><code class="hljs Go">fmt.Println(YiB/ZiB) <span class="hljs-comment">// &quot;1024&quot;</span></code></pre></li><li><p>另一个例子，math.Pi无类型的浮点数常量，可以直接用于任意需要浮点数或复数的地方</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">float32</span> = math.Pi<span class="hljs-keyword">var</span> y <span class="hljs-keyword">float64</span> = math.Pi<span class="hljs-keyword">var</span> z <span class="hljs-keyword">complex128</span> = math.Pi</code></pre></li><li><p>如果math.Pi被确定为特定类型，比如float64，那么结果精度可能会不一样，同时对于需要float32或complex128类型值的地方则会强制需要一个明确的类型转换</p><pre><code class="hljs Go"><span class="hljs-keyword">const</span> Pi64 <span class="hljs-keyword">float64</span> = math.Pi<span class="hljs-keyword">var</span> x <span class="hljs-keyword">float32</span> = <span class="hljs-keyword">float32</span>(Pi64)<span class="hljs-keyword">var</span> y <span class="hljs-keyword">float64</span> = Pi64<span class="hljs-keyword">var</span> z <span class="hljs-keyword">complex128</span> = <span class="hljs-keyword">complex128</span>(Pi64)</code></pre></li></ul></li><li><p>对于常量面值，不同的写法可能会对应不同的类型。例如0、0.0、0i和<code>\u0000</code>虽然有着相同的常量值，但是它们分别对应无类型的整数、无类型的浮点数、无类型的复数和无类型的字符等不同的常量类型。同样，true和false也是无类型的布尔类型，字符串面值常量是无类型的字符串类型。</p></li><li><p>前面说过除法运算符/会根据操作数的类型生成对应类型的结果。因此，不同写法的常量除法表达式可能对应不同的结果</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> f <span class="hljs-keyword">float64</span> = <span class="hljs-number">212</span>fmt.Println((f - <span class="hljs-number">32</span>) * <span class="hljs-number">5</span> / <span class="hljs-number">9</span>)     <span class="hljs-comment">// &quot;100&quot;; (f - 32) * 5 is a float64</span>fmt.Println(<span class="hljs-number">5</span> / <span class="hljs-number">9</span> * (f - <span class="hljs-number">32</span>))     <span class="hljs-comment">// &quot;0&quot;;   5/9 is an untyped integer, 0</span>fmt.Println(<span class="hljs-number">5.0</span> / <span class="hljs-number">9.0</span> * (f - <span class="hljs-number">32</span>)) <span class="hljs-comment">// &quot;100&quot;; 5.0/9.0 is an untyped float</span></code></pre></li><li><p>只有常量可以是无类型的。</p><ul><li><p>当一个无类型的常量被赋值给一个变量的时候，就像下面的第一行语句，或者出现在有明确类型的变量声明的右边，如下面的其余三行语句，无类型的常量将会被隐式转换为对应的类型，如果转换合法的话。</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> f <span class="hljs-keyword">float64</span> = <span class="hljs-number">3</span> + <span class="hljs-number">0i</span> <span class="hljs-comment">// untyped complex -&gt; float64</span>f = <span class="hljs-number">2</span>                  <span class="hljs-comment">// untyped integer -&gt; float64</span>f = <span class="hljs-number">1e123</span>              <span class="hljs-comment">// untyped floating-point -&gt; float64</span>f = <span class="hljs-string">&#x27;a&#x27;</span>                <span class="hljs-comment">// untyped rune -&gt; float64</span></code></pre><ul><li><p>上面的语句相当于</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> f <span class="hljs-keyword">float64</span> = <span class="hljs-keyword">float64</span>(<span class="hljs-number">3</span> + <span class="hljs-number">0i</span>)f = <span class="hljs-keyword">float64</span>(<span class="hljs-number">2</span>)f = <span class="hljs-keyword">float64</span>(<span class="hljs-number">1e123</span>)f = <span class="hljs-keyword">float64</span>(<span class="hljs-string">&#x27;a&#x27;</span>)</code></pre></li></ul></li><li><p>无论是隐式或显式转换，将一种类型转换为另一种类型都要求目标可以表示原始值。对于浮点数和复数，可能会有舍入处理</p><pre><code class="hljs Go"><span class="hljs-keyword">const</span> (deadbeef = <span class="hljs-number">0xdeadbeef</span> <span class="hljs-comment">// untyped int with value 3735928559</span>a = <span class="hljs-keyword">uint32</span>(deadbeef)  <span class="hljs-comment">// uint32 with value 3735928559</span>b = <span class="hljs-keyword">float32</span>(deadbeef) <span class="hljs-comment">// float32 with value 3735928576 (rounded up)</span>c = <span class="hljs-keyword">float64</span>(deadbeef) <span class="hljs-comment">// float64 with value 3735928559 (exact)</span>d = <span class="hljs-keyword">int32</span>(deadbeef)   <span class="hljs-comment">// compile error: constant overflows int32</span>e = <span class="hljs-keyword">float64</span>(<span class="hljs-number">1e309</span>)    <span class="hljs-comment">// compile error: constant overflows float64</span>f = <span class="hljs-keyword">uint</span>(<span class="hljs-number">-1</span>)          <span class="hljs-comment">// compile error: constant underflows uint</span>)</code></pre></li><li><p>对于一个没有显式类型的变量声明（包括简短变量声明），常量的形式将隐式决定变量的默认类型</p><pre><code class="hljs Go">i := <span class="hljs-number">0</span>      <span class="hljs-comment">// untyped integer;        implicit int(0)</span>r := <span class="hljs-string">&#x27;\000&#x27;</span> <span class="hljs-comment">// untyped rune;           implicit rune(&#x27;\000&#x27;)</span>f := <span class="hljs-number">0.0</span>    <span class="hljs-comment">// untyped floating-point; implicit float64(0.0)</span>c := <span class="hljs-number">0i</span>     <span class="hljs-comment">// untyped complex;        implicit complex128(0i)</span></code></pre></li><li><p>注意有一点不同：无类型整数常量转换为int，它的内存大小是不确定的，但是无类型浮点数和复数常量则转换为内存大小明确的float64和complex128。</p></li><li><p>如果不知道浮点数类型的内存大小是很难写出正确的数值算法的，因此Go语言不存在整型类似的不确定内存大小的浮点数和复数类型。</p><ul><li><p>如果要给变量一个不同的类型，我们必须显式地将无类型的常量转化为所需的类型，或给声明的变量指定明确的类型</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> i = <span class="hljs-keyword">int8</span>(<span class="hljs-number">0</span>)<span class="hljs-keyword">var</span> i <span class="hljs-keyword">int8</span> = <span class="hljs-number">0</span></code></pre></li><li><p>当尝试将这些无类型的常量转为一个接口值时（见第7章），这些默认类型将显得尤为重要，因为要靠它们明确接口对应的动态类型。</p><pre><code class="hljs Go">fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-number">0</span>)      <span class="hljs-comment">// &quot;int&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-number">0.0</span>)    <span class="hljs-comment">// &quot;float64&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-number">0i</span>)     <span class="hljs-comment">// &quot;complex128&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, <span class="hljs-string">&#x27;\000&#x27;</span>) <span class="hljs-comment">// &quot;int32&quot; (rune)</span></code></pre></li></ul></li></ul></li></ul></li></ul><h2 id="ch4-复合数据类型"><a href="#ch4-复合数据类型" class="headerlink" title="ch4  复合数据类型"></a>ch4  复合数据类型</h2><h3 id="ch4-0-简介"><a href="#ch4-0-简介" class="headerlink" title="ch4.0   简介"></a>ch4.0   简介</h3><ul><li><p>复合数据类型，它是以不同的方式组合基本类型而构造出来的复合数据类型。我们主要讨论四种类型——数组、slice、map和结构体——同时在本章的最后，我们将演示如何使用结构体来解码和编码到对应JSON格式的数据，并且通过结合使用模板来生成HTML页面。</p></li><li><p>数组和结构体是聚合类型；它们的值由许多元素或成员字段的值组成。</p><ul><li>数组是由同构的元素组成——每个数组元素都是完全相同的类型——结构体则是由异构的元素组成的。数组和结构体都是有固定内存大小的数据结构。</li></ul></li><li><p>相比之下，slice和map则是动态的数据结构，它们将根据需要动态增长。</p></li></ul><h3 id="ch4-1-数组"><a href="#ch4-1-数组" class="headerlink" title="ch4.1   数组"></a>ch4.1   数组</h3><ul><li><p>数组是一个由固定长度的特定类型元素组成的序列，一个数组可以由零个或多个元素组成。因为数组的长度是固定的，因此在Go语言中很少直接使用数组。和数组对应的类型是Slice（切片），它是可以增长和收缩的动态序列，slice功能也更灵活，但是要理解slice工作原理的话需要先理解数组。</p></li><li><p>数组的每个元素可以通过索引下标来访问，索引下标的范围是从0开始到数组长度减1的位置。内置的len函数将返回数组中元素的个数。</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> a [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>             <span class="hljs-comment">// array of 3 integers</span>fmt.Println(a[<span class="hljs-number">0</span>])        <span class="hljs-comment">// print the first element</span>fmt.Println(a[<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-1</span>]) <span class="hljs-comment">// print the last element, a[2]</span><span class="hljs-comment">// Print the indices and elements.</span><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> a &#123;fmt.Printf(<span class="hljs-string">&quot;%d %d\n&quot;</span>, i, v)&#125;<span class="hljs-comment">// Print the elements only.</span><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> a &#123;fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, v)&#125;</code></pre></li><li><p>默认情况下，数组的每个元素都被初始化为元素类型对应的零值，对于数字类型来说就是0。我们也可以使用数组字面值语法用一组值来初始化数组</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> q [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span> = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<span class="hljs-keyword">var</span> r [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span> = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;fmt.Println(r[<span class="hljs-number">2</span>]) <span class="hljs-comment">// &quot;0&quot;</span></code></pre><ul><li><p>在数组字面值中，如果在数组的长度位置出现的是“…”省略号，则表示数组的长度是根据初始化值的个数来计算。因此，上面q数组的定义可以简化为</p><pre><code class="hljs Go">q := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, q) <span class="hljs-comment">// &quot;[3]int&quot;</span></code></pre></li></ul></li><li><p>数组的长度是数组类型的一个组成部分，因此[3]int和[4]int是两种不同的数组类型。</p><ul><li><p>数组的长度必须是常量表达式，因为数组的长度需要在编译阶段确定。</p><pre><code class="hljs Go">q := [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;q = [<span class="hljs-number">4</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125; <span class="hljs-comment">// compile error: cannot assign [4]int to [3]int</span></code></pre></li></ul></li><li><p>我们将会发现，数组、slice、map和结构体字面值的写法都很相似。上面的形式是直接提供顺序初始化值序列，但是也可以指定一个索引和对应值列表的方式初始化，就像下面这样</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Currency <span class="hljs-keyword">int</span><span class="hljs-keyword">const</span> (USD Currency = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 美元</span>EUR                 <span class="hljs-comment">// 欧元</span>GBP                 <span class="hljs-comment">// 英镑</span>RMB                 <span class="hljs-comment">// 人民币</span>)symbol := [...]<span class="hljs-keyword">string</span>&#123;USD: <span class="hljs-string">&quot;$&quot;</span>, EUR: <span class="hljs-string">&quot;€&quot;</span>, GBP: <span class="hljs-string">&quot;￡&quot;</span>, RMB: <span class="hljs-string">&quot;￥&quot;</span>&#125;fmt.Println(RMB, symbol[RMB]) <span class="hljs-comment">// &quot;3 ￥&quot;</span></code></pre><ul><li><p>在这种形式的数组字面值形式中，初始化索引的顺序是无关紧要的，而且没用到的索引可以省略，和前面提到的规则一样，未指定初始值的元素将用零值初始化。</p><pre><code class="hljs Go">r := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">99</span>: <span class="hljs-number">-1</span>&#125;</code></pre><ul><li>定义了一个含有100个元素的数组r，最后一个元素被初始化为-1，其它元素都是用0初始化。</li></ul></li></ul></li><li><p>如果一个数组的元素类型是可以相互比较的，那么数组类型也是可以相互比较的，这时候我们可以直接通过==比较运算符来比较两个数组，只有当两个数组的所有元素都是相等的时候数组才是相等的。不相等比较运算符!=遵循同样的规则</p><pre><code class="hljs Go">a := [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;b := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;c := [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">3</span>&#125;fmt.Println(a == b, a == c, b == c) <span class="hljs-comment">// &quot;true false false&quot;</span>d := [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;fmt.Println(a == d) <span class="hljs-comment">// compile error: cannot compare [2]int == [3]int</span></code></pre></li><li><p>crypto/sha256包的Sum256函数对一个任意的字节slice类型的数据生成一个对应的消息摘要。消息摘要有256bit大小，因此对应[32]byte数组类型。</p><ul><li><p>如果两个消息摘要是相同的，那么可以认为两个消息本身也是相同（译注：理论上有HASH码碰撞的情况，但是实际应用可以基本忽略）</p></li><li><p>如果消息摘要不同，那么消息本身必然也是不同的。</p></li><li><p>下面的例子用SHA256算法分别生成“x”和“X”两个信息的摘要</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;crypto/sha256&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;c1 := sha256.Sum256([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;x&quot;</span>))c2 := sha256.Sum256([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;X&quot;</span>))fmt.Printf(<span class="hljs-string">&quot;%x\n%x\n%t\n%T\n&quot;</span>, c1, c2, c1 == c2, c1)<span class="hljs-comment">// Output:</span><span class="hljs-comment">// 2d711642b726b04401627ca9fbac32f5c8530fb1903cc4db02258717921a4881</span><span class="hljs-comment">// 4b68ab3847feda7d6c62c1fbcbeebfa35eab7351ed5e78f4ddadea5df64b8015</span><span class="hljs-comment">// false</span><span class="hljs-comment">// [32]uint8</span>&#125;</code></pre><ul><li>上面例子中，两个消息虽然只有一个字符的差异，但是生成的消息摘要则几乎有一半的bit位是不相同的。</li><li>需要注意Printf函数的%x副词参数，它用于指定以十六进制的格式打印数组或slice全部的元素</li><li>%t副词参数是用于打印布尔型数据</li><li>%T副词参数是用于显示一个值对应的数据类型</li></ul></li></ul></li><li><p>当调用一个函数的时候，函数的每个调用参数将会被赋值给函数内部的参数变量，所以函数参数变量接收的是一个复制的副本，并不是原始调用的变量。</p><ul><li><p>因为函数参数传递的机制导致传递大的数组类型将是低效的，并且对数组参数的任何的修改都是发生在复制的数组上，并不能直接修改调用时原始的数组变量。</p></li><li><p>在这个方面，Go语言对待数组的方式和其它很多编程语言不同，其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数。</p></li><li><p>当然，我们可以显式地传入一个数组指针，那样的话函数通过指针对数组的任何修改都可以直接反馈到调用者。下面的函数用于给[32]byte类型的数组清零</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zero</span><span class="hljs-params">(ptr *[32]<span class="hljs-keyword">byte</span>)</span></span> &#123;<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ptr &#123;ptr[i] = <span class="hljs-number">0</span>&#125;&#125;</code></pre><ul><li><p>其实数组字面值[32]byte{}就可以生成一个32字节的数组。而且每个数组的元素都是零值初始化，也就是0。因此，我们可以将上面的zero函数写的更简洁一点</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zero</span><span class="hljs-params">(ptr *[32]<span class="hljs-keyword">byte</span>)</span></span> &#123;*ptr = [<span class="hljs-number">32</span>]<span class="hljs-keyword">byte</span>&#123;&#125;&#125;</code></pre></li><li><p>虽然通过指针来传递数组参数是高效的，而且也允许在函数内部修改数组的值，但是数组依然是僵化的类型，因为数组的类型包含了僵化的长度信息。</p><ul><li>上面的zero函数并不能接收指向[16]byte类型数组的指针，而且也没有任何添加或删除数组元素的方法。</li><li>由于这些原因，除了像SHA256这类需要处理特定大小数组的特例外，数组依然很少用作函数参数；相反，我们一般使用slice来替代数组。</li></ul></li></ul></li></ul></li></ul><h3 id="ch4-2-Slice"><a href="#ch4-2-Slice" class="headerlink" title="ch4.2   Slice"></a>ch4.2   Slice</h3><ul><li><p>ch4.2.0简介</p><ul><li><p>Slice（切片）代表变长的序列，序列中每个元素都有相同的类型。一个slice类型一般写作[]T，其中T代表slice中元素的类型；slice的语法和数组很像，只是没有固定长度而已。</p></li><li><p>数组和slice之间有着紧密的联系。</p><ul><li><p>一个slice是一个轻量级的数据结构，提供了访问数组子序列（或者全部）元素的功能，而且slice的底层确实引用一个数组对象。</p></li><li><p>一个slice由三个部分构成：指针、长度和容量。</p><ul><li>指针指向第一个slice元素对应的底层数组元素的地址，要注意的是slice的第一个元素并不一定就是数组的第一个元素。</li><li>长度对应slice中元素的数目</li><li>长度不能超过容量，容量一般是从slice的开始位置到底层数据的结尾位置</li><li>内置的len和cap函数分别返回slice的长度和容量</li></ul></li></ul></li><li><p>多个slice之间可以共享底层的数据，并且引用的数组部分区间可能重叠。</p><ul><li>通常，数组的第一个元素从索引0开始，但是月份一般是从1开始的，因此我们声明数组时直接跳过第0个元素，第0个元素会被自动初始化为空字符串。</li></ul></li><li><p>slice的切片操作s[i:j]，其中0 ≤ i≤ j≤ cap(s)，用于创建一个新的slice，引用s的从第i个元素开始到第j-1个元素的子序列。</p><ul><li>新的slice将只有j-i个元素。如果i位置的索引被省略的话将使用0代替，如果j位置的索引被省略的话将使用len(s)代替。</li><li>因此，months[1:13]切片操作将引用全部有效的月份，和months[1:]操作等价；months[:]切片操作则是引用整个数组。</li></ul></li><li><p>如果切片操作超出cap(s)的上限将导致一个panic异常，但是超出len(s)则是意味着扩展了slice，因为新slice的长度会变大</p><pre><code class="hljs Go">fmt.Println(summer[:<span class="hljs-number">20</span>]) <span class="hljs-comment">// panic: out of range</span>endlessSummer := summer[:<span class="hljs-number">5</span>] <span class="hljs-comment">// extend a slice (within capacity)</span>fmt.Println(endlessSummer) <span class="hljs-comment">// &quot;[June July August September October]&quot;</span></code></pre></li><li><p>字符串的切片操作和[]byte字节类型切片的切片操作是类似的。都写作x[m:n]，并且都是返回一个原始字节序列的子序列，底层都是共享之前的底层数组，因此这种操作都是常量时间复杂度。</p><ul><li>x[m:n]切片操作对于字符串则生成一个新字符串，如果x是[]byte的话则生成一个新的[]byte</li></ul></li><li><p>因为slice值包含指向第一个slice元素的指针，因此向函数传递slice将允许在函数内部修改底层数组的元素。</p><ul><li><p>换句话说，复制一个slice只是对底层的数组创建了一个新的slice别名</p></li><li><p>下面的reverse函数在原内存空间将[]int类型的slice反转，而且它可以用于任意长度的slice</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// reverse reverses a slice of ints in place.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reverse</span><span class="hljs-params">(s []<span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">for</span> i, j := <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s)<span class="hljs-number">-1</span>; i &lt; j; i, j = i+<span class="hljs-number">1</span>, j<span class="hljs-number">-1</span> &#123;s[i], s[j] = s[j], s[i]&#125;&#125;</code></pre></li><li><p>这里我们反转数组的应用</p><pre><code class="hljs Go">a := [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;reverse(a[:])fmt.Println(a) <span class="hljs-comment">// &quot;[5 4 3 2 1 0]&quot;</span></code></pre></li><li><p>一种将slice元素循环向左旋转n个元素的方法是三次调用reverse反转函数</p><pre><code class="hljs Go">s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<span class="hljs-comment">// Rotate s left by two positions.</span>reverse(s[:<span class="hljs-number">2</span>])reverse(s[<span class="hljs-number">2</span>:])reverse(s)fmt.Println(s) <span class="hljs-comment">// &quot;[2 3 4 5 0 1]&quot;</span></code></pre><ul><li>第一次是反转开头的n个元素，然后是反转剩下的元素，最后是反转整个slice的元素。</li><li>如果是向右循环旋转，则将第三个函数调用移到第一个调用位置就可以了</li></ul></li></ul></li><li><p>要注意的是slice类型的变量s和数组类型的变量a的初始化语法的差异。</p><ul><li><p>slice和数组的字面值语法很类似，它们都是用花括弧包含一系列的初始化元素，但是对于slice并没有指明序列的长度。</p><ul><li>这会隐式地创建一个合适大小的数组，然后slice的指针指向底层的数组。就像数组字面值一样，slice的字面值也可以按顺序指定初始化值序列，或者是通过索引和元素值指定，或者用两种风格的混合语法初始化。</li></ul></li></ul></li><li><p>和数组不同的是，slice之间不能比较，因此我们不能使用==操作符来判断两个slice是否含有全部相等元素。</p><ul><li><p>。不过标准库提供了高度优化的bytes.Equal函数来判断两个字节型slice是否相等（[]byte），但是对于其他类型的slice，我们必须自己展开每个元素进行比较</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">equal</span><span class="hljs-params">(x, y []<span class="hljs-keyword">string</span>)</span> <span class="hljs-title">bool</span></span> &#123;<span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(x) != <span class="hljs-built_in">len</span>(y) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;<span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> x &#123;<span class="hljs-keyword">if</span> x[i] != y[i] &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>&#125;&#125;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>&#125;</code></pre></li><li><p>上面关于两个slice的深度相等测试，运行的时间并不比支持==操作的数组或字符串更多，但是为何slice不直接支持比较运算符呢</p><ul><li><p>第一个原因，一个slice的元素是间接引用的，一个slice甚至可以包含自身（译注：当slice声明为[]interface{}时，slice的元素可以是自身）。虽然有很多办法处理这种情形，但是没有一个是简单有效的。</p></li><li><p>第二个原因，因为slice的元素是间接引用的，一个固定的slice值（译注：指slice本身的值，不是元素的值）在不同的时刻可能包含不同的元素，因为底层数组的元素可能会被修改</p></li><li><p>例如Go语言中map的key只做简单的浅拷贝，它要求key在整个生命周期内保持不变性（译注：例如slice扩容，就会导致其本身的值/地址变化）。</p></li><li><p>而用深度相等判断的话，显然在map的key这种场合不合适。对于像指针或chan之类的引用类型，==相等测试可以判断两个是否是引用相同的对象。一个针对slice的浅相等测试的==操作符可能是有一定用处的，也能临时解决map类型的key问题，但是slice和数组不同的相等测试行为会让人困惑。因此，安全的做法是直接禁止slice之间的比较操作。</p><ul><li><p>slice唯一合法的比较操作是和nil比较，例如</p><pre><code class="hljs Go"><span class="hljs-keyword">if</span> summer == <span class="hljs-literal">nil</span> &#123; <span class="hljs-comment">/* ... */</span> &#125;</code></pre></li></ul></li></ul></li></ul></li><li><p>一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如[]int{}或make([]int, 3)[3:]。与任意类型的nil值一样，我们可以用[]int(nil)类型转换表达式来生成一个对应类型slice的nil值。</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> s []<span class="hljs-keyword">int</span>    <span class="hljs-comment">// len(s) == 0, s == nil</span>s = <span class="hljs-literal">nil</span>        <span class="hljs-comment">// len(s) == 0, s == nil</span>s = []<span class="hljs-keyword">int</span>(<span class="hljs-literal">nil</span>) <span class="hljs-comment">// len(s) == 0, s == nil</span>s = []<span class="hljs-keyword">int</span>&#123;&#125;    <span class="hljs-comment">// len(s) == 0, s != nil</span></code></pre><ul><li>如果你需要测试一个slice是否是空的，使用len(s) == 0来判断，而不应该用s == nil来判断。</li><li>除了和nil相等比较外，一个nil值的slice的行为和其它任意0长度的slice一样</li></ul></li><li><p>reverse(nil)也是安全的。除了文档已经明确说明的地方，所有的Go语言函数应该以相同的方式对待nil值的slice和0长度的slice。</p></li></ul></li></ul><p>内置的make函数创建一个指定元素类型、长度和容量的slice。容量部分可以省略，在这种情况下，容量将等于长度。</p><pre><code>  <pre><code class="hljs Go"><span class="hljs-built_in">make</span>([]T, <span class="hljs-built_in">len</span>)<span class="hljs-built_in">make</span>([]T, <span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span>) <span class="hljs-comment">// same as make([]T, cap)[:len]</span></code></pre>- 在底层，make创建了一个匿名的数组变量，然后返回一个slice；只有通过返回的slice才能引用底层匿名的数组变量。    - 在第一种语句中，slice是整个数组的view。在第二个语句中，slice只引用了底层数组的前len个元素，但是容量将包含整个的数组。额外的元素是留给未来的增长用的。</code></pre><ul><li><p>ch4.2.1append函数</p><ul><li><p>内置的append函数用于向slice追加元素</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> runes []<span class="hljs-keyword">rune</span><span class="hljs-keyword">for</span> _, r := <span class="hljs-keyword">range</span> <span class="hljs-string">&quot;Hello, 世界&quot;</span> &#123;runes = <span class="hljs-built_in">append</span>(runes, r)&#125;fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, runes) <span class="hljs-comment">// &quot;[&#x27;H&#x27; &#x27;e&#x27; &#x27;l&#x27; &#x27;l&#x27; &#x27;o&#x27; &#x27;,&#x27; &#x27; &#x27; &#x27;世&#x27; &#x27;界&#x27;]&quot;</span></code></pre><ul><li>在循环中使用append函数构建一个由九个rune字符构成的slice，当然对应这个特殊的问题我们可以通过Go语言内置的[]rune(“Hello, 世界”)转换操作完成。</li></ul></li><li><p>append函数对于理解slice底层是如何工作的非常重要</p><ul><li><p>下面是第一个版本的appendInt函数，专门用于处理[]int类型的slice</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendInt</span><span class="hljs-params">(x []<span class="hljs-keyword">int</span>, y <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">var</span> z []<span class="hljs-keyword">int</span>zlen := <span class="hljs-built_in">len</span>(x) + <span class="hljs-number">1</span><span class="hljs-keyword">if</span> zlen &lt;= <span class="hljs-built_in">cap</span>(x) &#123;<span class="hljs-comment">// There is room to grow.  Extend the slice.</span>z = x[:zlen]&#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">// There is insufficient space.  Allocate a new array.</span><span class="hljs-comment">// Grow by doubling, for amortized linear complexity.</span>zcap := zlen<span class="hljs-keyword">if</span> zcap &lt; <span class="hljs-number">2</span>*<span class="hljs-built_in">len</span>(x) &#123;zcap = <span class="hljs-number">2</span> * <span class="hljs-built_in">len</span>(x)&#125;z = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, zlen, zcap)<span class="hljs-built_in">copy</span>(z, x) <span class="hljs-comment">// a built-in function; see text</span>&#125;z[<span class="hljs-built_in">len</span>(x)] = y<span class="hljs-keyword">return</span> z&#125;</code></pre></li><li><p>每次调用appendInt函数，必须先检测slice底层数组是否有足够的容量来保存新添加的元素。</p><ul><li><p>如果有足够空间的话，直接扩展slice（依然在原有的底层数组之上），将新添加的y元素复制到新扩展的空间，并返回slice。因此，输入的x和输出的z共享相同的底层数组。</p></li><li><p>如果没有足够的增长空间的话，appendInt函数则会先分配一个足够大的slice用于保存新的结果，先将输入的x复制到新的空间，然后添加y元素。结果z和输入的x引用的将是不同的底层数组。</p></li><li><p>虽然通过循环复制元素更直接，不过内置的copy函数可以方便地将一个slice复制另一个相同类型的slice。</p><ul><li>copy函数的第一个参数是要复制的目标slice，第二个参数是源slice，目标和源的位置顺序和<code>dst = src</code>赋值语句是一致的。</li><li>两个slice可以共享同一个底层数组，甚至有重叠也没有问题。</li><li>copy函数将返回成功复制的元素的个数（我们这里没有用到），等于两个slice中较小的长度，所以我们不用担心覆盖会超出目标slice的范围。</li></ul></li></ul></li></ul></li><li><p>为了提高内存使用效率，新分配的数组一般略大于保存x和y所需要的最低大小。通过在每次扩展数组时直接将长度翻倍从而避免了多次内存分配，也确保了添加单个元素操的平均时间是一个常数时间</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> x, y []<span class="hljs-keyword">int</span><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;y = appendInt(x, i)fmt.Printf(<span class="hljs-string">&quot;%d cap=%d\t%v\n&quot;</span>, i, <span class="hljs-built_in">cap</span>(y), y)x = y&#125;&#125;</code></pre><ul><li><p>每一次容量的变化都会导致重新分配内存和copy操作</p><pre><code class="hljs basic"><span class="hljs-symbol">0 </span> cap=<span class="hljs-number">1</span>    [<span class="hljs-number">0</span>]<span class="hljs-symbol">1 </span> cap=<span class="hljs-number">2</span>    [<span class="hljs-number">0</span> <span class="hljs-number">1</span>]<span class="hljs-symbol">2 </span> cap=<span class="hljs-number">4</span>    [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span>]<span class="hljs-symbol">3 </span> cap=<span class="hljs-number">4</span>    [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span>]<span class="hljs-symbol">4 </span> cap=<span class="hljs-number">8</span>    [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>]<span class="hljs-symbol">5 </span> cap=<span class="hljs-number">8</span>    [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span>]<span class="hljs-symbol">6 </span> cap=<span class="hljs-number">8</span>    [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span>]<span class="hljs-symbol">7 </span> cap=<span class="hljs-number">8</span>    [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span>]<span class="hljs-symbol">8 </span> cap=<span class="hljs-number">16</span>   [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span>]<span class="hljs-symbol">9 </span> cap=<span class="hljs-number">16</span>   [<span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span>]</code></pre></li></ul></li><li><p>内置的append函数可能使用比appendInt更复杂的内存扩展策略。因此，通常我们并不知道append调用是否导致了内存的重新分配，因此我们也不能确认新的slice和原始的slice是否引用的是相同的底层数组空间。同样，我们不能确认在原先的slice上的操作是否会影响到新的slice。因此，通常是将append返回的结果直接赋值给输入的slice变量</p><pre><code class="hljs Go">runes = <span class="hljs-built_in">append</span>(runes, r)</code></pre></li><li><p>更新slice变量不仅对调用append函数是必要的，实际上对应任何可能导致长度、容量或底层数组变化的操作都是必要的。</p><ul><li><p>要正确地使用slice，需要记住尽管底层数组的元素是间接访问的，但是slice对应结构体本身的指针、长度和容量部分是直接访问的</p></li><li><p>要更新这些信息需要像上面例子那样一个显式的赋值操作</p></li><li><p>从这个角度看，slice并不是一个纯粹的引用类型，它实际上是一个类似下面结构体的聚合类型</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> IntSlice <span class="hljs-keyword">struct</span> &#123;ptr      *<span class="hljs-keyword">int</span><span class="hljs-built_in">len</span>, <span class="hljs-built_in">cap</span> <span class="hljs-keyword">int</span>&#125;</code></pre></li></ul></li><li><p>我们的appendInt函数每次只能向slice追加一个元素，但是内置的append函数则可以追加多个元素，甚至追加一个slice。</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> x []<span class="hljs-keyword">int</span>x = <span class="hljs-built_in">append</span>(x, <span class="hljs-number">1</span>)x = <span class="hljs-built_in">append</span>(x, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)x = <span class="hljs-built_in">append</span>(x, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>)x = <span class="hljs-built_in">append</span>(x, x...) <span class="hljs-comment">// append the slice x</span>fmt.Println(x)      <span class="hljs-comment">// &quot;[1 2 3 4 5 6 1 2 3 4 5 6]&quot;</span></code></pre><ul><li><p>通过下面的小修改，我们可以达到append函数类似的功能。其中在appendInt函数参数中的最后的“…”省略号表示接收变长的参数为slice。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">appendInt</span><span class="hljs-params">(x []<span class="hljs-keyword">int</span>, y ...<span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">var</span> z []<span class="hljs-keyword">int</span>zlen := <span class="hljs-built_in">len</span>(x) + <span class="hljs-built_in">len</span>(y)<span class="hljs-comment">// ...expand z to at least zlen...</span><span class="hljs-built_in">copy</span>(z[<span class="hljs-built_in">len</span>(x):], y)<span class="hljs-keyword">return</span> z&#125;</code></pre></li></ul></li></ul></li><li><p>ch4.2.2Slice内存技巧</p><ul><li><p>让我们看看更多的例子，比如旋转slice、反转slice或在slice原有内存空间修改元素。给定一个字符串列表，下面的nonempty函数将在原有slice内存空间之上返回不包含空字符串的列表</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// Nonempty is an example of an in-place slice algorithm.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-comment">// nonempty returns a slice holding only the non-empty strings.</span><span class="hljs-comment">// The underlying array is modified during the call.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nonempty</span><span class="hljs-params">(strings []<span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;i := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> strings &#123;<span class="hljs-keyword">if</span> s != <span class="hljs-string">&quot;&quot;</span> &#123;strings[i] = si++&#125;&#125;<span class="hljs-keyword">return</span> strings[:i]&#125;</code></pre><ul><li><p>比较微妙的地方是，输入的slice和输出的slice共享一个底层数组。这可以避免分配另一个数组，不过原来的数据将可能会被覆盖，正如下面两个打印语句看到的那样</p><pre><code class="hljs Go">data := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>&#125;fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, nonempty(data)) <span class="hljs-comment">// `[&quot;one&quot; &quot;three&quot;]`</span>fmt.Printf(<span class="hljs-string">&quot;%q\n&quot;</span>, data)           <span class="hljs-comment">// `[&quot;one&quot; &quot;three&quot; &quot;three&quot;]`</span></code></pre></li><li><p>因此我们通常会这样使用nonempty函数：<code>data = nonempty(data)</code>。</p></li><li><p>nonempty函数也可以使用append函数实现</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">nonempty2</span><span class="hljs-params">(strings []<span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;out := strings[:<span class="hljs-number">0</span>] <span class="hljs-comment">// zero-length slice of original</span><span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> strings &#123;<span class="hljs-keyword">if</span> s != <span class="hljs-string">&quot;&quot;</span> &#123;out = <span class="hljs-built_in">append</span>(out, s)&#125;&#125;<span class="hljs-keyword">return</span> out&#125;</code></pre><ul><li><p>无论如何实现，以这种方式重用一个slice一般都要求最多为每个输入值产生一个输出值，事实上很多这类算法都是用来过滤或合并序列中相邻的元素。这种slice用法是比较复杂的技巧，虽然使用到了slice的一些技巧，但是对于某些场合是比较清晰和有效的。</p></li><li><p>一个slice可以用来模拟一个stack。最初给定的空slice对应一个空的stack，然后可以使用append函数将新的值压入stack</p><pre><code class="hljs Go">stack = <span class="hljs-built_in">append</span>(stack, v) <span class="hljs-comment">// push v</span></code></pre></li><li><p>stack的顶部位置对应slice的最后一个元素</p><pre><code class="hljs Go">top := stack[<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] <span class="hljs-comment">// top of stack</span></code></pre></li><li><p>通过收缩stack可以弹出栈顶的元素</p><pre><code class="hljs Go">stack = stack[:<span class="hljs-built_in">len</span>(stack)<span class="hljs-number">-1</span>] <span class="hljs-comment">// pop</span></code></pre></li></ul></li></ul></li><li><p>要删除slice中间的某个元素并保存原有的元素顺序，可以通过内置的copy函数将后面的子slice向前依次移动一位完成</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">(slice []<span class="hljs-keyword">int</span>, i <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;<span class="hljs-built_in">copy</span>(slice[i:], slice[i+<span class="hljs-number">1</span>:])<span class="hljs-keyword">return</span> slice[:<span class="hljs-built_in">len</span>(slice)<span class="hljs-number">-1</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;fmt.Println(remove(s, <span class="hljs-number">2</span>)) <span class="hljs-comment">// &quot;[5 6 8 9]&quot;</span>&#125;</code></pre></li><li><p>如果删除元素后不用保持原来顺序的话，我们可以简单的用最后一个元素覆盖被删除的元素</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">remove</span><span class="hljs-params">(slice []<span class="hljs-keyword">int</span>, i <span class="hljs-keyword">int</span>)</span> []<span class="hljs-title">int</span></span> &#123;slice[i] = slice[<span class="hljs-built_in">len</span>(slice)<span class="hljs-number">-1</span>]<span class="hljs-keyword">return</span> slice[:<span class="hljs-built_in">len</span>(slice)<span class="hljs-number">-1</span>]&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;s := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;fmt.Println(remove(s, <span class="hljs-number">2</span>)) <span class="hljs-comment">// &quot;[5 6 9 8]</span>&#125;</code></pre></li></ul></li></ul><h3 id="ch4-3-Map"><a href="#ch4-3-Map" class="headerlink" title="ch4.3   Map"></a>ch4.3   Map</h3><ul><li><p>哈希表是一种巧妙并且实用的数据结构。它是一个无序的key/value对的集合，其中所有的key都是不同的，然后通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value。</p></li><li><p>在Go语言中，一个map就是一个哈希表的引用，map类型可以写为map[K]V，其中K和V分别对应key和value。</p><ul><li>map中所有的key都有相同的类型，所有的value也有着相同的类型，但是key和value之间可以是不同的数据类型。</li><li>其中K对应的key必须是支持==比较运算符的数据类型，所以map可以通过测试key是否相等来判断是否已经存在</li><li>虽然浮点数类型也是支持相等运算符比较的，但是将浮点数用做key类型则是一个坏的想法，正如第三章提到的，最坏的情况是可能出现的NaN和任何浮点数都不相等。对于V对应的value数据类型则没有任何的限制。</li></ul></li><li><p>内置的make函数可以创建一个map</p><pre><code class="hljs Go">ages := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>) <span class="hljs-comment">// mapping from strings to ints</span></code></pre></li><li><p>我们也可以用map字面值的语法创建map，同时还可以指定一些最初的key/value</p><pre><code class="hljs Go">ages := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-string">&quot;alice&quot;</span>:   <span class="hljs-number">31</span>,<span class="hljs-string">&quot;charlie&quot;</span>: <span class="hljs-number">34</span>,&#125;</code></pre><ul><li><p>这相当于</p><pre><code class="hljs Go">ages := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)ages[<span class="hljs-string">&quot;alice&quot;</span>] = <span class="hljs-number">31</span>ages[<span class="hljs-string">&quot;charlie&quot;</span>] = <span class="hljs-number">34</span></code></pre></li></ul></li><li><p>另一种创建空的map的表达式是<code>map[string]int&#123;&#125;</code></p></li><li><p>Map中的元素通过key对应的下标语法访问</p><pre><code class="hljs Go">ages[<span class="hljs-string">&quot;alice&quot;</span>] = <span class="hljs-number">32</span>fmt.Println(ages[<span class="hljs-string">&quot;alice&quot;</span>]) <span class="hljs-comment">// &quot;32&quot;</span></code></pre><ul><li><p>使用内置的delete函数可以删除元素</p><pre><code class="hljs Go"><span class="hljs-built_in">delete</span>(ages, <span class="hljs-string">&quot;alice&quot;</span>) <span class="hljs-comment">// remove element ages[&quot;alice&quot;]</span></code></pre></li></ul></li><li><p>所有这些操作是安全的，即使这些元素不在map中也没有关系</p><ul><li><p>如果一个查找失败将返回value类型对应的零值</p><ul><li><p>例如，即使map中不存在“bob”下面的代码也可以正常工作，因为ages[“bob”]失败时将返回0</p><pre><code class="hljs Go">ages[<span class="hljs-string">&quot;bob&quot;</span>] = ages[<span class="hljs-string">&quot;bob&quot;</span>] + <span class="hljs-number">1</span> <span class="hljs-comment">// happy birthday!</span></code></pre></li><li><p>而且<code>x += y</code>和<code>x++</code>等简短赋值语法也可以用在map上，所以上面的代码可以改写成</p><pre><code class="hljs Go">ages[<span class="hljs-string">&quot;bob&quot;</span>] += <span class="hljs-number">1</span></code></pre></li><li><p>更简单的写法</p><pre><code class="hljs Go">ages[<span class="hljs-string">&quot;bob&quot;</span>]++</code></pre></li></ul></li><li><p>但是map中的元素并不是一个变量，因此我们不能对map的元素进行取址操作</p><pre><code class="hljs Go">_ = &amp;ages[<span class="hljs-string">&quot;bob&quot;</span>] <span class="hljs-comment">// compile error: cannot take address of map element</span></code></pre><ul><li>禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效。</li></ul></li></ul></li><li><p>要想遍历map中全部的key/value对的话，可以使用range风格的for循环实现，和之前的slice遍历语法类似。</p><ul><li><p>下面的迭代语句将在每次迭代时设置name和age变量，它们对应下一个键/值对</p><pre><code class="hljs Go"><span class="hljs-keyword">for</span> name, age := <span class="hljs-keyword">range</span> ages &#123;fmt.Printf(<span class="hljs-string">&quot;%s\t%d\n&quot;</span>, name, age)&#125;</code></pre></li></ul></li><li><p>Map的迭代顺序是不确定的，并且不同的哈希函数实现可能导致不同的遍历顺序。</p><ul><li><p>在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现。</p></li><li><p>如果要按顺序遍历key/value对，我们必须显式地对key进行排序，可以使用sort包的Strings函数对字符串slice进行排序。</p><ul><li><p>下面是常见的处理方式</p><pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;sort&quot;</span><span class="hljs-keyword">var</span> names []<span class="hljs-keyword">string</span><span class="hljs-keyword">for</span> name := <span class="hljs-keyword">range</span> ages &#123;names = <span class="hljs-built_in">append</span>(names, name)&#125;sort.Strings(names)<span class="hljs-keyword">for</span> _, name := <span class="hljs-keyword">range</span> names &#123;fmt.Printf(<span class="hljs-string">&quot;%s\t%d\n&quot;</span>, name, ages[name])&#125;</code></pre></li></ul></li><li><p>因为我们一开始就知道names的最终大小，因此给slice分配一个合适的大小将会更有效。</p><ul><li><p>下面的代码创建了一个空的slice，但是slice的容量刚好可以放下map中全部的key</p><pre><code class="hljs Go">names := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">string</span>, <span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(ages))</code></pre></li></ul></li></ul></li></ul><h3 id="ch4-4-结构体"><a href="#ch4-4-结构体" class="headerlink" title="ch4.4   结构体"></a>ch4.4   结构体</h3><ul><li><p>结构体是一种聚合的数据类型，是由零个或多个任意类型的值聚合成的实体。每个值称为结构体的成员。</p><ul><li><p>用结构体的经典案例是处理公司的员工信息，每个员工信息包含一个唯一的员工编号、员工的名字、家庭住址、出生日期、工作岗位、薪资、上级领导等等。所有的这些信息都需要绑定到一个实体中，可以作为一个整体单元被复制，作为函数的参数或返回值，或者是被存储到数组中，等等。</p></li><li><p>下面两个语句声明了一个叫Employee的命名的结构体类型，并且声明了一个Employee类型的变量dilbert</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;ID        <span class="hljs-keyword">int</span>Name      <span class="hljs-keyword">string</span>Address   <span class="hljs-keyword">string</span>DoB       time.TimePosition  <span class="hljs-keyword">string</span>Salary    <span class="hljs-keyword">int</span>ManagerID <span class="hljs-keyword">int</span>&#125;<span class="hljs-keyword">var</span> dilbert Employee</code></pre><ul><li><p>dilbert结构体变量的成员可以通过点操作符访问，比如dilbert.Name和dilbert.DoB。因为dilbert是一个变量，它所有的成员也同样是变量，我们可以直接对每个成员赋值</p><pre><code class="hljs Go">dilbert.Salary -= <span class="hljs-number">5000</span> <span class="hljs-comment">// demoted, for writing too few lines of code</span></code></pre></li><li><p>或者是对成员取地址，然后通过指针访问</p><pre><code class="hljs Go">position := &amp;dilbert.Position*position = <span class="hljs-string">&quot;Senior &quot;</span> + *position <span class="hljs-comment">// promoted, for outsourcing to Elbonia</span></code></pre></li><li><p>点操作符也可以和指向结构体的指针一起工作</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> employeeOfTheMonth *Employee = &amp;dilbertemployeeOfTheMonth.Position += <span class="hljs-string">&quot; (proactive team player)&quot;</span></code></pre><ul><li><p>相当于下面语句</p><pre><code class="hljs Go">(*employeeOfTheMonth).Position += <span class="hljs-string">&quot; (proactive team player)&quot;</span></code></pre></li></ul></li></ul></li><li><p>下面的EmployeeByID函数将根据给定的员工ID返回对应的员工信息结构体的指针。我们可以使用点操作符来访问它里面的成员</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EmployeeByID</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>)</span> *<span class="hljs-title">Employee</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;fmt.Println(EmployeeByID(dilbert.ManagerID).Position) <span class="hljs-comment">// &quot;Pointy-haired boss&quot;</span>id := dilbert.IDEmployeeByID(id).Salary = <span class="hljs-number">0</span> <span class="hljs-comment">// fired for... no real reason</span></code></pre><ul><li>后面的语句通过EmployeeByID返回的结构体指针更新了Employee结构体的成员。如果将EmployeeByID函数的返回值从<code>*Employee</code>指针类型改为Employee值类型，那么更新语句将不能编译通过，因为在赋值语句的左边并不确定是一个变量（译注：调用函数返回的是值，并不是一个可取地址的变量）。</li></ul></li></ul></li><li><p>通常一行对应一个结构体成员，成员的名字在前类型在后，不过如果相邻的成员类型如果相同的话可以被合并到一行，就像下面的Name和Address成员那样</p><pre><code class="hljs Go"><span class="hljs-keyword">type</span> Employee <span class="hljs-keyword">struct</span> &#123;ID            <span class="hljs-keyword">int</span>Name, Address <span class="hljs-keyword">string</span>DoB           time.TimePosition      <span class="hljs-keyword">string</span>Salary        <span class="hljs-keyword">int</span>ManagerID     <span class="hljs-keyword">int</span>&#125;</code></pre><ul><li>结构体成员的输入顺序也有重要的意义。我们也可以将Position成员合并（因为也是字符串类型），或者是交换Name和Address出现的先后顺序，那样的话就是定义了不同的结构体类型。通常，我们只是将相关的成员写到一起。</li></ul></li><li><p>如果结构体成员名字是以大写字母开头的，那么该成员就是导出的；这是Go语言导出规则决定的。一个结构体可能同时包含导出和未导出的成员。</p></li><li><p>结构体类型往往是冗长的，因为它的每个成员可能都会占一行。虽然我们每次都可以重写整个结构体成员，但是重复会令人厌烦。因此，完整的结构体写法通常只在类型声明语句的地方出现，就像Employee类型声明语句那样。</p></li><li><p>一个命名为S的结构体类型将不能再包含S类型的成员</p><ul><li><p>因为一个聚合的值不能包含它自身</p></li><li><p>该限制同样适用于数组</p></li><li><p>但是S类型的结构体可以包含<code>*S</code>指针类型的成员，这可以让我们创建递归的数据结构，比如链表和树结构等</p><ul><li>在下面的代码中，我们使用一个二叉树来实现一个插入排序</li></ul></li></ul></li><li><p>结构体类型的零值是每个成员都是零值。通常会将零值作为最合理的默认值。</p><ul><li>例如，对于bytes.Buffer类型，结构体初始值就是一个随时可用的空缓存，还有在第9章将会讲到的sync.Mutex的零值也是有效的未锁定状态。</li><li>有时候这种零值可用的特性是自然获得的，但是也有些类型需要一些额外的工作。</li></ul></li><li><p>如果结构体没有任何成员的话就是空结构体，写作struct{}</p><ul><li><p>它的大小为0，也不包含任何信息，但是有时候依然是有价值的。</p></li><li><p>有些Go语言程序员用map来模拟set数据结构时，用它来代替map中布尔类型的value，只是强调key的重要性，但是因为节约的空间有限，而且语法比较复杂，所以我们通常会避免这样的用法。</p><pre><code class="hljs Go">seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">struct</span>&#123;&#125;) <span class="hljs-comment">// set of strings</span><span class="hljs-comment">// ...</span><span class="hljs-keyword">if</span> _, ok := seen[s]; !ok &#123;seen[s] = <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<span class="hljs-comment">// ...first time seeing s...</span>&#125;</code></pre></li></ul></li></ul><h3 id="ch4-5-JSON"><a href="#ch4-5-JSON" class="headerlink" title="ch4.5   JSON"></a>ch4.5   JSON</h3><ul><li><p>JavaScript对象表示法（JSON）是一种用于发送和接收结构化信息的标准协议。</p><ul><li>在类似的协议中，JSON并不是唯一的一个标准协议。</li><li>XML（§7.14）、ASN.1和Google的Protocol Buffers都是类似的协议，并且有各自的特色，但是由于简洁性、可读性和流行程度等原因，JSON是应用最广泛的一个。</li></ul></li><li><p>Go语言对于这些标准格式的编码和解码都有良好的支持，由标准库中的encoding/json、encoding/xml、encoding/asn1等包提供支持,并且这类包都有着相似的API接口。</p><ul><li>Protocol Buffers的支持由 github.com/golang/protobuf 包提供</li></ul></li><li><p>JSON是对JavaScript中各种类型的值——字符串、数字、布尔值和对象——Unicode本文编码。</p><ul><li>它可以用有效可读的方式表示第三章的基础数据类型和本章的数组、slice、结构体和map等聚合数据类型。</li></ul></li><li><p>基本的JSON类型有数字（十进制或科学记数法）、布尔值（true或false）、字符串</p><ul><li>其中字符串是以双引号包含的Unicode字符序列，支持和Go语言类似的反斜杠转义特性，不过JSON使用的是<code>\Uhhhh</code>转义数字来表示一个UTF-16编码，而不是Go语言的rune类型</li><li>UTF-16和UTF-8一样是一种变长的编码，有些Unicode码点较大的字符需要用4个字节表示；而且UTF-16还有大端和小端的问题</li></ul></li><li><p>这些基础类型可以通过JSON的数组和对象类型进行递归组合</p><ul><li><p>一个JSON数组是一个有序的值序列，写在一个方括号中并以逗号分隔</p></li><li><p>一个JSON数组可以用于编码Go语言的数组和slice</p></li><li><p>一个JSON对象是一个字符串到值的映射，写成一系列的name:value对形式，用花括号包含并以逗号分隔</p></li><li><p>JSON的对象类型可以用于编码Go语言的map类型（key类型是字符串）和结构体</p></li><li><p>例如：</p><pre><code class="hljs pgsql"><span class="hljs-type">boolean</span>         <span class="hljs-keyword">true</span>number          <span class="hljs-number">-273.15</span>string          &quot;She said \&quot;Hello, BF\&quot;&quot;<span class="hljs-keyword">array</span>           [&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;]<span class="hljs-keyword">object</span>          &#123;&quot;year&quot;: <span class="hljs-number">1980</span>,                 &quot;event&quot;: &quot;archery&quot;,                 &quot;medals&quot;: [&quot;gold&quot;, &quot;silver&quot;, &quot;bronze&quot;]&#125;</code></pre></li></ul></li><li><p>考虑一个应用程序，该程序负责收集各种电影评论并提供反馈功能。它的Movie数据类型和一个典型的表示电影的值列表如下所示。</p><ul><li>在结构体声明中，Year和Color成员后面的字符串面值是结构体成员Tag；我们稍后会解释它的作用</li></ul></li><li><p>这样的数据结构特别适合JSON格式，并且在两者之间相互转换也很容易。将一个Go语言中类似movies的结构体slice转为JSON的过程叫编组（marshaling）</p><ul><li><p>组通过调用json.Marshal函数完成</p><pre><code class="hljs Go">data, err := json.Marshal(movies)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;JSON marshaling failed: %s&quot;</span>, err)&#125;fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, data)</code></pre></li><li><p>Marshal函数返回一个编码后的字节slice，包含很长的字符串，并且没有空白缩进；我们将它折行以便于显示</p><pre><code class="hljs clojure">[&#123;<span class="hljs-string">&quot;Title&quot;</span>:<span class="hljs-string">&quot;Casablanca&quot;</span>,<span class="hljs-string">&quot;released&quot;</span>:<span class="hljs-number">1942</span>,<span class="hljs-string">&quot;Actors&quot;</span>:[<span class="hljs-string">&quot;Humphrey Bogart&quot;</span>,<span class="hljs-string">&quot;Ingr</span><span class="hljs-string">id Bergman&quot;</span>]&#125;,&#123;<span class="hljs-string">&quot;Title&quot;</span>:<span class="hljs-string">&quot;Cool Hand Luke&quot;</span>,<span class="hljs-string">&quot;released&quot;</span>:<span class="hljs-number">1967</span>,<span class="hljs-string">&quot;color&quot;</span><span class="hljs-symbol">:true</span>,<span class="hljs-string">&quot;Ac</span><span class="hljs-string">tors&quot;</span>:[<span class="hljs-string">&quot;Paul Newman&quot;</span>]&#125;,&#123;<span class="hljs-string">&quot;Title&quot;</span>:<span class="hljs-string">&quot;Bullitt&quot;</span>,<span class="hljs-string">&quot;released&quot;</span>:<span class="hljs-number">1968</span>,<span class="hljs-string">&quot;color&quot;</span><span class="hljs-symbol">:true</span>,<span class="hljs-string">&quot;</span><span class="hljs-string">Actors&quot;</span>:[<span class="hljs-string">&quot;Steve McQueen&quot;</span>,<span class="hljs-string">&quot;Jacqueline Bisset&quot;</span>]&#125;]</code></pre></li></ul></li><li><p>这种紧凑的表示形式虽然包含了全部的信息，但是很难阅读。为了生成便于阅读的格式，另一个json.MarshalIndent函数将产生整齐缩进的输出。</p><ul><li><p>该函数有两个额外的字符串参数用于表示每一行输出的前缀和每一个层级的缩进</p><pre><code class="hljs Go">data, err := json.MarshalIndent(movies, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;    &quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;JSON marshaling failed: %s&quot;</span>, err)&#125;fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, data)</code></pre></li><li><p>上面的代码将产生这样的输出（译注：在最后一个成员或元素后面并没有逗号分隔符）</p><pre><code class="hljs Json">[&#123;<span class="hljs-attr">&quot;Title&quot;</span>: <span class="hljs-string">&quot;Casablanca&quot;</span>,<span class="hljs-attr">&quot;released&quot;</span>: <span class="hljs-number">1942</span>,<span class="hljs-attr">&quot;Actors&quot;</span>: [<span class="hljs-string">&quot;Humphrey Bogart&quot;</span>,<span class="hljs-string">&quot;Ingrid Bergman&quot;</span>]&#125;,&#123;<span class="hljs-attr">&quot;Title&quot;</span>: <span class="hljs-string">&quot;Cool Hand Luke&quot;</span>,<span class="hljs-attr">&quot;released&quot;</span>: <span class="hljs-number">1967</span>,<span class="hljs-attr">&quot;color&quot;</span>: <span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;Actors&quot;</span>: [<span class="hljs-string">&quot;Paul Newman&quot;</span>]&#125;,&#123;<span class="hljs-attr">&quot;Title&quot;</span>: <span class="hljs-string">&quot;Bullitt&quot;</span>,<span class="hljs-attr">&quot;released&quot;</span>: <span class="hljs-number">1968</span>,<span class="hljs-attr">&quot;color&quot;</span>: <span class="hljs-literal">true</span>,<span class="hljs-attr">&quot;Actors&quot;</span>: [<span class="hljs-string">&quot;Steve McQueen&quot;</span>,<span class="hljs-string">&quot;Jacqueline Bisset&quot;</span>]&#125;]</code></pre></li></ul></li><li><p>在编码时，默认使用Go语言结构体的成员名字作为JSON的对象（通过reflect反射技术，我们将在12.6节讨论）。只有导出的结构体成员才会被编码，这也就是我们为什么选择用大写字母开头的成员名称。</p></li><li><p>细心的读者可能已经注意到，其中Year名字的成员在编码后变成了released，还有Color成员编码后变成了小写字母开头的color。这是因为结构体成员Tag所导致的。</p><ul><li><p>一个结构体成员Tag是和在编译阶段关联到该成员的元信息字符串</p><pre><code class="hljs pgsql">Year  <span class="hljs-type">int</span>  `<span class="hljs-type">json</span>:&quot;released&quot;`Color <span class="hljs-type">bool</span> `<span class="hljs-type">json</span>:&quot;color,omitempty&quot;`</code></pre></li></ul></li><li><p>结构体的成员Tag可以是任意的字符串面值，但是通常是一系列用空格分隔的key:”value”键值对序列；因为值中含有双引号字符，因此成员Tag一般用原生字符串面值的形式书写。</p><ul><li>json开头键名对应的值用于控制encoding/json包的编码和解码的行为，并且encoding/…下面其它的包也遵循这个约定。</li><li>成员Tag中json对应值的第一部分用于指定JSON对象的名字，比如将Go语言中的TotalCount成员对应到JSON中的total_count对象。</li><li>Color成员的Tag还带了一个额外的omitempty选项，表示当Go语言结构体成员为空或零值时不生成该JSON对象（这里false为零值）</li></ul></li><li><p>编码的逆操作是解码，对应将JSON数据解码为Go语言的数据结构，Go语言中一般叫unmarshaling，通过json.Unmarshal函数完成。</p><ul><li><p>下面的代码将JSON格式的电影数据解码为一个结构体slice，结构体中只有Title成员。通过定义合适的Go语言数据结构，我们可以选择性地解码JSON中感兴趣的成员。当Unmarshal函数调用返回，slice将被只含有Title信息的值填充，其它JSON成员将被忽略。</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> titles []<span class="hljs-keyword">struct</span>&#123; Title <span class="hljs-keyword">string</span> &#125;<span class="hljs-keyword">if</span> err := json.Unmarshal(data, &amp;titles); err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;JSON unmarshaling failed: %s&quot;</span>, err)&#125;fmt.Println(titles) <span class="hljs-comment">// &quot;[&#123;Casablanca&#125; &#123;Cool Hand Luke&#125; &#123;Bullitt&#125;]&quot;</span></code></pre></li></ul></li><li><p>许多web服务都提供JSON接口，通过HTTP接口发送JSON格式请求并返回JSON格式的信息。</p><ul><li><p>为了说明这一点，我们通过Github的issue查询服务来演示类似的用法。首先，我们要定义合适的类型和常量</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// Package github provides a Go API for the GitHub issue tracker.</span><span class="hljs-comment">// See https://developer.github.com/v3/search/[[search-issues]].</span><span class="hljs-keyword">package</span> github<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;time&quot;</span><span class="hljs-keyword">const</span> IssuesURL = <span class="hljs-string">&quot;https://api.github.com/search/issues&quot;</span><span class="hljs-keyword">type</span> IssuesSearchResult <span class="hljs-keyword">struct</span> &#123;TotalCount <span class="hljs-keyword">int</span> <span class="hljs-string">`json:&quot;total_count&quot;`</span>Items          []*Issue&#125;<span class="hljs-keyword">type</span> Issue <span class="hljs-keyword">struct</span> &#123;Number    <span class="hljs-keyword">int</span>HTMLURL   <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;html_url&quot;`</span>Title     <span class="hljs-keyword">string</span>State     <span class="hljs-keyword">string</span>User      *UserCreatedAt time.Time <span class="hljs-string">`json:&quot;created_at&quot;`</span>Body      <span class="hljs-keyword">string</span>    <span class="hljs-comment">// in Markdown format</span>&#125;<span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;Login   <span class="hljs-keyword">string</span>HTMLURL <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;html_url&quot;`</span>&#125;</code></pre><ul><li>和前面一样，即使对应的JSON对象名是小写字母，每个结构体的成员名也是声明为大写字母开头的。</li><li>因为有些JSON成员名字和Go结构体成员名字并不相同，因此需要Go语言结构体成员Tag来指定对应的JSON名字。</li><li>同样，在解码的时候也需要做同样的处理，GitHub服务返回的信息比我们定义的要多很多。</li></ul></li><li><p>SearchIssues函数发出一个HTTP请求，然后解码返回的JSON格式的结果。因为用户提供的查询条件可能包含类似<code>?</code>和<code>&amp;</code>之类的特殊字符，为了避免对URL造成冲突，我们用url.QueryEscape来对查询中的特殊字符进行转义操作。</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> github<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;encoding/json&quot;</span><span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;net/url&quot;</span><span class="hljs-string">&quot;strings&quot;</span>)<span class="hljs-comment">// SearchIssues queries the GitHub issue tracker.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SearchIssues</span><span class="hljs-params">(terms []<span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*IssuesSearchResult, error)</span></span> &#123;q := url.QueryEscape(strings.Join(terms, <span class="hljs-string">&quot; &quot;</span>))resp, err := http.Get(IssuesURL + <span class="hljs-string">&quot;?q=&quot;</span> + q)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;<span class="hljs-comment">// We must close resp.Body on all execution paths.</span><span class="hljs-comment">// (Chapter 5 presents &#x27;defer&#x27;, which makes this simpler.)</span><span class="hljs-keyword">if</span> resp.StatusCode != http.StatusOK &#123;resp.Body.Close()<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;search query failed: %s&quot;</span>, resp.Status)&#125;<span class="hljs-keyword">var</span> result IssuesSearchResult<span class="hljs-keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;result); err != <span class="hljs-literal">nil</span> &#123;resp.Body.Close()<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;resp.Body.Close()<span class="hljs-keyword">return</span> &amp;result, <span class="hljs-literal">nil</span>&#125;</code></pre></li><li><p>在早些的例子中，我们使用了json.Unmarshal函数来将JSON格式的字符串解码为字节slice。但是这个例子中，我们使用了基于流式的解码器json.Decoder，它可以从一个输入流解码JSON数据，尽管这不是必须的。如您所料，还有一个针对输出流的json.Encoder编码对象。</p></li><li><p>我们调用Decode方法来填充变量。这里有多种方法可以格式化结构。下面是最简单的一种，以一个固定宽度打印每个issue，但是在下一节我们将看到如何利用模板来输出复杂的格式。</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// Issues prints a table of GitHub issues matching the search terms.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;log&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;gopl.io/ch4/github&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;result, err := github.SearchIssues(os.Args[<span class="hljs-number">1</span>:])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;fmt.Printf(<span class="hljs-string">&quot;%d issues:\n&quot;</span>, result.TotalCount)<span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> result.Items &#123;fmt.Printf(<span class="hljs-string">&quot;#%-5d %9.9s %.55s\n&quot;</span>,item.Number, item.User.Login, item.Title)&#125;&#125;</code></pre></li><li><p>通过命令行参数指定检索条件。下面的命令是查询Go语言项目中和JSON解码相关的问题，还有查询返回的结果</p><pre><code class="hljs vala">$ go build gopl.io/ch4/issues$ ./issues repo:golang/go is:open json decoder<span class="hljs-number">13</span> issues:<span class="hljs-meta">#5680 eaigner encoding/json: set key converter on en/decoder</span><span class="hljs-meta">#6050 gopherbot encoding/json: provide tokenizer</span><span class="hljs-meta">#8658 gopherbot encoding/json: use bufio</span><span class="hljs-meta">#8462 kortschak encoding/json: UnmarshalText confuses json.Unmarshal</span><span class="hljs-meta">#5901 rsc encoding/json: allow override type marshaling</span><span class="hljs-meta">#9812 klauspost encoding/json: string tag not symmetric</span><span class="hljs-meta">#7872 extempora encoding/json: Encoder internally buffers full output</span><span class="hljs-meta">#9650 cespare encoding/json: Decoding gives errPhase when unmarshalin</span><span class="hljs-meta">#6716 gopherbot encoding/json: include field name in unmarshal error me</span><span class="hljs-meta">#6901 lukescott encoding/json, encoding/xml: option to treat unknown fi</span><span class="hljs-meta">#6384 joeshaw encoding/json: encode precise floating point integers u</span><span class="hljs-meta">#6647 btracey x/tools/cmd/godoc: display type kind of each named type</span><span class="hljs-meta">#4237 gjemiller encoding/base64: URLEncoding padding is optional</span></code></pre><ul><li>GitHub的Web服务接口 <a href="https://developer.github.com/v3/">https://developer.github.com/v3/</a> 包含了更多的特性。</li></ul></li></ul></li></ul><h3 id="ch4-6-文本和HTML模板"><a href="#ch4-6-文本和HTML模板" class="headerlink" title="ch4.6   文本和HTML模板"></a>ch4.6   文本和HTML模板</h3><ul><li><p>有时候会需要复杂的打印格式，这时候一般需要将格式化代码分离出来以便更安全地修改。这些功能是由text/template和html/template等模板包提供的，它们提供了一个将变量值填充到一个文本或HTML格式的模板的机制。</p></li><li><p>一个模板是一个字符串或一个文件，里面包含了一个或多个由双花括号包含的<code>&#123;&#123;action&#125;&#125;</code>对象。</p><ul><li>大部分的字符串只是按字面值打印，但是对于actions部分将触发其它的行为。</li><li>每个actions都包含了一个用模板语言书写的表达式，一个action虽然简短但是可以输出复杂的打印值，模板语言包含通过选择结构体的成员、调用函数或方法、表达式控制流if-else语句和range循环语句，还有其它实例化模板等诸多特性。</li></ul></li><li><p>下面是一个简单的模板字符串：</p>    <pre><code class="hljs Go"><span class="hljs-keyword">const</span> templ = <span class="hljs-string">`&#123;&#123;.TotalCount&#125;&#125; issues:</span><span class="hljs-string">&#123;&#123;range .Items&#125;&#125;----------------------------------------</span><span class="hljs-string">Number: &#123;&#123;.Number&#125;&#125;</span><span class="hljs-string">User:   &#123;&#123;.User.Login&#125;&#125;</span><span class="hljs-string">Title:  &#123;&#123;.Title | printf &quot;%.64s&quot;&#125;&#125;</span><span class="hljs-string">Age:    &#123;&#123;.CreatedAt | daysAgo&#125;&#125; days</span><span class="hljs-string">&#123;&#123;end&#125;&#125;`</span></code></pre>    - 这个模板先打印匹配到的issue总数，然后打印每个issue的编号、创建用户、标题还有存在的时间。- 对于每一个action，都有一个当前值的概念，对应点操作符，写作“.”。- 当前值“.”最初被初始化为调用模板时的参数，在当前例子中对应github.IssuesSearchResult类型的变量。- 模板中`{{.TotalCount}}`对应action将展开为结构体中TotalCount成员以默认的方式打印的值。- 模板中`{{range .Items}}`和`{{end}}`对应一个循环action，因此它们之间的内容可能会被展开多次，循环每次迭代的当前值对应当前的Items元素的值。- 在一个action中，`|`操作符表示将前一个表达式的结果作为后一个函数的输入，类似于UNIX中管道的概念。- 在Title这一行的action中，第二个操作是一个printf函数，是一个基于fmt.Sprintf实现的内置函数，所有模板都可以直接使用- 对于Age部分，第二个动作是一个叫daysAgo的函数，通过time.Since函数将CreatedAt成员转换为过去的时间长度  <pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">daysAgo</span><span class="hljs-params">(t time.Time)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">int</span>(time.Since(t).Hours() / <span class="hljs-number">24</span>)&#125;</code></pre>- 需要注意的是CreatedAt的参数类型是time.Time，并不是字符串。- 以同样的方式，我们可以通过定义一些方法来控制字符串的格式化（§2.5），一个类型同样可以定制自己的JSON编码和解码行为。time.Time类型对应的JSON值是一个标准时间格式的字符串。- 生成模板的输出需要两个处理步骤。- 第一步是要分析模板并转为内部表示，然后基于指定的输入执行模板。分析模板部分一般只需要执行一次。- 下面的代码创建并分析上面定义的模板templ。  <pre><code class="hljs Go">report, err := template.New(<span class="hljs-string">&quot;report&quot;</span>).Funcs(template.FuncMap&#123;<span class="hljs-string">&quot;daysAgo&quot;</span>: daysAgo&#125;).Parse(templ)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;</code></pre>- 注意方法调用链的顺序：template.New先创建并返回一个模板；Funcs方法将daysAgo等自定义函数注册到模板中，并返回模板；最后调用Parse函数分析模板。- 因为模板通常在编译时就测试好了，如果模板解析失败将是一个致命的错误。- template.Must辅助函数可以简化这个致命错误的处理- 它接受一个模板和一个error类型的参数，检测error是否为nil（如果不是nil则发出panic异常），然后返回传入的模板。- 一旦模板已经创建、注册了daysAgo函数、并通过分析和检测，我们就可以使用github.IssuesSearchResult作为输入源、os.Stdout作为输出源来执行模板  <pre><code class="hljs Go"><span class="hljs-keyword">var</span> report = template.Must(template.New(<span class="hljs-string">&quot;issuelist&quot;</span>).Funcs(template.FuncMap&#123;<span class="hljs-string">&quot;daysAgo&quot;</span>: daysAgo&#125;).Parse(templ))<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;result, err := github.SearchIssues(os.Args[<span class="hljs-number">1</span>:])<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;<span class="hljs-keyword">if</span> err := report.Execute(os.Stdout, result); err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;&#125;</code></pre>- 程序输出一个纯文本报告  <pre><code class="hljs asciidoc">$ go build gopl.io/ch4/issuesreport$ ./issuesreport repo:golang/go is:open json decoder13 issues:----------------------------------------Number: 5680User:      eaignerTitle:     encoding/json: set key converter on en/decoderAge:       750 days----------------------------------------Number: 6050User:      gopherbotTitle:     encoding/json: provide tokenizerAge:       695 days----------------------------------------...</code></pre>- 现在让我们转到html/template模板包。它使用和text/template包相同的API和模板语言，但是增加了一个将字符串自动转义特性，这可以避免输入字符串和HTML、JavaScript、CSS或URL语法产生冲突的问题。- 这个特性还可以避免一些长期存在的安全问题，比如通过生成HTML注入攻击，通过构造一个含有恶意代码的问题标题，这些都可能让模板输出错误的输出，从而让他们控制页面。- 下面的模板以HTML格式输出issue列表。注意import语句的不同  {% raw %}    <u><i>gopl.io/ch4/issueshtml</i></u>    <pre><code class="hljs Go"><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;html/template&quot;</span><span class="hljs-keyword">var</span> issueList = template.Must(template.New(<span class="hljs-string">&quot;issuelist&quot;</span>).Parse(<span class="hljs-string">`</span><span class="hljs-string">&lt;h1&gt;&#123;&#123;.TotalCount&#125;&#125; issues&lt;/h1&gt;</span><span class="hljs-string">&lt;table&gt;</span><span class="hljs-string">&lt;tr style=&#x27;text-align: left&#x27;&gt;</span><span class="hljs-string">  &lt;th&gt;#&lt;/th&gt;</span><span class="hljs-string">  &lt;th&gt;State&lt;/th&gt;</span><span class="hljs-string">  &lt;th&gt;User&lt;/th&gt;</span><span class="hljs-string">  &lt;th&gt;Title&lt;/th&gt;</span><span class="hljs-string">&lt;/tr&gt;</span><span class="hljs-string">&#123;&#123;range .Items&#125;&#125;</span><span class="hljs-string">&lt;tr&gt;</span><span class="hljs-string">  &lt;td&gt;&lt;a href=&#x27;&#123;&#123;.HTMLURL&#125;&#125;&#x27;&gt;&#123;&#123;.Number&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span><span class="hljs-string">  &lt;td&gt;&#123;&#123;.State&#125;&#125;&lt;/td&gt;</span><span class="hljs-string">  &lt;td&gt;&lt;a href=&#x27;&#123;&#123;.User.HTMLURL&#125;&#125;&#x27;&gt;&#123;&#123;.User.Login&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span><span class="hljs-string">  &lt;td&gt;&lt;a href=&#x27;&#123;&#123;.HTMLURL&#125;&#125;&#x27;&gt;&#123;&#123;.Title&#125;&#125;&lt;/a&gt;&lt;/td&gt;</span><span class="hljs-string">&lt;/tr&gt;</span><span class="hljs-string">&#123;&#123;end&#125;&#125;</span><span class="hljs-string">&lt;/table&gt;</span><span class="hljs-string">`</span>))</code></pre>    {% endraw %}<ul><li><p>下面的命令将在新的模板上执行一个稍微不同的查询</p><pre><code class="hljs awk">$ go build gopl.io<span class="hljs-regexp">/ch4/i</span>ssueshtml$ .<span class="hljs-regexp">/issueshtml repo:golang/g</span>o commenter:gopherbot json encoder &gt;issues.html</code></pre></li><li><p>html/template包已经自动将特殊字符转义，因此我们依然可以看到正确的字面值。如果我们使用text/template包的话，这2个issue将会产生错误，其中“&amp;lt;”四个字符将会被当作小于字符“&lt;”处理，同时“&lt;link&gt;”字符串将会被当作一个链接元素处理，它们都会导致HTML文档结构的改变，从而导致有未知的风险。</p></li><li><p>我们也可以通过对信任的HTML字符串使用template.HTML类型来抑制这种自动转义的行为。</p><ul><li><p>还有很多采用类型命名的字符串类型分别对应信任的JavaScript、CSS和URL。</p></li><li><p>下面的程序演示了两个使用不同类型的相同字符串产生的不同结果：A是一个普通字符串，B是一个信任的template.HTML字符串类型。</p>{% raw %}    <u><i>gopl.io/ch4/autoescape</i></u>    <pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">const</span> templ = <span class="hljs-string">`&lt;p&gt;A: &#123;&#123;.A&#125;&#125;&lt;/p&gt;&lt;p&gt;B: &#123;&#123;.B&#125;&#125;&lt;/p&gt;`</span>t := template.Must(template.New(<span class="hljs-string">&quot;escape&quot;</span>).Parse(templ))<span class="hljs-keyword">var</span> data <span class="hljs-keyword">struct</span> &#123;A <span class="hljs-keyword">string</span>        <span class="hljs-comment">// untrusted plain text</span>B template.HTML <span class="hljs-comment">// trusted HTML</span>&#125;data.A = <span class="hljs-string">&quot;&lt;b&gt;Hello!&lt;/b&gt;&quot;</span>data.B = <span class="hljs-string">&quot;&lt;b&gt;Hello!&lt;/b&gt;&quot;</span><span class="hljs-keyword">if</span> err := t.Execute(os.Stdout, data); err != <span class="hljs-literal">nil</span> &#123;log.Fatal(err)&#125;&#125;</code></pre>    {% endraw %}</li></ul></li></ul></li><li><p>我们这里只讲述了模板系统中最基本的特性。一如既往，如果想了解更多的信息，请自己查看包文档</p><pre><code class="hljs arduino">$ go doc <span class="hljs-built_in">text</span>/<span class="hljs-keyword">template</span>$ go doc html/<span class="hljs-keyword">template</span></code></pre></li></ul><h2 id="ch5-函数"><a href="#ch5-函数" class="headerlink" title="ch5  函数"></a>ch5  函数</h2><h3 id="ch5-0-简介"><a href="#ch5-0-简介" class="headerlink" title="ch5.0   简介"></a>ch5.0   简介</h3><ul><li>函数可以让我们将一个语句序列打包为一个单元，然后可以从程序中其它地方多次调用。</li><li>函数的机制可以让我们将一个大的工作分解为小的任务，这样的小任务可以让不同程序员在不同时间、不同地方独立完成。一个函数同时对用户隐藏了其实现细节。由于这些因素，对于任何编程语言来说，函数都是一个至关重要的部分。</li><li>本章的运行示例是一个网络蜘蛛，也就是web搜索引擎中负责抓取网页部分的组件，它们根据抓取网页中的链接继续抓取链接指向的页面。一个网络蜘蛛的例子给我们足够的机会去探索递归函数、匿名函数、错误处理和函数其它的很多特性。</li></ul><h3 id="ch5-1-函数声明"><a href="#ch5-1-函数声明" class="headerlink" title="ch5.1   函数声明"></a>ch5.1   函数声明</h3><ul><li><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">name</span><span class="hljs-params">(parameter-list)</span> <span class="hljs-params">(result-list)</span></span> &#123;body&#125;</code></pre><ul><li><p>形式参数列表描述了函数的参数名以及参数类型。</p><ul><li>这些参数作为局部变量，其值由参数调用者提供。</li></ul></li><li><p>返回值列表描述了函数返回值的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。</p><ul><li>如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值。</li></ul></li><li><p>在hypot函数中</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hypot</span><span class="hljs-params">(x, y <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float64</span></span> &#123;<span class="hljs-keyword">return</span> math.Sqrt(x*x + y*y)&#125;fmt.Println(hypot(<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)) <span class="hljs-comment">// &quot;5&quot;</span></code></pre><ul><li>x和y是形参名，3和4是调用时的传入的实参，函数返回了一个float64类型的值。</li></ul></li></ul></li><li><p>返回值也可以像形式参数一样被命名。在这种情况下，每个返回值被声明成一个局部变量，并根据该返回值的类型，将其初始化为该类型的零值。</p><ul><li><p>如果一个函数在声明时，包含返回值列表，该函数必须以 return语句结尾，除非函数明显无法运行到结尾处。</p><ul><li>例如函数在结尾时调用了panic异常或函数中存在无限循环。</li></ul></li></ul></li><li><p>正如hypot一样，如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型。下面2个声明是等价的</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(i, j, k <span class="hljs-keyword">int</span>, s, t <span class="hljs-keyword">string</span>)</span></span>                 &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>, k <span class="hljs-keyword">int</span>,  s <span class="hljs-keyword">string</span>, t <span class="hljs-keyword">string</span>)</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;</code></pre></li><li><p>下面，我们给出4种方法声明拥有2个int型参数和1个int型返回值的函数.blank identifier(译者注：即下文的_符号)可以强调某个参数未被使用。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span>   &#123;<span class="hljs-keyword">return</span> x + y&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">(x, y <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(z <span class="hljs-keyword">int</span>)</span></span>   &#123; z = x - y; <span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">first</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>, _ <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> x &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">zero</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span>      &#123; <span class="hljs-keyword">return</span> <span class="hljs-number">0</span> &#125;fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, add)   <span class="hljs-comment">// &quot;func(int, int) int&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, sub)   <span class="hljs-comment">// &quot;func(int, int) int&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, first) <span class="hljs-comment">// &quot;func(int, int) int&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, zero)  <span class="hljs-comment">// &quot;func(int, int) int&quot;</span></code></pre></li><li><p>函数的类型被称为函数的签名。</p><ul><li>如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。</li><li>形参和返回值的变量名不影响函数签名，也不影响它们是否可以以省略参数类型的形式表示。</li></ul></li><li><p>每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。</p></li><li><p>在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。</p></li><li><p>实参通过值的方式传递，因此函数的形参是实参的拷贝。</p><ul><li>对形参进行修改不会影响实参。</li><li>但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。</li></ul></li><li><p>你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数签名。</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> math<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sin</span><span class="hljs-params">(x <span class="hljs-keyword">float64</span>)</span> <span class="hljs-title">float</span> //<span class="hljs-title">implemented</span> <span class="hljs-title">in</span> <span class="hljs-title">assembly</span> <span class="hljs-title">language</span></span></code></pre></li></ul><h3 id="ch5-2-递归"><a href="#ch5-2-递归" class="headerlink" title="ch5.2   递归"></a>ch5.2   递归</h3><ul><li><p>函数可以是递归的，这意味着函数可以直接或间接的调用自身</p><ul><li>对许多问题而言，递归是一种强有力的技术，例如处理递归的数据结构。在4.4节，我们通过遍历二叉树来实现简单的插入排序，在本章节，我们再次使用它来处理HTML文件。</li></ul></li><li><p>下文的示例代码使用了非标准包 golang.org/x/net/html ，解析HTML。</p><ul><li><p>golang.org/x/… 目录下存储了一些由Go团队设计、维护，对网络编程、国际化文件处理、移动平台、图像处理、加密解密、开发者工具提供支持的扩展包。</p></li><li><p>未将这些扩展包加入到标准库原因有二，一是部分包仍在开发中，二是对大多数Go语言的开发者而言，扩展包提供的功能很少被使用。</p></li><li><p>例子中调用golang.org/x/net/html的部分api如下所示。html.Parse函数读入一组bytes解析后，返回html.Node类型的HTML页面树状结构根节点。HTML拥有很多类型的结点如text（文本）、commnets（注释）类型，在下面的例子中，我们 只关注&lt; name key=’value’ &gt;形式的结点。</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> html<span class="hljs-keyword">type</span> Node <span class="hljs-keyword">struct</span> &#123;Type                    NodeTypeData                    <span class="hljs-keyword">string</span>Attr                    []AttributeFirstChild, NextSibling *Node&#125;<span class="hljs-keyword">type</span> NodeType <span class="hljs-keyword">int32</span><span class="hljs-keyword">const</span> (ErrorNode NodeType = <span class="hljs-literal">iota</span>TextNodeDocumentNodeElementNodeCommentNodeDoctypeNode)<span class="hljs-keyword">type</span> Attribute <span class="hljs-keyword">struct</span> &#123;Key, Val <span class="hljs-keyword">string</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(r io.Reader)</span> <span class="hljs-params">(*Node, error)</span></span></code></pre></li><li><p>main函数解析HTML标准输入，通过递归函数visit获得links（链接），并打印出这些links</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// Findlinks1 prints the links in an HTML document read from standard input.</span><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;os&quot;</span><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;doc, err := html.Parse(os.Stdin)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;findlinks1: %v\n&quot;</span>, err)os.Exit(<span class="hljs-number">1</span>)&#125;<span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> visit(<span class="hljs-literal">nil</span>, doc) &#123;fmt.Println(link)&#125;&#125;</code></pre></li><li><p>visit函数遍历HTML的节点树，从每一个anchor元素的href属性获得link,将这些links存入字符串数组中，并返回这个字符串数组。</p><pre><code class="hljs Go"><span class="hljs-comment">// visit appends to links each link found in n and returns the result.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">visit</span><span class="hljs-params">(links []<span class="hljs-keyword">string</span>, n *html.Node)</span> []<span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="hljs-string">&quot;a&quot;</span> &#123;<span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> n.Attr &#123;<span class="hljs-keyword">if</span> a.Key == <span class="hljs-string">&quot;href&quot;</span> &#123;links = <span class="hljs-built_in">append</span>(links, a.Val)&#125;&#125;&#125;<span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;links = visit(links, c)&#125;<span class="hljs-keyword">return</span> links&#125;</code></pre></li><li><p>为了遍历结点n的所有后代结点，每次遇到n的孩子结点时，visit递归的调用自身。这些孩子结点存放在FirstChild链表中。</p></li></ul></li><li><p>在函数outline中，我们通过递归的方式遍历整个HTML结点树，并输出树的结构。在outline内部，每遇到一个HTML元素标签，就将其入栈，并输出。</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;doc, err := html.Parse(os.Stdin)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;outline: %v\n&quot;</span>, err)os.Exit(<span class="hljs-number">1</span>)&#125;outline(<span class="hljs-literal">nil</span>, doc)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">outline</span><span class="hljs-params">(stack []<span class="hljs-keyword">string</span>, n *html.Node)</span></span> &#123;<span class="hljs-keyword">if</span> n.Type == html.ElementNode &#123;stack = <span class="hljs-built_in">append</span>(stack, n.Data) <span class="hljs-comment">// push tag</span>fmt.Println(stack)&#125;<span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;outline(stack, c)&#125;&#125;</code></pre><ul><li>正如你在上面实验中所见，大部分HTML页面只需几层递归就能被处理，但仍然有些页面需要深层次的递归。</li></ul></li><li><p>大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。</p><ul><li>固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出</li><li>除此之外，还会导致安全性问题。</li><li>与此相反，Go语言使用可变栈，栈的大小按需增加（初始时很小）。这使得我们使用递归时不必考虑溢出和安全问题。</li></ul></li></ul><h3 id="ch5-3-多返回值"><a href="#ch5-3-多返回值" class="headerlink" title="ch5.3   多返回值"></a>ch5.3   多返回值</h3><ul><li><p>在Go中，一个函数可以返回多个值。我们已经在之前例子中看到，许多标准库中的函数返回2个值，一个是期望得到的返回值，另一个是函数出错时的错误信息。</p><ul><li><p>下面的例子会展示如何编写多返回值的函数。</p></li><li><p>下面的程序是findlinks的改进版本。修改后的findlinks可以自己发起HTTP请求，这样我们就不必再运行fetch。</p><ul><li>因为HTTP请求和解析操作可能会失败，因此findlinks声明了2个返回值：链接列表和错误信息。</li><li>一般而言，HTML的解析器可以处理HTML页面的错误结点，构造出HTML页面结构，所以解析HTML很少失败。</li><li>这意味着如果findlinks函数失败了，很可能是由于I/O的错误导致的。</li></ul></li></ul></li><li><p>findlinks2</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> _, url := <span class="hljs-keyword">range</span> os.Args[<span class="hljs-number">1</span>:] &#123;links, err := findLinks(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;findlinks2: %v\n&quot;</span>, err)<span class="hljs-keyword">continue</span>&#125;<span class="hljs-keyword">for</span> _, link := <span class="hljs-keyword">range</span> links &#123;fmt.Println(link)&#125;&#125;&#125;<span class="hljs-comment">// findLinks performs an HTTP GET request for url, parses the</span><span class="hljs-comment">// response as HTML, and extracts and returns the links.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLinks</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">string</span>, error)</span></span> &#123;resp, err := http.Get(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;<span class="hljs-keyword">if</span> resp.StatusCode != http.StatusOK &#123;resp.Body.Close()<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;getting %s: %s&quot;</span>, url, resp.Status)&#125;doc, err := html.Parse(resp.Body)resp.Body.Close()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;parsing %s as HTML: %v&quot;</span>, url, err)&#125;<span class="hljs-keyword">return</span> visit(<span class="hljs-literal">nil</span>, doc), <span class="hljs-literal">nil</span>&#125;</code></pre><ul><li>在findlinks中，有4处return语句，每一处return都返回了一组值。前三处return，将http和html包中的错误信息传递给findlinks的调用者。第一处return直接返回错误信息，其他两处通过fmt.Errorf（§7.8）输出详细的错误信息。如果findlinks成功结束，最后的return语句将一组解析获得的连接返回给用户。</li><li>在findlinks中，我们必须确保resp.Body被关闭，释放网络资源。虽然Go的垃圾回收机制会回收不被使用的内存，但是这不包括操作系统层面的资源，比如打开的文件、网络连接。因此我们必须显式的释放这些资源。</li></ul></li><li><p>调用多返回值函数时，返回给调用者的是一组值，调用者必须显式的将这些值分配给变量</p><pre><code class="hljs Go">links, err := findLinks(url)</code></pre><ul><li><p>如果某个值不被使用，可以将其分配给blank identifier</p><pre><code class="hljs Go">links, _ := findLinks(url) <span class="hljs-comment">// errors ignored</span></code></pre></li></ul></li><li><p>一个函数内部可以将另一个有多返回值的函数调用作为返回值</p><ul><li><p>下面的例子展示了与findLinks有相同功能的函数，两者的区别在于下面的例子先输出参数</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findLinksLog</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">string</span>, error)</span></span> &#123;log.Printf(<span class="hljs-string">&quot;findLinks %s&quot;</span>, url)<span class="hljs-keyword">return</span> findLinks(url)&#125;</code></pre></li></ul></li><li><p>当你调用接受多参数的函数时，可以将一个返回多参数的函数调用作为该函数的参数。</p><ul><li><p>虽然这很少出现在实际生产代码中，但这个特性在debug时很方便，我们只需要一条语句就可以输出所有的返回值。</p><ul><li><p>下面的代码是等价的</p><pre><code class="hljs Go">log.Println(findLinks(url))links, err := findLinks(url)log.Println(links, err)</code></pre></li></ul></li></ul></li><li><p>准确的变量名可以传达函数返回值的含义。尤其在返回值的类型都相同时，就像下面这样：</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Size</span><span class="hljs-params">(rect image.Rectangle)</span> <span class="hljs-params">(width, height <span class="hljs-keyword">int</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Split</span><span class="hljs-params">(path <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(dir, file <span class="hljs-keyword">string</span>)</span></span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">HourMinSec</span><span class="hljs-params">(t time.Time)</span> <span class="hljs-params">(hour, minute, second <span class="hljs-keyword">int</span>)</span></span></code></pre></li><li><p>虽然良好的命名很重要，但你也不必为每一个返回值都取一个适当的名字。</p><ul><li>比如，按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释。</li></ul></li><li><p>bare return</p><ul><li><p>如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数</p><pre><code class="hljs Go"><span class="hljs-comment">// CountWordsAndImages does an HTTP GET request for the HTML</span><span class="hljs-comment">// document url and returns the number of words and images in it.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CountWordsAndImages</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(words, images <span class="hljs-keyword">int</span>, err error)</span></span> &#123;resp, err := http.Get(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span>&#125;doc, err := html.Parse(resp.Body)resp.Body.Close()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;err = fmt.Errorf(<span class="hljs-string">&quot;parsing HTML: %s&quot;</span>, err)<span class="hljs-keyword">return</span>&#125;words, images = countWordsAndImages(doc)<span class="hljs-keyword">return</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">countWordsAndImages</span><span class="hljs-params">(n *html.Node)</span> <span class="hljs-params">(words, images <span class="hljs-keyword">int</span>)</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;</code></pre><ul><li><p>按照返回值列表的次序，返回所有的返回值，在上面的例子中，每一个return语句等价于：</p><pre><code class="hljs Go"><span class="hljs-keyword">return</span> words, images, err</code></pre></li></ul></li><li><p>当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。</p><ul><li>举个例子，如果你没有仔细的审查代码，很难发现前2处return等价于 return 0,0,err</li><li>Go会将返回值 words和images在函数体的开始处，根据它们的类型，将其初始化为0）</li><li>最后一处return等价于 return words, image, nil。</li></ul></li><li><p>基于以上原因，不宜过度使用bare return。</p></li></ul></li></ul><h3 id="ch5-4-错误"><a href="#ch5-4-错误" class="headerlink" title="ch5.4   错误"></a>ch5.4   错误</h3><ul><li><p>ch5.4.0简介</p><ul><li><p>在Go中有一部分函数总是能成功的运行。比如strings.Contains和strconv.FormatBool函数，对各种可能的输入都做了良好的处理，使得运行时几乎不会失败，除非遇到灾难性的、不可预料的情况，比如运行时的内存溢出。导致这种错误的原因很复杂，难以处理，从错误中恢复的可能性也很低。</p></li><li><p>还有一部分函数只要输入的参数满足一定条件，也能保证运行成功。比如time.Date函数，该函数将年月日等参数构造成time.Time对象，除非最后一个参数（时区）是nil。这种情况下会引发panic异常。panic是来自被调用函数的信号，表示发生了某个已知的bug。一个良好的程序永远不应该发生panic异常。</p></li><li><p>对于大部分函数而言，永远无法确保能否成功运行。这是因为错误的原因超出了程序员的控制。</p><ul><li>举个例子，任何进行I/O操作的函数都会面临出现错误的可能，只有没有经验的程序员才会相信读写操作不会失败，即使是简单的读写。因此，当本该可信的操作出乎意料的失败后，我们必须弄清楚导致失败的原因。</li></ul></li><li><p>在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。</p><ul><li><p>对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。</p><ul><li><p>如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。</p><ul><li><p>比如，cache.Lookup失败的唯一原因是key不存在，那么代码可以按照下面的方式组织</p><pre><code class="hljs Go">value, ok := cache.Lookup(key)<span class="hljs-keyword">if</span> !ok &#123;<span class="hljs-comment">// ...cache[key] does not exist…</span>&#125;</code></pre></li></ul></li></ul></li><li><p>通常，导致失败的原因不止一种，尤其是对I/O操作而言，用户需要了解更多的错误信息。因此，额外的返回值不再是简单的布尔类型，而是error类型。</p></li></ul></li><li><p>内置的error是接口类型。</p><ul><li><p>我们将在第七章了解接口类型的含义，以及它对错误处理的影响。现在我们只需要明白error类型可能是nil或者non-nil。</p><ul><li><p>nil意味着函数运行成功，non-nil表示失败。</p></li><li><p>对于non-nil的error类型，我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。</p><pre><code class="hljs Go">fmt.Println(err)fmt.Printf(<span class="hljs-string">&quot;%v&quot;</span>, err)</code></pre></li></ul></li><li><p>通常，当函数返回non-nil的error时，其他的返回值是未定义的（undefined），这些未定义的返回值应该被忽略。</p><ul><li><p>然而，有少部分函数在发生错误时，仍然会返回一些有用的返回值。</p><ul><li>比如，当读取文件发生错误时，Read函数会返回可以读取的字节数以及错误信息。</li></ul></li><li><p>对于这种情况，正确的处理方式应该是先处理这些不完整的数据，再处理错误。因此对函数的返回值要有清晰的说明，以便于其他人使用。</p></li></ul></li></ul></li><li><p>在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。</p><ul><li>虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。</li></ul></li><li><p>Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。</p><ul><li>当某个程序错误被当作异常处理后，这个错误会将堆栈跟踪信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。</li><li>正因此，Go使用控制流机制（如if和return）处理错误，这使得编码人员能更多的关注错误处理。</li></ul></li></ul></li><li><p>ch5.4.1错误处理策略</p><ul><li><p>当一次函数调用返回错误时，调用者应该选择合适的方式处理错误。根据情况的不同，有很多处理方式，让我们来看看常用的五种方式。</p></li><li><p>首先，也是最常用的方式是传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。</p><ul><li><p>下面，我们以5.3节的findLinks函数作为例子。如果findLinks对http.Get的调用失败，findLinks会直接将这个HTTP错误返回给调用者</p><pre><code class="hljs Go">resp, err := http.Get(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;</code></pre></li><li><p>当对html.Parse的调用失败时，findLinks不会直接返回html.Parse的错误，因为缺少两条重要信息</p><ul><li>1、发生错误时的解析器（html parser）</li><li>2、发生错误的url</li></ul></li><li><p>因此，findLinks构造了一个新的错误信息，既包含了这两项，也包括了底层的解析出错的信息。</p><pre><code class="hljs Go">doc, err := html.Parse(resp.Body)resp.Body.Close()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;parsing %s as HTML: %v&quot;</span>, url,err)&#125;</code></pre></li><li><p>fmt.Errorf函数使用fmt.Sprintf格式化错误信息并返回。我们使用该函数添加额外的前缀上下文信息到原始错误信息。当错误最终由main函数处理时，错误信息应提供清晰的从原因到后果的因果链，就像美国宇航局事故调查时做的那样</p><pre><code class="hljs groovy"><span class="hljs-attr">genesis:</span> <span class="hljs-attr">crashed:</span> no <span class="hljs-attr">parachute:</span> G-<span class="hljs-keyword">switch</span> <span class="hljs-attr">failed:</span> bad relay orientation</code></pre></li><li><p>由于错误信息经常是以链式组合在一起的，所以错误信息中应避免大写和换行符。最终的错误信息可能很长，我们可以通过类似grep的工具处理错误信息</p><ul><li>grep是一种文本搜索工具</li></ul></li><li><p>编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。</p><ul><li>尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。</li></ul></li><li><p>以os包为例，os包确保文件操作（如os.Open、Read、Write、Close）返回的每个错误的描述不仅仅包含错误的原因）也包含文件名，这样调用者在构造新的错误信息时无需再添加这些信息。</p><ul><li>如无权限，文件目录不存在</li></ul></li><li><p>一般而言，被调用函数f(x)会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息</p><ul><li>比如添加url到html.Parse返回的错误中。</li></ul></li></ul></li><li><p>让我们来看看处理错误的第二种策略。如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。</p><pre><code class="hljs Go"><span class="hljs-comment">// WaitForServer attempts to contact the server of a URL.</span><span class="hljs-comment">// It tries for one minute using exponential back-off.</span><span class="hljs-comment">// It reports an error if all attempts fail.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WaitForServer</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;<span class="hljs-keyword">const</span> timeout = <span class="hljs-number">1</span> * time.Minutedeadline := time.Now().Add(timeout)<span class="hljs-keyword">for</span> tries := <span class="hljs-number">0</span>; time.Now().Before(deadline); tries++ &#123;_, err := http.Head(url)<span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span> <span class="hljs-comment">// success</span>&#125;log.Printf(<span class="hljs-string">&quot;server not responding (%s);retrying…&quot;</span>, err)time.Sleep(time.Second &lt;&lt; <span class="hljs-keyword">uint</span>(tries)) <span class="hljs-comment">// exponential back-off</span>&#125;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;server %s failed to respond after %s&quot;</span>, url, timeout)&#125;</code></pre></li><li><p>如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。</p><ul><li><p>需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。</p><pre><code class="hljs Go"><span class="hljs-comment">// (In function main.)</span><span class="hljs-keyword">if</span> err := WaitForServer(url); err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Site is down: %v\n&quot;</span>, err)os.Exit(<span class="hljs-number">1</span>)&#125;</code></pre></li><li><p>调用log.Fatalf可以更简洁的代码达到与上文相同的效果。log中的所有函数，都默认会在错误信息之前输出时间信息。</p><pre><code class="hljs Go"><span class="hljs-keyword">if</span> err := WaitForServer(url); err != <span class="hljs-literal">nil</span> &#123;log.Fatalf(<span class="hljs-string">&quot;Site is down: %v\n&quot;</span>, err)&#125;</code></pre><ul><li><p>长时间运行的服务器常采用默认的时间格式，而交互式工具很少采用包含如此多信息的格式。</p><pre><code class="hljs angelscript"><span class="hljs-number">2006</span>/<span class="hljs-number">01</span>/<span class="hljs-number">02</span> <span class="hljs-number">15</span>:<span class="hljs-number">04</span>:<span class="hljs-number">05</span> Site <span class="hljs-keyword">is</span> down: no such domain:bad.gopl.io</code></pre></li><li><p>我们可以设置log的前缀信息屏蔽时间信息，一般而言，前缀信息会被设置成命令名。</p><pre><code class="hljs Go">log.SetPrefix(<span class="hljs-string">&quot;wait: &quot;</span>)log.SetFlags(<span class="hljs-number">0</span>)</code></pre></li></ul></li></ul></li><li><p>第四种策略：有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过log包提供函数</p><pre><code class="hljs Go"><span class="hljs-keyword">if</span> err := Ping(); err != <span class="hljs-literal">nil</span> &#123;log.Printf(<span class="hljs-string">&quot;ping failed: %v; networking disabled&quot;</span>,err)&#125;</code></pre><ul><li><p>或者标准错误流输出错误信息。</p><pre><code class="hljs Go"><span class="hljs-keyword">if</span> err := Ping(); err != <span class="hljs-literal">nil</span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;ping failed: %v; networking disabled\n&quot;</span>, err)&#125;</code></pre></li><li><p>log包中的所有函数会为没有换行符的字符串增加换行符。</p></li></ul></li><li><p>第五种，也是最后一种策略：我们可以直接忽略掉错误。</p><pre><code class="hljs Go">dir, err := ioutil.TempDir(<span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;scratch&quot;</span>)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;failed to create temp dir: %v&quot;</span>,err)&#125;<span class="hljs-comment">// ...use temp dir…</span>os.RemoveAll(dir) <span class="hljs-comment">// ignore errors; $TMPDIR is cleaned periodically</span></code></pre><ul><li>尽管os.RemoveAll会失败，但上面的例子并没有做错误处理。这是因为操作系统会定期的清理临时目录。正因如此，虽然程序没有处理错误，但程序的逻辑不会因此受到影响。我们应该在每次函数调用后，都养成考虑错误处理的习惯，当你决定忽略某个错误时，你应该清晰地写下你的意图。</li></ul></li><li><p>在Go中，错误处理有一套独特的编码风格。</p><ul><li>检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。</li><li>如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。</li><li>Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。</li></ul></li></ul></li><li><p>ch5.4.2文件结尾错误（EOF）</p><ul><li><p>函数经常会返回多种错误，这对终端用户来说可能会很有趣，但对程序而言，这使得情况变得复杂。很多时候，程序必须根据错误类型，作出不同的响应。</p><ul><li><p>让我们考虑这样一个例子：从文件中读取n个字节。如果n等于文件的长度，读取过程的任何错误都表示失败。</p></li><li><p>如果n小于文件的长度，调用者会重复的读取固定大小的数据直到文件结束。这会导致调用者必须分别处理由文件结束引起的各种错误。</p></li><li><p>基于这样的原因，io包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF，该错误在io包中定义</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> io<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;errors&quot;</span><span class="hljs-comment">// EOF is the error returned by Read when no more input is available.</span><span class="hljs-keyword">var</span> EOF = errors.New(<span class="hljs-string">&quot;EOF&quot;</span>)</code></pre></li></ul></li><li><p>调用者只需通过简单的比较，就可以检测出这个错误。</p><ul><li><p>下面的例子展示了如何从标准输入中读取字符，以及判断文件结束。</p><pre><code class="hljs Go">in := bufio.NewReader(os.Stdin)<span class="hljs-keyword">for</span> &#123;r, _, err := in.ReadRune()<span class="hljs-keyword">if</span> err == io.EOF &#123;<span class="hljs-keyword">break</span> <span class="hljs-comment">// finished reading</span>&#125;<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;read failed:%v&quot;</span>, err)&#125;<span class="hljs-comment">// ...use r…</span>&#125;</code></pre><ul><li>4.3的chartcount程序展示了更加复杂的代码</li></ul></li></ul></li><li><p>因为文件结束这种错误不需要更多的描述，所以io.EOF有固定的错误信息——“EOF”。对于其他错误，我们可能需要在错误信息中描述错误的类型和数量，这使得我们不能像io.EOF一样采用固定的错误信息。在7.11节中，我们会提出更系统的方法区分某些固定的错误值。</p></li></ul></li></ul><h3 id="ch5-5-函数值"><a href="#ch5-5-函数值" class="headerlink" title="ch5.5   函数值"></a>ch5.5   函数值</h3><ul><li><p>在Go中，函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。</p><ul><li><p>例子如下：</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">square</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> n * n &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">negative</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> -n &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">product</span><span class="hljs-params">(m, n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123; <span class="hljs-keyword">return</span> m * n &#125;  f := squarefmt.Println(f(<span class="hljs-number">3</span>)) <span class="hljs-comment">// &quot;9&quot;</span>  f = negativefmt.Println(f(<span class="hljs-number">3</span>))     <span class="hljs-comment">// &quot;-3&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, f) <span class="hljs-comment">// &quot;func(int) int&quot;</span>  f = product <span class="hljs-comment">// compile error: can&#x27;t assign func(int, int) int to func(int) int</span></code></pre></li><li><p>函数类型的零值是nil。调用值为nil的函数值会引起panic错误：</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span>f(<span class="hljs-number">3</span>) <span class="hljs-comment">// 此处f的值为nil, 会引起panic错误</span></code></pre></li></ul></li><li><p>函数值可以与nil比较</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span><span class="hljs-keyword">if</span> f != <span class="hljs-literal">nil</span> &#123;f(<span class="hljs-number">3</span>)&#125;</code></pre><ul><li>但是函数值之间是不可比较的，也不能用函数值作为map的key。</li></ul></li><li><p>函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为。</p><ul><li><p>标准库中包含许多这样的例子。下面的代码展示了如何使用这个技巧。strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者。</p><p>func add1(r rune) rune { return r + 1 }</p><pre><code>fmt.Println(strings.Map(add1, &quot;HAL-9000&quot;)) // &quot;IBM.:111&quot;fmt.Println(strings.Map(add1, &quot;VMS&quot;))      // &quot;WNT&quot;fmt.Println(strings.Map(add1, &quot;Admix&quot;))    // &quot;Benjy&quot;</code></pre></li><li><p>5.2节的findLinks函数使用了辅助函数visit，遍历和操作了HTML页面的所有结点。使用函数值，我们可以将遍历结点的逻辑和操作结点的逻辑分离，使得我们可以复用遍历的逻辑，从而对结点进行不同的操作。</p><p><u><i>gopl.io/ch5/outline2</i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// forEachNode针对每个结点x，都会调用pre(x)和post(x)。</span><span class="hljs-comment">// pre和post都是可选的。</span><span class="hljs-comment">// 遍历孩子结点之前，pre被调用</span><span class="hljs-comment">// 遍历孩子结点之后，post被调用</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">forEachNode</span><span class="hljs-params">(n *html.Node, pre, post <span class="hljs-keyword">func</span>(n *html.Node)</span>)</span> &#123;<span class="hljs-keyword">if</span> pre != <span class="hljs-literal">nil</span> &#123;pre(n)&#125;<span class="hljs-keyword">for</span> c := n.FirstChild; c != <span class="hljs-literal">nil</span>; c = c.NextSibling &#123;forEachNode(c, pre, post)&#125;<span class="hljs-keyword">if</span> post != <span class="hljs-literal">nil</span> &#123;post(n)&#125;&#125;</code></pre><ul><li><p>该函数接收2个函数作为参数，分别在结点的孩子被访问前和访问后调用。</p></li><li><p>这样的设计给调用者更大的灵活性。举个例子，现在我们有startElemen和endElement两个函数用于输出HTML元素的开始标签和结束标签<code>&lt;b&gt;...&lt;/b&gt;</code>：</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> depth <span class="hljs-keyword">int</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">startElement</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<span class="hljs-keyword">if</span> n.Type == html.ElementNode &#123;fmt.Printf(<span class="hljs-string">&quot;%*s&lt;%s&gt;\n&quot;</span>, depth*<span class="hljs-number">2</span>, <span class="hljs-string">&quot;&quot;</span>, n.Data)depth++&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">endElement</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<span class="hljs-keyword">if</span> n.Type == html.ElementNode &#123;depth--fmt.Printf(<span class="hljs-string">&quot;%*s&lt;/%s&gt;\n&quot;</span>, depth*<span class="hljs-number">2</span>, <span class="hljs-string">&quot;&quot;</span>, n.Data)&#125;&#125;</code></pre><ul><li><p>上面的代码利用fmt.Printf的一个小技巧控制输出的缩进。<code>%*s</code>中的<code>*</code>会在字符串之前填充一些空格。</p></li><li><p>在例子中，每次输出会先填充<code>depth*2</code>数量的空格，再输出””，最后再输出HTML标签。</p></li><li><p>如果我们像下面这样调用forEachNode</p><pre><code class="hljs Go">forEachNode(doc, startElement, endElement)</code></pre><ul><li><p>与之前的outline程序相比，我们得到了更加详细的页面结构</p><pre><code class="hljs dts">$ go build gopl.io<span class="hljs-meta-keyword">/ch5/</span>outline2$ ./outline2 http:<span class="hljs-comment">//gopl.io</span><span class="hljs-params">&lt;html&gt;</span>  <span class="hljs-params">&lt;head&gt;</span>    <span class="hljs-params">&lt;meta&gt;</span>    <span class="hljs-params">&lt;/meta&gt;</span>    <span class="hljs-params">&lt;title&gt;</span><span class="hljs-params">&lt;/title&gt;</span><span class="hljs-params">&lt;style&gt;</span><span class="hljs-params">&lt;/style&gt;</span>  <span class="hljs-params">&lt;/head&gt;</span>  <span class="hljs-params">&lt;body&gt;</span>    <span class="hljs-params">&lt;table&gt;</span>      <span class="hljs-params">&lt;tbody&gt;</span>        <span class="hljs-params">&lt;tr&gt;</span>          <span class="hljs-params">&lt;td&gt;</span>            <span class="hljs-params">&lt;a&gt;</span>              <span class="hljs-params">&lt;img&gt;</span>              <span class="hljs-params">&lt;/img&gt;</span>...</code></pre></li></ul></li></ul></li></ul></li></ul></li></ul><h3 id="ch5-6-匿名函数"><a href="#ch5-6-匿名函数" class="headerlink" title="ch5.6   匿名函数"></a>ch5.6   匿名函数</h3><ul><li><p>拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数（anonymous function）。</p></li><li><p>函数字面量允许我们在使用函数时，再定义它。通过这种技巧，我们可以改写之前对strings.Map的调用</p><pre><code class="hljs Go">strings.Map(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(r <span class="hljs-keyword">rune</span>)</span> <span class="hljs-title">rune</span></span> &#123; <span class="hljs-keyword">return</span> r + <span class="hljs-number">1</span> &#125;, <span class="hljs-string">&quot;HAL-9000&quot;</span>)</code></pre></li><li><p>更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量</p><ul><li><p>如下例所示：</p><p><u><i>gopl.io/ch5/squares</i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// squares返回一个匿名函数。</span><span class="hljs-comment">// 该匿名函数每次被调用时都会返回下一个数的平方。</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squares</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">var</span> x <span class="hljs-keyword">int</span><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;x++<span class="hljs-keyword">return</span> x * x&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f := squares()fmt.Println(f()) <span class="hljs-comment">// &quot;1&quot;</span>fmt.Println(f()) <span class="hljs-comment">// &quot;4&quot;</span>fmt.Println(f()) <span class="hljs-comment">// &quot;9&quot;</span>fmt.Println(f()) <span class="hljs-comment">// &quot;16&quot;</span>&#125;</code></pre><ul><li>函数squares返回另一个类型为 func() int 的函数。对squares的一次调用会生成一个局部变量x并返回一个匿名函数。</li><li>每次调用匿名函数时，该函数都会先使x的值加1，再返回x的平方。</li><li>第二次调用squares时，会生成第二个x变量，并返回一个新的匿名函数。新匿名函数操作的是第二个x变量。</li></ul></li></ul></li><li><p>squares的例子证明，函数值不仅仅是一串代码，还记录了状态。</p><ul><li>在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。</li><li>这就是函数值属于引用类型和函数值不可比较的原因。</li><li>Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。</li><li>通过这个例子，我们看到变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。</li></ul></li><li><p>接下来，我们讨论一个有点学术性的例子，考虑这样一个问题：给定一些计算机课程，每个课程都有前置课程，只有完成了前置课程才可以开始当前课程的学习；我们的目标是选择出一组课程，这组课程必须确保按顺序学习时，能全部被完成。</p><ul><li><p>每个课程的前置课程如下：</p><p><u><i>gopl.io/ch5/toposort</i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// prereqs记录了每个课程的前置课程</span><span class="hljs-keyword">var</span> prereqs = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;algorithms&quot;</span>: &#123;<span class="hljs-string">&quot;data structures&quot;</span>&#125;,<span class="hljs-string">&quot;calculus&quot;</span>: &#123;<span class="hljs-string">&quot;linear algebra&quot;</span>&#125;,<span class="hljs-string">&quot;compilers&quot;</span>: &#123;<span class="hljs-string">&quot;data structures&quot;</span>,<span class="hljs-string">&quot;formal languages&quot;</span>,<span class="hljs-string">&quot;computer organization&quot;</span>,&#125;,<span class="hljs-string">&quot;data structures&quot;</span>:       &#123;<span class="hljs-string">&quot;discrete math&quot;</span>&#125;,<span class="hljs-string">&quot;databases&quot;</span>:             &#123;<span class="hljs-string">&quot;data structures&quot;</span>&#125;,<span class="hljs-string">&quot;discrete math&quot;</span>:         &#123;<span class="hljs-string">&quot;intro to programming&quot;</span>&#125;,<span class="hljs-string">&quot;formal languages&quot;</span>:      &#123;<span class="hljs-string">&quot;discrete math&quot;</span>&#125;,<span class="hljs-string">&quot;networks&quot;</span>:              &#123;<span class="hljs-string">&quot;operating systems&quot;</span>&#125;,<span class="hljs-string">&quot;operating systems&quot;</span>:     &#123;<span class="hljs-string">&quot;data structures&quot;</span>, <span class="hljs-string">&quot;computer organization&quot;</span>&#125;,<span class="hljs-string">&quot;programming languages&quot;</span>: &#123;<span class="hljs-string">&quot;data structures&quot;</span>, <span class="hljs-string">&quot;computer organization&quot;</span>&#125;,&#125;</code></pre></li><li><p>这类问题被称作拓扑排序。从概念上说，前置条件可以构成有向图。图中的顶点表示课程，边表示课程间的依赖关系。显然，图中应该无环，这也就是说从某点出发的边，最终不会回到该点。</p></li><li><p>下面的代码用深度优先搜索了整张图，获得了符合要求的课程序列。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">for</span> i, course := <span class="hljs-keyword">range</span> topoSort(prereqs) &#123;fmt.Printf(<span class="hljs-string">&quot;%d:\t%s\n&quot;</span>, i+<span class="hljs-number">1</span>, course)&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">topoSort</span><span class="hljs-params">(m <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]<span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;<span class="hljs-keyword">var</span> order []<span class="hljs-keyword">string</span>seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)<span class="hljs-keyword">var</span> visitAll <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(items []<span class="hljs-keyword">string</span>)</span></span>visitAll = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(items []<span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;<span class="hljs-keyword">if</span> !seen[item] &#123;seen[item] = <span class="hljs-literal">true</span>visitAll(m[item])order = <span class="hljs-built_in">append</span>(order, item)&#125;&#125;&#125;<span class="hljs-keyword">var</span> keys []<span class="hljs-keyword">string</span><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> m &#123;keys = <span class="hljs-built_in">append</span>(keys, key)&#125;sort.Strings(keys)visitAll(keys)<span class="hljs-keyword">return</span> order&#125;</code></pre></li></ul></li><li><p>当匿名函数需要被递归调用时，我们必须首先声明一个变量（在上面的例子中，我们首先声明了 visitAll），再将匿名函数赋值给这个变量。如果不分成两步，函数字面量无法与visitAll绑定，我们也无法递归调用该匿名函数。</p><pre><code class="hljs Go">visitAll := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(items []<span class="hljs-keyword">string</span>)</span></span> &#123;<span class="hljs-comment">// ...</span>visitAll(m[item]) <span class="hljs-comment">// compile error: undefined: visitAll</span><span class="hljs-comment">// ...</span>&#125;</code></pre><ul><li><p>在toposort程序的输出如下所示，它的输出顺序是大多人想看到的固定顺序输出，但是这需要我们多花点心思才能做到。</p><pre><code class="hljs angelscript"><span class="hljs-number">1</span>: <span class="hljs-built_in">int</span>ro to programming<span class="hljs-number">2</span>: discrete math<span class="hljs-number">3</span>: data structures<span class="hljs-number">4</span>: algorithms<span class="hljs-number">5</span>: linear algebra<span class="hljs-number">6</span>: calculus<span class="hljs-number">7</span>: formal languages<span class="hljs-number">8</span>: computer organization<span class="hljs-number">9</span>: compilers<span class="hljs-number">10</span>: databases<span class="hljs-number">11</span>: operating systems<span class="hljs-number">12</span>: networks<span class="hljs-number">13</span>: programming languages</code></pre></li><li><p>哈希表prepreqs的value是遍历顺序固定的切片，而不再是遍历顺序随机的map，所以我们对prereqs的key值进行排序，保证每次运行toposort程序，都以相同的遍历顺序遍历prereqs。</p></li></ul></li><li><p>让我们回到findLinks这个例子。我们将代码移动到了links包下，将函数重命名为Extract，在第八章我们会再次用到这个函数。新的匿名函数被引入，用于替换原来的visit函数。该匿名函数负责将新连接添加到切片中。在Extract中，使用forEachNode遍历HTML页面，由于Extract只需要在遍历结点前操作结点，所以forEachNode的post参数被传入nil。</p><p><u><i>gopl.io/ch5/links</i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// Package links provides a link-extraction function.</span><span class="hljs-keyword">package</span> links<span class="hljs-keyword">import</span> (<span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-string">&quot;net/http&quot;</span><span class="hljs-string">&quot;golang.org/x/net/html&quot;</span>)<span class="hljs-comment">// Extract makes an HTTP GET request to the specified URL, parses</span><span class="hljs-comment">// the response as HTML, and returns the links in the HTML document.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Extract</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">string</span>, error)</span></span> &#123;resp, err := http.Get(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;<span class="hljs-keyword">if</span> resp.StatusCode != http.StatusOK &#123;resp.Body.Close()<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;getting %s: %s&quot;</span>, url, resp.Status)&#125;doc, err := html.Parse(resp.Body)resp.Body.Close()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, fmt.Errorf(<span class="hljs-string">&quot;parsing %s as HTML: %v&quot;</span>, url, err)&#125;<span class="hljs-keyword">var</span> links []<span class="hljs-keyword">string</span>visitNode := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<span class="hljs-keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="hljs-string">&quot;a&quot;</span> &#123;<span class="hljs-keyword">for</span> _, a := <span class="hljs-keyword">range</span> n.Attr &#123;<span class="hljs-keyword">if</span> a.Key != <span class="hljs-string">&quot;href&quot;</span> &#123;<span class="hljs-keyword">continue</span>&#125;link, err := resp.Request.URL.Parse(a.Val)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">continue</span> <span class="hljs-comment">// ignore bad URLs</span>&#125;links = <span class="hljs-built_in">append</span>(links, link.String())&#125;&#125;&#125;forEachNode(doc, visitNode, <span class="hljs-literal">nil</span>)<span class="hljs-keyword">return</span> links, <span class="hljs-literal">nil</span>&#125;</code></pre><ul><li>上面的代码对之前的版本做了改进，现在links中存储的不是href属性的原始值，而是通过resp.Request.URL解析后的值。解析后，这些连接以绝对路径的形式存在，可以直接被http.Get访问。</li></ul></li><li><p>网页抓取的核心问题就是如何遍历图。在topoSort的例子中，已经展示了深度优先遍历，在网页抓取中，我们会展示如何用广度优先遍历图。在第8章，我们会介绍如何将深度优先和广度优先结合使用。</p><ul><li><p>下面的函数实现了广度优先算法。调用者需要输入一个初始的待访问列表和一个函数f。待访问列表中的每个元素被定义为string类型。广度优先算法会为每个元素调用一次f。每次f执行完毕后，会返回一组待访问元素。这些元素会被加入到待访问列表中。当待访问列表中的所有元素都被访问后，breadthFirst函数运行结束。为了避免同一个元素被访问两次，代码中维护了一个map。</p><p><u><i>gopl.io/ch5/findlinks3</i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// breadthFirst calls f for each item in the worklist.</span><span class="hljs-comment">// Any items returned by f are added to the worklist.</span><span class="hljs-comment">// f is called at most once for each item.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">breadthFirst</span><span class="hljs-params">(f <span class="hljs-keyword">func</span>(item <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span>, <span class="hljs-title">worklist</span> []<span class="hljs-title">string</span>)</span> &#123;seen := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>)<span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(worklist) &gt; <span class="hljs-number">0</span> &#123;items := worklistworklist = <span class="hljs-literal">nil</span><span class="hljs-keyword">for</span> _, item := <span class="hljs-keyword">range</span> items &#123;<span class="hljs-keyword">if</span> !seen[item] &#123;seen[item] = <span class="hljs-literal">true</span>worklist = <span class="hljs-built_in">append</span>(worklist, f(item)...)&#125;&#125;&#125;&#125;</code></pre><ul><li><p>就像我们在章节3解释的那样，append的参数“f(item)…”，会将f返回的一组元素一个个添加到worklist中。</p></li><li><p>在我们网页抓取器中，元素的类型是url。crawl函数会将URL输出，提取其中的新链接，并将这些新链接返回。我们会将crawl作为参数传递给breadthFirst。</p><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">crawl</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> []<span class="hljs-title">string</span></span> &#123;fmt.Println(url)list, err := links.Extract(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;log.Print(err)&#125;<span class="hljs-keyword">return</span> list&#125;</code></pre></li><li><p>为了使抓取器开始运行，我们用命令行输入的参数作为初始的待访问url。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-comment">// Crawl the web breadth-first,</span><span class="hljs-comment">// starting from the command-line arguments.</span>breadthFirst(crawl, os.Args[<span class="hljs-number">1</span>:])&#125;</code></pre></li><li><p>让我们从 <a href="https://golang.org/">https://golang.org</a> 开始，下面是程序的输出结果：</p><pre><code class="hljs dts">$ go build gopl.io<span class="hljs-meta-keyword">/ch5/</span>findlinks3$ ./findlinks3 https:<span class="hljs-comment">//golang.org</span><span class="hljs-symbol">https:</span><span class="hljs-comment">//golang.org/</span><span class="hljs-symbol">https:</span><span class="hljs-comment">//golang.org/doc/</span><span class="hljs-symbol">https:</span><span class="hljs-comment">//golang.org/pkg/</span><span class="hljs-symbol">https:</span><span class="hljs-comment">//golang.org/project/</span><span class="hljs-symbol">https:</span><span class="hljs-comment">//code.google.com/p/go-tour/</span><span class="hljs-symbol">https:</span><span class="hljs-comment">//golang.org/doc/code.html</span><span class="hljs-symbol">https:</span><span class="hljs-comment">//www.youtube.com/watch?v=XCsL89YtqCs</span><span class="hljs-symbol">http:</span><span class="hljs-comment">//research.swtch.com/gotour</span></code></pre></li><li><p>当所有发现的链接都已经被访问或电脑的内存耗尽时，程序运行结束。</p></li></ul></li></ul></li></ul><h3 id="ch5-7-可变参数"><a href="#ch5-7-可变参数" class="headerlink" title="ch5.7   可变参数"></a>ch5.7   可变参数</h3><ul><li><p>参数数量可变的函数称为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个必备的参数，之后接收任意个数的后续参数。</p></li><li><p>在声明可变参数函数时，需要在参数列表的最后一个参数类型之前加上省略符号“…”，这表示该函数会接收任意数量的该类型参数。</p><p><u><i>gopl.io/ch5/sum</i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sum</span><span class="hljs-params">(vals ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;total := <span class="hljs-number">0</span><span class="hljs-keyword">for</span> _, val := <span class="hljs-keyword">range</span> vals &#123;total += val&#125;<span class="hljs-keyword">return</span> total&#125;</code></pre><ul><li><p>sum函数返回任意个int型参数的和。在函数体中，vals被看作是类型为[] int的切片。sum可以接收任意数量的int型参数</p><pre><code class="hljs Go">fmt.Println(sum())           <span class="hljs-comment">// &quot;0&quot;</span>fmt.Println(sum(<span class="hljs-number">3</span>))          <span class="hljs-comment">// &quot;3&quot;</span>fmt.Println(sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)) <span class="hljs-comment">// &quot;10&quot;</span></code></pre></li><li><p>在上面的代码中，调用者隐式的创建一个数组，并将原始参数复制到数组中，再把数组的一个切片作为参数传给被调用函数。</p></li><li><p>如果原始参数已经是切片类型，我们该如何传递给sum？只需在最后一个参数后加上省略符。下面的代码功能与上个例子中最后一条语句相同。</p><pre><code class="hljs Go">values := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;fmt.Println(sum(values...)) <span class="hljs-comment">// &quot;10&quot;</span></code></pre></li></ul></li><li><p>虽然在可变参数函数内部，…int 型参数的行为看起来很像切片类型，但实际上，可变参数函数和以切片作为参数的函数是不同的。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(...<span class="hljs-keyword">int</span>)</span></span> &#123;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">g</span><span class="hljs-params">([]<span class="hljs-keyword">int</span>)</span></span> &#123;&#125;fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, f) <span class="hljs-comment">// &quot;func(...int)&quot;</span>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, g) <span class="hljs-comment">// &quot;func([]int)&quot;</span></code></pre><ul><li><p>可变参数函数经常被用于格式化字符串。下面的errorf函数构造了一个以行号开头的，经过格式化的错误信息。函数名的后缀f是一种通用的命名规范，代表该可变参数函数可以接收Printf风格的格式化字符串。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">errorf</span><span class="hljs-params">(linenum <span class="hljs-keyword">int</span>, format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;fmt.Fprintf(os.Stderr, <span class="hljs-string">&quot;Line %d: &quot;</span>, linenum)fmt.Fprintf(os.Stderr, format, args...)fmt.Fprintln(os.Stderr)&#125;linenum, name := <span class="hljs-number">12</span>, <span class="hljs-string">&quot;count&quot;</span>errorf(linenum, <span class="hljs-string">&quot;undefined: %s&quot;</span>, name) <span class="hljs-comment">// &quot;Line 12: undefined: count&quot;</span></code></pre></li><li><p>interface{}表示函数的最后一个参数可以接收任意类型，我们会在第7章详细介绍。</p></li></ul></li></ul><h3 id="ch5-8-Deferred函数"><a href="#ch5-8-Deferred函数" class="headerlink" title="ch5.8   Deferred函数"></a>ch5.8   Deferred函数</h3><ul><li><p>在findLinks的例子中，我们用http.Get的输出作为html.Parse的输入。只有url的内容的确是HTML格式的，html.Parse才可以正常工作，但实际上，url指向的内容很丰富，可能是图片，纯文本或是其他。将这些格式的内容传递给html.parse，会产生不良后果。</p></li><li><p>下面的例子获取HTML页面并输出页面的标题。title函数会检查服务器返回的Content-Type字段，如果发现页面不是HTML，将终止函数运行，返回错误。</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">title</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;resp, err := http.Get(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-comment">// Check Content-Type is HTML (e.g., &quot;text/html;charset=utf-8&quot;).</span>ct := resp.Header.Get(<span class="hljs-string">&quot;Content-Type&quot;</span>)<span class="hljs-keyword">if</span> ct != <span class="hljs-string">&quot;text/html&quot;</span> &amp;&amp; !strings.HasPrefix(ct,<span class="hljs-string">&quot;text/html;&quot;</span>) &#123;resp.Body.Close()<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s has type %s, not text/html&quot;</span>,url, ct)&#125;doc, err := html.Parse(resp.Body)resp.Body.Close()<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;parsing %s as HTML: %v&quot;</span>, url,err)&#125;visitNode := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<span class="hljs-keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="hljs-string">&quot;title&quot;</span>&amp;&amp;n.FirstChild != <span class="hljs-literal">nil</span> &#123;fmt.Println(n.FirstChild.Data)&#125;&#125;forEachNode(doc, visitNode, <span class="hljs-literal">nil</span>)<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre><ul><li><p>下面展示了运行效果：</p><pre><code class="hljs groovy">$ go build gopl.io<span class="hljs-regexp">/ch5/</span>title1$ .<span class="hljs-regexp">/title1 http:/</span>/gopl.ioThe Go Programming Language$ .<span class="hljs-regexp">/title1 https:/</span><span class="hljs-regexp">/golang.org/</span>doc/effective_go.htmlEffective Go - The Go Programming Language$ .<span class="hljs-regexp">/title1 https:/</span><span class="hljs-regexp">/golang.org/</span>doc<span class="hljs-regexp">/gopher/</span>frontpage.png<span class="hljs-attr">title1:</span> <span class="hljs-attr">https:</span><span class="hljs-comment">//golang.org/doc/gopher/frontpage.png has type image/png, not text/html</span></code></pre></li><li><p>resp.Body.close调用了多次，这是为了确保title在所有执行路径下（即使函数运行失败）都关闭了网络连接。随着函数变得复杂，需要处理的错误也变多，维护清理逻辑变得越来越困难。而Go语言独有的defer机制可以让事情变得简单。</p></li></ul></li><li><p>你只需要在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。</p></li><li><p>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。</p><ul><li><p>在下面的代码中，一条defer语句替代了之前的所有resp.Body.Close</p><p><u><i>gopl.io/ch5/title2</i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">title</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;resp, err := http.Get(url)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">defer</span> resp.Body.Close()ct := resp.Header.Get(<span class="hljs-string">&quot;Content-Type&quot;</span>)<span class="hljs-keyword">if</span> ct != <span class="hljs-string">&quot;text/html&quot;</span> &amp;&amp; !strings.HasPrefix(ct,<span class="hljs-string">&quot;text/html;&quot;</span>) &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;%s has type %s, not text/html&quot;</span>,url, ct)&#125;doc, err := html.Parse(resp.Body)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> fmt.Errorf(<span class="hljs-string">&quot;parsing %s as HTML: %v&quot;</span>, url,err)&#125;<span class="hljs-comment">// ...print doc&#x27;s title element…</span><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>&#125;</code></pre></li><li><p>在处理其他资源时，也可以采用defer机制，比如对文件的操作：</p><p></i></u></p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> ioutil<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFile</span><span class="hljs-params">(filename <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;f, err := os.Open(filename)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err&#125;<span class="hljs-keyword">defer</span> f.Close()<span class="hljs-keyword">return</span> ReadAll(f)&#125;</code></pre></li><li><p>或是处理互斥锁</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> mu sync.Mutex<span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">lookup</span><span class="hljs-params">(key <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int</span></span> &#123;mu.Lock()<span class="hljs-keyword">defer</span> mu.Unlock()<span class="hljs-keyword">return</span> m[key]&#125;</code></pre></li></ul></li><li><p>调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。</p><ul><li><p>下例中的bigSlowOperation函数，直接调用trace记录函数的被调情况。bigSlowOperation被调时，trace会返回一个函数值，该函数值会在bigSlowOperation退出时被调用。</p><p><u><i>gopl.io/ch5/trace</i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bigSlowOperation</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> trace(<span class="hljs-string">&quot;bigSlowOperation&quot;</span>)() <span class="hljs-comment">// don&#x27;t forget the extra parentheses</span><span class="hljs-comment">// ...lots of work…</span>time.Sleep(<span class="hljs-number">10</span> * time.Second) <span class="hljs-comment">// simulate slow operation by sleeping</span>&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">trace</span><span class="hljs-params">(msg <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span> &#123;start := time.Now()log.Printf(<span class="hljs-string">&quot;enter %s&quot;</span>, msg)<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; log.Printf(<span class="hljs-string">&quot;exit %s (%s)&quot;</span>, msg,time.Since(start)) &#125;&#125;</code></pre></li><li><p>通过这种方式， 我们可以只通过一条语句控制函数的入口和所有的出口，甚至可以记录函数的运行时间，如例子中的start。需要注意一点：不要忘记defer语句后的圆括号，否则本该在进入时执行的操作会在退出时执行，而本该在退出时执行的，永远不会被执行。</p></li><li><p>每一次bigSlowOperation被调用，程序都会记录函数的进入，退出，持续时间。（我们用time.Sleep模拟一个耗时的操作）</p><pre><code class="hljs awk">$ go build gopl.io<span class="hljs-regexp">/ch5/</span>trace$ ./trace<span class="hljs-number">2015</span><span class="hljs-regexp">/11/</span><span class="hljs-number">18</span> <span class="hljs-number">09</span>:<span class="hljs-number">53</span>:<span class="hljs-number">26</span> enter bigSlowOperation<span class="hljs-number">2015</span><span class="hljs-regexp">/11/</span><span class="hljs-number">18</span> <span class="hljs-number">09</span>:<span class="hljs-number">53</span>:<span class="hljs-number">36</span> <span class="hljs-keyword">exit</span> bigSlowOperation (<span class="hljs-number">10.000589217</span>s)</code></pre></li></ul></li><li><p>我们知道，defer语句中的函数会在return语句更新返回值变量后再执行，又因为在函数中定义的匿名函数可以访问该函数包括返回值变量在内的所有变量，所以，对匿名函数采用defer机制，可以使其观察函数的返回值。</p><ul><li><p>以double函数为例：</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">double</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<span class="hljs-keyword">return</span> x + x&#125;</code></pre></li><li><p>我们只需要首先命名double的返回值，再增加defer语句，我们就可以在double每次被调用时，输出参数以及返回值。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">double</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(result <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; fmt.Printf(<span class="hljs-string">&quot;double(%d) = %d\n&quot;</span>, x,result) &#125;()<span class="hljs-keyword">return</span> x + x&#125;_ = double(<span class="hljs-number">4</span>)<span class="hljs-comment">// Output:</span><span class="hljs-comment">// &quot;double(4) = 8&quot;</span></code></pre></li><li><p>可能double函数过于简单，看不出这个小技巧的作用，但对于有许多return语句的函数而言，这个技巧很有用。</p></li><li><p>被延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">triple</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(result <span class="hljs-keyword">int</span>)</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123; result += x &#125;()<span class="hljs-keyword">return</span> double(x)&#125;fmt.Println(triple(<span class="hljs-number">4</span>)) <span class="hljs-comment">// &quot;12&quot;</span></code></pre></li></ul></li><li><p>在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。</p><ul><li><p>下面的代码会导致系统的文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭。</p><pre><code class="hljs Go"><span class="hljs-keyword">for</span> _, filename := <span class="hljs-keyword">range</span> filenames &#123;f, err := os.Open(filename)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">defer</span> f.Close() <span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> risky; could run out of file descriptors</span><span class="hljs-comment">// ...process f…</span>&#125;</code></pre></li><li><p>一种解决方法是将循环体中的defer语句移至另外一个函数。在每次循环时，调用这个函数。</p><pre><code class="hljs Go"><span class="hljs-keyword">for</span> _, filename := <span class="hljs-keyword">range</span> filenames &#123;<span class="hljs-keyword">if</span> err := doFile(filename); err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">doFile</span><span class="hljs-params">(filename <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">error</span></span> &#123;f, err := os.Open(filename)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">return</span> err&#125;<span class="hljs-keyword">defer</span> f.Close()<span class="hljs-comment">// ...process f…</span>&#125;</code></pre></li><li><p>下面的代码是fetch（1.5节）的改进版，我们将http响应信息写入本地文件而不是从标准输出流输出。我们通过path.Base提出url路径的最后一段作为文件名。</p><p><u><i>gopl.io/ch5/fetch</i></u></p><pre><code class="hljs Go"><span class="hljs-comment">// Fetch downloads the URL and returns the</span><span class="hljs-comment">// name and length of the local file.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fetch</span><span class="hljs-params">(url <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(filename <span class="hljs-keyword">string</span>, n <span class="hljs-keyword">int64</span>, err error)</span></span> &#123; resp, err := http.Get(url) <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, err &#125; <span class="hljs-keyword">defer</span> resp.Body.Close() local := path.Base(resp.Request.URL.Path) <span class="hljs-keyword">if</span> local == <span class="hljs-string">&quot;/&quot;</span> &#123; local = <span class="hljs-string">&quot;index.html&quot;</span> &#125; f, err := os.Create(local) <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">0</span>, err &#125; n, err = io.Copy(f, resp.Body) <span class="hljs-comment">// Close file, but prefer error from Copy, if any.</span> <span class="hljs-keyword">if</span> closeErr := f.Close(); err == <span class="hljs-literal">nil</span> &#123; err = closeErr &#125; <span class="hljs-keyword">return</span> local, n, err&#125;</code></pre><ul><li>对resp.Body.Close延迟调用我们已经见过了，在此不做解释。上例中，通过os.Create打开文件进行写入，在关闭文件时，我们没有对f.close采用defer机制，因为这会产生一些微妙的错误。</li><li>许多文件系统，尤其是NFS，写入文件时发生的错误会被延迟到文件关闭时反馈。</li><li>如果没有检查文件关闭时的反馈信息，可能会导致数据丢失，而我们还误以为写入操作成功。</li><li>如果io.Copy和f.close都失败了，我们倾向于将io.Copy的错误信息反馈给调用者，因为它先于f.close发生，更有可能接近问题的本质。</li></ul></li></ul></li></ul><h3 id="ch5-9-Panic异常"><a href="#ch5-9-Panic异常" class="headerlink" title="ch5.9   Panic异常"></a>ch5.9   Panic异常</h3><ul><li><p>Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。</p></li><li><p>一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine中被延迟的函数（defer 机制）。</p><ul><li>随后，程序崩溃并输出日志信息。日志信息包括panic value和函数调用的堆栈跟踪信息。</li><li>panic value通常是某种错误信息。对于每个goroutine，日志信息中都会有与之相对的，发生panic时的函数调用堆栈跟踪信息。</li><li>通常，我们不需要再次运行程序去定位问题，日志信息已经提供了足够的诊断依据。因此，在我们填写问题报告时，一般会将panic异常和日志信息一并记录。</li></ul></li><li><p>不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。</p><ul><li><p>当某些不应该发生的场景发生时，我们就应该调用panic。比如，当程序到达了某条逻辑上不可能到达的路径：</p><pre><code class="hljs Go"><span class="hljs-keyword">switch</span> s := suit(drawCard()); s &#123;<span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Spades&quot;</span>:                                <span class="hljs-comment">// ...</span><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Hearts&quot;</span>:                                <span class="hljs-comment">// ...</span><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Diamonds&quot;</span>:                              <span class="hljs-comment">// ...</span><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;Clubs&quot;</span>:                                 <span class="hljs-comment">// ...</span><span class="hljs-keyword">default</span>:<span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;invalid suit %q&quot;</span>, s)) <span class="hljs-comment">// Joker?</span>&#125;</code></pre></li></ul></li><li><p>断言函数必须满足的前置条件是明智的做法，但这很容易被滥用。除非你能提供更多的错误信息，或者能更快速的发现错误，否则不需要使用断言，编译器在运行时会帮你检查代码。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Reset</span><span class="hljs-params">(x *Buffer)</span></span> &#123;<span class="hljs-keyword">if</span> x == <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;x is nil&quot;</span>) <span class="hljs-comment">// unnecessary!</span>&#125;x.elements = <span class="hljs-literal">nil</span>&#125;</code></pre></li><li><p>虽然Go的panic机制类似于其他语言的异常，但panic的适用场景有一些不同。</p><ul><li>由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。</li><li>勤奋的程序员认为任何崩溃都表明代码中存在漏洞，所以对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。</li><li>在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I/O操作都应该被优雅的处理，最好的处理方式，就是使用Go的错误机制。</li></ul></li><li><p>考虑regexp.Compile函数，该函数将正则表达式编译成有效的可匹配格式。</p><ul><li><p>当输入的正则表达式不合法时，该函数会返回一个错误。</p></li><li><p>当调用者明确的知道正确的输入不会引起函数错误时，要求调用者检查这个错误是不必要和累赘的。</p></li><li><p>我们应该假设函数的输入一直合法，就如前面的断言一样：当调用者输入了不应该出现的输入时，触发panic异常。</p></li><li><p>在程序源码中，大多数正则表达式是字符串字面值（string literals），因此regexp包提供了包装函数regexp.MustCompile检查输入的合法性。</p><pre><code class="hljs Go"><span class="hljs-keyword">package</span> regexp<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Compile</span><span class="hljs-params">(expr <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*Regexp, error)</span></span> &#123; <span class="hljs-comment">/* ... */</span> &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MustCompile</span><span class="hljs-params">(expr <span class="hljs-keyword">string</span>)</span> *<span class="hljs-title">Regexp</span></span> &#123;re, err := Compile(expr)<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<span class="hljs-built_in">panic</span>(err)&#125;<span class="hljs-keyword">return</span> re&#125;</code></pre></li><li><p>包装函数使得调用者可以便捷的用一个编译后的正则表达式为包级别的变量赋值：</p><pre><code class="hljs Go"><span class="hljs-keyword">var</span> httpSchemeRE = regexp.MustCompile(<span class="hljs-string">`^https?:`</span>) <span class="hljs-comment">//&quot;http:&quot; or &quot;https:&quot;</span></code></pre></li><li><p>显然，MustCompile不能接收不合法的输入。函数名中的Must前缀是一种针对此类函数的命名约定，比如template.Must（4.6节）</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;f(<span class="hljs-number">3</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(x <span class="hljs-keyword">int</span>)</span></span> &#123;fmt.Printf(<span class="hljs-string">&quot;f(%d)\n&quot;</span>, x+<span class="hljs-number">0</span>/x) <span class="hljs-comment">// panics if x == 0</span><span class="hljs-keyword">defer</span> fmt.Printf(<span class="hljs-string">&quot;defer %d\n&quot;</span>, x)f(x - <span class="hljs-number">1</span>)&#125;</code></pre><ul><li><p>上例中的运行输出如下：</p><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">3</span>)</span></span><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">2</span>)</span></span><span class="hljs-function"><span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span>)</span></span>defer <span class="hljs-number">1</span>defer <span class="hljs-number">2</span>defer <span class="hljs-number">3</span></code></pre></li></ul></li><li><p>当f(0)被调用时，发生panic异常，之前被延迟执行的3个fmt.Printf被调用。</p><ul><li><p>程序中断执行后，panic信息和堆栈信息会被输出（下面是简化的输出）</p><pre><code class="hljs gradle">panic: <span class="hljs-keyword">runtime</span> error: integer divide by zeromain.f(<span class="hljs-number">0</span>)src<span class="hljs-regexp">/gopl.io/</span>ch5<span class="hljs-regexp">/defer1/</span>defer.go:<span class="hljs-number">14</span>main.f(<span class="hljs-number">1</span>)src<span class="hljs-regexp">/gopl.io/</span>ch5<span class="hljs-regexp">/defer1/</span>defer.go:<span class="hljs-number">16</span>main.f(<span class="hljs-number">2</span>)src<span class="hljs-regexp">/gopl.io/</span>ch5<span class="hljs-regexp">/defer1/</span>defer.go:<span class="hljs-number">16</span>main.f(<span class="hljs-number">3</span>)src<span class="hljs-regexp">/gopl.io/</span>ch5<span class="hljs-regexp">/defer1/</span>defer.go:<span class="hljs-number">16</span>main.main()src<span class="hljs-regexp">/gopl.io/</span>ch5<span class="hljs-regexp">/defer1/</span>defer.go:<span class="hljs-number">10</span></code></pre></li></ul></li><li><p>我们在下一节将看到，如何使程序从panic异常中恢复，阻止程序的崩溃。</p></li></ul></li><li><p>为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。</p><p><u><i>gopl.io/ch5/defer2</i></u></p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">defer</span> printStack()f(<span class="hljs-number">3</span>)&#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printStack</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">var</span> buf [<span class="hljs-number">4096</span>]<span class="hljs-keyword">byte</span>n := runtime.Stack(buf[:], <span class="hljs-literal">false</span>)os.Stdout.Write(buf[:n])&#125;</code></pre><ul><li><p>printStack的简化输出如下（下面只是printStack的输出，不包括panic的日志信息）</p><pre><code class="hljs awk">goroutine <span class="hljs-number">1</span> [running]:main.printStack()src<span class="hljs-regexp">/gopl.io/</span>ch5<span class="hljs-regexp">/defer2/</span>defer.go:<span class="hljs-number">20</span>main.f(<span class="hljs-number">0</span>)src<span class="hljs-regexp">/gopl.io/</span>ch5<span class="hljs-regexp">/defer2/</span>defer.go:<span class="hljs-number">27</span>main.f(<span class="hljs-number">1</span>)src<span class="hljs-regexp">/gopl.io/</span>ch5<span class="hljs-regexp">/defer2/</span>defer.go:<span class="hljs-number">29</span>main.f(<span class="hljs-number">2</span>)src<span class="hljs-regexp">/gopl.io/</span>ch5<span class="hljs-regexp">/defer2/</span>defer.go:<span class="hljs-number">29</span>main.f(<span class="hljs-number">3</span>)src<span class="hljs-regexp">/gopl.io/</span>ch5<span class="hljs-regexp">/defer2/</span>defer.go:<span class="hljs-number">29</span>main.main()src<span class="hljs-regexp">/gopl.io/</span>ch5<span class="hljs-regexp">/defer2/</span>defer.go:<span class="hljs-number">15</span></code></pre></li></ul></li><li><p>将panic机制类比其他语言异常机制的读者可能会惊讶，runtime.Stack为何能输出已经被释放函数的信息？在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。</p></li></ul><h3 id="ch5-10-Recover捕获异常"><a href="#ch5-10-Recover捕获异常" class="headerlink" title="ch5.10   Recover捕获异常"></a>ch5.10   Recover捕获异常</h3><ul><li><p>通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。</p><ul><li><p>举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭；</p><ul><li>如果不做任何处理，会使得客户端一直处于等待状态。</li><li>如果web服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。</li></ul></li></ul></li><li><p>如果在deferred函数中调用了内置函数recover，并且定义该defer语句的函数发生了panic异常，recover会使程序从panic中恢复，并返回panic value。导致panic异常的函数不会继续运行，但能正常返回。在未发生panic时调用recover，recover会返回nil。</p></li><li><p>让我们以语言解析器为例，说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误。</p><pre><code class="hljs Go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(input <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(s *Syntax, err error)</span></span> &#123;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">if</span> p := <span class="hljs-built_in">recover</span>(); p != <span class="hljs-literal">nil</span> &#123;err = fmt.Errorf(<span class="hljs-string">&quot;internal error: %v&quot;</span>, p)&#125;&#125;()<span class="hljs-comment">// ...parser...</span>&#125;</code></pre></li><li><p>deferred函数帮助Parse从panic中恢复。在deferred函数内部，panic value被附加到错误信息中；并用err变量接收错误信息，返回给调用者。我们也可以通过调用runtime.Stack往错误信息中添加完整的堆栈调用信息。</p></li><li><p>不加区分的恢复所有的panic异常，不是可取的做法；因为在panic之后，无法保证包级变量的状态仍然和我们预期一致。</p><ul><li>比如，对数据结构的一次重要更新没有被完整完成、文件或者网络连接没有被关闭、获得的锁没有被释放。</li><li>此外，如果写日志时产生的panic被不加区分的恢复，可能会导致漏洞被忽略。</li></ul></li><li><p>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。</p><ul><li>公有的API应该将函数的运行失败作为error返回，而不是panic。</li><li>同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。</li></ul></li><li><p>有时我们很难完全遵循规范</p><ul><li>举个例子，net/http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。</li><li>很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程</li><li>web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。</li><li>这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。</li></ul></li><li><p>基于以上原因，安全的做法是有选择性的recover。</p><ul><li><p>换句话说，只恢复应该被恢复的panic异常，此外，这些异常所占的比例应该尽可能的低。</p></li><li><p>为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为error处理，如果不是，则按照正常的panic进行处理（在下面的例子中，我们会看到这种方式）。</p></li><li><p>下面的例子是title函数的变形，如果HTML页面包含多个<code>&lt;title&gt;</code>，该函数会给调用者返回一个错误（error）。在soleTitle内部处理时，如果检测到有多个<code>&lt;title&gt;</code>，会调用panic，阻止函数继续递归，并将特殊类型bailout作为panic的参数。</p><pre><code class="hljs Go"><span class="hljs-comment">// soleTitle returns the text of the first non-empty title element</span><span class="hljs-comment">// in doc, and an error if there was not exactly one.</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">soleTitle</span><span class="hljs-params">(doc *html.Node)</span> <span class="hljs-params">(title <span class="hljs-keyword">string</span>, err error)</span></span> &#123;<span class="hljs-keyword">type</span> bailout <span class="hljs-keyword">struct</span>&#123;&#125;<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<span class="hljs-keyword">switch</span> p := <span class="hljs-built_in">recover</span>(); p &#123;<span class="hljs-keyword">case</span> <span class="hljs-literal">nil</span>:       <span class="hljs-comment">// no panic</span><span class="hljs-keyword">case</span> bailout&#123;&#125;: <span class="hljs-comment">// &quot;expected&quot; panic</span>err = fmt.Errorf(<span class="hljs-string">&quot;multiple title elements&quot;</span>)<span class="hljs-keyword">default</span>:<span class="hljs-built_in">panic</span>(p) <span class="hljs-comment">// unexpected panic; carry on panicking</span>&#125;&#125;()<span class="hljs-comment">// Bail out of recursion if we find more than one nonempty title.</span>forEachNode(doc, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n *html.Node)</span></span> &#123;<span class="hljs-keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="hljs-string">&quot;title&quot;</span> &amp;&amp;n.FirstChild != <span class="hljs-literal">nil</span> &#123;<span class="hljs-keyword">if</span> title != <span class="hljs-string">&quot;&quot;</span> &#123;<span class="hljs-built_in">panic</span>(bailout&#123;&#125;) <span class="hljs-comment">// multiple titleelements</span>&#125;title = n.FirstChild.Data&#125;&#125;, <span class="hljs-literal">nil</span>)<span class="hljs-keyword">if</span> title == <span class="hljs-string">&quot;&quot;</span> &#123;<span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, fmt.Errorf(<span class="hljs-string">&quot;no title element&quot;</span>)&#125;<span class="hljs-keyword">return</span> title, <span class="hljs-literal">nil</span>&#125;</code></pre><ul><li>在上例中，deferred函数调用recover，并检查panic value。当panic value是bailout{}类型时，deferred函数生成一个error返回给调用者。当panic value是其他non-nil值时，表示发生了未知的panic异常，deferred函数将调用panic函数并将当前的panic value作为参数传入；此时，等同于recover没有做任何操作。</li><li>请注意：在例子中，对可预期的错误采用了panic，这违反了之前的建议，我们在此只是想向读者演示这种机制。</li></ul></li></ul></li><li><p>有些情况下，我们无法恢复。某些致命错误会导致Go在运行时终止程序，如内存不足。</p></li><li><p>泛使用之一的接口类型fmt.Stringer：</p><pre><code class="hljs go"><span class="hljs-keyword">package</span> fmt<span class="hljs-comment">// The String method is used to print values passed</span><span class="hljs-comment">// as an operand to any format that accepts a string</span><span class="hljs-comment">// or to an unformatted printer such as Print.</span><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;String() <span class="hljs-keyword">string</span>&#125;</code></pre></li><li><p>我们会在7.10节解释fmt包怎么发现哪些值是满足这个接口类型的。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Book</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Bug 合集</title>
    <link href="/2020/11/07/go/BUG/Go%20Bug%20%E5%90%88%E9%9B%86/"/>
    <url>/2020/11/07/go/BUG/Go%20Bug%20%E5%90%88%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Go无法编译"><a href="#Go无法编译" class="headerlink" title="Go无法编译"></a>Go无法编译</h1><h3 id="Cannot-find-main-module"><a href="#Cannot-find-main-module" class="headerlink" title="Cannot find main module"></a>Cannot find main module</h3><p>设置 GO111MODULE=auto</p><h1 id="Wsarecv-An-existing-connection-was-forcibly-closed-by-the-remote-host-exit-status-1"><a href="#Wsarecv-An-existing-connection-was-forcibly-closed-by-the-remote-host-exit-status-1" class="headerlink" title="Wsarecv: An existing connection was forcibly closed by the remote host.exit status 1"></a>Wsarecv: An existing connection was forcibly closed by the remote host.exit status 1</h1><p>goproxy设置出错，将https写成了http</p><h1 id="Curl-1-Protocol-“‘http”-not-supported-or-disabled-in-libcurl"><a href="#Curl-1-Protocol-“‘http”-not-supported-or-disabled-in-libcurl" class="headerlink" title="Curl: (1) Protocol “‘http” not supported or disabled in libcurl"></a>Curl: (1) Protocol “‘http” not supported or disabled in libcurl</h1><p>使用双引号，不要使用单引号</p><p><img src="https://tool.lu/netcard/" alt="IP签名"></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go,bug</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Interview</title>
    <link href="/2020/11/07/go/Interview/interview_01/"/>
    <url>/2020/11/07/go/Interview/interview_01/</url>
    
    <content type="html"><![CDATA[<h1 id="Go-面试题-B站"><a href="#Go-面试题-B站" class="headerlink" title="Go 面试题 B站"></a>Go 面试题 B站</h1><h2 id="中高级-Golang-面试"><a href="#中高级-Golang-面试" class="headerlink" title="中高级 Golang 面试"></a>中高级 Golang 面试</h2><p><a href="https://www.bilibili.com/video/BV12p4y1W7Dz/?spm_id_from=333.788.recommend_more_video.-1">B站面试视频</a></p><ol><li>自我介绍</li><li>代码效率分析，考察局部性原理</li><li>多核CPU场景下，cache如何保持一致、不冲突？</li><li>uint类型溢出</li><li>介绍rune类型</li><li>编程题：3个函数分别打印cat、dog、fish，要求每个函数都要起一个goroutine，按照cat、dog、fish顺序打印在屏幕上100次。</li><li>介绍一下channel，无缓冲和有缓冲区别</li><li>是否了解channel底层实现，比如实现channel的数据结构是什么？</li><li>channel是否线程安全？</li><li>Mutex是悲观锁还是乐观锁？悲观锁、乐观锁是什么？</li><li>Mutex几种模式？</li><li>Mutex可以做自旋锁吗？</li><li>介绍一下RWMutex</li><li>项目中用过的锁？</li><li>介绍一下线程安全的共享内存方式</li><li>介绍一下goroutine</li><li>goroutine自旋占用cpu如何解决（go调用、gmp）</li><li>介绍linux系统信号</li><li>goroutine抢占时机（gc 栈扫描）</li><li>Gc触发时机</li><li>是否了解其他gc机制</li><li>Go内存管理方式</li><li>Channel分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？</li><li>介绍一下大对象小对象，为什么小对象多了会造成gc压力？</li><li>项目中遇到的oom情况？</li><li>项目中使用go遇到的坑？</li><li>工作遇到的难题、有挑战的事情，如何解决？</li><li>如何指定指令执行顺序？</li></ol><h2 id="初-中级-Golang-面试"><a href="#初-中级-Golang-面试" class="headerlink" title="初/中级 Golang 面试"></a>初/中级 Golang 面试</h2><ol><li>工作中Go遇到的问题—struct，内存不对齐，内存浪费</li></ol><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><p>\1. make 和 new 的区别﹖<br>\2. 了解过golang的内存管理吗?<br>\3. 调用函数传入结构体时，应该传值还是指针﹖说出你的理由?<br>\4. 线程有几种模型?Goroutine的原理了解过吗，讲一下实现和优势?<br>\5. Goroutine什么时候会发生阻塞?<br>\6. PMG模型中Goroutine有哪几种状态?<br>\7. 每个线程/协程占用多少内存知道吗?<br>\8. 如果Goroutine—直占用资源怎么办,PMG模型怎么解决的这个问题?<br>\9. 如果若干线程中一个线程OOM，会发生什么?如果是Goroutine 呢?<br>项目中出现过OOM吗，怎么解决的?<br>\10. 项目中错误处理是怎么做的?<br>\11. 如果若干个Goroutine,其中有一个panic，会发生什么?<br>\12. defer可以捕获到其Goroutine的子Goroutine 的panic吗?<br>\13. 开发用Gin框架吗?Gin怎么做参数校验?<br>\14. 中间件使用过吗?怎么使用的。Gin的错误处理使用过吗?Gin中自定义校验规则知道怎么做吗?自定义校验器的返回值呢?<br>\15. golang中解析tag是怎么实现的？反射原理是什么？通过反射调用函数<br>\16. golang的锁机制了解过吗? Mutex的锁有哪几种模式，分别介绍一下? Mutex锁底层如何实现了解过吗?<br>\17. channel、channel使用中需要注意的地方？<br>\18. 数据库用的什么？数据库锁有了解吗？mysql锁机制讲一下。mysql分库分表。<br>\19. 讲一下redis分布式锁？redis主从模式和集群模式的区别了解过吗？redis的数据类型有哪些？redis持久化怎么做的？<br>\20. 编程题：你了解的负载均衡算法有什么？实现一个负载均衡算法。</p><h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><p>\1. 自我介绍<br>\2. 代码效率分析，考察局部性原理<br>\3. 多核CPU场景下，cache如何保持一致、不冲突？<br>\4. uint类型溢出<br>\5. 介绍rune类型<br>\6. 编程题：3个函数分别打印cat、dog、fish，要求每个函数都要起一个goroutine，按照cat、dog、fish顺序打印在屏幕上100次。<br>\7. 介绍一下channel，无缓冲和有缓冲区别<br>\8. 是否了解channel底层实现，比如实现channel的数据结构是什么？<br>\9. channel是否线程安全？<br>\10. Mutex是悲观锁还是乐观锁？悲观锁、乐观锁是什么？<br>\11. Mutex几种模式？<br>\12. Mutex可以做自旋锁吗？<br>\13. 介绍一下RWMutex<br>\14. 项目中用过的锁？<br>\15. 介绍一下线程安全的共享内存方式<br>\16. 介绍一下goroutine<br>\17. goroutine自旋占用cpu如何解决（go调用、gmp）<br>\18. 介绍linux系统信号<br>\19. goroutine抢占时机（gc 栈扫描）<br>\20. Gc触发时机<br>\21. 是否了解其他gc机制<br>\22. Go内存管理方式<br>\23. Channel分配在栈上还是堆上？哪些对象分配在堆上，哪些对象分配在栈上？<br>\24. 介绍一下大对象小对象，为什么小对象多了会造成gc压力？<br>\25. 项目中遇到的oom情况？<br>\26. 项目中使用go遇到的坑？<br>\27. 工作遇到的难题、有挑战的事情，如何解决？<br>\28. 如何指定指令执行顺序？</p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview,go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang-100-days</title>
    <link href="/2020/11/05/go/Golang-100-days/"/>
    <url>/2020/11/05/go/Golang-100-days/</url>
    
    <content type="html"><![CDATA[<h1 id="cap（）函数的计算值"><a href="#cap（）函数的计算值" class="headerlink" title="cap（）函数的计算值"></a>cap（）函数的计算值</h1><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;   <span class="hljs-keyword">var</span> numbers []<span class="hljs-keyword">int</span>   printSlice(numbers)   <span class="hljs-comment">/* 允许追加空切片 */</span>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">0</span>)   printSlice(numbers)   <span class="hljs-comment">/* 向切片添加一个元素 */</span>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">1</span>)   printSlice(numbers)   <span class="hljs-comment">/* 同时添加多个元素 */</span>   numbers = <span class="hljs-built_in">append</span>(numbers, <span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>)   printSlice(numbers)   <span class="hljs-comment">/* 创建切片 numbers1 是之前切片的两倍容量*/</span>   numbers1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-built_in">len</span>(numbers), (<span class="hljs-built_in">cap</span>(numbers))*<span class="hljs-number">2</span>)   <span class="hljs-comment">/* 拷贝 numbers 的内容到 numbers1 */</span>   <span class="hljs-built_in">copy</span>(numbers1,numbers)   printSlice(numbers1)   &#125;<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printSlice</span><span class="hljs-params">(x []<span class="hljs-keyword">int</span>)</span></span>&#123;   fmt.Printf(<span class="hljs-string">&quot;len=%d cap=%d slice=%v\n&quot;</span>,<span class="hljs-built_in">len</span>(x),<span class="hljs-built_in">cap</span>(x),x)&#125;</code></pre><p>运行结果</p><pre><code class="hljs shell">len=0 cap=0 slice=[]len=1 cap=2 slice=[0]len=2 cap=2 slice=[0 1]len=5 cap=8 slice=[0 1 2 3 4]len=5 cap=12 slice=[0 1 2 3 4]</code></pre><p><img src="https://tool.lu/netcard/" alt="IP签名"></p>]]></content>
    
    
    <categories>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux配置静态IP</title>
    <link href="/2020/10/23/linux/tmp/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/"/>
    <url>/2020/10/23/linux/tmp/Linux%E9%85%8D%E7%BD%AE%E9%9D%99%E6%80%81IP/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu-20-配置-root-用户-ssh"><a href="#Ubuntu-20-配置-root-用户-ssh" class="headerlink" title="Ubuntu 20 配置 root 用户 ssh"></a>Ubuntu 20 配置 root 用户 ssh</h1><ol><li><p>sudo passwd 设置 root 密码</p></li><li><p>vim /etc/ssh/sshd_config</p></li></ol><p>   将 “[[port]] 22”修改为“port 22”</p><p>   将 “[[PermitRootLogin]] prohibit-password”修改为“PermitRootLogin yes”</p><p>tee -a /etc/ssh/sshd_config&lt;&lt;EOF<br>port 22<br>PermitRootLogin yes<br>EOF</p><ol start="3"><li>service sshd restart</li></ol><h1 id="Ubuntu18配置静态IP"><a href="#Ubuntu18配置静态IP" class="headerlink" title="Ubuntu18配置静态IP"></a>Ubuntu18配置静态IP</h1><ol><li>切换为root用户执行（具体配置文件用tab自动补全）</li></ol><pre><code class="hljs shell">vi /etc/netplan/00***.yml</code></pre><ol start="2"><li>编辑配置文件内容如下所示，addresses处填入所要设置ip地址，dhcp4 no代表不适用dhcp协议获取ip，gateway代表网关地址。nameservers代表DNS域名解析服务器</li></ol><pre><code class="hljs shell">network:  ethernets:    ens3:      addresses:      - 192.168.1.10/24      dhcp4: no      gateway4: 192.168.1.1      nameservers:          addresses: [&#x27;114.114.114.114&#x27;]  version: 2</code></pre><ol start="3"><li>执行以下命令是配置生效</li></ol><pre><code class="hljs shell">netplan apply</code></pre><ol start="4"><li>使用ifconfig查看配置是否成功</li></ol><h1 id="Centos8配置静态IP"><a href="#Centos8配置静态IP" class="headerlink" title="Centos8配置静态IP"></a>Centos8配置静态IP</h1><ul><li>vi /etc/sysconfig/network-scripts/ifcfg-ens32</li></ul><pre><code class="hljs ini"><span class="hljs-attr">TYPE</span>=Ethernet<span class="hljs-attr">PROXY_METHOD</span>=none<span class="hljs-attr">BROWSER_ONLY</span>=<span class="hljs-literal">no</span><span class="hljs-attr">BOOTPROTO</span>=static<span class="hljs-attr">DEFROUTE</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV4_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><span class="hljs-attr">IPV6INIT</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV6_AUTOCONF</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV6_DEFROUTE</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPV6_FAILURE_FATAL</span>=<span class="hljs-literal">no</span><span class="hljs-attr">IPV6_ADDR_GEN_MODE</span>=stable-privacy<span class="hljs-attr">NAME</span>=ens32<span class="hljs-attr">UUID</span>=<span class="hljs-number">066</span>b4926-b40c-<span class="hljs-number">4</span>c28-a5b4-<span class="hljs-number">2310</span>d2b96613<span class="hljs-attr">DEVICE</span>=ens32<span class="hljs-attr">ONBOOT</span>=<span class="hljs-literal">yes</span><span class="hljs-attr">IPADDR</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">1.200</span><span class="hljs-attr">NETMASK</span>=<span class="hljs-number">255.255</span>.<span class="hljs-number">255.0</span><span class="hljs-attr">GATEWAY</span>=<span class="hljs-number">192.168</span>.<span class="hljs-number">1.254</span><span class="hljs-attr">DNS1</span>=<span class="hljs-number">223.5</span>.<span class="hljs-number">5.5</span><span class="hljs-attr">PREFIX</span>=<span class="hljs-number">24</span></code></pre><ul><li><p>重启网络</p><pre><code class="hljs shell">nmcli c reloadsystemctl restart network #重启网卡service network restart   [[重启网卡network]]服务systemctl enable network #开机启动网卡</code></pre></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos7防止暴力破解</title>
    <link href="/2020/10/23/linux/tmp/Centos7/centos7%E7%A6%81%E6%AD%A2ip/"/>
    <url>/2020/10/23/linux/tmp/Centos7/centos7%E7%A6%81%E6%AD%A2ip/</url>
    
    <content type="html"><![CDATA[<h1 id="Centos7禁止ip访问"><a href="#Centos7禁止ip访问" class="headerlink" title="Centos7禁止ip访问"></a>Centos7禁止ip访问</h1><ol><li>编写脚本禁止ip访问</li></ol><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">!/bin/bash</span>cat /var/log/secure|awk &#x27;/Failed/&#123;print $(NF-3)&#125;&#x27;|sort|uniq -c|awk &#x27;&#123;print $2&quot;=&quot;$1;&#125;&#x27; &gt; /root/black.txtDEFINE=&quot;10&quot;for i in `cat  /root/black.txt`do        IP=`echo $i |awk -F= &#x27;&#123;print $1&#125;&#x27;`        NUM=`echo $i|awk -F= &#x27;&#123;print $2&#125;&#x27;`        if [ $NUM -gt $DEFINE ];        then         grep $IP /etc/hosts.deny &gt; /dev/null          if [ $? -gt 0 ];          then          echo &quot;sshd:$IP&quot; &gt;&gt; /etc/hosts.deny          fi        fidone</code></pre><ol start="2"><li><p>使用crontabp执行脚本</p><p>清空记录<code>echo &gt; /var/log/wtmp;echo &gt; /var/log/btmp;history -c;</code></p><p>使用lastb命令查看暴力破解情况</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux,centos7,shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Centos8修改密码</title>
    <link href="/2020/10/23/linux/tmp/Centos8/centos8%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/"/>
    <url>/2020/10/23/linux/tmp/Centos8/centos8%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="1-重启linux系统按e"><a href="#1-重启linux系统按e" class="headerlink" title="1. 重启linux系统按e"></a>1. 重启linux系统按e</h3><h3 id="2-开头为linux-root-那行末尾加-rd-break"><a href="#2-开头为linux-root-那行末尾加-rd-break" class="headerlink" title="2. 开头为linux($root)那行末尾加 rd.break"></a>2. 开头为linux($root)那行末尾加 rd.break</h3><h3 id="3-mount-grep-sysroot"><a href="#3-mount-grep-sysroot" class="headerlink" title="3. mount | grep sysroot"></a>3. mount | grep sysroot</h3><h3 id="4-mount-o-remount-rw-sysroot"><a href="#4-mount-o-remount-rw-sysroot" class="headerlink" title="4. mount -o remount,rw /sysroot/"></a>4. mount -o remount,rw /sysroot/</h3><pre><code class="hljs shell">mount | grep sysroot</code></pre><h3 id="5-切换系统的根目录位置为"><a href="#5-切换系统的根目录位置为" class="headerlink" title="5. 切换系统的根目录位置为"></a>5. 切换系统的根目录位置为</h3><pre><code class="hljs shell">chroot /sysroot</code></pre><h3 id="6-输入passwd修改密码"><a href="#6-输入passwd修改密码" class="headerlink" title="6. 输入passwd修改密码"></a>6. 输入passwd修改密码</h3><p>注意：新密码需符合centos8密码复杂度要求</p><h3 id="7-touch-autorelabel"><a href="#7-touch-autorelabel" class="headerlink" title="7. touch /.autorelabel"></a>7. touch /.autorelabel</h3><p>执行下面的命令让文件系统强制重新relabeling</p><h3 id="8-exit"><a href="#8-exit" class="headerlink" title="8. exit"></a>8. exit</h3><h3 id="9-logout"><a href="#9-logout" class="headerlink" title="9. logout"></a>9. logout</h3><p>[参照]<a href="https://linuxconfig.org/redhat-8-recover-root-password">https://linuxconfig.org/redhat-8-recover-root-password</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux,Centos8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kali工具</title>
    <link href="/2020/10/10/linux/tmp/kali/"/>
    <url>/2020/10/10/linux/tmp/kali/</url>
    
    <content type="html"><![CDATA[<h1 id="dirb"><a href="#dirb" class="headerlink" title="dirb"></a>dirb</h1><pre><code class="hljs shell">dirb https://x.x.x.x/</code></pre><p>[^目录扫描工具]: </p><p><a href="https://sourceforge.net/projects/dirbuster/files/latest/download">https://sourceforge.net/projects/dirbuster/files/latest/download</a></p><h3 id="参数介绍"><a href="#参数介绍" class="headerlink" title="参数介绍"></a>参数介绍</h3><pre><code class="hljs shell">-a 设置ua-c 设置cookie带cookie扫描-N 忽略某些响应码-o 输出结果-p 使用代理-X 在每个测试目录上附加后缀-z 设置毫秒延迟</code></pre><h1 id="hydra"><a href="#hydra" class="headerlink" title="hydra"></a>hydra</h1><p>密码爆破工具</p><pre><code class="hljs css"><span class="hljs-selector-tag">hydra</span> <span class="hljs-selector-tag">-l</span> <span class="hljs-selector-tag">root</span> <span class="hljs-selector-tag">-P</span> <span class="hljs-selector-tag">password</span><span class="hljs-selector-class">.txt</span> <span class="hljs-selector-tag">-o</span> <span class="hljs-selector-tag">save</span><span class="hljs-selector-class">.log</span> <span class="hljs-selector-tag">-vV</span> <span class="hljs-selector-tag">RHOSTS</span> <span class="hljs-selector-tag">ssh</span> <span class="hljs-selector-tag">-t</span> 30</code></pre><h1 id="开启远程连接"><a href="#开启远程连接" class="headerlink" title="开启远程连接"></a>开启远程连接</h1><ol><li>vi /etc/ssh/sshd_config</li><li>PermitRootLogin yes</li><li>PasswordAuthentication yes</li><li>wq</li><li>systemctl restart ssh.service</li><li>systemctl status ssh.service</li></ol>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
      <category>Hack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>The Chrome Extensions I&#39;d like to use</title>
    <link href="/2020/10/10/tmp/Daily/Chrome%20Extensions/"/>
    <url>/2020/10/10/tmp/Daily/Chrome%20Extensions/</url>
    
    <content type="html"><![CDATA[<h3 id="DARK-READER"><a href="#DARK-READER" class="headerlink" title="DARK READER"></a>DARK READER</h3><!--切换背景--><h3 id="Wappalyzer"><a href="#Wappalyzer" class="headerlink" title="Wappalyzer"></a>Wappalyzer</h3><!--用于探测网站版本，结果可能不准确--><h3 id="Proxy-SwitchyOmega"><a href="#Proxy-SwitchyOmega" class="headerlink" title="Proxy SwitchyOmega"></a>Proxy SwitchyOmega</h3><!--代理切换软件-->]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ChromeExtensions</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>渗透思考</title>
    <link href="/2020/10/10/tmp/Hack/%E6%B8%97%E9%80%8F%E6%80%9D%E8%80%83/"/>
    <url>/2020/10/10/tmp/Hack/%E6%B8%97%E9%80%8F%E6%80%9D%E8%80%83/</url>
    
    <content type="html"><![CDATA[<h1 id="公众号文章"><a href="#公众号文章" class="headerlink" title="公众号文章"></a>公众号文章</h1><p>​        知识化（对一流拦截的研究总结），体系化（对当时waf等的系统归纳），传递化（文章分享）。我把它简称渗透”三板斧”，更像是：学习，归纳，总结，分享的一个完整流程。并非知识太快，并非哪一安全方向领域就一定更有前景，而是这“三板斧”是否完整连接。</p><p>​        渗透的沉思非常重要，尤其是在后渗透阶段，需要有着一套非常完整周期计划，思考可能遇到的问题，或者通过已知的信息搜集，来推导可能面临的问题，这就是渗透的沉思。招式不在多，在于精，力道不在狠，在于寸。</p><p>​        渗透的本质是信息搜集，每一次的项目如果碰到迷茫无解的时候，请继续搜集。而信息搜集的本质是渗透的沉思，与线索“链”的关联。每一次真实的攻击演练项目，最难得并非是入侵攻击，也并非是得到域控或最高权限。而是如何把渗透攻击演变成一次对己有利的一个过程。后渗透需要沉淀，而沉淀需要给渗透留下沉思的时间。用“沉思”来化解五彩缤纷的工具，五颜六色的框架，日益骚奇的姿势，当戾气化解时，便形成一套了自我知识体系。<br>​        愿每一位读者能找到自己能融合贯通的“武功”，在结合吞噬其他“招式”，如行云流水，石便是器，枝便是剑</p>]]></content>
    
    
    <categories>
      
      <category>Hack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpentest</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>pip升级问题</title>
    <link href="/2020/07/07/python/pip%E5%8D%87%E7%BA%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2020/07/07/python/pip%E5%8D%87%E7%BA%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="pip升级出错"><a href="#pip升级出错" class="headerlink" title="pip升级出错"></a>pip升级出错</h1><p>使用国内源升级</p><pre><code class="hljs powershell">python <span class="hljs-literal">-m</span> pip install -<span class="hljs-literal">-upgrade</span> pip <span class="hljs-literal">-i</span> https://pypi.douban.com/simple</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Let life be beautiful like summer flowers</title>
    <link href="/1996/07/07/tmp/Let%20life%20be%20beautiful%20like%20summer%20flowers/"/>
    <url>/1996/07/07/tmp/Let%20life%20be%20beautiful%20like%20summer%20flowers/</url>
    
    <content type="html"><![CDATA[<h1 id="Let-life-be-beautiful-like-summer-flowers"><a href="#Let-life-be-beautiful-like-summer-flowers" class="headerlink" title="Let life be beautiful like summer flowers"></a>Let life be beautiful like summer flowers</h1><p>Life, thin and light-off time and time again</p><p>Frivolous tireless</p><h2 id="one"><a href="#one" class="headerlink" title="one"></a><strong>one</strong></h2><p>I heard the echo, from the valleys and the heart</p><p>Open to the lonely soul of sickle harvesting</p><p>Repeat outrightly, but also repeat the well-being of</p><p>Eventually swaying in the desert oasis</p><p>I believe I am</p><p>Born as the bright summer flowers</p><p>Do not withered undefeated fiery demon rule</p><p>Heart rate and breathing to bear the load of the cumbersome</p><p>Bored</p><h2 id="Two"><a href="#Two" class="headerlink" title="Two"></a><strong>Two</strong></h2><p>I heard the music, from the moon and carcass</p><p>Auxiliary extreme aestheticism bait to capture misty</p><p>Filling the intense life, but also filling the pure</p><p>There are always memories throughout the earth</p><p>I believe I am</p><p>Died as the quiet beauty of autumn leaves</p><p>Sheng is not chaos, smoke gesture</p><p>Even wilt also retained bone proudly Qing Feng muscle</p><p>Occult</p><h2 id="Three"><a href="#Three" class="headerlink" title="Three"></a><strong>Three</strong></h2><p>I hear love, I believe in love</p><p>Love is a pool of struggling blue-green algae</p><p>As desolate micro-burst of wind</p><p>Bleeding through my veins</p><p>Years stationed in the belief</p><h2 id="Four"><a href="#Four" class="headerlink" title="Four"></a><strong>Four</strong></h2><p>I believe that all can hear</p><p>Even anticipate discrete, I met the other their own</p><p>Some can not grasp the moment</p><p>Left to the East to go West, the dead must not return to nowhere</p><p>See, I wear Zan Flowers on my head, in full bloom along the way all the way</p><p>Frequently missed some, but also deeply moved by wind, frost, snow or rain</p><h2 id="Five"><a href="#Five" class="headerlink" title="Five"></a>Five</h2><p>Prajna Paramita, soon as soon as</p><p>life be beautiful like summer flowers and death like autumn leaves</p><p>Also care about what has</p>]]></content>
    
    
    <categories>
      
      <category>Life</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
